import {
  loadSetups
} from "./chunk-LOUKLO2C.mjs";
import {
  resolveImportPath,
  resolveImportUrl,
  toAtFS
} from "./chunk-AQQIBD5X.mjs";

// node/commands/shared.ts
import { existsSync, promises as fs } from "node:fs";
import { join } from "node:path";
import { loadConfigFromFile, mergeConfig, resolveConfig } from "vite";

// node/utils.ts
function stringifyMarkdownTokens(tokens) {
  return tokens.map((token) => token.children?.filter((t) => ["text", "code_inline"].includes(t.type) && !t.content.match(/^\s*$/)).map((t) => t.content.trim()).join(" ")).filter(Boolean).join(" ");
}
function generateGoogleFontsUrl(options) {
  const weights = options.weights.flatMap((i) => options.italic ? [`0,${i}`, `1,${i}`] : [`${i}`]).sort().join(";");
  const fonts = options.webfonts.map((i) => `family=${i.replace(/^(['"])(.*)\1$/, "$1").replace(/\s+/g, "+")}:${options.italic ? "ital," : ""}wght@${weights}`).join("&");
  return `https://fonts.googleapis.com/css2?${fonts}&display=swap`;
}

// node/commands/shared.ts
async function getIndexHtml({ clientRoot, roots, data }) {
  let main = await fs.readFile(join(clientRoot, "index.html"), "utf-8");
  let head = "";
  let body = "";
  head += `<link rel="icon" href="${data.config.favicon}">`;
  for (const root of roots) {
    const path2 = join(root, "index.html");
    if (!existsSync(path2))
      continue;
    const index = await fs.readFile(path2, "utf-8");
    head += `
${(index.match(/<head>([\s\S]*?)<\/head>/im)?.[1] || "").trim()}`;
    body += `
${(index.match(/<body>([\s\S]*?)<\/body>/im)?.[1] || "").trim()}`;
  }
  if (data.features.tweet)
    body += '\n<script async src="https://platform.twitter.com/widgets.js"></script>';
  if (data.config.fonts.webfonts.length && data.config.fonts.provider !== "none")
    head += `
<link rel="stylesheet" href="${generateGoogleFontsUrl(data.config.fonts)}" type="text/css">`;
  main = main.replace("__ENTRY__", toAtFS(join(clientRoot, "main.ts"))).replace("<!-- head -->", head).replace("<!-- body -->", body);
  return main;
}
async function mergeViteConfigs({ roots, entry }, viteConfig, config, command) {
  const configEnv = {
    mode: "development",
    command
  };
  const files = roots.map((i) => join(i, "vite.config.ts"));
  for await (const file of files) {
    if (!existsSync(file))
      continue;
    const viteConfig2 = await loadConfigFromFile(configEnv, file);
    if (!viteConfig2?.config)
      continue;
    config = mergeConfig(config, viteConfig2.config);
  }
  config = mergeConfig(config, viteConfig);
  const localConfig = await resolveConfig({}, command, entry);
  config = mergeConfig(config, { slidev: localConfig.slidev || {} });
  return config;
}

// node/vite/index.ts
import { join as join8 } from "node:path";
import { existsSync as existsSync5 } from "node:fs";
import process from "node:process";
import { fileURLToPath } from "node:url";
import Icons from "unplugin-icons/vite";
import IconsResolver from "unplugin-icons/resolver";
import Components from "unplugin-vue-components/vite";
import ServerRef from "vite-plugin-vue-server-ref";
import { notNullish as notNullish2 } from "@antfu/utils";

// node/integrations/drawings.ts
import { basename, dirname, join as join2, resolve } from "node:path";
import fs2 from "fs-extra";
import fg from "fast-glob";
function resolveDrawingsDir(options) {
  return options.data.config.drawings.persist ? resolve(
    dirname(options.entry),
    options.data.config.drawings.persist
  ) : void 0;
}
async function loadDrawings(options) {
  const dir = resolveDrawingsDir(options);
  if (!dir || !fs2.existsSync(dir))
    return {};
  const files = await fg("*.svg", {
    onlyFiles: true,
    cwd: dir,
    absolute: true,
    suppressErrors: true
  });
  const obj = {};
  await Promise.all(files.map(async (path2) => {
    const num = +basename(path2, ".svg");
    if (Number.isNaN(num))
      return;
    const content = await fs2.readFile(path2, "utf8");
    const lines = content.split(/\n/g);
    obj[num.toString()] = lines.slice(1, -1).join("\n");
  }));
  return obj;
}
async function writeDrawings(options, drawing) {
  const dir = resolveDrawingsDir(options);
  if (!dir)
    return;
  const width = options.data.config.canvasWidth;
  const height = Math.round(width / options.data.config.aspectRatio);
  const SVG_HEAD = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">`;
  await fs2.ensureDir(dir);
  return Promise.all(
    Object.entries(drawing).map(async ([key, value]) => {
      if (!value)
        return;
      const svg = `${SVG_HEAD}
${value}
</svg>`;
      await fs2.writeFile(join2(dir, `${key}.svg`), svg, "utf-8");
    })
  );
}

// node/vite/extendConfig.ts
import { join as join3 } from "node:path";
import { mergeConfig as mergeConfig2 } from "vite";
import isInstalledGlobally from "is-installed-globally";
import { uniq } from "@antfu/utils";

// ../client/package.json
var dependencies = {
  "@antfu/utils": "^0.7.7",
  "@iconify-json/carbon": "^1.1.31",
  "@iconify-json/ph": "^1.1.11",
  "@iconify-json/svg-spinners": "^1.1.2",
  "@shikijs/monaco": "^1.1.7",
  "@shikijs/vitepress-twoslash": "^1.1.7",
  "@slidev/parser": "workspace:*",
  "@slidev/rough-notation": "^0.1.0",
  "@slidev/types": "workspace:*",
  "@typescript/ata": "^0.9.4",
  "@unhead/vue": "^1.8.18",
  "@unocss/reset": "^0.58.5",
  "@vueuse/core": "^10.9.0",
  "@vueuse/math": "^10.9.0",
  "@vueuse/motion": "^2.1.0",
  codemirror: "^5.65.16",
  drauu: "^0.4.0",
  "file-saver": "^2.0.5",
  "floating-vue": "^5.2.2",
  "fuse.js": "^7.0.0",
  "js-yaml": "^4.1.0",
  katex: "^0.16.9",
  "lz-string": "^1.5.0",
  mermaid: "^10.9.0",
  "monaco-editor": "^0.47.0",
  prettier: "^3.2.5",
  recordrtc: "^5.6.2",
  shiki: "^1.1.7",
  "shiki-magic-move": "^0.3.4",
  typescript: "^5.4.2",
  unocss: "^0.58.5",
  vue: "^3.4.21",
  "vue-demi": "^0.14.7",
  "vue-router": "^4.3.0"
};

// node/vite/extendConfig.ts
var INCLUDE = [
  ...Object.keys(dependencies),
  // CodeMirror
  "codemirror/mode/javascript/javascript",
  "codemirror/mode/css/css",
  "codemirror/mode/markdown/markdown",
  "codemirror/mode/xml/xml",
  "codemirror/mode/htmlmixed/htmlmixed",
  "codemirror/addon/display/placeholder",
  // Monaco
  "monaco-editor/esm/vs/editor/standalone/browser/standaloneServices",
  "monaco-editor/esm/vs/platform/contextview/browser/contextViewService",
  "monaco-editor/esm/vs/platform/instantiation/common/descriptors",
  // Others
  "shiki-magic-move/vue"
];
var EXCLUDE = [
  "@slidev/shared",
  "@slidev/types",
  "@slidev/client",
  "@slidev/client/constants",
  "@slidev/client/logic/dark",
  "@vueuse/core",
  "@vueuse/math",
  "@vueuse/shared",
  "@unocss/reset",
  "unocss",
  "mermaid",
  "vue-demi",
  "vue",
  "shiki"
];
var ASYNC_MODULES = [
  "file-saver",
  "vue",
  "@vue"
];
function createConfigPlugin(options) {
  return {
    name: "slidev:config",
    async config(config) {
      const injection = {
        define: getDefine(options),
        resolve: {
          alias: [
            {
              find: /^@slidev\/client$/,
              replacement: `${toAtFS(options.clientRoot)}/index.ts`
            },
            {
              find: /^@slidev\/client\/(.*)/,
              replacement: `${toAtFS(options.clientRoot)}/$1`
            },
            {
              find: /^#slidev\/(.*)/,
              replacement: "/@slidev/$1"
            },
            {
              find: "vue",
              replacement: await resolveImportPath("vue/dist/vue.esm-browser.js", true)
            }
          ],
          dedupe: ["vue"]
        },
        optimizeDeps: {
          exclude: EXCLUDE,
          include: INCLUDE.filter((i) => !EXCLUDE.includes(i)).map((i) => `@slidev/cli > @slidev/client > ${i}`)
        },
        css: options.data.config.css === "unocss" ? {
          postcss: {
            plugins: [
              await import("postcss-nested").then((r) => (r.default || r)())
            ]
          }
        } : {},
        server: {
          fs: {
            strict: true,
            allow: uniq([
              options.userWorkspaceRoot,
              options.cliRoot,
              options.clientRoot,
              ...options.roots
            ])
          }
        },
        publicDir: join3(options.userRoot, "public"),
        build: {
          rollupOptions: {
            output: {
              chunkFileNames(chunkInfo) {
                const DEFAULT = "assets/[name]-[hash].js";
                if (chunkInfo.name.includes("/"))
                  return DEFAULT;
                if (chunkInfo.moduleIds.filter((i) => isSlidevClient(i)).length > chunkInfo.moduleIds.length * 0.6)
                  return "assets/slidev/[name]-[hash].js";
                if (chunkInfo.moduleIds.filter((i) => i.match(/\/monaco-editor(-core)?\//)).length > chunkInfo.moduleIds.length * 0.6)
                  return "assets/monaco/[name]-[hash].js";
                return DEFAULT;
              },
              manualChunks(id) {
                if (id.startsWith("/@slidev-monaco-types/") || id.includes("/@slidev/monaco-types") || id.endsWith("?monaco-types&raw"))
                  return "monaco/bundled-types";
                if (id.includes("/shiki/") || id.includes("/@shikijs/"))
                  return `modules/shiki`;
                if (id.startsWith("~icons/"))
                  return "modules/unplugin-icons";
                const matchedAsyncModule = ASYNC_MODULES.find((i) => id.includes(`/node_modules/${i}`));
                if (matchedAsyncModule)
                  return `modules/${matchedAsyncModule.replace("@", "").replace("/", "-")}`;
              }
            }
          }
        }
      };
      function isSlidevClient(id) {
        return id.includes("/@slidev/") || id.includes("/slidev/packages/client/") || id.includes("/@vueuse/");
      }
      if (isInstalledGlobally) {
        injection.cacheDir = join3(options.cliRoot, "node_modules/.vite");
        injection.root = options.cliRoot;
      }
      return mergeConfig2(injection, config);
    },
    configureServer(server) {
      return () => {
        server.middlewares.use(async (req, res, next) => {
          if (req.url.endsWith(".html")) {
            res.setHeader("Content-Type", "text/html");
            res.statusCode = 200;
            res.end(await getIndexHtml(options));
            return;
          }
          next();
        });
      };
    }
  };
}
function getDefine(options) {
  return {
    __DEV__: options.mode === "dev" ? "true" : "false",
    __SLIDEV_CLIENT_ROOT__: JSON.stringify(toAtFS(options.clientRoot)),
    __SLIDEV_HASH_ROUTE__: JSON.stringify(options.data.config.routerMode === "hash"),
    __SLIDEV_FEATURE_DRAWINGS__: JSON.stringify(options.data.config.drawings.enabled === true || options.data.config.drawings.enabled === options.mode),
    __SLIDEV_FEATURE_EDITOR__: JSON.stringify(options.mode === "dev" && options.data.config.editor !== false),
    __SLIDEV_FEATURE_DRAWINGS_PERSIST__: JSON.stringify(!!options.data.config.drawings.persist === true),
    __SLIDEV_FEATURE_RECORD__: JSON.stringify(options.data.config.record === true || options.data.config.record === options.mode),
    __SLIDEV_FEATURE_PRESENTER__: JSON.stringify(options.data.config.presenter === true || options.data.config.presenter === options.mode),
    __SLIDEV_HAS_SERVER__: options.mode !== "build" ? "true" : "false"
  };
}

// node/vite/loaders.ts
import { basename as basename2 } from "node:path";
import { isString as isString2, isTruthy as isTruthy2, notNullish, range } from "@antfu/utils";
import fg3 from "fast-glob";
import fs4 from "fs-extra";
import Markdown from "markdown-it";
import { bold, gray, red, yellow } from "kolorist";
import mila from "markdown-it-link-attributes";
import * as parser from "@slidev/parser/fs";
import equal from "fast-deep-equal";

// node/virtual/configs.ts
import { isString } from "@antfu/utils";
var templateConfigs = {
  id: "/@slidev/configs",
  getContent: async ({ data, remote }, { md: md2 }) => {
    function getTitle() {
      if (isString(data.config.title)) {
        const tokens = md2.parseInline(data.config.title, {});
        return stringifyMarkdownTokens(tokens);
      }
      return data.config.title;
    }
    const config = {
      ...data.config,
      remote,
      title: getTitle()
    };
    if (isString(config.info))
      config.info = md2.render(config.info);
    return `export default ${JSON.stringify(config)}`;
  }
};

// node/virtual/deprecated.ts
var templateLegacyRoutes = {
  id: "/@slidev/routes",
  getContent() {
    return [
      `export { slides } from '#slidev/slides'`,
      `console.warn('[slidev] #slidev/routes is deprecated, use #slidev/slides instead')`
    ].join("\n");
  }
};
var templateLegacyTitles = {
  id: "/@slidev/titles.md",
  async getContent() {
    return `
<script setup lang="ts">
import TitleRenderer from '#slidev/title-renderer'
defineProps<{ no: number | string }>()
console.warn('/@slidev/titles.md is deprecated, import from #slidev/title-renderer instead')
</script>

<TitleRenderer :no="no" />
`;
  }
};

// node/virtual/global-components.ts
import { existsSync as existsSync2 } from "node:fs";
import { join as join4 } from "node:path";
function createGlobalComponentTemplate(layer) {
  return {
    id: `/@slidev/global-components/${layer}`,
    getContent({ roots }) {
      const components = roots.flatMap((root) => {
        if (layer === "top") {
          return [
            join4(root, "global.vue"),
            join4(root, "global-top.vue"),
            join4(root, "GlobalTop.vue")
          ];
        } else {
          return [
            join4(root, "global-bottom.vue"),
            join4(root, "GlobalBottom.vue")
          ];
        }
      }).filter((i) => existsSync2(i));
      const imports = components.map((i, idx) => `import __n${idx} from '${toAtFS(i)}'`).join("\n");
      const render = components.map((i, idx) => `h(__n${idx})`).join(",");
      return `
${imports}
import { h } from 'vue'
export default {
render() {
  return [${render}]
}
}
`;
    }
  };
}
var templateNavControls = {
  id: "/@slidev/custom-nav-controls",
  getContent({ roots }) {
    const components = roots.flatMap((root) => {
      return [
        join4(root, "custom-nav-controls.vue"),
        join4(root, "CustomNavControls.vue")
      ];
    }).filter((i) => existsSync2(i));
    const imports = components.map((i, idx) => `import __n${idx} from '${toAtFS(i)}'`).join("\n");
    const render = components.map((i, idx) => `h(__n${idx})`).join(",");
    return `
${imports}
import { h } from 'vue'
export default {
render() {
  return [${render}]
}
}
`;
  }
};
var templateGlobalTop = createGlobalComponentTemplate("top");
var templateGlobalBottom = createGlobalComponentTemplate("bottom");

// node/virtual/layouts.ts
import { objectMap } from "@antfu/utils";
var templateLayouts = {
  id: "/@slidev/layouts",
  async getContent(_, { getLayouts }) {
    const imports = [];
    const layouts = objectMap(
      await getLayouts(),
      (k, v) => {
        imports.push(`import __layout_${k} from "${toAtFS(v)}"`);
        return [k, `__layout_${k}`];
      }
    );
    return [
      imports.join("\n"),
      `export default {
${Object.entries(layouts).map(([k, v]) => `"${k}": ${v}`).join(",\n")}
}`
    ].join("\n\n");
  }
};

// node/virtual/monaco-types.ts
import { builtinModules } from "node:module";
import { join as join5, resolve as resolve2 } from "node:path";
import fg2 from "fast-glob";
import { uniq as uniq2 } from "@antfu/utils";

// node/syntax/transform/monaco.ts
import { isTruthy } from "@antfu/utils";
import lz from "lz-string";
function transformMonaco(md2, enabled = true) {
  if (!enabled)
    return truncateMancoMark(md2);
  md2 = md2.replace(
    /^```(\w+?)\s*{monaco-diff}\s*?({.*?})?\s*?\n([\s\S]+?)^~~~\s*?\n([\s\S]+?)^```/mg,
    (full, lang = "ts", options = "{}", code, diff) => {
      lang = lang.trim();
      options = options.trim() || "{}";
      const encoded = lz.compressToBase64(code);
      const encodedDiff = lz.compressToBase64(diff);
      return `<Monaco code-lz="${encoded}" diff-lz="${encodedDiff}" lang="${lang}" v-bind="${options}" />`;
    }
  );
  md2 = md2.replace(
    /^```(\w+?)\s*{monaco}\s*?({.*?})?\s*?\n([\s\S]+?)^```/mg,
    (full, lang = "ts", options = "{}", code) => {
      lang = lang.trim();
      options = options.trim() || "{}";
      const encoded = lz.compressToBase64(code);
      return `<Monaco code-lz="${encoded}" lang="${lang}" v-bind="${options}" />`;
    }
  );
  md2 = md2.replace(
    /^```(\w+?)\s*{monaco-run}\s*?({.*?})?\s*?\n([\s\S]+?)^```/mg,
    (full, lang = "ts", options = "{}", code) => {
      lang = lang.trim();
      options = options.trim() || "{}";
      const encoded = lz.compressToBase64(code);
      return `<Monaco runnable code-lz="${encoded}" lang="${lang}" v-bind="${options}" />`;
    }
  );
  return md2;
}
function scanMonacoModules(md2) {
  const typeModules = /* @__PURE__ */ new Set();
  md2.replace(
    /^```(\w+?)\s*{monaco([\w:,-]*)}[\s\n]*([\s\S]+?)^```/mg,
    (full, lang = "ts", options, code) => {
      options = options || "";
      lang = lang.trim();
      if (lang === "ts" || lang === "typescript") {
        Array.from(code.matchAll(/\s+from\s+(["'])([\/\w@-]+)\1/g)).map((i) => i[2]).filter(isTruthy).map((i) => typeModules.add(i));
      }
      return "";
    }
  );
  return Array.from(typeModules);
}
function truncateMancoMark(md2) {
  return md2.replace(/{monaco([\w:,-]*)}/g, "");
}

// node/virtual/monaco-types.ts
var templateMonacoTypes = {
  id: "/@slidev/monaco-types",
  getContent: async ({ userRoot, data }) => {
    const typesRoot = join5(userRoot, "snippets");
    const files = await fg2(["**/*.ts", "**/*.mts", "**/*.cts"], { cwd: typesRoot });
    let result = 'import { addFile } from "@slidev/client/setup/monaco.ts"\n';
    for (const file of files) {
      const url = `${toAtFS(resolve2(typesRoot, file))}?monaco-types&raw`;
      result += `addFile(import(${JSON.stringify(url)}), ${JSON.stringify(file)})
`;
    }
    const deps = [...data.config.monacoTypesAdditionalPackages];
    if (data.config.monacoTypesSource === "local")
      deps.push(...scanMonacoModules(data.slides.map((s) => s.source.raw).join()));
    function mapModuleNameToModule(moduleSpecifier) {
      if (moduleSpecifier.startsWith("node:"))
        return "node";
      if (builtinModules.includes(moduleSpecifier))
        return "node";
      const mainPackageName = moduleSpecifier.split("/")[0];
      if (builtinModules.includes(mainPackageName) && !mainPackageName.startsWith("@"))
        return "node";
      const [a = "", b = ""] = moduleSpecifier.split("/");
      const moduleName = a.startsWith("@") ? `${a}/${b}` : a;
      return moduleName;
    }
    for (const specifier of uniq2(deps)) {
      if (specifier[0] === ".")
        continue;
      const moduleName = mapModuleNameToModule(specifier);
      result += `import(${JSON.stringify(`/@slidev-monaco-types/resolve?pkg=${moduleName}`)})
`;
    }
    return result;
  }
};

// node/virtual/setups.ts
import { existsSync as existsSync3 } from "node:fs";
import { join as join6 } from "node:path";
function createSetupTemplate(name) {
  return {
    id: `/@slidev/setups/${name}`,
    getContent({ roots }) {
      const setups = roots.flatMap((i) => {
        const path2 = join6(i, "setup", name);
        return [".ts", ".mts", ".js", ".mjs"].map((ext) => path2 + ext);
      }).filter((i) => existsSync3(i));
      const imports = [];
      setups.forEach((path2, idx) => {
        imports.push(`import __n${idx} from '${toAtFS(path2)}'`);
      });
      imports.push(`export default [${setups.map((_, idx) => `__n${idx}`).join(",")}]`);
      return imports.join("\n");
    }
  };
}
var setupModules = ["shiki", "code-runners", "monaco", "mermaid", "main", "root", "shortcuts"];
var templateSetups = setupModules.map(createSetupTemplate);

// node/setups/shiki.ts
import fs3 from "node:fs/promises";
async function loadShikiSetups(clientRoot, roots) {
  const result = await loadSetups(
    clientRoot,
    roots,
    "shiki.ts",
    {
      /** @deprecated */
      async loadTheme(path2) {
        console.warn("[slidev] `loadTheme` in `setup/shiki.ts` is deprecated. Pass directly the theme name it's supported by Shiki. For custom themes, load it manually via `JSON.parse(fs.readFileSync(path, 'utf-8'))` and pass the raw JSON object instead.");
        return JSON.parse(await fs3.readFile(path2, "utf-8"));
      }
    },
    {},
    false
  );
  if ("theme" in result && "themes" in result)
    delete result.theme;
  if (result.theme && typeof result.theme !== "string" && !result.theme.name && !result.theme.tokenColors) {
    result.themes = result.theme;
    delete result.theme;
  }
  if (!result.theme && !result.themes) {
    result.themes = {
      dark: "vitesse-dark",
      light: "vitesse-light"
    };
  }
  if (result.themes)
    result.defaultColor = false;
  return result;
}

// node/virtual/shiki.ts
var templateShiki = {
  id: "/@slidev/shiki",
  getContent: async ({ clientRoot, roots }) => {
    const options = await loadShikiSetups(clientRoot, roots);
    const langs = await resolveLangs(options.langs || ["javascript", "typescript", "html", "css"]);
    const resolvedThemeOptions = "themes" in options ? {
      themes: Object.fromEntries(await Promise.all(
        Object.entries(options.themes).map(async ([name, value]) => [name, await resolveTheme(value)])
      ))
    } : {
      theme: await resolveTheme(options.theme || "vitesse-dark")
    };
    const themes = resolvedThemeOptions.themes ? Object.values(resolvedThemeOptions.themes) : [resolvedThemeOptions.theme];
    const themeOptionsNames = resolvedThemeOptions.themes ? { themes: Object.fromEntries(Object.entries(resolvedThemeOptions.themes).map(([name, value]) => [name, typeof value === "string" ? value : value.name])) } : { theme: typeof resolvedThemeOptions.theme === "string" ? resolvedThemeOptions.theme : resolvedThemeOptions.theme.name };
    async function normalizeGetter(p) {
      return Promise.resolve(typeof p === "function" ? p() : p).then((r) => r.default || r);
    }
    async function resolveLangs(langs2) {
      return Array.from(new Set((await Promise.all(
        langs2.map(async (lang) => await normalizeGetter(lang).then((r) => Array.isArray(r) ? r : [r]))
      )).flat()));
    }
    async function resolveTheme(theme) {
      return typeof theme === "string" ? theme : await normalizeGetter(theme);
    }
    const langsInit = await Promise.all(
      langs.map(async (lang) => typeof lang === "string" ? `import('${await resolveImportUrl(`shiki/langs/${lang}.mjs`)}')` : JSON.stringify(lang))
    );
    const themesInit = await Promise.all(themes.map(async (theme) => typeof theme === "string" ? `import('${await resolveImportUrl(`shiki/themes/${theme}.mjs`)}')` : JSON.stringify(theme)));
    const langNames = langs.flatMap((lang) => typeof lang === "string" ? lang : lang.name);
    const lines = [];
    lines.push(
      `import { getHighlighterCore } from "${await resolveImportUrl("shiki/core")}"`,
      `export { shikiToMonaco } from "${await resolveImportUrl("@shikijs/monaco")}"`,
      `export const languages = ${JSON.stringify(langNames)}`,
      `export const themes = ${JSON.stringify(themeOptionsNames.themes || themeOptionsNames.theme)}`,
      "export const shiki = getHighlighterCore({",
      `  themes: [${themesInit.join(",")}],`,
      `  langs: [${langsInit.join(",")}],`,
      `  loadWasm: import('${await resolveImportUrl("shiki/wasm")}'),`,
      "})"
    );
    return lines.join("\n");
  }
};

// node/virtual/slides.ts
var VIRTUAL_SLIDE_PREFIX = "/@slidev/slides/";
var templateSlides = {
  id: "/@slidev/slides",
  async getContent({ data }, { getLayouts }) {
    const layouts = await getLayouts();
    const imports = [
      `import { shallowRef } from 'vue'`,
      `import * as __layout__error from '${layouts.error}'`
    ];
    const slides = data.slides.map((_, idx) => {
      const no = idx + 1;
      imports.push(`import { meta as f${no} } from '${VIRTUAL_SLIDE_PREFIX}${no}.frontmatter'`);
      return `{
          no: ${no},
          meta: f${no},
          component: async () => {
            try {
              return await import('${VIRTUAL_SLIDE_PREFIX}${no}.md')
            }
            catch(e) {
              console.error('Failed to load slide ${no}:', e)
              return __layout__error
            }
          },
        }`;
    });
    return [
      ...imports,
      `const data = [
${slides.join(",\n")}
]`,
      `if (import.meta.hot) {`,
      `  import.meta.hot.data.slides ??= shallowRef()`,
      `  import.meta.hot.data.slides.value = data`,
      `  import.meta.hot.accept()`,
      `}`,
      `export const slides = import.meta.hot ? import.meta.hot.data.slides : shallowRef(data)`
    ].join("\n");
  }
};

// node/virtual/styles.ts
import { join as join7 } from "node:path";
import { existsSync as existsSync4 } from "node:fs";
var templateStyle = {
  id: "/@slidev/styles",
  getContent: async ({ data, clientRoot, roots }) => {
    function resolveUrlOfClient(name) {
      return toAtFS(join7(clientRoot, name));
    }
    const imports = [
      `import "${resolveUrlOfClient("styles/vars.css")}"`,
      `import "${resolveUrlOfClient("styles/index.css")}"`,
      `import "${resolveUrlOfClient("styles/code.css")}"`,
      `import "${resolveUrlOfClient("styles/katex.css")}"`,
      `import "${resolveUrlOfClient("styles/transitions.css")}"`
    ];
    for (const root of roots) {
      const styles = [
        join7(root, "styles", "index.ts"),
        join7(root, "styles", "index.js"),
        join7(root, "styles", "index.css"),
        join7(root, "styles.css"),
        join7(root, "style.css")
      ];
      for (const style of styles) {
        if (existsSync4(style)) {
          imports.push(`import "${toAtFS(style)}"`);
          continue;
        }
      }
    }
    if (data.features.katex)
      imports.push(`import "${await resolveImportUrl("katex/dist/katex.min.css")}"`);
    if (data.config.highlighter === "shiki") {
      imports.push(
        `import "${await resolveImportUrl("@shikijs/vitepress-twoslash/style.css")}"`,
        `import "${resolveUrlOfClient("styles/shiki-twoslash.css")}"`
      );
    }
    if (data.config.css === "unocss") {
      imports.unshift(
        `import "${await resolveImportUrl("@unocss/reset/tailwind.css")}"`,
        'import "uno:preflights.css"',
        'import "uno:typography.css"',
        'import "uno:shortcuts.css"'
      );
      imports.push('import "uno.css"');
    }
    return imports.join("\n");
  }
};

// node/virtual/titles.ts
var templateTitleRendererMd = {
  id: "/@slidev/title-renderer.md",
  async getContent({ data }) {
    const lines = data.slides.map(({ title }, i) => `<template ${i === 0 ? "v-if" : "v-else-if"}="+no === ${i + 1}">

${title}

</template>`);
    lines.push(`<script setup lang="ts">defineProps<{ no: number | string }>()</script>`);
    return lines.join("\n");
  }
};
var templateTitleRenderer = {
  id: "/@slidev/title-renderer",
  async getContent() {
    return 'export { default } from "/@slidev/title-renderer.md"';
  }
};

// node/virtual/index.ts
var templates = [
  templateShiki,
  templateMonacoTypes,
  templateConfigs,
  templateStyle,
  templateGlobalBottom,
  templateGlobalTop,
  templateNavControls,
  templateSlides,
  templateLayouts,
  templateTitleRenderer,
  templateTitleRendererMd,
  ...templateSetups,
  // Deprecated
  templateLegacyRoutes,
  templateLegacyTitles
];

// node/vite/loaders.ts
var regexId = /^\/\@slidev\/slide\/(\d+)\.(md|json)(?:\?import)?$/;
var regexIdQuery = /(\d+?)\.(md|json|frontmatter)$/;
var templateInjectionMarker = "/* @slidev-injection */";
var templateImportContextUtils = `import {
  useSlideContext,
  provideFrontmatter as _provideFrontmatter,
  frontmatterToProps as _frontmatterToProps,
} from "@slidev/client/context.ts"`.replace(/\n\s*/g, " ");
var templateInitContext = `const { $slidev, $nav, $clicksContext, $clicks, $page, $renderContext, $frontmatter } = useSlideContext()`;
function getBodyJson(req) {
  return new Promise((resolve4, reject) => {
    let body = "";
    req.on("data", (chunk) => body += chunk);
    req.on("error", reject);
    req.on("end", () => {
      try {
        resolve4(JSON.parse(body) || {});
      } catch (e) {
        reject(e);
      }
    });
  });
}
var md = Markdown({ html: true });
md.use(mila, {
  attrs: {
    target: "_blank",
    rel: "noopener"
  }
});
function renderNote(text = "") {
  let clickCount = 0;
  const html = md.render(
    text.replace(/\[click(?::(\d+))?\]/gi, (_, count = 1) => {
      clickCount += Number(count);
      return `<span class="slidev-note-click-mark" data-clicks="${clickCount}"></span>`;
    })
  );
  return html;
}
function withRenderedNote(data) {
  return {
    ...data,
    noteHTML: renderNote(data?.note)
  };
}
function createSlidesLoader(options, pluginOptions, serverOptions) {
  const hmrPages = /* @__PURE__ */ new Set();
  let server;
  let _layouts_cache_time = 0;
  let _layouts_cache = {};
  const { data, clientRoot, roots, mode } = options;
  const templateCtx = {
    md,
    async getLayouts() {
      const now = Date.now();
      if (now - _layouts_cache_time < 2e3)
        return _layouts_cache;
      const layouts = {};
      for (const root of [...roots, clientRoot]) {
        const layoutPaths = await fg3("layouts/**/*.{vue,ts}", {
          cwd: root,
          absolute: true,
          suppressErrors: true
        });
        for (const layoutPath of layoutPaths) {
          const layout = basename2(layoutPath).replace(/\.\w+$/, "");
          if (layouts[layout])
            continue;
          layouts[layout] = layoutPath;
        }
      }
      _layouts_cache_time = now;
      _layouts_cache = layouts;
      return layouts;
    }
  };
  return [
    {
      name: "slidev:loader",
      configureServer(_server) {
        server = _server;
        updateServerWatcher();
        server.middlewares.use(async (req, res, next) => {
          const match = req.url?.match(regexId);
          if (!match)
            return next();
          const [, no, type] = match;
          const idx = Number.parseInt(no) - 1;
          if (type === "json" && req.method === "GET") {
            res.write(JSON.stringify(withRenderedNote(data.slides[idx])));
            return res.end();
          }
          if (type === "json" && req.method === "POST") {
            const body = await getBodyJson(req);
            const slide = data.slides[idx];
            if (body.content && body.content !== slide.source.content)
              hmrPages.add(idx);
            Object.assign(slide.source, body);
            parser.prettifySlide(slide.source);
            await parser.save(data.markdownFiles[slide.source.filepath]);
            res.statusCode = 200;
            res.write(JSON.stringify(withRenderedNote(slide)));
            return res.end();
          }
          next();
        });
      },
      async handleHotUpdate(ctx) {
        if (!data.watchFiles.includes(ctx.file))
          return;
        await ctx.read();
        const newData = await serverOptions.loadData?.();
        if (!newData)
          return [];
        const moduleIds = /* @__PURE__ */ new Set();
        if (data.slides.length !== newData.slides.length) {
          moduleIds.add(templateSlides.id);
          range(newData.slides.length).map((i) => hmrPages.add(i));
        }
        if (!equal(data.headmatter.defaults, newData.headmatter.defaults)) {
          moduleIds.add(templateSlides.id);
          range(data.slides.length).map((i) => hmrPages.add(i));
        }
        if (!equal(data.config, newData.config))
          moduleIds.add(templateConfigs.id);
        if (!equal(data.features, newData.features)) {
          setTimeout(() => {
            ctx.server.hot.send({ type: "full-reload" });
          }, 1);
        }
        const length = Math.min(data.slides.length, newData.slides.length);
        for (let i = 0; i < length; i++) {
          const a = data.slides[i];
          const b = newData.slides[i];
          if (!hmrPages.has(i) && a.content.trim() === b.content.trim() && a.title?.trim() === b.title?.trim() && equal(a.frontmatter, b.frontmatter) && Object.entries(a.snippetsUsed ?? {}).every(([file, oldContent]) => {
            try {
              const newContent = fs4.readFileSync(file, "utf-8");
              return oldContent === newContent;
            } catch {
              return false;
            }
          })) {
            if (a.note !== b.note) {
              ctx.server.hot.send(
                "slidev:update-note",
                {
                  no: i + 1,
                  note: b.note || "",
                  noteHTML: renderNote(b.note || "")
                }
              );
            }
            continue;
          }
          ctx.server.hot.send(
            "slidev:update-slide",
            {
              no: i + 1,
              data: withRenderedNote(newData.slides[i])
            }
          );
          hmrPages.add(i);
        }
        Object.assign(data, newData);
        if (hmrPages.size > 0)
          moduleIds.add(templateTitleRendererMd.id);
        const vueModules = Array.from(hmrPages).flatMap((i) => [
          ctx.server.moduleGraph.getModuleById(`${VIRTUAL_SLIDE_PREFIX}${i + 1}.frontmatter`),
          ctx.server.moduleGraph.getModuleById(`${VIRTUAL_SLIDE_PREFIX}${i + 1}.md`)
        ]);
        hmrPages.clear();
        const moduleEntries = [
          ...vueModules,
          ...Array.from(moduleIds).map((id) => ctx.server.moduleGraph.getModuleById(id))
        ].filter(notNullish).filter((i) => !i.id?.startsWith("/@id/@vite-icons"));
        updateServerWatcher();
        return moduleEntries;
      },
      resolveId(id) {
        if (id.startsWith(VIRTUAL_SLIDE_PREFIX) || id.startsWith("/@slidev/"))
          return id;
        return null;
      },
      async load(id) {
        const template = templates.find((i) => i.id === id);
        if (template) {
          return {
            code: await template.getContent(options, templateCtx),
            map: { mappings: "" }
          };
        }
        if (id.startsWith(VIRTUAL_SLIDE_PREFIX)) {
          const remaning = id.slice(VIRTUAL_SLIDE_PREFIX.length);
          const match = remaning.match(regexIdQuery);
          if (match) {
            const [, no, type] = match;
            const pageNo = Number.parseInt(no) - 1;
            const slide = data.slides[pageNo];
            if (!slide)
              return;
            if (type === "md") {
              return {
                code: slide?.content,
                map: { mappings: "" }
              };
            } else if (type === "frontmatter") {
              const slideBase = {
                ...withRenderedNote(slide),
                frontmatter: void 0,
                source: void 0,
                // remove raw content in build, optimize the bundle size
                ...mode === "build" ? { raw: "", content: "", note: "" } : {}
              };
              const fontmatter = getFrontmatter(pageNo);
              return {
                code: [
                  "// @unocss-include",
                  'import { reactive, computed } from "vue"',
                  `export const frontmatter = reactive(${JSON.stringify(fontmatter)})`,
                  `export const meta = reactive({
                    layout: computed(() => frontmatter.layout),
                    transition: computed(() => frontmatter.transition),
                    class: computed(() => frontmatter.class),
                    clicks: computed(() => frontmatter.clicks),
                    name: computed(() => frontmatter.name),
                    preload: computed(() => frontmatter.preload),
                    slide: {
                      ...(${JSON.stringify(slideBase)}),
                      frontmatter,
                      filepath: ${JSON.stringify(slide.source.filepath)},
                      start: ${JSON.stringify(slide.source.start)},
                      id: ${pageNo},
                      no: ${no},
                    },
                    __clicksContext: null,
                    __preloaded: false,
                  })`,
                  "export default frontmatter",
                  // handle HMR, update frontmatter with update
                  "if (import.meta.hot) {",
                  "  import.meta.hot.accept(({ frontmatter: update }) => {",
                  "    if(!update) return",
                  "    Object.keys(frontmatter).forEach(key => {",
                  "      if (!(key in update)) delete frontmatter[key]",
                  "    })",
                  "    Object.assign(frontmatter, update)",
                  "  })",
                  "}"
                ].join("\n"),
                map: { mappings: "" }
              };
            }
          }
          return {
            code: "",
            map: { mappings: "" }
          };
        }
      }
    },
    {
      name: "slidev:layout-transform:pre",
      enforce: "pre",
      async transform(code, id) {
        if (!id.startsWith(VIRTUAL_SLIDE_PREFIX))
          return;
        const remaning = id.slice(VIRTUAL_SLIDE_PREFIX.length);
        const match = remaning.match(regexIdQuery);
        if (!match)
          return;
        const [, no, type] = match;
        if (type !== "md")
          return;
        const pageNo = Number.parseInt(no) - 1;
        return transformMarkdown(code, pageNo);
      }
    },
    {
      name: "slidev:context-transform:pre",
      enforce: "pre",
      async transform(code, id) {
        if (!id.endsWith(".vue") || id.includes("/@slidev/client/") || id.includes("/packages/client/"))
          return;
        return transformVue(code);
      }
    },
    {
      name: "slidev:slide-transform:post",
      enforce: "post",
      transform(code, id) {
        if (!id.match(/\/@slidev\/slides\/\d+\.md($|\?)/))
          return;
        const replaced = code.replace("if (_rerender_only)", "if (false)");
        if (replaced !== code)
          return replaced;
      }
    },
    {
      name: "slidev:index-html-transform",
      transformIndexHtml() {
        const { info, author, keywords } = data.headmatter;
        return [
          {
            tag: "title",
            children: getTitle()
          },
          info && {
            tag: "meta",
            attrs: {
              name: "description",
              content: info
            }
          },
          author && {
            tag: "meta",
            attrs: {
              name: "author",
              content: author
            }
          },
          keywords && {
            tag: "meta",
            attrs: {
              name: "keywords",
              content: Array.isArray(keywords) ? keywords.join(", ") : keywords
            }
          }
        ].filter(isTruthy2);
      }
    }
  ];
  function updateServerWatcher() {
    if (!server)
      return;
    server.watcher.add(data.watchFiles);
  }
  function getFrontmatter(pageNo) {
    return {
      ...data.headmatter?.defaults || {},
      ...data.slides[pageNo]?.frontmatter || {}
    };
  }
  async function transformMarkdown(code, pageNo) {
    const layouts = await templateCtx.getLayouts();
    const frontmatter = getFrontmatter(pageNo);
    let layoutName = frontmatter?.layout || (pageNo === 0 ? "cover" : "default");
    if (!layouts[layoutName]) {
      console.error(red(`
Unknown layout "${bold(layoutName)}".${yellow(" Available layouts are:")}`) + Object.keys(layouts).map((i, idx) => (idx % 3 === 0 ? "\n    " : "") + gray(i.padEnd(15, " "))).join("  "));
      console.error();
      layoutName = "default";
    }
    delete frontmatter.title;
    const imports = [
      `import InjectedLayout from "${toAtFS(layouts[layoutName])}"`,
      `import frontmatter from "${toAtFS(`${VIRTUAL_SLIDE_PREFIX + (pageNo + 1)}.frontmatter`)}"`,
      templateImportContextUtils,
      "_provideFrontmatter(frontmatter)",
      templateInitContext,
      templateInjectionMarker
    ];
    code = code.replace(/(<script setup.*>)/g, `$1
${imports.join("\n")}
`);
    const injectA = code.indexOf("<template>") + "<template>".length;
    const injectB = code.lastIndexOf("</template>");
    let body = code.slice(injectA, injectB).trim();
    if (body.startsWith("<div>") && body.endsWith("</div>"))
      body = body.slice(5, -6);
    code = `${code.slice(0, injectA)}
<InjectedLayout v-bind="_frontmatterToProps(frontmatter,${pageNo})">
${body}
</InjectedLayout>
${code.slice(injectB)}`;
    return code;
  }
  function transformVue(code) {
    if (code.includes(templateInjectionMarker) || code.includes("useSlideContext()"))
      return code;
    const imports = [
      templateImportContextUtils,
      templateInitContext,
      templateInjectionMarker
    ];
    const matchScript = code.match(/<script((?!setup).)*(setup)?.*>/);
    if (matchScript && matchScript[2]) {
      return code.replace(/(<script.*>)/g, `$1
${imports.join("\n")}
`);
    } else if (matchScript && !matchScript[2]) {
      const matchExport = code.match(/export\s+default\s+{/);
      if (matchExport) {
        const exportIndex = (matchExport.index || 0) + matchExport[0].length;
        let component = code.slice(exportIndex);
        component = component.slice(0, component.indexOf("</script>"));
        const scriptIndex = (matchScript.index || 0) + matchScript[0].length;
        const provideImport = '\nimport { injectionSlidevContext } from "@slidev/client/constants.ts"\n';
        code = `${code.slice(0, scriptIndex)}${provideImport}${code.slice(scriptIndex)}`;
        let injectIndex = exportIndex + provideImport.length;
        let injectObject = "$slidev: { from: injectionSlidevContext },";
        const matchInject = component.match(/.*inject\s*:\s*([\[{])/);
        if (matchInject) {
          injectIndex += (matchInject.index || 0) + matchInject[0].length;
          if (matchInject[1] === "[") {
            let injects = component.slice((matchInject.index || 0) + matchInject[0].length);
            const injectEndIndex = injects.indexOf("]");
            injects = injects.slice(0, injectEndIndex);
            injectObject += injects.split(",").map((inject) => `${inject}: {from: ${inject}}`).join(",");
            return `${code.slice(0, injectIndex - 1)}{
${injectObject}
}${code.slice(injectIndex + injectEndIndex + 1)}`;
          } else {
            return `${code.slice(0, injectIndex)}
${injectObject}
${code.slice(injectIndex)}`;
          }
        }
        return `${code.slice(0, injectIndex)}
inject: { ${injectObject} },
${code.slice(injectIndex)}`;
      }
    }
    return `<script setup>
${imports.join("\n")}
</script>
${code}`;
  }
  function getTitle() {
    if (isString2(data.config.title)) {
      const tokens = md.parseInline(data.config.title, {});
      return stringifyMarkdownTokens(tokens);
    }
    return data.config.title;
  }
}

// node/vite/markdown.ts
import Markdown2 from "unplugin-vue-markdown/vite";
import { isTruthy as isTruthy3, slash } from "@antfu/utils";

// ../../node_modules/.pnpm/@hedgedoc+markdown-it-plugins@2.1.4_patch_hash=tuyuxytl56b2vxulpkzt2wf4o4_markdown-it@14.0.0/node_modules/@hedgedoc/markdown-it-plugins/dist/esm/image-size/specialCharacters.js
var SpecialCharacters;
(function(SpecialCharacters2) {
  SpecialCharacters2[SpecialCharacters2["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
  SpecialCharacters2[SpecialCharacters2["OPENING_BRACKET"] = 91] = "OPENING_BRACKET";
  SpecialCharacters2[SpecialCharacters2["OPENING_PARENTHESIS"] = 40] = "OPENING_PARENTHESIS";
  SpecialCharacters2[SpecialCharacters2["WHITESPACE"] = 32] = "WHITESPACE";
  SpecialCharacters2[SpecialCharacters2["NEW_LINE"] = 10] = "NEW_LINE";
  SpecialCharacters2[SpecialCharacters2["EQUALS"] = 61] = "EQUALS";
  SpecialCharacters2[SpecialCharacters2["LOWER_CASE_X"] = 120] = "LOWER_CASE_X";
  SpecialCharacters2[SpecialCharacters2["NUMBER_ZERO"] = 48] = "NUMBER_ZERO";
  SpecialCharacters2[SpecialCharacters2["NUMBER_NINE"] = 57] = "NUMBER_NINE";
  SpecialCharacters2[SpecialCharacters2["PERCENTAGE"] = 37] = "PERCENTAGE";
  SpecialCharacters2[SpecialCharacters2["CLOSING_PARENTHESIS"] = 41] = "CLOSING_PARENTHESIS";
})(SpecialCharacters || (SpecialCharacters = {}));

// ../../node_modules/.pnpm/@hedgedoc+markdown-it-plugins@2.1.4_patch_hash=tuyuxytl56b2vxulpkzt2wf4o4_markdown-it@14.0.0/node_modules/@hedgedoc/markdown-it-plugins/dist/esm/task-lists/index.js
import Token from "markdown-it/lib/token.mjs";
var checkboxRegex = /^ *\[([\sx])] /i;
function taskLists(md2, options = { enabled: false, label: false, lineNumber: false }) {
  md2.core.ruler.after("inline", "task-lists", (state) => processToken(state, options));
  md2.renderer.rules.taskListItemCheckbox = (tokens) => {
    const token = tokens[0];
    const checkedAttribute = token.attrGet("checked") ? 'checked="" ' : "";
    const disabledAttribute = token.attrGet("disabled") ? 'disabled="" ' : "";
    const line = token.attrGet("line");
    const idAttribute = `id="${token.attrGet("id")}" `;
    const dataLineAttribute = line && options.lineNumber ? `data-line="${line}" ` : "";
    return `<input class="task-list-item-checkbox" type="checkbox" ${checkedAttribute}${disabledAttribute}${dataLineAttribute}${idAttribute}/>`;
  };
  md2.renderer.rules.taskListItemLabel_close = () => {
    return "</label>";
  };
  md2.renderer.rules.taskListItemLabel_open = (tokens) => {
    const token = tokens[0];
    const id = token.attrGet("id");
    return `<label for="${id}">`;
  };
}
function processToken(state, options) {
  const allTokens = state.tokens;
  for (let i = 2; i < allTokens.length; i++) {
    if (!isTodoItem(allTokens, i)) {
      continue;
    }
    todoify(allTokens[i], options);
    allTokens[i - 2].attrJoin("class", `task-list-item ${options.enabled ? " enabled" : ""}`);
    const parentToken = findParentToken(allTokens, i - 2);
    if (parentToken) {
      const classes = parentToken.attrGet("class") ?? "";
      if (!classes.match(/(^| )contains-task-list/)) {
        parentToken.attrJoin("class", "contains-task-list");
      }
    }
  }
  return false;
}
function findParentToken(tokens, index) {
  const targetLevel = tokens[index].level - 1;
  for (let currentTokenIndex = index - 1; currentTokenIndex >= 0; currentTokenIndex--) {
    if (tokens[currentTokenIndex].level === targetLevel) {
      return tokens[currentTokenIndex];
    }
  }
  return void 0;
}
function isTodoItem(tokens, index) {
  return isInline(tokens[index]) && isParagraph(tokens[index - 1]) && isListItem(tokens[index - 2]) && startsWithTodoMarkdown(tokens[index]);
}
function todoify(token, options) {
  if (token.children == null) {
    return;
  }
  const id = generateIdForToken(token);
  token.children.splice(0, 0, createCheckboxToken(token, options.enabled, id));
  token.children[1].content = token.children[1].content.replace(checkboxRegex, "");
  if (options.label) {
    token.children.splice(1, 0, createLabelBeginToken(id));
    token.children.push(createLabelEndToken());
  }
}
function generateIdForToken(token) {
  if (token.map) {
    return `task-item-${token.map[0]}`;
  } else {
    return `task-item-${Math.ceil(Math.random() * (1e4 * 1e3) - 1e3)}`;
  }
}
function createCheckboxToken(token, enabled, id) {
  const checkbox = new Token("taskListItemCheckbox", "", 0);
  if (!enabled) {
    checkbox.attrSet("disabled", "true");
  }
  if (token.map) {
    checkbox.attrSet("line", token.map[0].toString());
  }
  checkbox.attrSet("id", id);
  const checkboxRegexResult = checkboxRegex.exec(token.content);
  const isChecked = checkboxRegexResult?.[1].toLowerCase() === "x";
  if (isChecked) {
    checkbox.attrSet("checked", "true");
  }
  return checkbox;
}
function createLabelBeginToken(id) {
  const labelBeginToken = new Token("taskListItemLabel_open", "", 1);
  labelBeginToken.attrSet("id", id);
  return labelBeginToken;
}
function createLabelEndToken() {
  return new Token("taskListItemLabel_close", "", -1);
}
function isInline(token) {
  return token.type === "inline";
}
function isParagraph(token) {
  return token.type === "paragraph_open";
}
function isListItem(token) {
  return token.type === "list_item_open";
}
function startsWithTodoMarkdown(token) {
  return checkboxRegex.test(token.content);
}

// node/vite/markdown.ts
import MarkdownItMdc from "markdown-it-mdc";
import MarkdownItAttrs from "markdown-it-link-attributes";
import MarkdownItFootnote from "markdown-it-footnote";

// node/syntax/markdown-it/markdown-it-katex.ts
import katex from "katex";
function isValidDelim(state, pos) {
  const max = state.posMax;
  let can_open = true;
  let can_close = true;
  const prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;
  const nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;
  if (prevChar === 32 || prevChar === 9 || /* \t */
  nextChar >= 48 && nextChar <= 57)
    can_close = false;
  if (nextChar === 32 || nextChar === 9)
    can_open = false;
  return {
    can_open,
    can_close
  };
}
function math_inline(state, silent) {
  let match, token, res, pos;
  if (state.src[state.pos] !== "$")
    return false;
  res = isValidDelim(state, state.pos);
  if (!res.can_open) {
    if (!silent)
      state.pending += "$";
    state.pos += 1;
    return true;
  }
  const start = state.pos + 1;
  match = start;
  while ((match = state.src.indexOf("$", match)) !== -1) {
    pos = match - 1;
    while (state.src[pos] === "\\")
      pos -= 1;
    if ((match - pos) % 2 === 1)
      break;
    match += 1;
  }
  if (match === -1) {
    if (!silent)
      state.pending += "$";
    state.pos = start;
    return true;
  }
  if (match - start === 0) {
    if (!silent)
      state.pending += "$$";
    state.pos = start + 1;
    return true;
  }
  res = isValidDelim(state, match);
  if (!res.can_close) {
    if (!silent)
      state.pending += "$";
    state.pos = start;
    return true;
  }
  if (!silent) {
    token = state.push("math_inline", "math", 0);
    token.markup = "$";
    token.content = state.src.slice(start, match);
  }
  state.pos = match + 1;
  return true;
}
function math_block(state, start, end, silent) {
  let firstLine;
  let lastLine;
  let next;
  let lastPos;
  let found = false;
  let pos = state.bMarks[start] + state.tShift[start];
  let max = state.eMarks[start];
  if (pos + 2 > max)
    return false;
  if (state.src.slice(pos, pos + 2) !== "$$")
    return false;
  pos += 2;
  firstLine = state.src.slice(pos, max);
  if (silent)
    return true;
  if (firstLine.trim().slice(-2) === "$$") {
    firstLine = firstLine.trim().slice(0, -2);
    found = true;
  }
  for (next = start; !found; ) {
    next++;
    if (next >= end)
      break;
    pos = state.bMarks[next] + state.tShift[next];
    max = state.eMarks[next];
    if (pos < max && state.tShift[next] < state.blkIndent) {
      break;
    }
    if (state.src.slice(pos, max).trim().slice(-2) === "$$") {
      lastPos = state.src.slice(0, max).lastIndexOf("$$");
      lastLine = state.src.slice(pos, lastPos);
      found = true;
    }
  }
  state.line = next + 1;
  const token = state.push("math_block", "math", 0);
  token.block = true;
  token.content = (firstLine && firstLine.trim() ? `${firstLine}
` : "") + state.getLines(start + 1, next, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : "");
  token.map = [start, state.line];
  token.markup = "$$";
  return true;
}
function math_plugin(md2, options) {
  options = options || {};
  const katexInline = function(latex) {
    options.displayMode = false;
    try {
      return katex.renderToString(latex, options);
    } catch (error) {
      if (options.throwOnError)
        console.warn(error);
      return latex;
    }
  };
  const inlineRenderer = function(tokens, idx) {
    return katexInline(tokens[idx].content);
  };
  const katexBlock = function(latex) {
    options.displayMode = true;
    try {
      return `<p>${katex.renderToString(latex, options)}</p>`;
    } catch (error) {
      if (options.throwOnError)
        console.warn(error);
      return latex;
    }
  };
  const blockRenderer = function(tokens, idx) {
    return `${katexBlock(tokens[idx].content)}
`;
  };
  md2.inline.ruler.after("escape", "math_inline", math_inline);
  md2.block.ruler.after("blockquote", "math_block", math_block, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  });
  md2.renderer.rules.math_inline = inlineRenderer;
  md2.renderer.rules.math_block = blockRenderer;
}

// node/syntax/markdown-it/markdown-it-prism.ts
import { createRequire } from "node:module";
import Prism from "prismjs";
import loadLanguages from "prismjs/components/index.js";
import * as htmlparser2 from "htmlparser2";

// node/syntax/transform/utils.ts
function normalizeRangeStr(rangeStr = "") {
  return !rangeStr.trim() ? [] : rangeStr.trim().split(/\|/g).map((i) => i.trim());
}
function getCodeBlocks(md2) {
  const codeblocks = Array.from(md2.matchAll(/^```[\s\S]*?^```/mg)).map((m) => {
    const start = m.index;
    const end = m.index + m[0].length;
    const startLine = md2.slice(0, start).match(/\n/g)?.length || 0;
    const endLine = md2.slice(0, end).match(/\n/g)?.length || 0;
    return [start, end, startLine, endLine];
  });
  return {
    codeblocks,
    isInsideCodeblocks(idx) {
      return codeblocks.some(([s, e]) => s <= idx && idx <= e);
    },
    isLineInsideCodeblocks(line) {
      return codeblocks.some(([, , s, e]) => s <= line && line <= e);
    }
  };
}
function escapeVueInCode(md2) {
  return md2.replace(/{{/g, "&lbrace;&lbrace;");
}

// node/syntax/markdown-it/markdown-it-prism.ts
var require2 = createRequire(import.meta.url);
var Tag = class {
  tagname;
  attributes;
  constructor(tagname, attributes) {
    this.tagname = tagname;
    this.attributes = attributes;
  }
  asOpen() {
    return `<${this.tagname} ${Object.entries(this.attributes).map(([key, value]) => `${key}="${value}"`).join(" ")}>`;
  }
  asClosed() {
    return `</${this.tagname}>`;
  }
};
var DEFAULTS = {
  plugins: [],
  init: () => {
  },
  defaultLanguageForUnknown: void 0,
  defaultLanguageForUnspecified: void 0,
  defaultLanguage: void 0
};
function loadPrismLang(lang) {
  if (!lang)
    return void 0;
  let langObject = Prism.languages[lang];
  if (langObject === void 0) {
    loadLanguages([lang]);
    langObject = Prism.languages[lang];
  }
  return langObject;
}
function loadPrismPlugin(name) {
  try {
    require2(`prismjs/plugins/${name}/prism-${name}`);
  } catch (e) {
    throw new Error(`Cannot load Prism plugin "${name}". Please check the spelling.`);
  }
}
function selectLanguage(options, lang) {
  let langToUse = lang;
  if (langToUse === "" && options.defaultLanguageForUnspecified !== void 0)
    langToUse = options.defaultLanguageForUnspecified;
  let prismLang = loadPrismLang(langToUse);
  if (prismLang === void 0 && options.defaultLanguageForUnknown !== void 0) {
    langToUse = options.defaultLanguageForUnknown;
    prismLang = loadPrismLang(langToUse);
  }
  return [langToUse, prismLang];
}
function highlight(markdownit, options, text, lang) {
  const [langToUse, prismLang] = selectLanguage(options, lang);
  let code = text.trimEnd();
  code = prismLang ? highlightPrism(code, prismLang, langToUse) : markdownit.utils.escapeHtml(code);
  code = code.split(/\r?\n/g).map((line) => `<span class="line">${line}</span>`).join("\n");
  const classAttribute = langToUse ? ` class="slidev-code ${markdownit.options.langPrefix}${markdownit.utils.escapeHtml(langToUse)}"` : "";
  return escapeVueInCode(`<pre${classAttribute}><code>${code}</code></pre>`);
}
function highlightPrism(code, prismLang, langToUse) {
  const openTags = [];
  const parser2 = new htmlparser2.Parser({
    onopentag(tagname, attributes) {
      openTags.push(new Tag(tagname, attributes));
    },
    onclosetag() {
      openTags.pop();
    }
  });
  code = Prism.highlight(code, prismLang, langToUse);
  code = code.split(/\r?\n/g).map((line) => {
    const prefix = openTags.map((tag) => tag.asOpen()).join("");
    parser2.write(line);
    const postfix = openTags.reverse().map((tag) => tag.asClosed()).join("");
    return prefix + line + postfix;
  }).join("\n");
  parser2.end();
  return code;
}
function checkLanguageOption(options, optionName) {
  const language = options[optionName];
  if (language !== void 0 && loadPrismLang(language) === void 0)
    throw new Error(`Bad option ${optionName}: There is no Prism language '${language}'.`);
}
function markdownItPrism(markdownit, useroptions) {
  const options = Object.assign({}, DEFAULTS, useroptions);
  checkLanguageOption(options, "defaultLanguage");
  checkLanguageOption(options, "defaultLanguageForUnknown");
  checkLanguageOption(options, "defaultLanguageForUnspecified");
  options.defaultLanguageForUnknown = options.defaultLanguageForUnknown || options.defaultLanguage;
  options.defaultLanguageForUnspecified = options.defaultLanguageForUnspecified || options.defaultLanguage;
  options.plugins.forEach(loadPrismPlugin);
  options.init(Prism);
  markdownit.options.highlight = (text, lang) => highlight(markdownit, options, text, lang);
}

// node/syntax/transform/code-wrapper.ts
var reCodeBlock = /^```([\w'-]+?)(?:\s*{([\d\w*,\|-]+)}\s*?({.*?})?(.*?))?\n([\s\S]+?)^```$/mg;
function transformCodeWrapper(md2) {
  return md2.replace(
    reCodeBlock,
    (full, lang = "", rangeStr = "", options = "", attrs = "", code) => {
      const ranges = normalizeRangeStr(rangeStr);
      code = code.trimEnd();
      options = options.trim() || "{}";
      return `
<CodeBlockWrapper v-bind="${options}" :ranges='${JSON.stringify(ranges)}'>

\`\`\`${lang}${attrs}
${code}
\`\`\`

</CodeBlockWrapper>`;
    }
  );
}

// node/syntax/transform/magic-move.ts
import { codeToKeyedTokens } from "shiki-magic-move/core";
import lz2 from "lz-string";
var reMagicMoveBlock = /^````(?:md|markdown) magic-move(?:[ ]*(\{.*?\})?([^\n]*?))?\n([\s\S]+?)^````$/mg;
function transformMagicMove(md2, shiki2, shikiOptions2) {
  return md2.replace(
    reMagicMoveBlock,
    (full, options = "{}", _attrs = "", body) => {
      if (!shiki2 || !shikiOptions2)
        throw new Error("Shiki is required for Magic Move. You may need to set `highlighter: shiki` in your Slidev config.");
      const matches = Array.from(body.matchAll(reCodeBlock));
      if (!matches.length)
        throw new Error("Magic Move block must contain at least one code block");
      const ranges = matches.map((i) => normalizeRangeStr(i[2]));
      const steps = matches.map(
        (i) => codeToKeyedTokens(shiki2, i[5].trimEnd(), {
          ...shikiOptions2,
          lang: i[1]
        })
      );
      const compressed = lz2.compressToBase64(JSON.stringify(steps));
      return `<ShikiMagicMove v-bind="${options}" steps-lz="${compressed}" :step-ranges='${JSON.stringify(ranges)}' />`;
    }
  );
}

// node/syntax/transform/mermaid.ts
import lz3 from "lz-string";
function transformMermaid(md2) {
  return md2.replace(/^```mermaid\s*?({.*?})?\n([\s\S]+?)\n```/mg, (full, options = "", code = "") => {
    code = code.trim();
    options = options.trim() || "{}";
    const encoded = lz3.compressToBase64(code);
    return `<Mermaid code-lz="${encoded}" v-bind="${options}" />`;
  });
}

// node/syntax/transform/plant-uml.ts
import { encode as encodePlantUml } from "plantuml-encoder";
function transformPlantUml(md2, server) {
  return md2.replace(/^```plantuml\s*?({.*?})?\n([\s\S]+?)\n```/mg, (full, options = "", content = "") => {
    const code = encodePlantUml(content.trim());
    options = options.trim() || "{}";
    return `<PlantUml :code="'${code}'" :server="'${server}'" v-bind="${options}" />`;
  });
}

// node/syntax/transform/snippet.ts
import path from "node:path";
import fs5 from "fs-extra";
function dedent(text) {
  const lines = text.split("\n");
  const minIndentLength = lines.reduce((acc, line) => {
    for (let i = 0; i < line.length; i++) {
      if (line[i] !== " " && line[i] !== "	")
        return Math.min(i, acc);
    }
    return acc;
  }, Number.POSITIVE_INFINITY);
  if (minIndentLength < Number.POSITIVE_INFINITY)
    return lines.map((x) => x.slice(minIndentLength)).join("\n");
  return text;
}
function testLine(line, regexp, regionName, end = false) {
  const [full, tag, name] = regexp.exec(line.trim()) || [];
  return full && tag && name === regionName && tag.match(end ? /^[Ee]nd ?[rR]egion$/ : /^[rR]egion$/);
}
function findRegion(lines, regionName) {
  const regionRegexps = [
    /^\/\/ ?#?((?:end)?region) ([\w*-]+)$/,
    // javascript, typescript, java
    /^\/\* ?#((?:end)?region) ([\w*-]+) ?\*\/$/,
    // css, less, scss
    /^#pragma ((?:end)?region) ([\w*-]+)$/,
    // C, C++
    /^<!-- #?((?:end)?region) ([\w*-]+) -->$/,
    // HTML, markdown
    /^#((?:End )Region) ([\w*-]+)$/,
    // Visual Basic
    /^::#((?:end)region) ([\w*-]+)$/,
    // Bat
    /^# ?((?:end)?region) ([\w*-]+)$/
    // C#, PHP, Powershell, Python, perl & misc
  ];
  let regexp = null;
  let start = -1;
  for (const [lineId, line] of lines.entries()) {
    if (regexp === null) {
      for (const reg of regionRegexps) {
        if (testLine(line, reg, regionName)) {
          start = lineId + 1;
          regexp = reg;
          break;
        }
      }
    } else if (testLine(line, regexp, regionName, true)) {
      return { start, end: lineId, regexp };
    }
  }
  return null;
}
function transformSnippet(md2, options, id) {
  const slideId = id.match(/(\d+)\.md$/)?.[1];
  if (!slideId)
    return md2;
  const data = options.data;
  const slideInfo = data.slides[+slideId - 1];
  const dir = path.dirname(slideInfo.source?.filepath ?? options.entry ?? options.userRoot);
  return md2.replace(
    /^<<< *(.+?)(#[\w-]+)? *(?: (\S+?))? *(\{.*)?$/mg,
    (full, filepath = "", regionName = "", lang = "", meta = "") => {
      const firstLine = `\`\`\`${lang || path.extname(filepath).slice(1)} ${meta}`;
      const src = /^\@[\/]/.test(filepath) ? path.resolve(options.userRoot, filepath.slice(2)) : path.resolve(dir, filepath);
      data.watchFiles.push(src);
      const isAFile = fs5.statSync(src).isFile();
      if (!fs5.existsSync(src) || !isAFile) {
        throw new Error(isAFile ? `Code snippet path not found: ${src}` : `Invalid code snippet option`);
      }
      let content = fs5.readFileSync(src, "utf8");
      slideInfo.snippetsUsed ??= {};
      slideInfo.snippetsUsed[src] = content;
      if (regionName) {
        const lines = content.split(/\r?\n/);
        const region = findRegion(lines, regionName.slice(1));
        if (region) {
          content = dedent(
            lines.slice(region.start, region.end).filter((line) => !region.regexp.test(line.trim())).join("\n")
          );
        }
      }
      return `${firstLine}
${content}
\`\`\``;
    }
  );
}

// node/syntax/transform/slot-sugar.ts
function transformSlotSugar(md2) {
  const lines = md2.split(/\r?\n/g);
  let prevSlot = false;
  const { isLineInsideCodeblocks } = getCodeBlocks(md2);
  lines.forEach((line, idx) => {
    if (isLineInsideCodeblocks(idx))
      return;
    const match = line.trimEnd().match(/^::\s*([\w\.\-\:]+)\s*::$/);
    if (match) {
      lines[idx] = `${prevSlot ? "\n\n</template>\n" : "\n"}<template v-slot:${match[1]}="slotProps">
`;
      prevSlot = true;
    }
  });
  if (prevSlot)
    lines[lines.length - 1] += "\n\n</template>";
  return lines.join("\n");
}

// node/syntax/transform/in-page-css.ts
function transformPageCSS(md2, id) {
  const page = id.match(/(\d+)\.md$/)?.[1];
  if (!page)
    return md2;
  const { isInsideCodeblocks } = getCodeBlocks(md2);
  const result = md2.replace(
    /(\n<style[^>]*?>)([\s\S]+?)(<\/style>)/g,
    (full, start, css, end, index) => {
      if (index < 0 || isInsideCodeblocks(index))
        return full;
      if (!start.includes("scoped"))
        start = start.replace("<style", "<style scoped");
      return `${start}
${css}${end}`;
    }
  );
  return result;
}

// node/syntax/transform/katex-wrapper.ts
function transformKaTexWrapper(md2) {
  return md2.replace(
    /^\$\$(?:\s*{([\d\w*,\|-]+)}\s*?({.*?})?\s*?)?\n([\s\S]+?)^\$\$/mg,
    (full, rangeStr = "", options = "", code) => {
      const ranges = !rangeStr.trim() ? [] : rangeStr.trim().split(/\|/g).map((i) => i.trim());
      code = code.trimEnd();
      options = options.trim() || "{}";
      return `<KaTexBlockWrapper v-bind="${options}" :ranges='${JSON.stringify(ranges)}'>

$$
${code}
$$
</KaTexBlockWrapper>
`;
    }
  );
}

// node/vite/markdown.ts
var shiki;
var shikiOptions;
async function createMarkdownPlugin(options, { markdown: mdOptions }) {
  const { data: { config }, roots, mode, entry, clientRoot } = options;
  const setups = [];
  const entryPath = slash(entry);
  if (config.highlighter === "shiki") {
    const [
      options2,
      { getHighlighter, bundledLanguages },
      markdownItShiki,
      transformerTwoslash
    ] = await Promise.all([
      loadShikiSetups(clientRoot, roots),
      import("shiki").then(({ getHighlighter: getHighlighter2, bundledLanguages: bundledLanguages2 }) => ({ bundledLanguages: bundledLanguages2, getHighlighter: getHighlighter2 })),
      import("@shikijs/markdown-it/core").then(({ fromHighlighter }) => fromHighlighter),
      import("@shikijs/vitepress-twoslash").then(({ transformerTwoslash: transformerTwoslash2 }) => transformerTwoslash2)
    ]);
    shikiOptions = options2;
    shiki = await getHighlighter({
      ...options2,
      langs: options2.langs ?? Object.keys(bundledLanguages),
      themes: "themes" in options2 ? Object.values(options2.themes) : [options2.theme]
    });
    const twoslashEnabled = config.twoslash === true || config.twoslash === mode;
    const transformers = [
      ...options2.transformers || [],
      twoslashEnabled && transformerTwoslash({
        explicitTrigger: true,
        twoslashOptions: {
          handbookOptions: {
            noErrorValidation: true
          }
        }
      }),
      {
        pre(pre) {
          this.addClassToHast(pre, "slidev-code");
          delete pre.properties.tabindex;
        },
        postprocess(code) {
          return escapeVueInCode(code);
        }
      }
    ].filter(isTruthy3);
    const plugin = markdownItShiki(shiki, {
      ...options2,
      transformers
    });
    setups.push((md2) => md2.use(plugin));
  } else {
    setups.push((md2) => md2.use(markdownItPrism));
  }
  if (config.mdc)
    setups.push((md2) => md2.use(MarkdownItMdc));
  const KatexOptions = await loadSetups(options.clientRoot, roots, "katex.ts", {}, { strict: false }, false);
  return Markdown2({
    include: [/\.md$/],
    wrapperClasses: "",
    headEnabled: false,
    frontmatter: false,
    escapeCodeTagInterpolation: false,
    markdownItOptions: {
      quotes: `""''`,
      html: true,
      xhtmlOut: true,
      linkify: true,
      ...mdOptions?.markdownItOptions
    },
    ...mdOptions,
    markdownItSetup(md2) {
      md2.use(MarkdownItAttrs, {
        attrs: {
          target: "_blank",
          rel: "noopener"
        }
      });
      md2.use(MarkdownItFootnote);
      md2.use(taskLists, { enabled: true, lineNumber: true, label: true });
      md2.use(math_plugin, KatexOptions);
      setups.forEach((i) => i(md2));
      mdOptions?.markdownItSetup?.(md2);
    },
    transforms: {
      before(code, id) {
        if (id === entryPath)
          return "";
        const monacoEnabled = config.monaco === true || config.monaco === mode;
        if (config.highlighter === "shiki")
          code = transformMagicMove(code, shiki, shikiOptions);
        code = transformSlotSugar(code);
        code = transformSnippet(code, options, id);
        code = transformMermaid(code);
        code = transformPlantUml(code, config.plantUmlServer);
        code = transformMonaco(code, monacoEnabled);
        code = transformCodeWrapper(code);
        code = transformPageCSS(code, id);
        code = transformKaTexWrapper(code);
        return code;
      }
    }
  });
}

// node/vite/compilerFlagsVue.ts
import { objectEntries } from "@antfu/utils";
function createVueCompilerFlagsPlugin(options) {
  const define = objectEntries(getDefine(options));
  return [
    {
      name: "slidev:flags",
      enforce: "pre",
      transform(code, id) {
        if (id.match(/\.vue($|\?)/)) {
          const original = code;
          define.forEach(([from, to]) => {
            code = code.replace(new RegExp(from, "g"), to);
          });
          if (original !== code)
            return code;
        }
      }
    }
  ];
}

// node/vite/monacoTypes.ts
import fs6 from "node:fs/promises";
import { dirname as dirname2, resolve as resolve3 } from "node:path";
import { slash as slash2 } from "@antfu/utils";
import fg4 from "fast-glob";
import { findDepPkgJsonPath } from "vitefu";
function createMonacoTypesLoader({ userRoot }) {
  const resolvedDepsMap = {};
  return {
    name: "slidev:monaco-types-loader",
    resolveId(id) {
      if (id.startsWith("/@slidev-monaco-types/"))
        return id;
      return null;
    },
    async load(id) {
      const matchResolve = id.match(/^\/\@slidev-monaco-types\/resolve\?pkg=(.*?)(?:&importer=(.*))?$/);
      if (matchResolve) {
        const [_, pkg, importer = userRoot] = matchResolve;
        const resolvedDeps = resolvedDepsMap[importer] ??= /* @__PURE__ */ new Set();
        if (resolvedDeps.has(pkg))
          return "";
        resolvedDeps.add(pkg);
        const pkgJsonPath = await findDepPkgJsonPath(pkg, importer);
        if (!pkgJsonPath)
          throw new Error(`Package "${pkg}" not found in "${importer}"`);
        const root = dirname2(pkgJsonPath);
        const pkgJson = JSON.parse(await fs6.readFile(pkgJsonPath, "utf-8"));
        const deps = pkgJson.dependencies ?? {};
        return [
          `import "/@slidev-monaco-types/load?root=${slash2(root)}&name=${pkgJson.name}"`,
          ...Object.keys(deps).map((dep) => `import "/@slidev-monaco-types/resolve?pkg=${dep}&importer=${slash2(root)}"`)
        ].join("\n");
      }
      const matchLoad = id.match(/^\/\@slidev-monaco-types\/load\?root=(.*?)&name=(.*)$/);
      if (matchLoad) {
        const [_, root, name] = matchLoad;
        const files = await fg4(
          [
            "**/*.ts",
            "**/*.mts",
            "**/*.cts",
            "package.json"
          ],
          {
            cwd: root,
            followSymbolicLinks: true,
            ignore: ["**/node_modules/**"]
          }
        );
        if (!files.length)
          return "";
        return [
          'import { addFile } from "@slidev/client/setup/monaco.ts"',
          ...files.map((file) => `addFile(import(${JSON.stringify(`${toAtFS(resolve3(root, file))}?monaco-types&raw`)}), ${JSON.stringify(`node_modules/${name}/${file}`)})`)
        ].join("\n");
      }
    }
  };
}

// node/vite/vue.ts
import Vue from "@vitejs/plugin-vue";
import VueJsx from "@vitejs/plugin-vue-jsx";
var customElements = /* @__PURE__ */ new Set([
  // katex
  "annotation",
  "math",
  "menclose",
  "mfrac",
  "mglyph",
  "mi",
  "mlabeledtr",
  "mn",
  "mo",
  "mover",
  "mpadded",
  "mphantom",
  "mroot",
  "mrow",
  "mspace",
  "msqrt",
  "mstyle",
  "msub",
  "msubsup",
  "msup",
  "mtable",
  "mtd",
  "mtext",
  "mtr",
  "munder",
  "munderover",
  "semantics"
]);
async function createVuePlugin(options, pluginOptions) {
  const {
    vue: vueOptions = {},
    vuejsx: vuejsxOptions = {}
  } = pluginOptions;
  const VuePlugin = Vue({
    include: [/\.vue$/, /\.md$/],
    exclude: [],
    template: {
      compilerOptions: {
        isCustomElement(tag) {
          return customElements.has(tag);
        }
      },
      ...vueOptions?.template
    },
    ...vueOptions
  });
  const VueJsxPlugin = VueJsx(vuejsxOptions);
  return [
    VueJsxPlugin,
    VuePlugin
  ];
}

// node/vite/index.ts
async function ViteSlidevPlugin(options, pluginOptions, serverOptions = {}) {
  const {
    components: componentsOptions = {},
    icons: iconsOptions = {},
    remoteAssets: remoteAssetsOptions = {},
    serverRef: serverRefOptions = {}
  } = pluginOptions;
  const {
    mode,
    themeRoots,
    addonRoots,
    roots,
    data: { config }
  } = options;
  const drawingData = await loadDrawings(options);
  const publicRoots = [...themeRoots, ...addonRoots].map((i) => join8(i, "public")).filter(existsSync5);
  const plugins = [
    createMarkdownPlugin(options, pluginOptions),
    createVuePlugin(options, pluginOptions),
    createSlidesLoader(options, pluginOptions, serverOptions),
    Components({
      extensions: ["vue", "md", "js", "ts", "jsx", "tsx"],
      dirs: [
        join8(options.clientRoot, "builtin"),
        ...roots.map((i) => join8(i, "components")),
        "src/components",
        "components",
        join8(process.cwd(), "components")
      ],
      include: [/\.vue$/, /\.vue\?vue/, /\.vue\?v=/, /\.md$/, /\.md\?vue/],
      exclude: [],
      resolvers: [
        IconsResolver({
          prefix: "",
          customCollections: Object.keys(iconsOptions.customCollections || [])
        })
      ],
      dts: false,
      ...componentsOptions
    }),
    Icons({
      defaultClass: "slidev-icon",
      collectionsNodeResolvePath: fileURLToPath(import.meta.url),
      ...iconsOptions
    }),
    config.remoteAssets === true || config.remoteAssets === mode ? import("vite-plugin-remote-assets").then((r) => r.VitePluginRemoteAssets({
      rules: [
        ...r.DefaultRules,
        {
          match: /\b(https?:\/\/image.unsplash\.com.*?)(?=[`'")\]])/ig,
          ext: ".png"
        }
      ],
      resolveMode: (id) => id.endsWith("index.html") ? "relative" : "@fs",
      awaitDownload: mode === "build",
      ...remoteAssetsOptions
    })) : null,
    ServerRef({
      debug: false,
      // process.env.NODE_ENV === 'development',
      state: {
        sync: false,
        nav: {
          page: 0,
          clicks: 0
        },
        drawings: drawingData,
        ...serverRefOptions.state
      },
      onChanged(key, data, patch, timestamp) {
        serverRefOptions.onChanged && serverRefOptions.onChanged(key, data, patch, timestamp);
        if (!options.data.config.drawings.persist)
          return;
        if (key === "drawings")
          writeDrawings(options, patch ?? data);
      }
    }),
    createConfigPlugin(options),
    createMonacoTypesLoader(options),
    createVueCompilerFlagsPlugin(options),
    publicRoots.length ? import("vite-plugin-static-copy").then((r) => r.viteStaticCopy({
      silent: true,
      targets: publicRoots.map((r2) => ({
        src: `${r2}/*`,
        dest: "theme"
      }))
    })) : null,
    options.inspect ? import("vite-plugin-inspect").then((r) => (r.default || r)({
      dev: true,
      build: true
    })) : null,
    config.css === "none" ? null : import("./unocss-AGKZGMYO.mjs").then((r) => r.createUnocssPlugin(options, pluginOptions))
  ];
  return (await Promise.all(plugins)).flat().filter(notNullish2);
}

export {
  getIndexHtml,
  mergeViteConfigs,
  ViteSlidevPlugin
};
