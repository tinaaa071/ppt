import {
  detectFeatures,
  getDefaultConfig,
  mergeFeatureFlags,
  parse,
  parseAspectRatio,
  parseRangeString,
  parseSlide,
  prettify,
  prettifySlide,
  resolveConfig,
  resolveFonts,
  slash,
  stringify,
  stringifySlide,
  verifyConfig
} from "./chunk-YNRNLEBD.mjs";

// src/fs.ts
import { promises as fs } from "node:fs";
import { dirname, resolve } from "node:path";
import YAML from "js-yaml";
var preparserExtensionLoader = null;
function injectPreparserExtensionLoader(fn) {
  preparserExtensionLoader = fn;
}
async function load(userRoot, filepath, content, mode) {
  const markdown = content ?? await fs.readFile(filepath, "utf-8");
  let extensions;
  if (preparserExtensionLoader) {
    const lines = markdown.split(/\r?\n/g);
    let hm = "";
    if (lines[0].match(/^---([^-].*)?$/) && !lines[1]?.match(/^\s*$/)) {
      let hEnd = 1;
      while (hEnd < lines.length && !lines[hEnd].trimEnd().match(/^---$/))
        hEnd++;
      hm = lines.slice(1, hEnd).join("\n");
    }
    const o = YAML.load(hm) ?? {};
    extensions = await preparserExtensionLoader(o, filepath, mode);
  }
  const markdownFiles = {};
  const slides = [];
  async function loadMarkdown(path, range, frontmatterOverride) {
    let md = markdownFiles[path];
    if (!md) {
      const raw = await fs.readFile(path, "utf-8");
      md = await parse(raw, path, extensions);
      markdownFiles[path] = md;
    }
    for (const index of parseRangeString(md.slides.length, range))
      await loadSlide(md.slides[index - 1], frontmatterOverride);
    return md;
  }
  async function loadSlide(slide, frontmatterOverride) {
    if (slide.frontmatter.disabled || slide.frontmatter.hide)
      return;
    if (slide.frontmatter.src) {
      const [rawPath, rangeRaw] = slide.frontmatter.src.split("#");
      const path = rawPath.startsWith("/") ? resolve(userRoot, rawPath.substring(1)) : resolve(dirname(slide.filepath), rawPath);
      frontmatterOverride = {
        ...slide.frontmatter,
        ...frontmatterOverride
      };
      delete frontmatterOverride.src;
      await loadMarkdown(path, rangeRaw, frontmatterOverride);
    } else {
      slides.push({
        index: slides.length,
        source: slide,
        frontmatter: { ...slide.frontmatter, ...frontmatterOverride },
        content: slide.content,
        note: slide.note,
        title: slide.title,
        level: slide.level
      });
    }
  }
  const entry = await loadMarkdown(filepath);
  const headmatter = {
    title: slides[0]?.title,
    ...entry.slides[0]?.frontmatter
  };
  return {
    slides,
    entry,
    headmatter,
    features: detectFeatures(slides.map((s) => s.source.raw).join("")),
    markdownFiles,
    watchFiles: Object.keys(markdownFiles).map(slash)
  };
}
async function save(markdown) {
  await fs.writeFile(markdown.filepath, stringify(markdown), "utf-8");
}
export {
  detectFeatures,
  getDefaultConfig,
  injectPreparserExtensionLoader,
  load,
  mergeFeatureFlags,
  parse,
  parseAspectRatio,
  parseRangeString,
  parseSlide,
  prettify,
  prettifySlide,
  resolveConfig,
  resolveFonts,
  save,
  stringify,
  stringifySlide,
  verifyConfig
};
