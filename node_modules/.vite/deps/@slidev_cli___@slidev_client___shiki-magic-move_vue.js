import "./chunk-BYPFWIQ6.js";

// node_modules/shiki-magic-move/dist/vue.mjs
import { defineComponent, ref, onMounted, watch, nextTick, h, renderList, computed } from "vue";

// node_modules/diff-match-patch-es/dist/index.mjs
var defaultOptions = Object.freeze({
  diffTimeout: 1,
  diffEditCost: 4,
  matchThreshold: 0.5,
  matchDistance: 1e3,
  patchDeleteThreshold: 0.5,
  patchMargin: 4,
  matchMaxBits: 32
});
function resolveOptions(options) {
  if (options == null ? void 0 : options.__resolved)
    return options;
  const resolved = {
    ...defaultOptions,
    ...options
  };
  Object.defineProperty(resolved, "__resolved", { value: true, enumerable: false });
  return resolved;
}
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;
function createDiff(op, text) {
  return [op, text];
}
function diffMain(text1, text2, options, opt_checklines = true, opt_deadline) {
  const resolved = resolveOptions(options);
  if (typeof opt_deadline == "undefined") {
    if (resolved.diffTimeout <= 0)
      opt_deadline = Number.MAX_VALUE;
    else
      opt_deadline = (/* @__PURE__ */ new Date()).getTime() + resolved.diffTimeout * 1e3;
  }
  const deadline = opt_deadline;
  if (text1 == null || text2 == null)
    throw new Error("Null input. (diff_main)");
  if (text1 === text2) {
    if (text1)
      return [createDiff(DIFF_EQUAL, text1)];
    return [];
  }
  const checklines = opt_checklines;
  let commonlength = diffCommonPrefix(text1, text2);
  const commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);
  commonlength = diffCommonSuffix(text1, text2);
  const commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);
  const diffs = diffCompute(text1, text2, resolved, checklines, deadline);
  if (commonprefix)
    diffs.unshift(createDiff(DIFF_EQUAL, commonprefix));
  if (commonsuffix)
    diffs.push(createDiff(DIFF_EQUAL, commonsuffix));
  diffCleanupMerge(diffs);
  return diffs;
}
function diffCompute(text1, text2, options, checklines, deadline) {
  let diffs;
  if (!text1) {
    return [createDiff(DIFF_INSERT, text2)];
  }
  if (!text2) {
    return [createDiff(DIFF_DELETE, text1)];
  }
  const longtext = text1.length > text2.length ? text1 : text2;
  const shorttext = text1.length > text2.length ? text2 : text1;
  const i = longtext.indexOf(shorttext);
  if (i !== -1) {
    diffs = [createDiff(DIFF_INSERT, longtext.substring(0, i)), createDiff(DIFF_EQUAL, shorttext), createDiff(DIFF_INSERT, longtext.substring(i + shorttext.length))];
    if (text1.length > text2.length)
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    return diffs;
  }
  if (shorttext.length === 1) {
    return [createDiff(DIFF_DELETE, text1), createDiff(DIFF_INSERT, text2)];
  }
  const hm = diffHalfMatch(text1, text2, options);
  if (hm) {
    const text1_a = hm[0];
    const text1_b = hm[1];
    const text2_a = hm[2];
    const text2_b = hm[3];
    const mid_common = hm[4];
    const diffs_a = diffMain(text1_a, text2_a, options, checklines, deadline);
    const diffs_b = diffMain(text1_b, text2_b, options, checklines, deadline);
    return diffs_a.concat([createDiff(DIFF_EQUAL, mid_common)], diffs_b);
  }
  if (checklines && text1.length > 100 && text2.length > 100)
    return diffLineMode(text1, text2, options, deadline);
  return diffBisect(text1, text2, options, deadline);
}
function diffLineMode(text1, text2, options, deadline) {
  const a = diffLinesToChars(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  const linearray = a.lineArray;
  const diffs = diffMain(text1, text2, options, false, deadline);
  diffCharsToLines(diffs, linearray);
  diffCleanupSemantic(diffs);
  diffs.push(createDiff(DIFF_EQUAL, ""));
  let pointer = 0;
  let count_delete = 0;
  let count_insert = 0;
  let text_delete = "";
  let text_insert = "";
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        if (count_delete >= 1 && count_insert >= 1) {
          diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          const subDiff = diffMain(text_delete, text_insert, options, false, deadline);
          for (let j = subDiff.length - 1; j >= 0; j--)
            diffs.splice(pointer, 0, subDiff[j]);
          pointer = pointer + subDiff.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
    pointer++;
  }
  diffs.pop();
  return diffs;
}
function diffBisect(text1, text2, options, deadline) {
  const text1_length = text1.length;
  const text2_length = text2.length;
  const max_d = Math.ceil((text1_length + text2_length) / 2);
  const v_offset = max_d;
  const v_length = 2 * max_d;
  const v1 = new Array(v_length);
  const v2 = new Array(v_length);
  for (let x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  const delta = text1_length - text2_length;
  const front = delta % 2 !== 0;
  let k1start = 0;
  let k1end = 0;
  let k2start = 0;
  let k2end = 0;
  for (let d = 0; d < max_d; d++) {
    if ((/* @__PURE__ */ new Date()).getTime() > deadline)
      break;
    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      const k1_offset = v_offset + k1;
      let x1;
      if (k1 === -d || k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1])
        x1 = v1[k1_offset + 1];
      else
        x1 = v1[k1_offset - 1] + 1;
      let y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        k1end += 2;
      } else if (y1 > text2_length) {
        k1start += 2;
      } else if (front) {
        const k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
          const x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            return diffBisectSplit(text1, text2, options, x1, y1, deadline);
          }
        }
      }
    }
    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      const k2_offset = v_offset + k2;
      let x2;
      if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1])
        x2 = v2[k2_offset + 1];
      else
        x2 = v2[k2_offset - 1] + 1;
      let y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        k2end += 2;
      } else if (y2 > text2_length) {
        k2start += 2;
      } else if (!front) {
        const k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
          const x1 = v1[k1_offset];
          const y1 = v_offset + x1 - k1_offset;
          x2 = text1_length - x2;
          if (x1 >= x2) {
            return diffBisectSplit(text1, text2, options, x1, y1, deadline);
          }
        }
      }
    }
  }
  return [createDiff(DIFF_DELETE, text1), createDiff(DIFF_INSERT, text2)];
}
function diffBisectSplit(text1, text2, options, x, y, deadline) {
  const text1a = text1.substring(0, x);
  const text2a = text2.substring(0, y);
  const text1b = text1.substring(x);
  const text2b = text2.substring(y);
  const diffs = diffMain(text1a, text2a, options, false, deadline);
  const diffsb = diffMain(text1b, text2b, options, false, deadline);
  return diffs.concat(diffsb);
}
function diffLinesToChars(text1, text2) {
  const lineArray = [];
  const lineHash = {};
  let maxLines = 4e4;
  lineArray[0] = "";
  function diffLinesToCharsMunge(text) {
    let chars = "";
    let lineStart = 0;
    let lineEnd = -1;
    let lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf("\n", lineStart);
      if (lineEnd === -1)
        lineEnd = text.length - 1;
      let line = text.substring(lineStart, lineEnd + 1);
      if (lineHash.hasOwnProperty ? Object.prototype.hasOwnProperty.call(lineHash, line) : lineHash[line] !== void 0) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        if (lineArrayLength === maxLines) {
          line = text.substring(lineStart);
          lineEnd = text.length;
        }
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
      lineStart = lineEnd + 1;
    }
    return chars;
  }
  const chars1 = diffLinesToCharsMunge(text1);
  maxLines = 65535;
  const chars2 = diffLinesToCharsMunge(text2);
  return { chars1, chars2, lineArray };
}
function diffCharsToLines(diffs, lineArray) {
  for (let i = 0; i < diffs.length; i++) {
    const chars = diffs[i][1];
    const text = [];
    for (let j = 0; j < chars.length; j++)
      text[j] = lineArray[chars.charCodeAt(j)];
    diffs[i][1] = text.join("");
  }
}
function diffCommonPrefix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0))
    return 0;
  let pointermin = 0;
  let pointermax = Math.min(text1.length, text2.length);
  let pointermid = pointermax;
  let pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
function diffCommonSuffix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1))
    return 0;
  let pointermin = 0;
  let pointermax = Math.min(text1.length, text2.length);
  let pointermid = pointermax;
  let pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
function diffCommonOverlap(text1, text2) {
  const text1_length = text1.length;
  const text2_length = text2.length;
  if (text1_length === 0 || text2_length === 0)
    return 0;
  if (text1_length > text2_length)
    text1 = text1.substring(text1_length - text2_length);
  else if (text1_length < text2_length)
    text2 = text2.substring(0, text1_length);
  const text_length = Math.min(text1_length, text2_length);
  if (text1 === text2)
    return text_length;
  let best = 0;
  let length = 1;
  while (true) {
    const pattern = text1.substring(text_length - length);
    const found = text2.indexOf(pattern);
    if (found === -1)
      return best;
    length += found;
    if (found === 0 || text1.substring(text_length - length) === text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
}
function diffHalfMatch(text1, text2, options) {
  if (options.diffTimeout <= 0) {
    return null;
  }
  const longtext = text1.length > text2.length ? text1 : text2;
  const shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length)
    return null;
  function diffHalfMatchI(longtext2, shorttext2, i) {
    const seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
    let j = -1;
    let best_common = "";
    let best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {
      const prefixLength = diffCommonPrefix(longtext2.substring(i), shorttext2.substring(j));
      const suffixLength = diffCommonSuffix(longtext2.substring(0, i), shorttext2.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
        best_longtext_a = longtext2.substring(0, i - suffixLength);
        best_longtext_b = longtext2.substring(i + prefixLength);
        best_shorttext_a = shorttext2.substring(0, j - suffixLength);
        best_shorttext_b = shorttext2.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext2.length)
      return [best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common];
    else
      return null;
  }
  const hm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));
  const hm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));
  let hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }
  let text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  const mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
}
function diffCleanupSemantic(diffs) {
  let changes = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer = 0;
  let length_insertions1 = 0;
  let length_deletions1 = 0;
  let length_insertions2 = 0;
  let length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] === DIFF_EQUAL) {
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastEquality = diffs[pointer][1];
    } else {
      if (diffs[pointer][0] === DIFF_INSERT)
        length_insertions2 += diffs[pointer][1].length;
      else
        length_deletions2 += diffs[pointer][1].length;
      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, createDiff(DIFF_DELETE, lastEquality));
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = null;
        changes = true;
      }
    }
    pointer++;
  }
  if (changes)
    diffCleanupMerge(diffs);
  diffCleanupSemanticLossless(diffs);
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
      const deletion = diffs[pointer - 1][1];
      const insertion = diffs[pointer][1];
      const overlap_length1 = diffCommonOverlap(deletion, insertion);
      const overlap_length2 = diffCommonOverlap(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
          diffs.splice(pointer, 0, createDiff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
          diffs.splice(pointer, 0, createDiff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] = deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
}
var nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
var whitespaceRegex_ = /\s/;
var linebreakRegex_ = /[\r\n]/;
var blanklineEndRegex_ = /\n\r?\n$/;
var blanklineStartRegex_ = /^\r?\n\r?\n/;
function diffCleanupSemanticLossless(diffs) {
  function diffCleanupSemanticScore(one, two) {
    if (!one || !two) {
      return 6;
    }
    const char1 = one.charAt(one.length - 1);
    const char2 = two.charAt(0);
    const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
    const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
    const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
    const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
    const lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
    const lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
    const blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
    const blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
    if (blankLine1 || blankLine2) {
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      return 3;
    } else if (whitespace1 || whitespace2) {
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      return 1;
    }
    return 0;
  }
  let pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer - 1][1];
      let edit = diffs[pointer][1];
      let equality2 = diffs[pointer + 1][1];
      const commonOffset = diffCommonSuffix(equality1, edit);
      if (commonOffset) {
        const commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1;
      let bestEdit = edit;
      let bestEquality2 = equality2;
      let bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }
      if (diffs[pointer - 1][1] !== bestEquality1) {
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
}
function diffCleanupMerge(diffs) {
  diffs.push(createDiff(DIFF_EQUAL, ""));
  let pointer = 0;
  let count_delete = 0;
  let count_insert = 0;
  let text_delete = "";
  let text_insert = "";
  let commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            commonlength = diffCommonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] === DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, createDiff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            commonlength = diffCommonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length - commonlength);
              text_delete = text_delete.substring(0, text_delete.length - commonlength);
            }
          }
          pointer -= count_delete + count_insert;
          diffs.splice(pointer, count_delete + count_insert);
          if (text_delete.length) {
            diffs.splice(pointer, 0, createDiff(DIFF_DELETE, text_delete));
            pointer++;
          }
          if (text_insert.length) {
            diffs.splice(pointer, 0, createDiff(DIFF_INSERT, text_insert));
            pointer++;
          }
          pointer++;
        } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === "")
    diffs.pop();
  let changes = false;
  pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  if (changes)
    diffCleanupMerge(diffs);
}

// node_modules/ohash/dist/index.mjs
var defaults = Object.freeze({
  ignoreUnknown: false,
  respectType: false,
  respectFunctionNames: false,
  respectFunctionProperties: false,
  unorderedObjects: true,
  unorderedArrays: false,
  unorderedSets: false,
  excludeKeys: void 0,
  excludeValues: void 0,
  replacer: void 0
});
function objectHash(object, options) {
  if (options) {
    options = { ...defaults, ...options };
  } else {
    options = defaults;
  }
  const hasher = createHasher(options);
  hasher.dispatch(object);
  return hasher.toString();
}
var defaultPrototypesKeys = Object.freeze([
  "prototype",
  "__proto__",
  "constructor"
]);
function createHasher(options) {
  let buff = "";
  let context = /* @__PURE__ */ new Map();
  const write = (str) => {
    buff += str;
  };
  return {
    toString() {
      return buff;
    },
    getContext() {
      return context;
    },
    dispatch(value) {
      if (options.replacer) {
        value = options.replacer(value);
      }
      const type = value === null ? "null" : typeof value;
      return this[type](value);
    },
    object(object) {
      if (object && typeof object.toJSON === "function") {
        return this.object(object.toJSON());
      }
      const objString = Object.prototype.toString.call(object);
      let objType = "";
      const objectLength = objString.length;
      if (objectLength < 10) {
        objType = "unknown:[" + objString + "]";
      } else {
        objType = objString.slice(8, objectLength - 1);
      }
      objType = objType.toLowerCase();
      let objectNumber = null;
      if ((objectNumber = context.get(object)) === void 0) {
        context.set(object, context.size);
      } else {
        return this.dispatch("[CIRCULAR:" + objectNumber + "]");
      }
      if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object)) {
        write("buffer:");
        return write(object.toString("utf8"));
      }
      if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
        if (this[objType]) {
          this[objType](object);
        } else if (!options.ignoreUnknown) {
          this.unkown(object, objType);
        }
      } else {
        let keys = Object.keys(object);
        if (options.unorderedObjects) {
          keys = keys.sort();
        }
        let extraKeys = [];
        if (options.respectType !== false && !isNativeFunction(object)) {
          extraKeys = defaultPrototypesKeys;
        }
        if (options.excludeKeys) {
          keys = keys.filter((key) => {
            return !options.excludeKeys(key);
          });
          extraKeys = extraKeys.filter((key) => {
            return !options.excludeKeys(key);
          });
        }
        write("object:" + (keys.length + extraKeys.length) + ":");
        const dispatchForKey = (key) => {
          this.dispatch(key);
          write(":");
          if (!options.excludeValues) {
            this.dispatch(object[key]);
          }
          write(",");
        };
        for (const key of keys) {
          dispatchForKey(key);
        }
        for (const key of extraKeys) {
          dispatchForKey(key);
        }
      }
    },
    array(arr, unordered) {
      unordered = unordered === void 0 ? options.unorderedArrays !== false : unordered;
      write("array:" + arr.length + ":");
      if (!unordered || arr.length <= 1) {
        for (const entry of arr) {
          this.dispatch(entry);
        }
        return;
      }
      const contextAdditions = /* @__PURE__ */ new Map();
      const entries = arr.map((entry) => {
        const hasher = createHasher(options);
        hasher.dispatch(entry);
        for (const [key, value] of hasher.getContext()) {
          contextAdditions.set(key, value);
        }
        return hasher.toString();
      });
      context = contextAdditions;
      entries.sort();
      return this.array(entries, false);
    },
    date(date) {
      return write("date:" + date.toJSON());
    },
    symbol(sym) {
      return write("symbol:" + sym.toString());
    },
    unkown(value, type) {
      write(type);
      if (!value) {
        return;
      }
      write(":");
      if (value && typeof value.entries === "function") {
        return this.array(
          Array.from(value.entries()),
          true
          /* ordered */
        );
      }
    },
    error(err) {
      return write("error:" + err.toString());
    },
    boolean(bool) {
      return write("bool:" + bool);
    },
    string(string) {
      write("string:" + string.length + ":");
      write(string);
    },
    function(fn) {
      write("fn:");
      if (isNativeFunction(fn)) {
        this.dispatch("[native]");
      } else {
        this.dispatch(fn.toString());
      }
      if (options.respectFunctionNames !== false) {
        this.dispatch("function-name:" + String(fn.name));
      }
      if (options.respectFunctionProperties) {
        this.object(fn);
      }
    },
    number(number) {
      return write("number:" + number);
    },
    xml(xml) {
      return write("xml:" + xml.toString());
    },
    null() {
      return write("Null");
    },
    undefined() {
      return write("Undefined");
    },
    regexp(regex) {
      return write("regex:" + regex.toString());
    },
    uint8array(arr) {
      write("uint8array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    uint8clampedarray(arr) {
      write("uint8clampedarray:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    int8array(arr) {
      write("int8array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    uint16array(arr) {
      write("uint16array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    int16array(arr) {
      write("int16array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    uint32array(arr) {
      write("uint32array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    int32array(arr) {
      write("int32array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    float32array(arr) {
      write("float32array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    float64array(arr) {
      write("float64array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    arraybuffer(arr) {
      write("arraybuffer:");
      return this.dispatch(new Uint8Array(arr));
    },
    url(url) {
      return write("url:" + url.toString());
    },
    map(map) {
      write("map:");
      const arr = [...map];
      return this.array(arr, options.unorderedSets !== false);
    },
    set(set) {
      write("set:");
      const arr = [...set];
      return this.array(arr, options.unorderedSets !== false);
    },
    file(file) {
      write("file:");
      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);
    },
    blob() {
      if (options.ignoreUnknown) {
        return write("[blob]");
      }
      throw new Error(
        'Hashing Blob objects is currently not supported\nUse "options.replacer" or "options.ignoreUnknown"\n'
      );
    },
    domwindow() {
      return write("domwindow");
    },
    bigint(number) {
      return write("bigint:" + number.toString());
    },
    /* Node.js standard native objects */
    process() {
      return write("process");
    },
    timer() {
      return write("timer");
    },
    pipe() {
      return write("pipe");
    },
    tcp() {
      return write("tcp");
    },
    udp() {
      return write("udp");
    },
    tty() {
      return write("tty");
    },
    statwatcher() {
      return write("statwatcher");
    },
    securecontext() {
      return write("securecontext");
    },
    connection() {
      return write("connection");
    },
    zlib() {
      return write("zlib");
    },
    context() {
      return write("context");
    },
    nodescript() {
      return write("nodescript");
    },
    httpparser() {
      return write("httpparser");
    },
    dataview() {
      return write("dataview");
    },
    signal() {
      return write("signal");
    },
    fsevent() {
      return write("fsevent");
    },
    tlswrap() {
      return write("tlswrap");
    }
  };
}
var nativeFunc = "[native code] }";
var nativeFuncLength = nativeFunc.length;
function isNativeFunction(f) {
  if (typeof f !== "function") {
    return false;
  }
  return Function.prototype.toString.call(f).slice(-nativeFuncLength) === nativeFunc;
}
var WordArray = class _WordArray {
  constructor(words, sigBytes) {
    words = this.words = words || [];
    this.sigBytes = sigBytes === void 0 ? words.length * 4 : sigBytes;
  }
  toString(encoder) {
    return (encoder || Hex).stringify(this);
  }
  concat(wordArray) {
    this.clamp();
    if (this.sigBytes % 4) {
      for (let i = 0; i < wordArray.sigBytes; i++) {
        const thatByte = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
        this.words[this.sigBytes + i >>> 2] |= thatByte << 24 - (this.sigBytes + i) % 4 * 8;
      }
    } else {
      for (let j = 0; j < wordArray.sigBytes; j += 4) {
        this.words[this.sigBytes + j >>> 2] = wordArray.words[j >>> 2];
      }
    }
    this.sigBytes += wordArray.sigBytes;
    return this;
  }
  clamp() {
    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;
    this.words.length = Math.ceil(this.sigBytes / 4);
  }
  clone() {
    return new _WordArray([...this.words]);
  }
};
var Hex = {
  stringify(wordArray) {
    const hexChars = [];
    for (let i = 0; i < wordArray.sigBytes; i++) {
      const bite = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
      hexChars.push((bite >>> 4).toString(16), (bite & 15).toString(16));
    }
    return hexChars.join("");
  }
};
var Base64 = {
  stringify(wordArray) {
    const keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const base64Chars = [];
    for (let i = 0; i < wordArray.sigBytes; i += 3) {
      const byte1 = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
      const byte2 = wordArray.words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
      const byte3 = wordArray.words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
      const triplet = byte1 << 16 | byte2 << 8 | byte3;
      for (let j = 0; j < 4 && i * 8 + j * 6 < wordArray.sigBytes * 8; j++) {
        base64Chars.push(keyStr.charAt(triplet >>> 6 * (3 - j) & 63));
      }
    }
    return base64Chars.join("");
  }
};
var Latin1 = {
  parse(latin1Str) {
    const latin1StrLength = latin1Str.length;
    const words = [];
    for (let i = 0; i < latin1StrLength; i++) {
      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
    }
    return new WordArray(words, latin1StrLength);
  }
};
var Utf8 = {
  parse(utf8Str) {
    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
  }
};
var BufferedBlockAlgorithm = class {
  constructor() {
    this._data = new WordArray();
    this._nDataBytes = 0;
    this._minBufferSize = 0;
    this.blockSize = 512 / 32;
  }
  reset() {
    this._data = new WordArray();
    this._nDataBytes = 0;
  }
  _append(data) {
    if (typeof data === "string") {
      data = Utf8.parse(data);
    }
    this._data.concat(data);
    this._nDataBytes += data.sigBytes;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _doProcessBlock(_dataWords, _offset) {
  }
  _process(doFlush) {
    let processedWords;
    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);
    if (doFlush) {
      nBlocksReady = Math.ceil(nBlocksReady);
    } else {
      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
    }
    const nWordsReady = nBlocksReady * this.blockSize;
    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);
    if (nWordsReady) {
      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {
        this._doProcessBlock(this._data.words, offset);
      }
      processedWords = this._data.words.splice(0, nWordsReady);
      this._data.sigBytes -= nBytesReady;
    }
    return new WordArray(processedWords, nBytesReady);
  }
};
var Hasher = class extends BufferedBlockAlgorithm {
  update(messageUpdate) {
    this._append(messageUpdate);
    this._process();
    return this;
  }
  finalize(messageUpdate) {
    if (messageUpdate) {
      this._append(messageUpdate);
    }
  }
};
var H = [
  1779033703,
  -1150833019,
  1013904242,
  -1521486534,
  1359893119,
  -1694144372,
  528734635,
  1541459225
];
var K = [
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998
];
var W = [];
var SHA256 = class extends Hasher {
  constructor() {
    super(...arguments);
    this._hash = new WordArray([...H]);
  }
  reset() {
    super.reset();
    this._hash = new WordArray([...H]);
  }
  _doProcessBlock(M, offset) {
    const H2 = this._hash.words;
    let a = H2[0];
    let b = H2[1];
    let c = H2[2];
    let d = H2[3];
    let e = H2[4];
    let f = H2[5];
    let g = H2[6];
    let h2 = H2[7];
    for (let i = 0; i < 64; i++) {
      if (i < 16) {
        W[i] = M[offset + i] | 0;
      } else {
        const gamma0x = W[i - 15];
        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
        const gamma1x = W[i - 2];
        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
      }
      const ch = e & f ^ ~e & g;
      const maj = a & b ^ a & c ^ b & c;
      const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
      const t1 = h2 + sigma1 + ch + K[i] + W[i];
      const t2 = sigma0 + maj;
      h2 = g;
      g = f;
      f = e;
      e = d + t1 | 0;
      d = c;
      c = b;
      b = a;
      a = t1 + t2 | 0;
    }
    H2[0] = H2[0] + a | 0;
    H2[1] = H2[1] + b | 0;
    H2[2] = H2[2] + c | 0;
    H2[3] = H2[3] + d | 0;
    H2[4] = H2[4] + e | 0;
    H2[5] = H2[5] + f | 0;
    H2[6] = H2[6] + g | 0;
    H2[7] = H2[7] + h2 | 0;
  }
  finalize(messageUpdate) {
    super.finalize(messageUpdate);
    const nBitsTotal = this._nDataBytes * 8;
    const nBitsLeft = this._data.sigBytes * 8;
    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(
      nBitsTotal / 4294967296
    );
    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
    this._data.sigBytes = this._data.words.length * 4;
    this._process();
    return this._hash;
  }
};
function sha256base64(message) {
  return new SHA256().finalize(message).toString(Base64);
}
function hash(object, options = {}) {
  const hashed = typeof object === "string" ? object : objectHash(object, options);
  return sha256base64(hashed).slice(0, 10);
}

// node_modules/shiki-magic-move/dist/core.mjs
function createMagicMoveMachine(codeToKeyedTokens2, options = {}) {
  const EMPTY = toKeyedTokens("", []);
  let previous = EMPTY;
  let current = EMPTY;
  function commit(code, override = {}) {
    previous = current;
    const newTokens = codeToKeyedTokens2(code);
    ({ from: previous, to: current } = syncTokenKeys(previous, newTokens, {
      ...options,
      ...override
    }));
    return {
      current,
      previous
    };
  }
  return {
    get current() {
      return current;
    },
    get previous() {
      return previous;
    },
    commit,
    reset() {
      previous = EMPTY;
      current = EMPTY;
    }
  };
}
function codeToKeyedTokens(highlighter, code, options) {
  const result = highlighter.codeToTokens(code, options);
  return {
    ...toKeyedTokens(
      code,
      result.tokens,
      // We put the lang and theme to participate in the hash calculation because they can affect the tokenization
      JSON.stringify([options.lang, "themes" in options ? options.themes : options.theme])
    ),
    bg: result.bg,
    fg: result.fg,
    rootStyle: result.rootStyle,
    themeName: result.themeName,
    lang: options.lang
  };
}
function toKeyedTokens(code, tokens, salt = "") {
  const hash$1 = hash(code + salt);
  let lastOffset = 0;
  const keyed = splitWhitespaceTokens(tokens).flatMap((line) => {
    const lastEl = line[line.length - 1];
    if (!lastEl)
      lastOffset += 1;
    else
      lastOffset = lastEl.offset + lastEl.content.length;
    return [
      ...line,
      {
        content: "\n",
        offset: lastOffset
      }
    ];
  }).map((token, idx) => {
    const t = token;
    t.key = `${hash$1}-${idx}`;
    return t;
  });
  return {
    code,
    hash: hash$1,
    tokens: keyed
  };
}
function splitWhitespaceTokens(tokens) {
  return tokens.map((line) => {
    return line.flatMap((token) => {
      if (token.content.match(/^\s+$/))
        return token;
      const match = token.content.match(/^(\s*)(.*?)(\s*)$/);
      if (!match)
        return token;
      const [, leading, content, trailing] = match;
      if (!leading && !trailing)
        return token;
      const expanded = [{
        ...token,
        offset: token.offset + leading.length,
        content
      }];
      if (leading) {
        expanded.unshift({
          content: leading,
          offset: token.offset
        });
      }
      if (trailing) {
        expanded.push({
          content: trailing,
          offset: token.offset + leading.length + content.length
        });
      }
      return expanded;
    });
  });
}
function splitToken(token, offsets) {
  let lastOffset = 0;
  const key = token.key;
  let index = 0;
  const tokens = [];
  function getKey() {
    if (index === 0) {
      index++;
      return key;
    }
    return `${key}-${index++}`;
  }
  for (const offset of offsets) {
    if (offset > lastOffset) {
      tokens.push({
        ...token,
        content: token.content.slice(lastOffset, offset),
        offset: token.offset + lastOffset,
        key: getKey()
      });
    }
    lastOffset = offset;
  }
  if (lastOffset < token.content.length) {
    tokens.push({
      ...token,
      content: token.content.slice(lastOffset),
      offset: token.offset + lastOffset,
      key: getKey()
    });
  }
  return tokens;
}
function splitTokens(tokens, breakpoints) {
  const sorted = Array.from(breakpoints instanceof Set ? breakpoints : new Set(breakpoints)).sort((a, b) => a - b);
  if (!sorted.length)
    return tokens;
  return tokens.flatMap((token) => {
    const breakpointsInToken = sorted.filter((i) => token.offset < i && i < token.offset + token.content.length).map((i) => i - token.offset).sort((a, b) => a - b);
    if (!breakpointsInToken.length)
      return token;
    return splitToken(token, breakpointsInToken);
  });
}
function syncTokenKeys(from, to, options = {}) {
  const {
    splitTokens: shouldSplitTokens = false,
    enhanceMatching = true
  } = options;
  const matches = findTextMatches(from.code, to.code, options);
  const tokensFrom = shouldSplitTokens ? splitTokens(from.tokens, matches.flatMap((m) => m.from)) : from.tokens;
  const tokensTo = shouldSplitTokens ? splitTokens(to.tokens, matches.flatMap((m) => m.to)) : to.tokens;
  const matchedKeys = /* @__PURE__ */ new Set();
  matches.forEach((match) => {
    var _a, _b;
    const tokensF = tokensFrom.filter((t) => t.offset >= match.from[0] && t.offset + t.content.length <= match.from[1]);
    const tokensT = tokensTo.filter((t) => t.offset >= match.to[0] && t.offset + t.content.length <= match.to[1]);
    let idxF = 0;
    let idxT = 0;
    while (idxF < tokensF.length && idxT < tokensT.length) {
      if (!tokensF[idxF] || !tokensT[idxT])
        break;
      if (tokensF[idxF].content === tokensT[idxT].content) {
        tokensT[idxT].key = tokensF[idxF].key;
        matchedKeys.add(tokensF[idxF].key);
        idxF++;
        idxT++;
      } else if (((_a = tokensF[idxF + 1]) == null ? void 0 : _a.content) === tokensT[idxT].content) {
        idxF++;
      } else if (tokensF[idxF].content === ((_b = tokensT[idxT + 1]) == null ? void 0 : _b.content)) {
        idxT++;
      } else {
        idxF++;
        idxT++;
      }
    }
  });
  if (enhanceMatching) {
    for (const token of tokensFrom) {
      if (matchedKeys.has(token.key))
        continue;
      if (token.content.length < 3 || !token.content.match(/^[\w\d_-]+$/))
        continue;
      const matched = tokensTo.find((t) => t.content === token.content && !matchedKeys.has(t.key));
      if (matched) {
        matched.key = token.key;
        matchedKeys.add(token.key);
      }
    }
  }
  return {
    from: tokensFrom.length === from.tokens.length ? from : { ...from, tokens: tokensFrom },
    to: tokensTo.length === to.tokens.length ? to : { ...to, tokens: tokensTo }
  };
}
function findTextMatches(a, b, options = {}) {
  var _a;
  let delta = diffMain(a, b);
  delta = ((_a = options.diffCleanup) == null ? void 0 : _a.call(options, delta)) || delta;
  let aContent = "";
  let bContent = "";
  const matched = [];
  for (const [op, text] of delta) {
    if (op === 0) {
      matched.push({
        from: [aContent.length, aContent.length + text.length],
        to: [bContent.length, bContent.length + text.length],
        content: text
      });
      aContent += text;
      bContent += text;
    } else if (op === -1) {
      aContent += text;
    } else if (op === 1) {
      bContent += text;
    }
  }
  if (aContent !== a || bContent !== b)
    throw new Error("Content mismatch");
  return matched;
}

// node_modules/shiki-magic-move/dist/renderer.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var CLASS_PREFIX = "shiki-magic-move";
var CLASS_LEAVE_FROM = `${CLASS_PREFIX}-leave-from`;
var CLASS_LEAVE_TO = `${CLASS_PREFIX}-leave-to`;
var CLASS_LEAVE_ACTIVE = `${CLASS_PREFIX}-leave-active`;
var CLASS_ENTER_FROM = `${CLASS_PREFIX}-enter-from`;
var CLASS_ENTER_TO = `${CLASS_PREFIX}-enter-to`;
var CLASS_ENTER_ACTIVE = `${CLASS_PREFIX}-enter-active`;
var CLASS_MOVE = `${CLASS_PREFIX}-move`;
var CLASS_CONTAINER_RESIZE = `${CLASS_PREFIX}-container-resize`;
var CLASS_CONTAINER_RESTYLE = `${CLASS_PREFIX}-container-restyle`;
var defaultOptions2 = {
  globalScale: 1,
  duration: 500,
  delayMove: 0.3,
  delayLeave: 0.1,
  delayEnter: 0.7,
  delayContainer: 0.4,
  stagger: 0,
  easing: "ease",
  animateContainer: true,
  containerStyle: true
};
var MagicMoveRenderer = class {
  constructor(target, options = {}) {
    __publicField(this, "mapDom", /* @__PURE__ */ new Map());
    __publicField(this, "container");
    __publicField(this, "anchor");
    __publicField(this, "previousPromises", []);
    __publicField(this, "options");
    __publicField(this, "isFirstRender", true);
    this.options = {
      ...defaultOptions2,
      ...options
    };
    if (typeof target === "string")
      this.container = document.querySelector(target);
    else
      this.container = target;
    this.anchor = document.createElement("span");
    this.anchor.style.position = "absolute";
    this.anchor.style.top = "0";
    this.anchor.style.left = "0";
    this.anchor.style.height = "1px";
    this.anchor.style.width = "1px";
    this.container.prepend(this.anchor);
  }
  applyElementContent(el, token) {
    if (token.content !== "\n") {
      el.textContent = token.content;
      el.classList.add(`${CLASS_PREFIX}-item`);
    }
  }
  applyElementStyle(el, token) {
    if (token.htmlStyle)
      el.setAttribute("style", token.htmlStyle);
    if (token.color)
      el.style.color = token.color;
    if (token.bgColor)
      el.style.backgroundColor = token.bgColor;
  }
  applyElement(el, token) {
    this.applyElementContent(el, token);
    this.applyElementStyle(el, token);
  }
  applyContainerStyle(step) {
    if (!this.options.containerStyle)
      return;
    if (step.bg)
      this.container.style.backgroundColor = step.bg;
    if (step.fg)
      this.container.style.color = step.fg;
    if (step.rootStyle) {
      const items = step.rootStyle.split(";");
      for (const item of items) {
        const [key, value] = item.split(":");
        if (key && value)
          this.container.style.setProperty(key.trim(), value.trim());
      }
    }
  }
  registerTransitionEnd(el, cb) {
    let resolved = false;
    let resolve = () => {
    };
    const promise = new Promise((_resolve) => {
      const finish = (e) => {
        if (!e || e.target !== el)
          return;
        resolve();
      };
      resolve = () => {
        if (resolved)
          return;
        resolved = true;
        el.removeEventListener("transitionend", finish);
        cb();
        _resolve();
      };
      el.addEventListener("transitionend", finish);
    });
    promise.resolve = resolve;
    return promise;
  }
  setCssVariables() {
    this.container.style.setProperty("--smm-duration", `${this.options.duration}ms`);
    this.container.style.setProperty("--smm-delay-move", `${this.options.delayMove}`);
    this.container.style.setProperty("--smm-delay-leave", `${this.options.delayLeave}`);
    this.container.style.setProperty("--smm-delay-enter", `${this.options.delayEnter}`);
    this.container.style.setProperty("--smm-delay-container", `${this.options.delayContainer}`);
    this.container.style.setProperty("--smm-easing", this.options.easing);
    this.container.style.setProperty("--smm-stagger", "0");
  }
  /**
   * Replace tokens without animation
   */
  replace(step) {
    const newDomMap = /* @__PURE__ */ new Map();
    const newChildren = step.tokens.map((token) => {
      if (this.mapDom.has(token.key)) {
        const el = this.mapDom.get(token.key);
        this.applyElement(el, token);
        newDomMap.set(token.key, el);
        this.mapDom.delete(token.key);
        return el;
      } else {
        const el = document.createElement(token.content === "\n" ? "br" : "span");
        this.applyElement(el, token);
        newDomMap.set(token.key, el);
        return el;
      }
    });
    this.container.replaceChildren(
      this.anchor,
      ...newChildren
    );
    this.applyContainerStyle(step);
    this.mapDom = newDomMap;
  }
  // Note: This function is intentionally not async to keep the operations sync
  /**
   * Render tokens with animation
   */
  render(step) {
    this.setCssVariables();
    const newDomMap = /* @__PURE__ */ new Map();
    const move = [];
    const enter = [];
    const leave = [];
    const promises = [];
    this.previousPromises.forEach((p) => p.resolve());
    this.previousPromises = [];
    const postReflow = [];
    const {
      globalScale: scale
    } = this.options;
    const position = /* @__PURE__ */ new Map();
    let anchorRect = this.anchor.getBoundingClientRect();
    const containerRect = this.container.getBoundingClientRect();
    for (const el of this.mapDom.values()) {
      const rect = el.getBoundingClientRect();
      position.set(el, { x: rect.x - anchorRect.x, y: rect.y - anchorRect.y });
    }
    const newChildren = step.tokens.map((token) => {
      if (this.mapDom.has(token.key)) {
        const el = this.mapDom.get(token.key);
        this.applyElementContent(el, token);
        postReflow.push(() => {
          this.applyElementStyle(el, token);
        });
        move.push(el);
        newDomMap.set(token.key, el);
        this.mapDom.delete(token.key);
        return el;
      } else {
        const el = document.createElement(token.content === "\n" ? "br" : "span");
        this.applyElement(el, token);
        enter.push(el);
        newDomMap.set(token.key, el);
        return el;
      }
    });
    for (const [_, el] of this.mapDom) {
      if (el.tagName === "BR")
        continue;
      leave.push(el);
    }
    for (const el of leave)
      el.style.position = "absolute";
    this.container.replaceChildren(
      this.anchor,
      ...newChildren,
      ...leave
    );
    this.mapDom = newDomMap;
    leave.forEach((el, idx) => {
      el.style.position = "absolute";
      const pos = position.get(el);
      el.style.top = `${pos.y / scale}px`;
      el.style.left = `${pos.x / scale}px`;
      if (this.options.stagger)
        el.style.setProperty("--smm-stagger", `${idx * this.options.stagger}ms`);
      else
        el.style.removeProperty("--smm-stagger");
      el.classList.add(CLASS_LEAVE_FROM);
      el.classList.add(CLASS_LEAVE_ACTIVE);
      postReflow.unshift(() => {
        el.classList.remove(CLASS_LEAVE_FROM);
        el.classList.add(CLASS_LEAVE_TO);
      });
      promises.push(
        this.registerTransitionEnd(el, () => {
          el.classList.remove(CLASS_LEAVE_FROM);
          el.classList.remove(CLASS_LEAVE_ACTIVE);
          el.classList.remove(CLASS_ENTER_TO);
          el.remove();
        })
      );
    });
    if (!this.isFirstRender) {
      enter.forEach((el, idx) => {
        el.classList.add(CLASS_ENTER_FROM);
        el.classList.add(CLASS_ENTER_ACTIVE);
        if (this.options.stagger)
          el.style.setProperty("--smm-stagger", `${idx * this.options.stagger}ms`);
        else
          el.style.removeProperty("--smm-stagger");
        postReflow.push(() => {
          el.classList.remove(CLASS_ENTER_FROM);
          el.classList.add(CLASS_ENTER_TO);
        });
        promises.push(
          this.registerTransitionEnd(el, () => {
            el.classList.remove(CLASS_ENTER_FROM);
            el.classList.remove(CLASS_ENTER_ACTIVE);
            el.classList.remove(CLASS_ENTER_TO);
          })
        );
      });
    }
    anchorRect = this.anchor.getBoundingClientRect();
    move.forEach((el, idx) => {
      const newRect = el.getBoundingClientRect();
      const newPos = { x: newRect.x - anchorRect.x, y: newRect.y - anchorRect.y };
      const oldPos = position.get(el);
      el.style.transitionDuration = el.style.transitionDelay = "0ms";
      const dx = (oldPos.x - newPos.x) / scale;
      const dy = (oldPos.y - newPos.y) / scale;
      el.style.transform = `translate(${dx}px, ${dy}px)`;
      if (this.options.stagger)
        el.style.setProperty("--smm-stagger", `${idx * this.options.stagger}ms`);
      else
        el.style.removeProperty("--smm-stagger");
      postReflow.unshift(() => {
        el.classList.add(CLASS_MOVE);
        el.style.transform = el.style.transitionDuration = el.style.transitionDelay = "";
      });
      promises.push(
        this.registerTransitionEnd(el, () => {
          el.classList.remove(CLASS_MOVE);
        })
      );
    });
    if (this.options.animateContainer && !this.isFirstRender) {
      const newRect = this.container.getBoundingClientRect();
      if (newRect.width !== containerRect.width || newRect.height !== containerRect.height) {
        this.container.style.transitionDuration = this.container.style.transitionDelay = "0ms";
        this.container.style.height = `${containerRect.height / scale}px`;
        this.container.style.width = `${containerRect.width / scale}px`;
        postReflow.unshift(() => {
          this.container.classList.add(CLASS_CONTAINER_RESIZE);
          this.container.style.transitionDuration = this.container.style.transitionDelay = "";
          this.container.style.height = `${newRect.height / scale}px`;
          this.container.style.width = `${newRect.width / scale}px`;
        });
        promises.push(
          this.registerTransitionEnd(this.container, () => {
            this.container.classList.remove(CLASS_CONTAINER_RESIZE);
            this.container.style.height = this.container.style.width = "";
          })
        );
      }
    }
    if (this.options.containerStyle) {
      if (this.isFirstRender) {
        this.applyContainerStyle(step);
      } else {
        postReflow.push(() => {
          this.container.classList.add(CLASS_CONTAINER_RESTYLE);
          this.applyContainerStyle(step);
        });
        promises.push(
          this.registerTransitionEnd(this.container, () => {
            this.container.classList.remove(CLASS_CONTAINER_RESTYLE);
          })
        );
      }
    }
    forceReflow();
    postReflow.forEach((cb) => cb());
    this.isFirstRender = false;
    this.previousPromises = promises;
    return Promise.all(promises).then();
  }
};
function forceReflow() {
  return document.body.offsetHeight;
}

// node_modules/shiki-magic-move/dist/vue.mjs
var ShikiMagicMoveRenderer = defineComponent({
  name: "ShikiMagicMoveRenderer",
  props: {
    animate: {
      type: Boolean,
      default: true
    },
    tokens: {
      type: Object,
      required: true
    },
    previous: {
      type: Object,
      required: false
    },
    options: {
      type: Object
    }
  },
  emits: [
    "end",
    "start"
  ],
  setup(props, { emit }) {
    const container = ref();
    let isMounted = false;
    onMounted(() => {
      container.value.innerHTML = "";
      isMounted = true;
      const renderer = new MagicMoveRenderer(container.value);
      watch(
        () => props.tokens,
        async (tokens) => {
          Object.assign(renderer.options, props.options);
          if (props.animate) {
            if (props.previous)
              renderer.replace(props.previous);
            await nextTick();
            const process = renderer.render(tokens);
            await nextTick();
            emit("start");
            await process;
            emit("end");
          } else {
            renderer.replace(tokens);
          }
        },
        { immediate: true }
      );
    });
    return () => h(
      "pre",
      { ref: container, class: "shiki-magic-move-container" },
      // Render initial tokens for SSR
      isMounted ? void 0 : renderList(props.tokens.tokens, (token) => {
        if (token.content === "\n")
          return h("br", { key: token.key });
        return h(
          "span",
          {
            style: [{ color: token.color }, token.htmlStyle],
            class: "shiki-magic-move-item",
            key: token.key
          },
          token.content
        );
      })
    );
  }
});
var ShikiMagicMove = defineComponent({
  name: "ShikiMagicMove",
  props: {
    highlighter: {
      type: Object,
      required: true
    },
    lang: {
      type: String,
      required: true
    },
    theme: {
      type: String,
      required: true
    },
    code: {
      type: String,
      required: true
    },
    options: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [
    "start",
    "end"
  ],
  setup(props, { emit }) {
    const machine = createMagicMoveMachine(
      (code) => codeToKeyedTokens(props.highlighter, code, {
        lang: props.lang,
        theme: props.theme
      }),
      props.options
    );
    const result = computed(() => machine.commit(props.code));
    return () => h(ShikiMagicMoveRenderer, {
      tokens: result.value.current,
      options: props.options,
      previous: result.value.previous,
      onStart: () => emit("start"),
      onEnd: () => emit("end")
    });
  }
});
var ShikiMagicMovePrecompiled = defineComponent({
  name: "ShikiMagicMovePrecompiled",
  props: {
    steps: {
      type: Array,
      required: true
    },
    step: {
      type: Number,
      default: 0
    },
    animate: {
      type: Boolean,
      default: true
    },
    options: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [
    "start",
    "end"
  ],
  setup(props, { emit }) {
    const EMPTY = toKeyedTokens("", []);
    let previous = EMPTY;
    const result = computed(() => {
      const res = syncTokenKeys(
        previous,
        props.steps[Math.min(props.step, props.steps.length - 1)],
        props.options
      );
      previous = res.to;
      return res;
    });
    return () => h(ShikiMagicMoveRenderer, {
      tokens: result.value.to,
      previous: result.value.from,
      options: props.options,
      animate: props.animate,
      onStart: () => emit("start"),
      onEnd: () => emit("end")
    });
  }
});
function install(app) {
  app.component("ShikiMagicMove", ShikiMagicMove);
  app.component("ShikiMagicMovePrecompiled", ShikiMagicMovePrecompiled);
  app.component("ShikiMagicMoveRenderer", ShikiMagicMoveRenderer);
}
export {
  ShikiMagicMove,
  ShikiMagicMovePrecompiled,
  ShikiMagicMoveRenderer,
  install
};
//# sourceMappingURL=@slidev_cli___@slidev_client___shiki-magic-move_vue.js.map
