{
  "version": 3,
  "sources": ["../../shiki-magic-move/dist/vue.mjs", "../../diff-match-patch-es/dist/index.mjs", "../../ohash/dist/index.mjs", "../../shiki-magic-move/dist/core.mjs", "../../shiki-magic-move/dist/renderer.mjs"],
  "sourcesContent": ["import { defineComponent, ref, onMounted, watch, nextTick, h, renderList, computed } from 'vue';\nimport { createMagicMoveMachine, codeToKeyedTokens, toKeyedTokens, syncTokenKeys } from './core.mjs';\nimport { MagicMoveRenderer } from './renderer.mjs';\nimport 'diff-match-patch-es';\nimport 'ohash';\n\nconst ShikiMagicMoveRenderer = /* @__PURE__ */ defineComponent({\n  name: \"ShikiMagicMoveRenderer\",\n  props: {\n    animate: {\n      type: Boolean,\n      default: true\n    },\n    tokens: {\n      type: Object,\n      required: true\n    },\n    previous: {\n      type: Object,\n      required: false\n    },\n    options: {\n      type: Object\n    }\n  },\n  emits: [\n    \"end\",\n    \"start\"\n  ],\n  setup(props, { emit }) {\n    const container = ref();\n    let isMounted = false;\n    onMounted(() => {\n      container.value.innerHTML = \"\";\n      isMounted = true;\n      const renderer = new MagicMoveRenderer(container.value);\n      watch(\n        () => props.tokens,\n        async (tokens) => {\n          Object.assign(renderer.options, props.options);\n          if (props.animate) {\n            if (props.previous)\n              renderer.replace(props.previous);\n            await nextTick();\n            const process = renderer.render(tokens);\n            await nextTick();\n            emit(\"start\");\n            await process;\n            emit(\"end\");\n          } else {\n            renderer.replace(tokens);\n          }\n        },\n        { immediate: true }\n      );\n    });\n    return () => h(\n      \"pre\",\n      { ref: container, class: \"shiki-magic-move-container\" },\n      // Render initial tokens for SSR\n      isMounted ? void 0 : renderList(props.tokens.tokens, (token) => {\n        if (token.content === \"\\n\")\n          return h(\"br\", { key: token.key });\n        return h(\n          \"span\",\n          {\n            style: [{ color: token.color }, token.htmlStyle],\n            class: \"shiki-magic-move-item\",\n            key: token.key\n          },\n          token.content\n        );\n      })\n    );\n  }\n});\n\nconst ShikiMagicMove = /* @__PURE__ */ defineComponent({\n  name: \"ShikiMagicMove\",\n  props: {\n    highlighter: {\n      type: Object,\n      required: true\n    },\n    lang: {\n      type: String,\n      required: true\n    },\n    theme: {\n      type: String,\n      required: true\n    },\n    code: {\n      type: String,\n      required: true\n    },\n    options: {\n      type: Object,\n      default: () => ({})\n    }\n  },\n  emits: [\n    \"start\",\n    \"end\"\n  ],\n  setup(props, { emit }) {\n    const machine = createMagicMoveMachine(\n      (code) => codeToKeyedTokens(props.highlighter, code, {\n        lang: props.lang,\n        theme: props.theme\n      }),\n      props.options\n    );\n    const result = computed(() => machine.commit(props.code));\n    return () => h(ShikiMagicMoveRenderer, {\n      tokens: result.value.current,\n      options: props.options,\n      previous: result.value.previous,\n      onStart: () => emit(\"start\"),\n      onEnd: () => emit(\"end\")\n    });\n  }\n});\n\nconst ShikiMagicMovePrecompiled = /* @__PURE__ */ defineComponent({\n  name: \"ShikiMagicMovePrecompiled\",\n  props: {\n    steps: {\n      type: Array,\n      required: true\n    },\n    step: {\n      type: Number,\n      default: 0\n    },\n    animate: {\n      type: Boolean,\n      default: true\n    },\n    options: {\n      type: Object,\n      default: () => ({})\n    }\n  },\n  emits: [\n    \"start\",\n    \"end\"\n  ],\n  setup(props, { emit }) {\n    const EMPTY = toKeyedTokens(\"\", []);\n    let previous = EMPTY;\n    const result = computed(() => {\n      const res = syncTokenKeys(\n        previous,\n        props.steps[Math.min(props.step, props.steps.length - 1)],\n        props.options\n      );\n      previous = res.to;\n      return res;\n    });\n    return () => h(ShikiMagicMoveRenderer, {\n      tokens: result.value.to,\n      previous: result.value.from,\n      options: props.options,\n      animate: props.animate,\n      onStart: () => emit(\"start\"),\n      onEnd: () => emit(\"end\")\n    });\n  }\n});\n\nfunction install(app) {\n  app.component(\"ShikiMagicMove\", ShikiMagicMove);\n  app.component(\"ShikiMagicMovePrecompiled\", ShikiMagicMovePrecompiled);\n  app.component(\"ShikiMagicMoveRenderer\", ShikiMagicMoveRenderer);\n}\n\nexport { ShikiMagicMove, ShikiMagicMovePrecompiled, ShikiMagicMoveRenderer, install };\n", "const defaultOptions = /* @__PURE__ */ Object.freeze({\n  diffTimeout: 1,\n  diffEditCost: 4,\n  matchThreshold: 0.5,\n  matchDistance: 1e3,\n  patchDeleteThreshold: 0.5,\n  patchMargin: 4,\n  matchMaxBits: 32\n});\nfunction resolveOptions(options) {\n  if (options?.__resolved)\n    return options;\n  const resolved = {\n    ...defaultOptions,\n    ...options\n  };\n  Object.defineProperty(resolved, \"__resolved\", { value: true, enumerable: false });\n  return resolved;\n}\n\nconst DIFF_DELETE = -1;\nconst DIFF_INSERT = 1;\nconst DIFF_EQUAL = 0;\nfunction createDiff(op, text) {\n  return [op, text];\n}\nfunction diffMain(text1, text2, options, opt_checklines = true, opt_deadline) {\n  const resolved = resolveOptions(options);\n  if (typeof opt_deadline == \"undefined\") {\n    if (resolved.diffTimeout <= 0)\n      opt_deadline = Number.MAX_VALUE;\n    else\n      opt_deadline = (/* @__PURE__ */ new Date()).getTime() + resolved.diffTimeout * 1e3;\n  }\n  const deadline = opt_deadline;\n  if (text1 == null || text2 == null)\n    throw new Error(\"Null input. (diff_main)\");\n  if (text1 === text2) {\n    if (text1)\n      return [createDiff(DIFF_EQUAL, text1)];\n    return [];\n  }\n  const checklines = opt_checklines;\n  let commonlength = diffCommonPrefix(text1, text2);\n  const commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n  commonlength = diffCommonSuffix(text1, text2);\n  const commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n  const diffs = diffCompute(text1, text2, resolved, checklines, deadline);\n  if (commonprefix)\n    diffs.unshift(createDiff(DIFF_EQUAL, commonprefix));\n  if (commonsuffix)\n    diffs.push(createDiff(DIFF_EQUAL, commonsuffix));\n  diffCleanupMerge(diffs);\n  return diffs;\n}\nfunction diffCompute(text1, text2, options, checklines, deadline) {\n  let diffs;\n  if (!text1) {\n    return [createDiff(DIFF_INSERT, text2)];\n  }\n  if (!text2) {\n    return [createDiff(DIFF_DELETE, text1)];\n  }\n  const longtext = text1.length > text2.length ? text1 : text2;\n  const shorttext = text1.length > text2.length ? text2 : text1;\n  const i = longtext.indexOf(shorttext);\n  if (i !== -1) {\n    diffs = [createDiff(DIFF_INSERT, longtext.substring(0, i)), createDiff(DIFF_EQUAL, shorttext), createDiff(DIFF_INSERT, longtext.substring(i + shorttext.length))];\n    if (text1.length > text2.length)\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    return diffs;\n  }\n  if (shorttext.length === 1) {\n    return [createDiff(DIFF_DELETE, text1), createDiff(DIFF_INSERT, text2)];\n  }\n  const hm = diffHalfMatch(text1, text2, options);\n  if (hm) {\n    const text1_a = hm[0];\n    const text1_b = hm[1];\n    const text2_a = hm[2];\n    const text2_b = hm[3];\n    const mid_common = hm[4];\n    const diffs_a = diffMain(text1_a, text2_a, options, checklines, deadline);\n    const diffs_b = diffMain(text1_b, text2_b, options, checklines, deadline);\n    return diffs_a.concat([createDiff(DIFF_EQUAL, mid_common)], diffs_b);\n  }\n  if (checklines && text1.length > 100 && text2.length > 100)\n    return diffLineMode(text1, text2, options, deadline);\n  return diffBisect(text1, text2, options, deadline);\n}\nfunction diffLineMode(text1, text2, options, deadline) {\n  const a = diffLinesToChars(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  const linearray = a.lineArray;\n  const diffs = diffMain(text1, text2, options, false, deadline);\n  diffCharsToLines(diffs, linearray);\n  diffCleanupSemantic(diffs);\n  diffs.push(createDiff(DIFF_EQUAL, \"\"));\n  let pointer = 0;\n  let count_delete = 0;\n  let count_insert = 0;\n  let text_delete = \"\";\n  let text_insert = \"\";\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        if (count_delete >= 1 && count_insert >= 1) {\n          diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          const subDiff = diffMain(text_delete, text_insert, options, false, deadline);\n          for (let j = subDiff.length - 1; j >= 0; j--)\n            diffs.splice(pointer, 0, subDiff[j]);\n          pointer = pointer + subDiff.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = \"\";\n        text_insert = \"\";\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();\n  return diffs;\n}\nfunction diffBisect(text1, text2, options, deadline) {\n  const text1_length = text1.length;\n  const text2_length = text2.length;\n  const max_d = Math.ceil((text1_length + text2_length) / 2);\n  const v_offset = max_d;\n  const v_length = 2 * max_d;\n  const v1 = new Array(v_length);\n  const v2 = new Array(v_length);\n  for (let x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  const delta = text1_length - text2_length;\n  const front = delta % 2 !== 0;\n  let k1start = 0;\n  let k1end = 0;\n  let k2start = 0;\n  let k2end = 0;\n  for (let d = 0; d < max_d; d++) {\n    if ((/* @__PURE__ */ new Date()).getTime() > deadline)\n      break;\n    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      const k1_offset = v_offset + k1;\n      let x1;\n      if (k1 === -d || k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1])\n        x1 = v1[k1_offset + 1];\n      else\n        x1 = v1[k1_offset - 1] + 1;\n      let y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        k1start += 2;\n      } else if (front) {\n        const k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {\n          const x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            return diffBisectSplit(text1, text2, options, x1, y1, deadline);\n          }\n        }\n      }\n    }\n    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      const k2_offset = v_offset + k2;\n      let x2;\n      if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1])\n        x2 = v2[k2_offset + 1];\n      else\n        x2 = v2[k2_offset - 1] + 1;\n      let y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        k2start += 2;\n      } else if (!front) {\n        const k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {\n          const x1 = v1[k1_offset];\n          const y1 = v_offset + x1 - k1_offset;\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            return diffBisectSplit(text1, text2, options, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  return [createDiff(DIFF_DELETE, text1), createDiff(DIFF_INSERT, text2)];\n}\nfunction diffBisectSplit(text1, text2, options, x, y, deadline) {\n  const text1a = text1.substring(0, x);\n  const text2a = text2.substring(0, y);\n  const text1b = text1.substring(x);\n  const text2b = text2.substring(y);\n  const diffs = diffMain(text1a, text2a, options, false, deadline);\n  const diffsb = diffMain(text1b, text2b, options, false, deadline);\n  return diffs.concat(diffsb);\n}\nfunction diffLinesToChars(text1, text2) {\n  const lineArray = [];\n  const lineHash = {};\n  let maxLines = 4e4;\n  lineArray[0] = \"\";\n  function diffLinesToCharsMunge(text) {\n    let chars = \"\";\n    let lineStart = 0;\n    let lineEnd = -1;\n    let lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf(\"\\n\", lineStart);\n      if (lineEnd === -1)\n        lineEnd = text.length - 1;\n      let line = text.substring(lineStart, lineEnd + 1);\n      if (lineHash.hasOwnProperty ? Object.prototype.hasOwnProperty.call(lineHash, line) : lineHash[line] !== void 0) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        if (lineArrayLength === maxLines) {\n          line = text.substring(lineStart);\n          lineEnd = text.length;\n        }\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n      lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  const chars1 = diffLinesToCharsMunge(text1);\n  maxLines = 65535;\n  const chars2 = diffLinesToCharsMunge(text2);\n  return { chars1, chars2, lineArray };\n}\nfunction diffCharsToLines(diffs, lineArray) {\n  for (let i = 0; i < diffs.length; i++) {\n    const chars = diffs[i][1];\n    const text = [];\n    for (let j = 0; j < chars.length; j++)\n      text[j] = lineArray[chars.charCodeAt(j)];\n    diffs[i][1] = text.join(\"\");\n  }\n}\nfunction diffCommonPrefix(text1, text2) {\n  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0))\n    return 0;\n  let pointermin = 0;\n  let pointermax = Math.min(text1.length, text2.length);\n  let pointermid = pointermax;\n  let pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n}\nfunction diffCommonSuffix(text1, text2) {\n  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1))\n    return 0;\n  let pointermin = 0;\n  let pointermax = Math.min(text1.length, text2.length);\n  let pointermid = pointermax;\n  let pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n}\nfunction diffCommonOverlap(text1, text2) {\n  const text1_length = text1.length;\n  const text2_length = text2.length;\n  if (text1_length === 0 || text2_length === 0)\n    return 0;\n  if (text1_length > text2_length)\n    text1 = text1.substring(text1_length - text2_length);\n  else if (text1_length < text2_length)\n    text2 = text2.substring(0, text1_length);\n  const text_length = Math.min(text1_length, text2_length);\n  if (text1 === text2)\n    return text_length;\n  let best = 0;\n  let length = 1;\n  while (true) {\n    const pattern = text1.substring(text_length - length);\n    const found = text2.indexOf(pattern);\n    if (found === -1)\n      return best;\n    length += found;\n    if (found === 0 || text1.substring(text_length - length) === text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n}\nfunction diffHalfMatch(text1, text2, options) {\n  if (options.diffTimeout <= 0) {\n    return null;\n  }\n  const longtext = text1.length > text2.length ? text1 : text2;\n  const shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length)\n    return null;\n  function diffHalfMatchI(longtext2, shorttext2, i) {\n    const seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));\n    let j = -1;\n    let best_common = \"\";\n    let best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {\n      const prefixLength = diffCommonPrefix(longtext2.substring(i), shorttext2.substring(j));\n      const suffixLength = diffCommonSuffix(longtext2.substring(0, i), shorttext2.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);\n        best_longtext_a = longtext2.substring(0, i - suffixLength);\n        best_longtext_b = longtext2.substring(i + prefixLength);\n        best_shorttext_a = shorttext2.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext2.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext2.length)\n      return [best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common];\n    else\n      return null;\n  }\n  const hm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));\n  const hm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));\n  let hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n  let text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  const mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n}\nfunction diffCleanupSemantic(diffs) {\n  let changes = false;\n  const equalities = [];\n  let equalitiesLength = 0;\n  let lastEquality = null;\n  let pointer = 0;\n  let length_insertions1 = 0;\n  let length_deletions1 = 0;\n  let length_insertions2 = 0;\n  let length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] === DIFF_EQUAL) {\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {\n      if (diffs[pointer][0] === DIFF_INSERT)\n        length_insertions2 += diffs[pointer][1].length;\n      else\n        length_deletions2 += diffs[pointer][1].length;\n      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {\n        diffs.splice(equalities[equalitiesLength - 1], 0, createDiff(DIFF_DELETE, lastEquality));\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  if (changes)\n    diffCleanupMerge(diffs);\n  diffCleanupSemanticLossless(diffs);\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1];\n      const insertion = diffs[pointer][1];\n      const overlap_length1 = diffCommonOverlap(deletion, insertion);\n      const overlap_length2 = diffCommonOverlap(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {\n          diffs.splice(pointer, 0, createDiff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));\n          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {\n          diffs.splice(pointer, 0, createDiff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] = deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n}\nconst nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\nconst whitespaceRegex_ = /\\s/;\nconst linebreakRegex_ = /[\\r\\n]/;\nconst blanklineEndRegex_ = /\\n\\r?\\n$/;\nconst blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\nfunction diffCleanupSemanticLossless(diffs) {\n  function diffCleanupSemanticScore(one, two) {\n    if (!one || !two) {\n      return 6;\n    }\n    const char1 = one.charAt(one.length - 1);\n    const char2 = two.charAt(0);\n    const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\n    const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\n    const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);\n    const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);\n    const lineBreak1 = whitespace1 && char1.match(linebreakRegex_);\n    const lineBreak2 = whitespace2 && char2.match(linebreakRegex_);\n    const blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);\n    const blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);\n    if (blankLine1 || blankLine2) {\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      return 1;\n    }\n    return 0;\n  }\n  let pointer = 1;\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      let equality1 = diffs[pointer - 1][1];\n      let edit = diffs[pointer][1];\n      let equality2 = diffs[pointer + 1][1];\n      const commonOffset = diffCommonSuffix(equality1, edit);\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n      let bestEquality1 = equality1;\n      let bestEdit = edit;\n      let bestEquality2 = equality2;\n      let bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n      if (diffs[pointer - 1][1] !== bestEquality1) {\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n}\nfunction diffCleanupEfficiency(diffs, options = {}) {\n  const {\n    diffEditCost = defaultOptions.diffEditCost\n  } = options;\n  let changes = false;\n  const equalities = [];\n  let equalitiesLength = 0;\n  let lastEquality = null;\n  let pointer = 0;\n  let pre_ins = false;\n  let pre_del = false;\n  let post_ins = false;\n  let post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] === DIFF_EQUAL) {\n      if (diffs[pointer][1].length < diffEditCost && (post_ins || post_del)) {\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastEquality = diffs[pointer][1];\n      } else {\n        equalitiesLength = 0;\n        lastEquality = null;\n      }\n      post_ins = post_del = false;\n    } else {\n      let booleanCount = function(...args) {\n        return args.filter(Boolean).length;\n      };\n      if (diffs[pointer][0] === DIFF_DELETE)\n        post_del = true;\n      else\n        post_ins = true;\n      if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < diffEditCost / 2 && booleanCount(pre_ins, pre_del, post_ins, post_del) === 3)) {\n        diffs.splice(equalities[equalitiesLength - 1], 0, createDiff(DIFF_DELETE, lastEquality));\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;\n        lastEquality = null;\n        if (pre_ins && pre_del) {\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;\n          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  if (changes)\n    diffCleanupMerge(diffs);\n}\nfunction diffCleanupMerge(diffs) {\n  diffs.push(createDiff(DIFF_EQUAL, \"\"));\n  let pointer = 0;\n  let count_delete = 0;\n  let count_insert = 0;\n  let text_delete = \"\";\n  let text_insert = \"\";\n  let commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            commonlength = diffCommonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] === DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, createDiff(DIFF_EQUAL, text_insert.substring(0, commonlength)));\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            commonlength = diffCommonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length - commonlength);\n              text_delete = text_delete.substring(0, text_delete.length - commonlength);\n            }\n          }\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n          if (text_delete.length) {\n            diffs.splice(pointer, 0, createDiff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n          if (text_insert.length) {\n            diffs.splice(pointer, 0, createDiff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = \"\";\n        text_insert = \"\";\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === \"\")\n    diffs.pop();\n  let changes = false;\n  pointer = 1;\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {\n        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  if (changes)\n    diffCleanupMerge(diffs);\n}\nfunction diffXIndex(diffs, loc) {\n  let chars1 = 0;\n  let chars2 = 0;\n  let last_chars1 = 0;\n  let last_chars2 = 0;\n  let x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  if (diffs.length !== x && diffs[x][0] === DIFF_DELETE)\n    return last_chars2;\n  return last_chars2 + (loc - last_chars1);\n}\nfunction diffPrettyHtml(diffs) {\n  const html = [];\n  const pattern_amp = /&/g;\n  const pattern_lt = /</g;\n  const pattern_gt = />/g;\n  const pattern_para = /\\n/g;\n  for (let x = 0; x < diffs.length; x++) {\n    const op = diffs[x][0];\n    const data = diffs[x][1];\n    const text = data.replace(pattern_amp, \"&amp;\").replace(pattern_lt, \"&lt;\").replace(pattern_gt, \"&gt;\").replace(pattern_para, \"&para;<br>\");\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = `<ins style=\"background:#e6ffe6;\">${text}</ins>`;\n        break;\n      case DIFF_DELETE:\n        html[x] = `<del style=\"background:#ffe6e6;\">${text}</del>`;\n        break;\n      case DIFF_EQUAL:\n        html[x] = `<span>${text}</span>`;\n        break;\n    }\n  }\n  return html.join(\"\");\n}\nfunction diffText1(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT)\n      text[x] = diffs[x][1];\n  }\n  return text.join(\"\");\n}\nfunction diffText2(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE)\n      text[x] = diffs[x][1];\n  }\n  return text.join(\"\");\n}\nfunction diffLevenshtein(diffs) {\n  let levenshtein = 0;\n  let insertions = 0;\n  let deletions = 0;\n  for (let x = 0; x < diffs.length; x++) {\n    const op = diffs[x][0];\n    const data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n}\nfunction diffToDelta(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = `+${encodeURI(diffs[x][1])}`;\n        break;\n      case DIFF_DELETE:\n        text[x] = `-${diffs[x][1].length}`;\n        break;\n      case DIFF_EQUAL:\n        text[x] = `=${diffs[x][1].length}`;\n        break;\n    }\n  }\n  return text.join(\"\t\").replace(/%20/g, \" \");\n}\nfunction diffFromDelta(text1, delta) {\n  const diffs = [];\n  let diffsLength = 0;\n  let pointer = 0;\n  const tokens = delta.split(/\\t/g);\n  for (let x = 0; x < tokens.length; x++) {\n    const param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case \"+\":\n        try {\n          diffs[diffsLength++] = createDiff(DIFF_INSERT, decodeURI(param));\n        } catch (ex) {\n          throw new Error(`Illegal escape in diff_fromDelta: ${param}`);\n        }\n        break;\n      case \"-\":\n      case \"=\": {\n        const n = Number.parseInt(param, 10);\n        if (Number.isNaN(n) || n < 0)\n          throw new Error(`Invalid number in diff_fromDelta: ${param}`);\n        const text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) === \"=\")\n          diffs[diffsLength++] = createDiff(DIFF_EQUAL, text);\n        else\n          diffs[diffsLength++] = createDiff(DIFF_DELETE, text);\n        break;\n      }\n      default:\n        if (tokens[x])\n          throw new Error(`Invalid diff operation in diff_fromDelta: ${tokens[x]}`);\n    }\n  }\n  if (pointer !== text1.length)\n    throw new Error(`Delta length (${pointer}) does not equal source text length (${text1.length}).`);\n  return diffs;\n}\n\nfunction matchMain(text, pattern, loc, options) {\n  if (text == null || pattern == null || loc == null)\n    throw new Error(\"Null input. (match_main)\");\n  loc = Math.max(0, Math.min(loc, text.length));\n  if (text === pattern) {\n    return 0;\n  } else if (!text.length) {\n    return -1;\n  } else if (text.substring(loc, loc + pattern.length) === pattern) {\n    return loc;\n  } else {\n    return matchBitap(text, pattern, loc, options);\n  }\n}\nfunction matchBitap(text, pattern, loc, options) {\n  const resolved = resolveOptions(options);\n  if (pattern.length > resolved.matchMaxBits)\n    throw new Error(\"Pattern too long for this browser.\");\n  const s = matchAlphabet(pattern);\n  function matchBitapScore(e, x) {\n    const accuracy = e / pattern.length;\n    const proximity = Math.abs(loc - x);\n    if (!resolved.matchDistance) {\n      return proximity ? 1 : accuracy;\n    }\n    return accuracy + proximity / resolved.matchDistance;\n  }\n  let score_threshold = resolved.matchThreshold;\n  let best_loc = text.indexOf(pattern, loc);\n  if (best_loc !== -1) {\n    score_threshold = Math.min(matchBitapScore(0, best_loc), score_threshold);\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n    if (best_loc !== -1)\n      score_threshold = Math.min(matchBitapScore(0, best_loc), score_threshold);\n  }\n  const matchmask = 1 << pattern.length - 1;\n  best_loc = -1;\n  let bin_min, bin_mid;\n  let bin_max = pattern.length + text.length;\n  let last_rd = [];\n  for (let d = 0; d < pattern.length; d++) {\n    bin_min = 0;\n    bin_mid = bin_max;\n    while (bin_min < bin_mid) {\n      if (matchBitapScore(d, loc + bin_mid) <= score_threshold)\n        bin_min = bin_mid;\n      else\n        bin_max = bin_mid;\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n    }\n    bin_max = bin_mid;\n    let start = Math.max(1, loc - bin_mid + 1);\n    const finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n    const rd = Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (let j = finish; j >= start; j--) {\n      const charMatch = s[text.charAt(j - 1)];\n      if (d === 0) {\n        rd[j] = (rd[j + 1] << 1 | 1) & charMatch;\n      } else {\n        rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1];\n      }\n      if (rd[j] & matchmask) {\n        const score = matchBitapScore(d, j - 1);\n        if (score <= score_threshold) {\n          score_threshold = score;\n          best_loc = j - 1;\n          if (best_loc > loc) {\n            start = Math.max(1, 2 * loc - best_loc);\n          } else {\n            break;\n          }\n        }\n      }\n    }\n    if (matchBitapScore(d + 1, loc) > score_threshold)\n      break;\n    last_rd = rd;\n  }\n  return best_loc;\n}\nfunction matchAlphabet(pattern) {\n  const s = {};\n  for (let i = 0; i < pattern.length; i++)\n    s[pattern.charAt(i)] = 0;\n  for (let i = 0; i < pattern.length; i++)\n    s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;\n  return s;\n}\n\nfunction patchAddContext(patch, text, options) {\n  if (text.length === 0)\n    return;\n  if (patch.start2 === null)\n    throw new Error(\"patch not initialized\");\n  const {\n    matchMaxBits = defaultOptions.matchMaxBits,\n    patchMargin = defaultOptions.patchMargin\n  } = options;\n  let pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n  let padding = 0;\n  while (text.indexOf(pattern) !== text.lastIndexOf(pattern) && pattern.length < matchMaxBits - patchMargin - patchMargin) {\n    padding += patchMargin;\n    pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);\n  }\n  padding += patchMargin;\n  const prefix = text.substring(patch.start2 - padding, patch.start2);\n  if (prefix)\n    patch.diffs.unshift(createDiff(DIFF_EQUAL, prefix));\n  const suffix = text.substring(patch.start2 + patch.length1, patch.start2 + patch.length1 + padding);\n  if (suffix)\n    patch.diffs.push(createDiff(DIFF_EQUAL, suffix));\n  patch.start1 -= prefix.length;\n  patch.start2 -= prefix.length;\n  patch.length1 += prefix.length + suffix.length;\n  patch.length2 += prefix.length + suffix.length;\n}\nfunction patchMake(a, opt_b, opt_c, options = {}) {\n  const resolved = {\n    ...defaultOptions,\n    ...options\n  };\n  let text1, diffs;\n  if (typeof a == \"string\" && typeof opt_b == \"string\" && typeof opt_c == \"undefined\") {\n    text1 = a;\n    diffs = diffMain(text1, opt_b, resolved, true);\n    if (diffs.length > 2) {\n      diffCleanupSemantic(diffs);\n      diffCleanupEfficiency(diffs);\n    }\n  } else if (a && typeof a == \"object\" && typeof opt_b == \"undefined\" && typeof opt_c == \"undefined\") {\n    diffs = /** @type {Diff[]} */\n    a;\n    text1 = diffText1(diffs);\n  } else if (typeof a == \"string\" && opt_b && typeof opt_b == \"object\" && typeof opt_c == \"undefined\") {\n    text1 = /** @type {string} */\n    a;\n    diffs = /** @type {Diff[]} */\n    opt_b;\n  } else if (typeof a == \"string\" && typeof opt_b == \"string\" && opt_c && typeof opt_c == \"object\") {\n    text1 = /** @type {string} */\n    a;\n    diffs = /** @type {Diff[]} */\n    opt_c;\n  } else {\n    throw new Error(\"Unknown call format to patch_make.\");\n  }\n  if (diffs.length === 0)\n    return [];\n  const patches = [];\n  let patch = createPatch();\n  let patchDiffLength = 0;\n  let char_count1 = 0;\n  let char_count2 = 0;\n  let prepatch_text = text1;\n  let postpatch_text = text1;\n  for (let x = 0; x < diffs.length; x++) {\n    const diff_type = diffs[x][0];\n    const diff_text = diffs[x][1];\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n      patch.start1 = char_count1;\n      patch.start2 = char_count2;\n    }\n    switch (diff_type) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = diffs[x];\n        patch.length2 += diff_text.length;\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diff_text.length;\n        patch.diffs[patchDiffLength++] = diffs[x];\n        postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);\n        break;\n      case DIFF_EQUAL:\n        if (diff_text.length <= 2 * resolved.patchMargin && patchDiffLength && diffs.length !== x + 1) {\n          patch.diffs[patchDiffLength++] = diffs[x];\n          patch.length1 += diff_text.length;\n          patch.length2 += diff_text.length;\n        } else if (diff_text.length >= 2 * resolved.patchMargin) {\n          if (patchDiffLength) {\n            patchAddContext(patch, prepatch_text, resolved);\n            patches.push(patch);\n            patch = createPatch();\n            patchDiffLength = 0;\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n    }\n    if (diff_type !== DIFF_INSERT)\n      char_count1 += diff_text.length;\n    if (diff_type !== DIFF_DELETE)\n      char_count2 += diff_text.length;\n  }\n  if (patchDiffLength) {\n    patchAddContext(patch, prepatch_text, resolved);\n    patches.push(patch);\n  }\n  return patches;\n}\nfunction patchDeepCopy(patches) {\n  const patchesCopy = [];\n  for (let x = 0; x < patches.length; x++) {\n    const patch = patches[x];\n    const patchCopy = createPatch();\n    patchCopy.diffs = [];\n    for (let y = 0; y < patch.diffs.length; y++) {\n      patchCopy.diffs[y] = createDiff(patch.diffs[y][0], patch.diffs[y][1]);\n    }\n    patchCopy.start1 = patch.start1;\n    patchCopy.start2 = patch.start2;\n    patchCopy.length1 = patch.length1;\n    patchCopy.length2 = patch.length2;\n    patchesCopy[x] = patchCopy;\n  }\n  return patchesCopy;\n}\nfunction patchApply(patches, text, options) {\n  if (patches.length === 0)\n    return [text, []];\n  patches = patchDeepCopy(patches);\n  const resolved = resolveOptions(options);\n  const nullPadding = patchAddPadding(patches, resolved);\n  text = nullPadding + text + nullPadding;\n  patchSplitMax(patches, resolved);\n  let delta = 0;\n  const results = [];\n  for (let x = 0; x < patches.length; x++) {\n    const expected_loc = patches[x].start2 + delta;\n    const text1 = diffText1(patches[x].diffs);\n    let start_loc;\n    let end_loc = -1;\n    if (text1.length > resolved.matchMaxBits) {\n      start_loc = matchMain(\n        text,\n        text1.substring(0, resolved.matchMaxBits),\n        expected_loc,\n        options\n      );\n      if (start_loc !== -1) {\n        end_loc = matchMain(\n          text,\n          text1.substring(text1.length - resolved.matchMaxBits),\n          expected_loc + text1.length - resolved.matchMaxBits,\n          options\n        );\n        if (end_loc === -1 || start_loc >= end_loc) {\n          start_loc = -1;\n        }\n      }\n    } else {\n      start_loc = matchMain(text, text1, expected_loc, options);\n    }\n    if (start_loc === -1) {\n      results[x] = false;\n      delta -= patches[x].length2 - patches[x].length1;\n    } else {\n      results[x] = true;\n      delta = start_loc - expected_loc;\n      let text2;\n      if (end_loc === -1)\n        text2 = text.substring(start_loc, start_loc + text1.length);\n      else\n        text2 = text.substring(start_loc, end_loc + resolved.matchMaxBits);\n      if (text1 === text2) {\n        text = text.substring(0, start_loc) + diffText2(patches[x].diffs) + text.substring(start_loc + text1.length);\n      } else {\n        const diffs = diffMain(text1, text2, options, false);\n        if (text1.length > resolved.matchMaxBits && diffLevenshtein(diffs) / text1.length > resolved.patchDeleteThreshold) {\n          results[x] = false;\n        } else {\n          diffCleanupSemanticLossless(diffs);\n          let index1 = 0;\n          let index2 = 0;\n          for (let y = 0; y < patches[x].diffs.length; y++) {\n            const mod = patches[x].diffs[y];\n            if (mod[0] !== DIFF_EQUAL)\n              index2 = diffXIndex(diffs, index1);\n            if (mod[0] === DIFF_INSERT) {\n              text = text.substring(0, start_loc + index2) + mod[1] + text.substring(start_loc + index2);\n            } else if (mod[0] === DIFF_DELETE) {\n              text = text.substring(0, start_loc + index2) + text.substring(start_loc + diffXIndex(diffs, index1 + mod[1].length));\n            }\n            if (mod[0] !== DIFF_DELETE)\n              index1 += mod[1].length;\n          }\n        }\n      }\n    }\n  }\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\n  return [text, results];\n}\nfunction patchAddPadding(patches, options = {}) {\n  const {\n    patchMargin: paddingLength = defaultOptions.patchMargin\n  } = options;\n  let nullPadding = \"\";\n  for (let x = 1; x <= paddingLength; x++)\n    nullPadding += String.fromCharCode(x);\n  for (let x = 0; x < patches.length; x++) {\n    patches[x].start1 += paddingLength;\n    patches[x].start2 += paddingLength;\n  }\n  let patch = patches[0];\n  let diffs = patch.diffs;\n  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL) {\n    diffs.unshift(createDiff(DIFF_EQUAL, nullPadding));\n    patch.start1 -= paddingLength;\n    patch.start2 -= paddingLength;\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[0][1].length) {\n    const extraLength = paddingLength - diffs[0][1].length;\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n    patch.start1 -= extraLength;\n    patch.start2 -= extraLength;\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n  patch = patches[patches.length - 1];\n  diffs = patch.diffs;\n  if (diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL) {\n    diffs.push(createDiff(DIFF_EQUAL, nullPadding));\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n  return nullPadding;\n}\nfunction patchSplitMax(patches, options) {\n  const resolved = resolveOptions(options);\n  for (let x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= resolved.matchMaxBits)\n      continue;\n    const bigpatch = patches[x];\n    patches.splice(x--, 1);\n    let start1 = bigpatch.start1;\n    let start2 = bigpatch.start2;\n    let precontext = \"\";\n    while (bigpatch.diffs.length !== 0) {\n      const patch = createPatch();\n      let empty = true;\n      patch.start1 = start1 - precontext.length;\n      patch.start2 = start2 - precontext.length;\n      if (precontext !== \"\") {\n        patch.length1 = patch.length2 = precontext.length;\n        patch.diffs.push(createDiff(DIFF_EQUAL, precontext));\n      }\n      while (bigpatch.diffs.length !== 0 && patch.length1 < resolved.matchMaxBits - resolved.patchMargin) {\n        const diff_type = bigpatch.diffs[0][0];\n        let diff_text = bigpatch.diffs[0][1];\n        if (diff_type === DIFF_INSERT) {\n          patch.length2 += diff_text.length;\n          start2 += diff_text.length;\n          patch.diffs.push(bigpatch.diffs.shift());\n          empty = false;\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diff_text.length > 2 * resolved.matchMaxBits) {\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          empty = false;\n          patch.diffs.push(createDiff(diff_type, diff_text));\n          bigpatch.diffs.shift();\n        } else {\n          diff_text = diff_text.substring(0, resolved.matchMaxBits - patch.length1 - resolved.patchMargin);\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          if (diff_type === DIFF_EQUAL) {\n            patch.length2 += diff_text.length;\n            start2 += diff_text.length;\n          } else {\n            empty = false;\n          }\n          patch.diffs.push(createDiff(diff_type, diff_text));\n          if (diff_text === bigpatch.diffs[0][1]) {\n            bigpatch.diffs.shift();\n          } else {\n            bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);\n          }\n        }\n      }\n      precontext = diffText2(patch.diffs);\n      precontext = precontext.substring(precontext.length - resolved.patchMargin);\n      const postcontext = diffText1(bigpatch.diffs).substring(0, resolved.patchMargin);\n      if (postcontext !== \"\") {\n        patch.length1 += postcontext.length;\n        patch.length2 += postcontext.length;\n        if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL)\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\n        else\n          patch.diffs.push(createDiff(DIFF_EQUAL, postcontext));\n      }\n      if (!empty)\n        patches.splice(++x, 0, patch);\n    }\n  }\n}\nfunction patchToText(patches) {\n  const text = [];\n  for (let x = 0; x < patches.length; x++)\n    text[x] = patches[x];\n  return text.join(\"\");\n}\nfunction patchFromText(textline) {\n  const patches = [];\n  if (!textline)\n    return patches;\n  const text = textline.split(\"\\n\");\n  let textPointer = 0;\n  const patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n  while (textPointer < text.length) {\n    const m = text[textPointer].match(patchHeader);\n    if (!m)\n      throw new Error(`Invalid patch string: ${text[textPointer]}`);\n    const patch = createPatch();\n    patches.push(patch);\n    patch.start1 = Number.parseInt(m[1], 10);\n    if (m[2] === \"\") {\n      patch.start1--;\n      patch.length1 = 1;\n    } else if (m[2] === \"0\") {\n      patch.length1 = 0;\n    } else {\n      patch.start1--;\n      patch.length1 = Number.parseInt(m[2], 10);\n    }\n    patch.start2 = Number.parseInt(m[3], 10);\n    if (m[4] === \"\") {\n      patch.start2--;\n      patch.length2 = 1;\n    } else if (m[4] === \"0\") {\n      patch.length2 = 0;\n    } else {\n      patch.start2--;\n      patch.length2 = Number.parseInt(m[4], 10);\n    }\n    textPointer++;\n    while (textPointer < text.length) {\n      const sign = text[textPointer].charAt(0);\n      let line = \"\";\n      try {\n        line = decodeURI(text[textPointer].substring(1));\n      } catch (ex) {\n        throw new Error(`Illegal escape in patch_fromText: ${line}`);\n      }\n      if (sign === \"-\") {\n        patch.diffs.push(createDiff(DIFF_DELETE, line));\n      } else if (sign === \"+\") {\n        patch.diffs.push(createDiff(DIFF_INSERT, line));\n      } else if (sign === \" \") {\n        patch.diffs.push(createDiff(DIFF_EQUAL, line));\n      } else if (sign === \"@\") {\n        break;\n      } else if (sign === \"\") ; else {\n        throw new Error(`Invalid patch mode \"${sign}\" in: ${line}`);\n      }\n      textPointer++;\n    }\n  }\n  return patches;\n}\nfunction createPatch() {\n  const patch = {\n    diffs: [],\n    start1: null,\n    start2: null,\n    length1: 0,\n    length2: 0\n  };\n  patch.toString = function() {\n    let coords1, coords2;\n    if (this.length1 === 0)\n      coords1 = `${this.start1},0`;\n    else if (this.length1 === 1)\n      coords1 = this.start1 + 1;\n    else\n      coords1 = `${this.start1 + 1},${this.length1}`;\n    if (this.length2 === 0)\n      coords2 = `${this.start2},0`;\n    else if (this.length2 === 1)\n      coords2 = this.start2 + 1;\n    else\n      coords2 = `${this.start2 + 1},${this.length2}`;\n    const text = [`@@ -${coords1} +${coords2} @@\n`];\n    let op;\n    for (let x = 0; x < this.diffs.length; x++) {\n      switch (this.diffs[x][0]) {\n        case DIFF_INSERT:\n          op = \"+\";\n          break;\n        case DIFF_DELETE:\n          op = \"-\";\n          break;\n        case DIFF_EQUAL:\n          op = \" \";\n          break;\n      }\n      text[x + 1] = `${op + encodeURI(this.diffs[x][1])}\n`;\n    }\n    return text.join(\"\").replace(/%20/g, \" \");\n  };\n  return patch;\n}\n\nexport { DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, defaultOptions, diffMain as diff, diffCleanupEfficiency, diffCleanupMerge, diffCleanupSemantic, diffCleanupSemanticLossless, diffCommonPrefix, diffCommonSuffix, diffFromDelta, diffLevenshtein, diffMain, diffPrettyHtml, diffText1, diffText2, diffToDelta, diffXIndex, matchMain as match, matchAlphabet, matchBitap, matchMain, patchMake as patch, patchAddPadding, patchApply, patchDeepCopy, patchFromText, patchMake, patchSplitMax, patchToText, resolveOptions };\n", "const defaults = Object.freeze({\n  ignoreUnknown: false,\n  respectType: false,\n  respectFunctionNames: false,\n  respectFunctionProperties: false,\n  unorderedObjects: true,\n  unorderedArrays: false,\n  unorderedSets: false,\n  excludeKeys: void 0,\n  excludeValues: void 0,\n  replacer: void 0\n});\nfunction objectHash(object, options) {\n  if (options) {\n    options = { ...defaults, ...options };\n  } else {\n    options = defaults;\n  }\n  const hasher = createHasher(options);\n  hasher.dispatch(object);\n  return hasher.toString();\n}\nconst defaultPrototypesKeys = Object.freeze([\n  \"prototype\",\n  \"__proto__\",\n  \"constructor\"\n]);\nfunction createHasher(options) {\n  let buff = \"\";\n  let context = /* @__PURE__ */ new Map();\n  const write = (str) => {\n    buff += str;\n  };\n  return {\n    toString() {\n      return buff;\n    },\n    getContext() {\n      return context;\n    },\n    dispatch(value) {\n      if (options.replacer) {\n        value = options.replacer(value);\n      }\n      const type = value === null ? \"null\" : typeof value;\n      return this[type](value);\n    },\n    object(object) {\n      if (object && typeof object.toJSON === \"function\") {\n        return this.object(object.toJSON());\n      }\n      const objString = Object.prototype.toString.call(object);\n      let objType = \"\";\n      const objectLength = objString.length;\n      if (objectLength < 10) {\n        objType = \"unknown:[\" + objString + \"]\";\n      } else {\n        objType = objString.slice(8, objectLength - 1);\n      }\n      objType = objType.toLowerCase();\n      let objectNumber = null;\n      if ((objectNumber = context.get(object)) === void 0) {\n        context.set(object, context.size);\n      } else {\n        return this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n      }\n      if (typeof Buffer !== \"undefined\" && Buffer.isBuffer && Buffer.isBuffer(object)) {\n        write(\"buffer:\");\n        return write(object.toString(\"utf8\"));\n      }\n      if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n        if (this[objType]) {\n          this[objType](object);\n        } else if (!options.ignoreUnknown) {\n          this.unkown(object, objType);\n        }\n      } else {\n        let keys = Object.keys(object);\n        if (options.unorderedObjects) {\n          keys = keys.sort();\n        }\n        let extraKeys = [];\n        if (options.respectType !== false && !isNativeFunction(object)) {\n          extraKeys = defaultPrototypesKeys;\n        }\n        if (options.excludeKeys) {\n          keys = keys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n          extraKeys = extraKeys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n        }\n        write(\"object:\" + (keys.length + extraKeys.length) + \":\");\n        const dispatchForKey = (key) => {\n          this.dispatch(key);\n          write(\":\");\n          if (!options.excludeValues) {\n            this.dispatch(object[key]);\n          }\n          write(\",\");\n        };\n        for (const key of keys) {\n          dispatchForKey(key);\n        }\n        for (const key of extraKeys) {\n          dispatchForKey(key);\n        }\n      }\n    },\n    array(arr, unordered) {\n      unordered = unordered === void 0 ? options.unorderedArrays !== false : unordered;\n      write(\"array:\" + arr.length + \":\");\n      if (!unordered || arr.length <= 1) {\n        for (const entry of arr) {\n          this.dispatch(entry);\n        }\n        return;\n      }\n      const contextAdditions = /* @__PURE__ */ new Map();\n      const entries = arr.map((entry) => {\n        const hasher = createHasher(options);\n        hasher.dispatch(entry);\n        for (const [key, value] of hasher.getContext()) {\n          contextAdditions.set(key, value);\n        }\n        return hasher.toString();\n      });\n      context = contextAdditions;\n      entries.sort();\n      return this.array(entries, false);\n    },\n    date(date) {\n      return write(\"date:\" + date.toJSON());\n    },\n    symbol(sym) {\n      return write(\"symbol:\" + sym.toString());\n    },\n    unkown(value, type) {\n      write(type);\n      if (!value) {\n        return;\n      }\n      write(\":\");\n      if (value && typeof value.entries === \"function\") {\n        return this.array(\n          Array.from(value.entries()),\n          true\n          /* ordered */\n        );\n      }\n    },\n    error(err) {\n      return write(\"error:\" + err.toString());\n    },\n    boolean(bool) {\n      return write(\"bool:\" + bool);\n    },\n    string(string) {\n      write(\"string:\" + string.length + \":\");\n      write(string);\n    },\n    function(fn) {\n      write(\"fn:\");\n      if (isNativeFunction(fn)) {\n        this.dispatch(\"[native]\");\n      } else {\n        this.dispatch(fn.toString());\n      }\n      if (options.respectFunctionNames !== false) {\n        this.dispatch(\"function-name:\" + String(fn.name));\n      }\n      if (options.respectFunctionProperties) {\n        this.object(fn);\n      }\n    },\n    number(number) {\n      return write(\"number:\" + number);\n    },\n    xml(xml) {\n      return write(\"xml:\" + xml.toString());\n    },\n    null() {\n      return write(\"Null\");\n    },\n    undefined() {\n      return write(\"Undefined\");\n    },\n    regexp(regex) {\n      return write(\"regex:\" + regex.toString());\n    },\n    uint8array(arr) {\n      write(\"uint8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint8clampedarray(arr) {\n      write(\"uint8clampedarray:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int8array(arr) {\n      write(\"int8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint16array(arr) {\n      write(\"uint16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int16array(arr) {\n      write(\"int16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint32array(arr) {\n      write(\"uint32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int32array(arr) {\n      write(\"int32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float32array(arr) {\n      write(\"float32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float64array(arr) {\n      write(\"float64array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    arraybuffer(arr) {\n      write(\"arraybuffer:\");\n      return this.dispatch(new Uint8Array(arr));\n    },\n    url(url) {\n      return write(\"url:\" + url.toString());\n    },\n    map(map) {\n      write(\"map:\");\n      const arr = [...map];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    set(set) {\n      write(\"set:\");\n      const arr = [...set];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    file(file) {\n      write(\"file:\");\n      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);\n    },\n    blob() {\n      if (options.ignoreUnknown) {\n        return write(\"[blob]\");\n      }\n      throw new Error(\n        'Hashing Blob objects is currently not supported\\nUse \"options.replacer\" or \"options.ignoreUnknown\"\\n'\n      );\n    },\n    domwindow() {\n      return write(\"domwindow\");\n    },\n    bigint(number) {\n      return write(\"bigint:\" + number.toString());\n    },\n    /* Node.js standard native objects */\n    process() {\n      return write(\"process\");\n    },\n    timer() {\n      return write(\"timer\");\n    },\n    pipe() {\n      return write(\"pipe\");\n    },\n    tcp() {\n      return write(\"tcp\");\n    },\n    udp() {\n      return write(\"udp\");\n    },\n    tty() {\n      return write(\"tty\");\n    },\n    statwatcher() {\n      return write(\"statwatcher\");\n    },\n    securecontext() {\n      return write(\"securecontext\");\n    },\n    connection() {\n      return write(\"connection\");\n    },\n    zlib() {\n      return write(\"zlib\");\n    },\n    context() {\n      return write(\"context\");\n    },\n    nodescript() {\n      return write(\"nodescript\");\n    },\n    httpparser() {\n      return write(\"httpparser\");\n    },\n    dataview() {\n      return write(\"dataview\");\n    },\n    signal() {\n      return write(\"signal\");\n    },\n    fsevent() {\n      return write(\"fsevent\");\n    },\n    tlswrap() {\n      return write(\"tlswrap\");\n    }\n  };\n}\nconst nativeFunc = \"[native code] }\";\nconst nativeFuncLength = nativeFunc.length;\nfunction isNativeFunction(f) {\n  if (typeof f !== \"function\") {\n    return false;\n  }\n  return Function.prototype.toString.call(f).slice(-nativeFuncLength) === nativeFunc;\n}\n\nclass WordArray {\n  constructor(words, sigBytes) {\n    words = this.words = words || [];\n    this.sigBytes = sigBytes === void 0 ? words.length * 4 : sigBytes;\n  }\n  toString(encoder) {\n    return (encoder || Hex).stringify(this);\n  }\n  concat(wordArray) {\n    this.clamp();\n    if (this.sigBytes % 4) {\n      for (let i = 0; i < wordArray.sigBytes; i++) {\n        const thatByte = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n        this.words[this.sigBytes + i >>> 2] |= thatByte << 24 - (this.sigBytes + i) % 4 * 8;\n      }\n    } else {\n      for (let j = 0; j < wordArray.sigBytes; j += 4) {\n        this.words[this.sigBytes + j >>> 2] = wordArray.words[j >>> 2];\n      }\n    }\n    this.sigBytes += wordArray.sigBytes;\n    return this;\n  }\n  clamp() {\n    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;\n    this.words.length = Math.ceil(this.sigBytes / 4);\n  }\n  clone() {\n    return new WordArray([...this.words]);\n  }\n}\nconst Hex = {\n  stringify(wordArray) {\n    const hexChars = [];\n    for (let i = 0; i < wordArray.sigBytes; i++) {\n      const bite = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      hexChars.push((bite >>> 4).toString(16), (bite & 15).toString(16));\n    }\n    return hexChars.join(\"\");\n  }\n};\nconst Base64 = {\n  stringify(wordArray) {\n    const keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const base64Chars = [];\n    for (let i = 0; i < wordArray.sigBytes; i += 3) {\n      const byte1 = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      const byte2 = wordArray.words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;\n      const byte3 = wordArray.words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;\n      const triplet = byte1 << 16 | byte2 << 8 | byte3;\n      for (let j = 0; j < 4 && i * 8 + j * 6 < wordArray.sigBytes * 8; j++) {\n        base64Chars.push(keyStr.charAt(triplet >>> 6 * (3 - j) & 63));\n      }\n    }\n    return base64Chars.join(\"\");\n  }\n};\nconst Latin1 = {\n  parse(latin1Str) {\n    const latin1StrLength = latin1Str.length;\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i++) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;\n    }\n    return new WordArray(words, latin1StrLength);\n  }\n};\nconst Utf8 = {\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  }\n};\nclass BufferedBlockAlgorithm {\n  constructor() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n    this._minBufferSize = 0;\n    this.blockSize = 512 / 32;\n  }\n  reset() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n  _append(data) {\n    if (typeof data === \"string\") {\n      data = Utf8.parse(data);\n    }\n    this._data.concat(data);\n    this._nDataBytes += data.sigBytes;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _doProcessBlock(_dataWords, _offset) {\n  }\n  _process(doFlush) {\n    let processedWords;\n    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);\n    if (doFlush) {\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n    const nWordsReady = nBlocksReady * this.blockSize;\n    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {\n        this._doProcessBlock(this._data.words, offset);\n      }\n      processedWords = this._data.words.splice(0, nWordsReady);\n      this._data.sigBytes -= nBytesReady;\n    }\n    return new WordArray(processedWords, nBytesReady);\n  }\n}\nclass Hasher extends BufferedBlockAlgorithm {\n  update(messageUpdate) {\n    this._append(messageUpdate);\n    this._process();\n    return this;\n  }\n  finalize(messageUpdate) {\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n  }\n}\n\nconst H = [\n  1779033703,\n  -1150833019,\n  1013904242,\n  -1521486534,\n  1359893119,\n  -1694144372,\n  528734635,\n  1541459225\n];\nconst K = [\n  1116352408,\n  1899447441,\n  -1245643825,\n  -373957723,\n  961987163,\n  1508970993,\n  -1841331548,\n  -1424204075,\n  -670586216,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  -2132889090,\n  -1680079193,\n  -1046744716,\n  -459576895,\n  -272742522,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  -1740746414,\n  -1473132947,\n  -1341970488,\n  -1084653625,\n  -958395405,\n  -710438585,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  -2117940946,\n  -1838011259,\n  -1564481375,\n  -1474664885,\n  -1035236496,\n  -949202525,\n  -778901479,\n  -694614492,\n  -200395387,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  -2067236844,\n  -1933114872,\n  -1866530822,\n  -1538233109,\n  -1090935817,\n  -965641998\n];\nconst W = [];\nclass SHA256 extends Hasher {\n  constructor() {\n    super(...arguments);\n    this._hash = new WordArray([...H]);\n  }\n  reset() {\n    super.reset();\n    this._hash = new WordArray([...H]);\n  }\n  _doProcessBlock(M, offset) {\n    const H2 = this._hash.words;\n    let a = H2[0];\n    let b = H2[1];\n    let c = H2[2];\n    let d = H2[3];\n    let e = H2[4];\n    let f = H2[5];\n    let g = H2[6];\n    let h = H2[7];\n    for (let i = 0; i < 64; i++) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const gamma0x = W[i - 15];\n        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n        const gamma1x = W[i - 2];\n        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n      }\n      const ch = e & f ^ ~e & g;\n      const maj = a & b ^ a & c ^ b & c;\n      const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n      const t1 = h + sigma1 + ch + K[i] + W[i];\n      const t2 = sigma0 + maj;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t1 | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t1 + t2 | 0;\n    }\n    H2[0] = H2[0] + a | 0;\n    H2[1] = H2[1] + b | 0;\n    H2[2] = H2[2] + c | 0;\n    H2[3] = H2[3] + d | 0;\n    H2[4] = H2[4] + e | 0;\n    H2[5] = H2[5] + f | 0;\n    H2[6] = H2[6] + g | 0;\n    H2[7] = H2[7] + h | 0;\n  }\n  finalize(messageUpdate) {\n    super.finalize(messageUpdate);\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = this._data.sigBytes * 8;\n    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(\n      nBitsTotal / 4294967296\n    );\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n    this._data.sigBytes = this._data.words.length * 4;\n    this._process();\n    return this._hash;\n  }\n}\nfunction sha256(message) {\n  return new SHA256().finalize(message).toString();\n}\nfunction sha256base64(message) {\n  return new SHA256().finalize(message).toString(Base64);\n}\n\nfunction hash(object, options = {}) {\n  const hashed = typeof object === \"string\" ? object : objectHash(object, options);\n  return sha256base64(hashed).slice(0, 10);\n}\n\nfunction murmurHash(key, seed = 0) {\n  if (typeof key === \"string\") {\n    key = createBuffer(key);\n  }\n  let i = 0;\n  let h1 = seed;\n  let k1;\n  let h1b;\n  const remainder = key.length & 3;\n  const bytes = key.length - remainder;\n  const c1 = 3432918353;\n  const c2 = 461845907;\n  while (i < bytes) {\n    k1 = key[i] & 255 | (key[++i] & 255) << 8 | (key[++i] & 255) << 16 | (key[++i] & 255) << 24;\n    ++i;\n    k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;\n    k1 = k1 << 15 | k1 >>> 17;\n    k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;\n    h1 ^= k1;\n    h1 = h1 << 13 | h1 >>> 19;\n    h1b = (h1 & 65535) * 5 + (((h1 >>> 16) * 5 & 65535) << 16) & 4294967295;\n    h1 = (h1b & 65535) + 27492 + (((h1b >>> 16) + 58964 & 65535) << 16);\n  }\n  k1 = 0;\n  switch (remainder) {\n    case 3: {\n      k1 ^= (key[i + 2] & 255) << 16;\n      break;\n    }\n    case 2: {\n      k1 ^= (key[i + 1] & 255) << 8;\n      break;\n    }\n    case 1: {\n      k1 ^= key[i] & 255;\n      k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;\n      k1 = k1 << 15 | k1 >>> 17;\n      k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;\n      h1 ^= k1;\n    }\n  }\n  h1 ^= key.length;\n  h1 ^= h1 >>> 16;\n  h1 = (h1 & 65535) * 2246822507 + (((h1 >>> 16) * 2246822507 & 65535) << 16) & 4294967295;\n  h1 ^= h1 >>> 13;\n  h1 = (h1 & 65535) * 3266489909 + (((h1 >>> 16) * 3266489909 & 65535) << 16) & 4294967295;\n  h1 ^= h1 >>> 16;\n  return h1 >>> 0;\n}\nfunction createBuffer(val) {\n  return new TextEncoder().encode(val);\n}\n\nfunction isEqual(object1, object2, hashOptions = {}) {\n  if (object1 === object2) {\n    return true;\n  }\n  if (objectHash(object1, hashOptions) === objectHash(object2, hashOptions)) {\n    return true;\n  }\n  return false;\n}\n\nfunction diff(obj1, obj2, opts = {}) {\n  const h1 = _toHashedObject(obj1, opts);\n  const h2 = _toHashedObject(obj2, opts);\n  return _diff(h1, h2, opts);\n}\nfunction _diff(h1, h2, opts = {}) {\n  const diffs = [];\n  const allProps = /* @__PURE__ */ new Set([\n    ...Object.keys(h1.props || {}),\n    ...Object.keys(h2.props || {})\n  ]);\n  if (h1.props && h2.props) {\n    for (const prop of allProps) {\n      const p1 = h1.props[prop];\n      const p2 = h2.props[prop];\n      if (p1 && p2) {\n        diffs.push(..._diff(h1.props?.[prop], h2.props?.[prop], opts));\n      } else if (p1 || p2) {\n        diffs.push(\n          new DiffEntry((p2 || p1).key, p1 ? \"removed\" : \"added\", p2, p1)\n        );\n      }\n    }\n  }\n  if (allProps.size === 0 && h1.hash !== h2.hash) {\n    diffs.push(new DiffEntry((h2 || h1).key, \"changed\", h2, h1));\n  }\n  return diffs;\n}\nfunction _toHashedObject(obj, opts, key = \"\") {\n  if (obj && typeof obj !== \"object\") {\n    return new DiffHashedObject(key, obj, objectHash(obj, opts));\n  }\n  const props = {};\n  const hashes = [];\n  for (const _key in obj) {\n    props[_key] = _toHashedObject(\n      obj[_key],\n      opts,\n      key ? `${key}.${_key}` : _key\n    );\n    hashes.push(props[_key].hash);\n  }\n  return new DiffHashedObject(key, obj, `{${hashes.join(\":\")}}`, props);\n}\nclass DiffEntry {\n  // eslint-disable-next-line no-useless-constructor\n  constructor(key, type, newValue, oldValue) {\n    this.key = key;\n    this.type = type;\n    this.newValue = newValue;\n    this.oldValue = oldValue;\n  }\n  toString() {\n    return this.toJSON();\n  }\n  toJSON() {\n    switch (this.type) {\n      case \"added\": {\n        return `Added   \\`${this.key}\\``;\n      }\n      case \"removed\": {\n        return `Removed \\`${this.key}\\``;\n      }\n      case \"changed\": {\n        return `Changed \\`${this.key}\\` from \\`${this.oldValue?.toString() || \"-\"}\\` to \\`${this.newValue.toString()}\\``;\n      }\n    }\n  }\n}\nclass DiffHashedObject {\n  // eslint-disable-next-line no-useless-constructor\n  constructor(key, value, hash, props) {\n    this.key = key;\n    this.value = value;\n    this.hash = hash;\n    this.props = props;\n  }\n  toString() {\n    if (this.props) {\n      return `{${Object.keys(this.props).join(\",\")}}`;\n    } else {\n      return JSON.stringify(this.value);\n    }\n  }\n  toJSON() {\n    const k = this.key || \".\";\n    if (this.props) {\n      return `${k}({${Object.keys(this.props).join(\",\")}})`;\n    }\n    return `${k}(${this.value})`;\n  }\n}\n\nexport { diff, hash, isEqual, murmurHash, objectHash, sha256, sha256base64 };\n", "import { diff } from 'diff-match-patch-es';\nimport { hash } from 'ohash';\n\nfunction createMagicMoveMachine(codeToKeyedTokens2, options = {}) {\n  const EMPTY = toKeyedTokens(\"\", []);\n  let previous = EMPTY;\n  let current = EMPTY;\n  function commit(code, override = {}) {\n    previous = current;\n    const newTokens = codeToKeyedTokens2(code);\n    ({ from: previous, to: current } = syncTokenKeys(previous, newTokens, {\n      ...options,\n      ...override\n    }));\n    return {\n      current,\n      previous\n    };\n  }\n  return {\n    get current() {\n      return current;\n    },\n    get previous() {\n      return previous;\n    },\n    commit,\n    reset() {\n      previous = EMPTY;\n      current = EMPTY;\n    }\n  };\n}\nfunction codeToKeyedTokens(highlighter, code, options) {\n  const result = highlighter.codeToTokens(code, options);\n  return {\n    ...toKeyedTokens(\n      code,\n      result.tokens,\n      // We put the lang and theme to participate in the hash calculation because they can affect the tokenization\n      JSON.stringify([options.lang, \"themes\" in options ? options.themes : options.theme])\n    ),\n    bg: result.bg,\n    fg: result.fg,\n    rootStyle: result.rootStyle,\n    themeName: result.themeName,\n    lang: options.lang\n  };\n}\nfunction toKeyedTokens(code, tokens, salt = \"\") {\n  const hash$1 = hash(code + salt);\n  let lastOffset = 0;\n  const keyed = splitWhitespaceTokens(tokens).flatMap((line) => {\n    const lastEl = line[line.length - 1];\n    if (!lastEl)\n      lastOffset += 1;\n    else\n      lastOffset = lastEl.offset + lastEl.content.length;\n    return [\n      ...line,\n      {\n        content: \"\\n\",\n        offset: lastOffset\n      }\n    ];\n  }).map((token, idx) => {\n    const t = token;\n    t.key = `${hash$1}-${idx}`;\n    return t;\n  });\n  return {\n    code,\n    hash: hash$1,\n    tokens: keyed\n  };\n}\nfunction splitWhitespaceTokens(tokens) {\n  return tokens.map((line) => {\n    return line.flatMap((token) => {\n      if (token.content.match(/^\\s+$/))\n        return token;\n      const match = token.content.match(/^(\\s*)(.*?)(\\s*)$/);\n      if (!match)\n        return token;\n      const [, leading, content, trailing] = match;\n      if (!leading && !trailing)\n        return token;\n      const expanded = [{\n        ...token,\n        offset: token.offset + leading.length,\n        content\n      }];\n      if (leading) {\n        expanded.unshift({\n          content: leading,\n          offset: token.offset\n        });\n      }\n      if (trailing) {\n        expanded.push({\n          content: trailing,\n          offset: token.offset + leading.length + content.length\n        });\n      }\n      return expanded;\n    });\n  });\n}\nfunction splitToken(token, offsets) {\n  let lastOffset = 0;\n  const key = token.key;\n  let index = 0;\n  const tokens = [];\n  function getKey() {\n    if (index === 0) {\n      index++;\n      return key;\n    }\n    return `${key}-${index++}`;\n  }\n  for (const offset of offsets) {\n    if (offset > lastOffset) {\n      tokens.push({\n        ...token,\n        content: token.content.slice(lastOffset, offset),\n        offset: token.offset + lastOffset,\n        key: getKey()\n      });\n    }\n    lastOffset = offset;\n  }\n  if (lastOffset < token.content.length) {\n    tokens.push({\n      ...token,\n      content: token.content.slice(lastOffset),\n      offset: token.offset + lastOffset,\n      key: getKey()\n    });\n  }\n  return tokens;\n}\nfunction splitTokens(tokens, breakpoints) {\n  const sorted = Array.from(breakpoints instanceof Set ? breakpoints : new Set(breakpoints)).sort((a, b) => a - b);\n  if (!sorted.length)\n    return tokens;\n  return tokens.flatMap((token) => {\n    const breakpointsInToken = sorted.filter((i) => token.offset < i && i < token.offset + token.content.length).map((i) => i - token.offset).sort((a, b) => a - b);\n    if (!breakpointsInToken.length)\n      return token;\n    return splitToken(token, breakpointsInToken);\n  });\n}\nfunction syncTokenKeys(from, to, options = {}) {\n  const {\n    splitTokens: shouldSplitTokens = false,\n    enhanceMatching = true\n  } = options;\n  const matches = findTextMatches(from.code, to.code, options);\n  const tokensFrom = shouldSplitTokens ? splitTokens(from.tokens, matches.flatMap((m) => m.from)) : from.tokens;\n  const tokensTo = shouldSplitTokens ? splitTokens(to.tokens, matches.flatMap((m) => m.to)) : to.tokens;\n  const matchedKeys = /* @__PURE__ */ new Set();\n  matches.forEach((match) => {\n    const tokensF = tokensFrom.filter((t) => t.offset >= match.from[0] && t.offset + t.content.length <= match.from[1]);\n    const tokensT = tokensTo.filter((t) => t.offset >= match.to[0] && t.offset + t.content.length <= match.to[1]);\n    let idxF = 0;\n    let idxT = 0;\n    while (idxF < tokensF.length && idxT < tokensT.length) {\n      if (!tokensF[idxF] || !tokensT[idxT])\n        break;\n      if (tokensF[idxF].content === tokensT[idxT].content) {\n        tokensT[idxT].key = tokensF[idxF].key;\n        matchedKeys.add(tokensF[idxF].key);\n        idxF++;\n        idxT++;\n      } else if (tokensF[idxF + 1]?.content === tokensT[idxT].content) {\n        idxF++;\n      } else if (tokensF[idxF].content === tokensT[idxT + 1]?.content) {\n        idxT++;\n      } else {\n        idxF++;\n        idxT++;\n      }\n    }\n  });\n  if (enhanceMatching) {\n    for (const token of tokensFrom) {\n      if (matchedKeys.has(token.key))\n        continue;\n      if (token.content.length < 3 || !token.content.match(/^[\\w\\d_-]+$/))\n        continue;\n      const matched = tokensTo.find((t) => t.content === token.content && !matchedKeys.has(t.key));\n      if (matched) {\n        matched.key = token.key;\n        matchedKeys.add(token.key);\n      }\n    }\n  }\n  return {\n    from: tokensFrom.length === from.tokens.length ? from : { ...from, tokens: tokensFrom },\n    to: tokensTo.length === to.tokens.length ? to : { ...to, tokens: tokensTo }\n  };\n}\nfunction findTextMatches(a, b, options = {}) {\n  let delta = diff(a, b);\n  delta = options.diffCleanup?.(delta) || delta;\n  let aContent = \"\";\n  let bContent = \"\";\n  const matched = [];\n  for (const [op, text] of delta) {\n    if (op === 0) {\n      matched.push({\n        from: [aContent.length, aContent.length + text.length],\n        to: [bContent.length, bContent.length + text.length],\n        content: text\n      });\n      aContent += text;\n      bContent += text;\n    } else if (op === -1) {\n      aContent += text;\n    } else if (op === 1) {\n      bContent += text;\n    }\n  }\n  if (aContent !== a || bContent !== b)\n    throw new Error(\"Content mismatch\");\n  return matched;\n}\n\nexport { codeToKeyedTokens, createMagicMoveMachine, findTextMatches, syncTokenKeys, toKeyedTokens };\n", "var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst CLASS_PREFIX = \"shiki-magic-move\";\nconst CLASS_LEAVE_FROM = `${CLASS_PREFIX}-leave-from`;\nconst CLASS_LEAVE_TO = `${CLASS_PREFIX}-leave-to`;\nconst CLASS_LEAVE_ACTIVE = `${CLASS_PREFIX}-leave-active`;\nconst CLASS_ENTER_FROM = `${CLASS_PREFIX}-enter-from`;\nconst CLASS_ENTER_TO = `${CLASS_PREFIX}-enter-to`;\nconst CLASS_ENTER_ACTIVE = `${CLASS_PREFIX}-enter-active`;\nconst CLASS_MOVE = `${CLASS_PREFIX}-move`;\nconst CLASS_CONTAINER_RESIZE = `${CLASS_PREFIX}-container-resize`;\nconst CLASS_CONTAINER_RESTYLE = `${CLASS_PREFIX}-container-restyle`;\nconst defaultOptions = {\n  globalScale: 1,\n  duration: 500,\n  delayMove: 0.3,\n  delayLeave: 0.1,\n  delayEnter: 0.7,\n  delayContainer: 0.4,\n  stagger: 0,\n  easing: \"ease\",\n  animateContainer: true,\n  containerStyle: true\n};\nclass MagicMoveRenderer {\n  constructor(target, options = {}) {\n    __publicField(this, \"mapDom\", /* @__PURE__ */ new Map());\n    __publicField(this, \"container\");\n    __publicField(this, \"anchor\");\n    __publicField(this, \"previousPromises\", []);\n    __publicField(this, \"options\");\n    __publicField(this, \"isFirstRender\", true);\n    this.options = {\n      ...defaultOptions,\n      ...options\n    };\n    if (typeof target === \"string\")\n      this.container = document.querySelector(target);\n    else\n      this.container = target;\n    this.anchor = document.createElement(\"span\");\n    this.anchor.style.position = \"absolute\";\n    this.anchor.style.top = \"0\";\n    this.anchor.style.left = \"0\";\n    this.anchor.style.height = \"1px\";\n    this.anchor.style.width = \"1px\";\n    this.container.prepend(this.anchor);\n  }\n  applyElementContent(el, token) {\n    if (token.content !== \"\\n\") {\n      el.textContent = token.content;\n      el.classList.add(`${CLASS_PREFIX}-item`);\n    }\n  }\n  applyElementStyle(el, token) {\n    if (token.htmlStyle)\n      el.setAttribute(\"style\", token.htmlStyle);\n    if (token.color)\n      el.style.color = token.color;\n    if (token.bgColor)\n      el.style.backgroundColor = token.bgColor;\n  }\n  applyElement(el, token) {\n    this.applyElementContent(el, token);\n    this.applyElementStyle(el, token);\n  }\n  applyContainerStyle(step) {\n    if (!this.options.containerStyle)\n      return;\n    if (step.bg)\n      this.container.style.backgroundColor = step.bg;\n    if (step.fg)\n      this.container.style.color = step.fg;\n    if (step.rootStyle) {\n      const items = step.rootStyle.split(\";\");\n      for (const item of items) {\n        const [key, value] = item.split(\":\");\n        if (key && value)\n          this.container.style.setProperty(key.trim(), value.trim());\n      }\n    }\n  }\n  registerTransitionEnd(el, cb) {\n    let resolved = false;\n    let resolve = () => {\n    };\n    const promise = new Promise((_resolve) => {\n      const finish = (e) => {\n        if (!e || e.target !== el)\n          return;\n        resolve();\n      };\n      resolve = () => {\n        if (resolved)\n          return;\n        resolved = true;\n        el.removeEventListener(\"transitionend\", finish);\n        cb();\n        _resolve();\n      };\n      el.addEventListener(\"transitionend\", finish);\n    });\n    promise.resolve = resolve;\n    return promise;\n  }\n  setCssVariables() {\n    this.container.style.setProperty(\"--smm-duration\", `${this.options.duration}ms`);\n    this.container.style.setProperty(\"--smm-delay-move\", `${this.options.delayMove}`);\n    this.container.style.setProperty(\"--smm-delay-leave\", `${this.options.delayLeave}`);\n    this.container.style.setProperty(\"--smm-delay-enter\", `${this.options.delayEnter}`);\n    this.container.style.setProperty(\"--smm-delay-container\", `${this.options.delayContainer}`);\n    this.container.style.setProperty(\"--smm-easing\", this.options.easing);\n    this.container.style.setProperty(\"--smm-stagger\", \"0\");\n  }\n  /**\n   * Replace tokens without animation\n   */\n  replace(step) {\n    const newDomMap = /* @__PURE__ */ new Map();\n    const newChildren = step.tokens.map((token) => {\n      if (this.mapDom.has(token.key)) {\n        const el = this.mapDom.get(token.key);\n        this.applyElement(el, token);\n        newDomMap.set(token.key, el);\n        this.mapDom.delete(token.key);\n        return el;\n      } else {\n        const el = document.createElement(token.content === \"\\n\" ? \"br\" : \"span\");\n        this.applyElement(el, token);\n        newDomMap.set(token.key, el);\n        return el;\n      }\n    });\n    this.container.replaceChildren(\n      this.anchor,\n      ...newChildren\n    );\n    this.applyContainerStyle(step);\n    this.mapDom = newDomMap;\n  }\n  // Note: This function is intentionally not async to keep the operations sync\n  /**\n   * Render tokens with animation\n   */\n  render(step) {\n    this.setCssVariables();\n    const newDomMap = /* @__PURE__ */ new Map();\n    const move = [];\n    const enter = [];\n    const leave = [];\n    const promises = [];\n    this.previousPromises.forEach((p) => p.resolve());\n    this.previousPromises = [];\n    const postReflow = [];\n    const {\n      globalScale: scale\n    } = this.options;\n    const position = /* @__PURE__ */ new Map();\n    let anchorRect = this.anchor.getBoundingClientRect();\n    const containerRect = this.container.getBoundingClientRect();\n    for (const el of this.mapDom.values()) {\n      const rect = el.getBoundingClientRect();\n      position.set(el, { x: rect.x - anchorRect.x, y: rect.y - anchorRect.y });\n    }\n    const newChildren = step.tokens.map((token) => {\n      if (this.mapDom.has(token.key)) {\n        const el = this.mapDom.get(token.key);\n        this.applyElementContent(el, token);\n        postReflow.push(() => {\n          this.applyElementStyle(el, token);\n        });\n        move.push(el);\n        newDomMap.set(token.key, el);\n        this.mapDom.delete(token.key);\n        return el;\n      } else {\n        const el = document.createElement(token.content === \"\\n\" ? \"br\" : \"span\");\n        this.applyElement(el, token);\n        enter.push(el);\n        newDomMap.set(token.key, el);\n        return el;\n      }\n    });\n    for (const [_, el] of this.mapDom) {\n      if (el.tagName === \"BR\")\n        continue;\n      leave.push(el);\n    }\n    for (const el of leave)\n      el.style.position = \"absolute\";\n    this.container.replaceChildren(\n      this.anchor,\n      ...newChildren,\n      ...leave\n    );\n    this.mapDom = newDomMap;\n    leave.forEach((el, idx) => {\n      el.style.position = \"absolute\";\n      const pos = position.get(el);\n      el.style.top = `${pos.y / scale}px`;\n      el.style.left = `${pos.x / scale}px`;\n      if (this.options.stagger)\n        el.style.setProperty(\"--smm-stagger\", `${idx * this.options.stagger}ms`);\n      else\n        el.style.removeProperty(\"--smm-stagger\");\n      el.classList.add(CLASS_LEAVE_FROM);\n      el.classList.add(CLASS_LEAVE_ACTIVE);\n      postReflow.unshift(() => {\n        el.classList.remove(CLASS_LEAVE_FROM);\n        el.classList.add(CLASS_LEAVE_TO);\n      });\n      promises.push(\n        this.registerTransitionEnd(el, () => {\n          el.classList.remove(CLASS_LEAVE_FROM);\n          el.classList.remove(CLASS_LEAVE_ACTIVE);\n          el.classList.remove(CLASS_ENTER_TO);\n          el.remove();\n        })\n      );\n    });\n    if (!this.isFirstRender) {\n      enter.forEach((el, idx) => {\n        el.classList.add(CLASS_ENTER_FROM);\n        el.classList.add(CLASS_ENTER_ACTIVE);\n        if (this.options.stagger)\n          el.style.setProperty(\"--smm-stagger\", `${idx * this.options.stagger}ms`);\n        else\n          el.style.removeProperty(\"--smm-stagger\");\n        postReflow.push(() => {\n          el.classList.remove(CLASS_ENTER_FROM);\n          el.classList.add(CLASS_ENTER_TO);\n        });\n        promises.push(\n          this.registerTransitionEnd(el, () => {\n            el.classList.remove(CLASS_ENTER_FROM);\n            el.classList.remove(CLASS_ENTER_ACTIVE);\n            el.classList.remove(CLASS_ENTER_TO);\n          })\n        );\n      });\n    }\n    anchorRect = this.anchor.getBoundingClientRect();\n    move.forEach((el, idx) => {\n      const newRect = el.getBoundingClientRect();\n      const newPos = { x: newRect.x - anchorRect.x, y: newRect.y - anchorRect.y };\n      const oldPos = position.get(el);\n      el.style.transitionDuration = el.style.transitionDelay = \"0ms\";\n      const dx = (oldPos.x - newPos.x) / scale;\n      const dy = (oldPos.y - newPos.y) / scale;\n      el.style.transform = `translate(${dx}px, ${dy}px)`;\n      if (this.options.stagger)\n        el.style.setProperty(\"--smm-stagger\", `${idx * this.options.stagger}ms`);\n      else\n        el.style.removeProperty(\"--smm-stagger\");\n      postReflow.unshift(() => {\n        el.classList.add(CLASS_MOVE);\n        el.style.transform = el.style.transitionDuration = el.style.transitionDelay = \"\";\n      });\n      promises.push(\n        this.registerTransitionEnd(el, () => {\n          el.classList.remove(CLASS_MOVE);\n        })\n      );\n    });\n    if (this.options.animateContainer && !this.isFirstRender) {\n      const newRect = this.container.getBoundingClientRect();\n      if (newRect.width !== containerRect.width || newRect.height !== containerRect.height) {\n        this.container.style.transitionDuration = this.container.style.transitionDelay = \"0ms\";\n        this.container.style.height = `${containerRect.height / scale}px`;\n        this.container.style.width = `${containerRect.width / scale}px`;\n        postReflow.unshift(() => {\n          this.container.classList.add(CLASS_CONTAINER_RESIZE);\n          this.container.style.transitionDuration = this.container.style.transitionDelay = \"\";\n          this.container.style.height = `${newRect.height / scale}px`;\n          this.container.style.width = `${newRect.width / scale}px`;\n        });\n        promises.push(\n          this.registerTransitionEnd(this.container, () => {\n            this.container.classList.remove(CLASS_CONTAINER_RESIZE);\n            this.container.style.height = this.container.style.width = \"\";\n          })\n        );\n      }\n    }\n    if (this.options.containerStyle) {\n      if (this.isFirstRender) {\n        this.applyContainerStyle(step);\n      } else {\n        postReflow.push(() => {\n          this.container.classList.add(CLASS_CONTAINER_RESTYLE);\n          this.applyContainerStyle(step);\n        });\n        promises.push(\n          this.registerTransitionEnd(this.container, () => {\n            this.container.classList.remove(CLASS_CONTAINER_RESTYLE);\n          })\n        );\n      }\n    }\n    forceReflow();\n    postReflow.forEach((cb) => cb());\n    this.isFirstRender = false;\n    this.previousPromises = promises;\n    return Promise.all(promises).then();\n  }\n}\nfunction forceReflow() {\n  return document.body.offsetHeight;\n}\n\nexport { MagicMoveRenderer, defaultOptions };\n"],
  "mappings": ";;;AAAA,SAAS,iBAAiB,KAAK,WAAW,OAAO,UAAU,GAAG,YAAY,gBAAgB;;;ACA1F,IAAM,iBAAiC,OAAO,OAAO;AAAA,EACnD,aAAa;AAAA,EACb,cAAc;AAAA,EACd,gBAAgB;AAAA,EAChB,eAAe;AAAA,EACf,sBAAsB;AAAA,EACtB,aAAa;AAAA,EACb,cAAc;AAChB,CAAC;AACD,SAAS,eAAe,SAAS;AAC/B,MAAI,mCAAS;AACX,WAAO;AACT,QAAM,WAAW;AAAA,IACf,GAAG;AAAA,IACH,GAAG;AAAA,EACL;AACA,SAAO,eAAe,UAAU,cAAc,EAAE,OAAO,MAAM,YAAY,MAAM,CAAC;AAChF,SAAO;AACT;AAEA,IAAM,cAAc;AACpB,IAAM,cAAc;AACpB,IAAM,aAAa;AACnB,SAAS,WAAW,IAAI,MAAM;AAC5B,SAAO,CAAC,IAAI,IAAI;AAClB;AACA,SAAS,SAAS,OAAO,OAAO,SAAS,iBAAiB,MAAM,cAAc;AAC5E,QAAM,WAAW,eAAe,OAAO;AACvC,MAAI,OAAO,gBAAgB,aAAa;AACtC,QAAI,SAAS,eAAe;AAC1B,qBAAe,OAAO;AAAA;AAEtB,sBAAgC,oBAAI,KAAK,GAAG,QAAQ,IAAI,SAAS,cAAc;AAAA,EACnF;AACA,QAAM,WAAW;AACjB,MAAI,SAAS,QAAQ,SAAS;AAC5B,UAAM,IAAI,MAAM,yBAAyB;AAC3C,MAAI,UAAU,OAAO;AACnB,QAAI;AACF,aAAO,CAAC,WAAW,YAAY,KAAK,CAAC;AACvC,WAAO,CAAC;AAAA,EACV;AACA,QAAM,aAAa;AACnB,MAAI,eAAe,iBAAiB,OAAO,KAAK;AAChD,QAAM,eAAe,MAAM,UAAU,GAAG,YAAY;AACpD,UAAQ,MAAM,UAAU,YAAY;AACpC,UAAQ,MAAM,UAAU,YAAY;AACpC,iBAAe,iBAAiB,OAAO,KAAK;AAC5C,QAAM,eAAe,MAAM,UAAU,MAAM,SAAS,YAAY;AAChE,UAAQ,MAAM,UAAU,GAAG,MAAM,SAAS,YAAY;AACtD,UAAQ,MAAM,UAAU,GAAG,MAAM,SAAS,YAAY;AACtD,QAAM,QAAQ,YAAY,OAAO,OAAO,UAAU,YAAY,QAAQ;AACtE,MAAI;AACF,UAAM,QAAQ,WAAW,YAAY,YAAY,CAAC;AACpD,MAAI;AACF,UAAM,KAAK,WAAW,YAAY,YAAY,CAAC;AACjD,mBAAiB,KAAK;AACtB,SAAO;AACT;AACA,SAAS,YAAY,OAAO,OAAO,SAAS,YAAY,UAAU;AAChE,MAAI;AACJ,MAAI,CAAC,OAAO;AACV,WAAO,CAAC,WAAW,aAAa,KAAK,CAAC;AAAA,EACxC;AACA,MAAI,CAAC,OAAO;AACV,WAAO,CAAC,WAAW,aAAa,KAAK,CAAC;AAAA,EACxC;AACA,QAAM,WAAW,MAAM,SAAS,MAAM,SAAS,QAAQ;AACvD,QAAM,YAAY,MAAM,SAAS,MAAM,SAAS,QAAQ;AACxD,QAAM,IAAI,SAAS,QAAQ,SAAS;AACpC,MAAI,MAAM,IAAI;AACZ,YAAQ,CAAC,WAAW,aAAa,SAAS,UAAU,GAAG,CAAC,CAAC,GAAG,WAAW,YAAY,SAAS,GAAG,WAAW,aAAa,SAAS,UAAU,IAAI,UAAU,MAAM,CAAC,CAAC;AAChK,QAAI,MAAM,SAAS,MAAM;AACvB,YAAM,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC,IAAI;AAC9B,WAAO;AAAA,EACT;AACA,MAAI,UAAU,WAAW,GAAG;AAC1B,WAAO,CAAC,WAAW,aAAa,KAAK,GAAG,WAAW,aAAa,KAAK,CAAC;AAAA,EACxE;AACA,QAAM,KAAK,cAAc,OAAO,OAAO,OAAO;AAC9C,MAAI,IAAI;AACN,UAAM,UAAU,GAAG,CAAC;AACpB,UAAM,UAAU,GAAG,CAAC;AACpB,UAAM,UAAU,GAAG,CAAC;AACpB,UAAM,UAAU,GAAG,CAAC;AACpB,UAAM,aAAa,GAAG,CAAC;AACvB,UAAM,UAAU,SAAS,SAAS,SAAS,SAAS,YAAY,QAAQ;AACxE,UAAM,UAAU,SAAS,SAAS,SAAS,SAAS,YAAY,QAAQ;AACxE,WAAO,QAAQ,OAAO,CAAC,WAAW,YAAY,UAAU,CAAC,GAAG,OAAO;AAAA,EACrE;AACA,MAAI,cAAc,MAAM,SAAS,OAAO,MAAM,SAAS;AACrD,WAAO,aAAa,OAAO,OAAO,SAAS,QAAQ;AACrD,SAAO,WAAW,OAAO,OAAO,SAAS,QAAQ;AACnD;AACA,SAAS,aAAa,OAAO,OAAO,SAAS,UAAU;AACrD,QAAM,IAAI,iBAAiB,OAAO,KAAK;AACvC,UAAQ,EAAE;AACV,UAAQ,EAAE;AACV,QAAM,YAAY,EAAE;AACpB,QAAM,QAAQ,SAAS,OAAO,OAAO,SAAS,OAAO,QAAQ;AAC7D,mBAAiB,OAAO,SAAS;AACjC,sBAAoB,KAAK;AACzB,QAAM,KAAK,WAAW,YAAY,EAAE,CAAC;AACrC,MAAI,UAAU;AACd,MAAI,eAAe;AACnB,MAAI,eAAe;AACnB,MAAI,cAAc;AAClB,MAAI,cAAc;AAClB,SAAO,UAAU,MAAM,QAAQ;AAC7B,YAAQ,MAAM,OAAO,EAAE,CAAC,GAAG;AAAA,MACzB,KAAK;AACH;AACA,uBAAe,MAAM,OAAO,EAAE,CAAC;AAC/B;AAAA,MACF,KAAK;AACH;AACA,uBAAe,MAAM,OAAO,EAAE,CAAC;AAC/B;AAAA,MACF,KAAK;AACH,YAAI,gBAAgB,KAAK,gBAAgB,GAAG;AAC1C,gBAAM,OAAO,UAAU,eAAe,cAAc,eAAe,YAAY;AAC/E,oBAAU,UAAU,eAAe;AACnC,gBAAM,UAAU,SAAS,aAAa,aAAa,SAAS,OAAO,QAAQ;AAC3E,mBAAS,IAAI,QAAQ,SAAS,GAAG,KAAK,GAAG;AACvC,kBAAM,OAAO,SAAS,GAAG,QAAQ,CAAC,CAAC;AACrC,oBAAU,UAAU,QAAQ;AAAA,QAC9B;AACA,uBAAe;AACf,uBAAe;AACf,sBAAc;AACd,sBAAc;AACd;AAAA,IACJ;AACA;AAAA,EACF;AACA,QAAM,IAAI;AACV,SAAO;AACT;AACA,SAAS,WAAW,OAAO,OAAO,SAAS,UAAU;AACnD,QAAM,eAAe,MAAM;AAC3B,QAAM,eAAe,MAAM;AAC3B,QAAM,QAAQ,KAAK,MAAM,eAAe,gBAAgB,CAAC;AACzD,QAAM,WAAW;AACjB,QAAM,WAAW,IAAI;AACrB,QAAM,KAAK,IAAI,MAAM,QAAQ;AAC7B,QAAM,KAAK,IAAI,MAAM,QAAQ;AAC7B,WAAS,IAAI,GAAG,IAAI,UAAU,KAAK;AACjC,OAAG,CAAC,IAAI;AACR,OAAG,CAAC,IAAI;AAAA,EACV;AACA,KAAG,WAAW,CAAC,IAAI;AACnB,KAAG,WAAW,CAAC,IAAI;AACnB,QAAM,QAAQ,eAAe;AAC7B,QAAM,QAAQ,QAAQ,MAAM;AAC5B,MAAI,UAAU;AACd,MAAI,QAAQ;AACZ,MAAI,UAAU;AACd,MAAI,QAAQ;AACZ,WAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC9B,SAAqB,oBAAI,KAAK,GAAG,QAAQ,IAAI;AAC3C;AACF,aAAS,KAAK,CAAC,IAAI,SAAS,MAAM,IAAI,OAAO,MAAM,GAAG;AACpD,YAAM,YAAY,WAAW;AAC7B,UAAI;AACJ,UAAI,OAAO,CAAC,KAAK,OAAO,KAAK,GAAG,YAAY,CAAC,IAAI,GAAG,YAAY,CAAC;AAC/D,aAAK,GAAG,YAAY,CAAC;AAAA;AAErB,aAAK,GAAG,YAAY,CAAC,IAAI;AAC3B,UAAI,KAAK,KAAK;AACd,aAAO,KAAK,gBAAgB,KAAK,gBAAgB,MAAM,OAAO,EAAE,MAAM,MAAM,OAAO,EAAE,GAAG;AACtF;AACA;AAAA,MACF;AACA,SAAG,SAAS,IAAI;AAChB,UAAI,KAAK,cAAc;AACrB,iBAAS;AAAA,MACX,WAAW,KAAK,cAAc;AAC5B,mBAAW;AAAA,MACb,WAAW,OAAO;AAChB,cAAM,YAAY,WAAW,QAAQ;AACrC,YAAI,aAAa,KAAK,YAAY,YAAY,GAAG,SAAS,MAAM,IAAI;AAClE,gBAAM,KAAK,eAAe,GAAG,SAAS;AACtC,cAAI,MAAM,IAAI;AACZ,mBAAO,gBAAgB,OAAO,OAAO,SAAS,IAAI,IAAI,QAAQ;AAAA,UAChE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,aAAS,KAAK,CAAC,IAAI,SAAS,MAAM,IAAI,OAAO,MAAM,GAAG;AACpD,YAAM,YAAY,WAAW;AAC7B,UAAI;AACJ,UAAI,OAAO,CAAC,KAAK,OAAO,KAAK,GAAG,YAAY,CAAC,IAAI,GAAG,YAAY,CAAC;AAC/D,aAAK,GAAG,YAAY,CAAC;AAAA;AAErB,aAAK,GAAG,YAAY,CAAC,IAAI;AAC3B,UAAI,KAAK,KAAK;AACd,aAAO,KAAK,gBAAgB,KAAK,gBAAgB,MAAM,OAAO,eAAe,KAAK,CAAC,MAAM,MAAM,OAAO,eAAe,KAAK,CAAC,GAAG;AAC5H;AACA;AAAA,MACF;AACA,SAAG,SAAS,IAAI;AAChB,UAAI,KAAK,cAAc;AACrB,iBAAS;AAAA,MACX,WAAW,KAAK,cAAc;AAC5B,mBAAW;AAAA,MACb,WAAW,CAAC,OAAO;AACjB,cAAM,YAAY,WAAW,QAAQ;AACrC,YAAI,aAAa,KAAK,YAAY,YAAY,GAAG,SAAS,MAAM,IAAI;AAClE,gBAAM,KAAK,GAAG,SAAS;AACvB,gBAAM,KAAK,WAAW,KAAK;AAC3B,eAAK,eAAe;AACpB,cAAI,MAAM,IAAI;AACZ,mBAAO,gBAAgB,OAAO,OAAO,SAAS,IAAI,IAAI,QAAQ;AAAA,UAChE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO,CAAC,WAAW,aAAa,KAAK,GAAG,WAAW,aAAa,KAAK,CAAC;AACxE;AACA,SAAS,gBAAgB,OAAO,OAAO,SAAS,GAAG,GAAG,UAAU;AAC9D,QAAM,SAAS,MAAM,UAAU,GAAG,CAAC;AACnC,QAAM,SAAS,MAAM,UAAU,GAAG,CAAC;AACnC,QAAM,SAAS,MAAM,UAAU,CAAC;AAChC,QAAM,SAAS,MAAM,UAAU,CAAC;AAChC,QAAM,QAAQ,SAAS,QAAQ,QAAQ,SAAS,OAAO,QAAQ;AAC/D,QAAM,SAAS,SAAS,QAAQ,QAAQ,SAAS,OAAO,QAAQ;AAChE,SAAO,MAAM,OAAO,MAAM;AAC5B;AACA,SAAS,iBAAiB,OAAO,OAAO;AACtC,QAAM,YAAY,CAAC;AACnB,QAAM,WAAW,CAAC;AAClB,MAAI,WAAW;AACf,YAAU,CAAC,IAAI;AACf,WAAS,sBAAsB,MAAM;AACnC,QAAI,QAAQ;AACZ,QAAI,YAAY;AAChB,QAAI,UAAU;AACd,QAAI,kBAAkB,UAAU;AAChC,WAAO,UAAU,KAAK,SAAS,GAAG;AAChC,gBAAU,KAAK,QAAQ,MAAM,SAAS;AACtC,UAAI,YAAY;AACd,kBAAU,KAAK,SAAS;AAC1B,UAAI,OAAO,KAAK,UAAU,WAAW,UAAU,CAAC;AAChD,UAAI,SAAS,iBAAiB,OAAO,UAAU,eAAe,KAAK,UAAU,IAAI,IAAI,SAAS,IAAI,MAAM,QAAQ;AAC9G,iBAAS,OAAO,aAAa,SAAS,IAAI,CAAC;AAAA,MAC7C,OAAO;AACL,YAAI,oBAAoB,UAAU;AAChC,iBAAO,KAAK,UAAU,SAAS;AAC/B,oBAAU,KAAK;AAAA,QACjB;AACA,iBAAS,OAAO,aAAa,eAAe;AAC5C,iBAAS,IAAI,IAAI;AACjB,kBAAU,iBAAiB,IAAI;AAAA,MACjC;AACA,kBAAY,UAAU;AAAA,IACxB;AACA,WAAO;AAAA,EACT;AACA,QAAM,SAAS,sBAAsB,KAAK;AAC1C,aAAW;AACX,QAAM,SAAS,sBAAsB,KAAK;AAC1C,SAAO,EAAE,QAAQ,QAAQ,UAAU;AACrC;AACA,SAAS,iBAAiB,OAAO,WAAW;AAC1C,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAM,QAAQ,MAAM,CAAC,EAAE,CAAC;AACxB,UAAM,OAAO,CAAC;AACd,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ;AAChC,WAAK,CAAC,IAAI,UAAU,MAAM,WAAW,CAAC,CAAC;AACzC,UAAM,CAAC,EAAE,CAAC,IAAI,KAAK,KAAK,EAAE;AAAA,EAC5B;AACF;AACA,SAAS,iBAAiB,OAAO,OAAO;AACtC,MAAI,CAAC,SAAS,CAAC,SAAS,MAAM,OAAO,CAAC,MAAM,MAAM,OAAO,CAAC;AACxD,WAAO;AACT,MAAI,aAAa;AACjB,MAAI,aAAa,KAAK,IAAI,MAAM,QAAQ,MAAM,MAAM;AACpD,MAAI,aAAa;AACjB,MAAI,eAAe;AACnB,SAAO,aAAa,YAAY;AAC9B,QAAI,MAAM,UAAU,cAAc,UAAU,MAAM,MAAM,UAAU,cAAc,UAAU,GAAG;AAC3F,mBAAa;AACb,qBAAe;AAAA,IACjB,OAAO;AACL,mBAAa;AAAA,IACf;AACA,iBAAa,KAAK,OAAO,aAAa,cAAc,IAAI,UAAU;AAAA,EACpE;AACA,SAAO;AACT;AACA,SAAS,iBAAiB,OAAO,OAAO;AACtC,MAAI,CAAC,SAAS,CAAC,SAAS,MAAM,OAAO,MAAM,SAAS,CAAC,MAAM,MAAM,OAAO,MAAM,SAAS,CAAC;AACtF,WAAO;AACT,MAAI,aAAa;AACjB,MAAI,aAAa,KAAK,IAAI,MAAM,QAAQ,MAAM,MAAM;AACpD,MAAI,aAAa;AACjB,MAAI,aAAa;AACjB,SAAO,aAAa,YAAY;AAC9B,QAAI,MAAM,UAAU,MAAM,SAAS,YAAY,MAAM,SAAS,UAAU,MAAM,MAAM,UAAU,MAAM,SAAS,YAAY,MAAM,SAAS,UAAU,GAAG;AACnJ,mBAAa;AACb,mBAAa;AAAA,IACf,OAAO;AACL,mBAAa;AAAA,IACf;AACA,iBAAa,KAAK,OAAO,aAAa,cAAc,IAAI,UAAU;AAAA,EACpE;AACA,SAAO;AACT;AACA,SAAS,kBAAkB,OAAO,OAAO;AACvC,QAAM,eAAe,MAAM;AAC3B,QAAM,eAAe,MAAM;AAC3B,MAAI,iBAAiB,KAAK,iBAAiB;AACzC,WAAO;AACT,MAAI,eAAe;AACjB,YAAQ,MAAM,UAAU,eAAe,YAAY;AAAA,WAC5C,eAAe;AACtB,YAAQ,MAAM,UAAU,GAAG,YAAY;AACzC,QAAM,cAAc,KAAK,IAAI,cAAc,YAAY;AACvD,MAAI,UAAU;AACZ,WAAO;AACT,MAAI,OAAO;AACX,MAAI,SAAS;AACb,SAAO,MAAM;AACX,UAAM,UAAU,MAAM,UAAU,cAAc,MAAM;AACpD,UAAM,QAAQ,MAAM,QAAQ,OAAO;AACnC,QAAI,UAAU;AACZ,aAAO;AACT,cAAU;AACV,QAAI,UAAU,KAAK,MAAM,UAAU,cAAc,MAAM,MAAM,MAAM,UAAU,GAAG,MAAM,GAAG;AACvF,aAAO;AACP;AAAA,IACF;AAAA,EACF;AACF;AACA,SAAS,cAAc,OAAO,OAAO,SAAS;AAC5C,MAAI,QAAQ,eAAe,GAAG;AAC5B,WAAO;AAAA,EACT;AACA,QAAM,WAAW,MAAM,SAAS,MAAM,SAAS,QAAQ;AACvD,QAAM,YAAY,MAAM,SAAS,MAAM,SAAS,QAAQ;AACxD,MAAI,SAAS,SAAS,KAAK,UAAU,SAAS,IAAI,SAAS;AACzD,WAAO;AACT,WAAS,eAAe,WAAW,YAAY,GAAG;AAChD,UAAM,OAAO,UAAU,UAAU,GAAG,IAAI,KAAK,MAAM,UAAU,SAAS,CAAC,CAAC;AACxE,QAAI,IAAI;AACR,QAAI,cAAc;AAClB,QAAI,iBAAiB,iBAAiB,kBAAkB;AACxD,YAAQ,IAAI,WAAW,QAAQ,MAAM,IAAI,CAAC,OAAO,IAAI;AACnD,YAAM,eAAe,iBAAiB,UAAU,UAAU,CAAC,GAAG,WAAW,UAAU,CAAC,CAAC;AACrF,YAAM,eAAe,iBAAiB,UAAU,UAAU,GAAG,CAAC,GAAG,WAAW,UAAU,GAAG,CAAC,CAAC;AAC3F,UAAI,YAAY,SAAS,eAAe,cAAc;AACpD,sBAAc,WAAW,UAAU,IAAI,cAAc,CAAC,IAAI,WAAW,UAAU,GAAG,IAAI,YAAY;AAClG,0BAAkB,UAAU,UAAU,GAAG,IAAI,YAAY;AACzD,0BAAkB,UAAU,UAAU,IAAI,YAAY;AACtD,2BAAmB,WAAW,UAAU,GAAG,IAAI,YAAY;AAC3D,2BAAmB,WAAW,UAAU,IAAI,YAAY;AAAA,MAC1D;AAAA,IACF;AACA,QAAI,YAAY,SAAS,KAAK,UAAU;AACtC,aAAO,CAAC,iBAAiB,iBAAiB,kBAAkB,kBAAkB,WAAW;AAAA;AAEzF,aAAO;AAAA,EACX;AACA,QAAM,MAAM,eAAe,UAAU,WAAW,KAAK,KAAK,SAAS,SAAS,CAAC,CAAC;AAC9E,QAAM,MAAM,eAAe,UAAU,WAAW,KAAK,KAAK,SAAS,SAAS,CAAC,CAAC;AAC9E,MAAI;AACJ,MAAI,CAAC,OAAO,CAAC,KAAK;AAChB,WAAO;AAAA,EACT,WAAW,CAAC,KAAK;AACf,SAAK;AAAA,EACP,WAAW,CAAC,KAAK;AACf,SAAK;AAAA,EACP,OAAO;AACL,SAAK,IAAI,CAAC,EAAE,SAAS,IAAI,CAAC,EAAE,SAAS,MAAM;AAAA,EAC7C;AACA,MAAI,SAAS,SAAS,SAAS;AAC/B,MAAI,MAAM,SAAS,MAAM,QAAQ;AAC/B,cAAU,GAAG,CAAC;AACd,cAAU,GAAG,CAAC;AACd,cAAU,GAAG,CAAC;AACd,cAAU,GAAG,CAAC;AAAA,EAChB,OAAO;AACL,cAAU,GAAG,CAAC;AACd,cAAU,GAAG,CAAC;AACd,cAAU,GAAG,CAAC;AACd,cAAU,GAAG,CAAC;AAAA,EAChB;AACA,QAAM,aAAa,GAAG,CAAC;AACvB,SAAO,CAAC,SAAS,SAAS,SAAS,SAAS,UAAU;AACxD;AACA,SAAS,oBAAoB,OAAO;AAClC,MAAI,UAAU;AACd,QAAM,aAAa,CAAC;AACpB,MAAI,mBAAmB;AACvB,MAAI,eAAe;AACnB,MAAI,UAAU;AACd,MAAI,qBAAqB;AACzB,MAAI,oBAAoB;AACxB,MAAI,qBAAqB;AACzB,MAAI,oBAAoB;AACxB,SAAO,UAAU,MAAM,QAAQ;AAC7B,QAAI,MAAM,OAAO,EAAE,CAAC,MAAM,YAAY;AACpC,iBAAW,kBAAkB,IAAI;AACjC,2BAAqB;AACrB,0BAAoB;AACpB,2BAAqB;AACrB,0BAAoB;AACpB,qBAAe,MAAM,OAAO,EAAE,CAAC;AAAA,IACjC,OAAO;AACL,UAAI,MAAM,OAAO,EAAE,CAAC,MAAM;AACxB,8BAAsB,MAAM,OAAO,EAAE,CAAC,EAAE;AAAA;AAExC,6BAAqB,MAAM,OAAO,EAAE,CAAC,EAAE;AACzC,UAAI,gBAAgB,aAAa,UAAU,KAAK,IAAI,oBAAoB,iBAAiB,KAAK,aAAa,UAAU,KAAK,IAAI,oBAAoB,iBAAiB,GAAG;AACpK,cAAM,OAAO,WAAW,mBAAmB,CAAC,GAAG,GAAG,WAAW,aAAa,YAAY,CAAC;AACvF,cAAM,WAAW,mBAAmB,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI;AACjD;AACA;AACA,kBAAU,mBAAmB,IAAI,WAAW,mBAAmB,CAAC,IAAI;AACpE,6BAAqB;AACrB,4BAAoB;AACpB,6BAAqB;AACrB,4BAAoB;AACpB,uBAAe;AACf,kBAAU;AAAA,MACZ;AAAA,IACF;AACA;AAAA,EACF;AACA,MAAI;AACF,qBAAiB,KAAK;AACxB,8BAA4B,KAAK;AACjC,YAAU;AACV,SAAO,UAAU,MAAM,QAAQ;AAC7B,QAAI,MAAM,UAAU,CAAC,EAAE,CAAC,MAAM,eAAe,MAAM,OAAO,EAAE,CAAC,MAAM,aAAa;AAC9E,YAAM,WAAW,MAAM,UAAU,CAAC,EAAE,CAAC;AACrC,YAAM,YAAY,MAAM,OAAO,EAAE,CAAC;AAClC,YAAM,kBAAkB,kBAAkB,UAAU,SAAS;AAC7D,YAAM,kBAAkB,kBAAkB,WAAW,QAAQ;AAC7D,UAAI,mBAAmB,iBAAiB;AACtC,YAAI,mBAAmB,SAAS,SAAS,KAAK,mBAAmB,UAAU,SAAS,GAAG;AACrF,gBAAM,OAAO,SAAS,GAAG,WAAW,YAAY,UAAU,UAAU,GAAG,eAAe,CAAC,CAAC;AACxF,gBAAM,UAAU,CAAC,EAAE,CAAC,IAAI,SAAS,UAAU,GAAG,SAAS,SAAS,eAAe;AAC/E,gBAAM,UAAU,CAAC,EAAE,CAAC,IAAI,UAAU,UAAU,eAAe;AAC3D;AAAA,QACF;AAAA,MACF,OAAO;AACL,YAAI,mBAAmB,SAAS,SAAS,KAAK,mBAAmB,UAAU,SAAS,GAAG;AACrF,gBAAM,OAAO,SAAS,GAAG,WAAW,YAAY,SAAS,UAAU,GAAG,eAAe,CAAC,CAAC;AACvF,gBAAM,UAAU,CAAC,EAAE,CAAC,IAAI;AACxB,gBAAM,UAAU,CAAC,EAAE,CAAC,IAAI,UAAU,UAAU,GAAG,UAAU,SAAS,eAAe;AACjF,gBAAM,UAAU,CAAC,EAAE,CAAC,IAAI;AACxB,gBAAM,UAAU,CAAC,EAAE,CAAC,IAAI,SAAS,UAAU,eAAe;AAC1D;AAAA,QACF;AAAA,MACF;AACA;AAAA,IACF;AACA;AAAA,EACF;AACF;AACA,IAAM,wBAAwB;AAC9B,IAAM,mBAAmB;AACzB,IAAM,kBAAkB;AACxB,IAAM,qBAAqB;AAC3B,IAAM,uBAAuB;AAC7B,SAAS,4BAA4B,OAAO;AAC1C,WAAS,yBAAyB,KAAK,KAAK;AAC1C,QAAI,CAAC,OAAO,CAAC,KAAK;AAChB,aAAO;AAAA,IACT;AACA,UAAM,QAAQ,IAAI,OAAO,IAAI,SAAS,CAAC;AACvC,UAAM,QAAQ,IAAI,OAAO,CAAC;AAC1B,UAAM,mBAAmB,MAAM,MAAM,qBAAqB;AAC1D,UAAM,mBAAmB,MAAM,MAAM,qBAAqB;AAC1D,UAAM,cAAc,oBAAoB,MAAM,MAAM,gBAAgB;AACpE,UAAM,cAAc,oBAAoB,MAAM,MAAM,gBAAgB;AACpE,UAAM,aAAa,eAAe,MAAM,MAAM,eAAe;AAC7D,UAAM,aAAa,eAAe,MAAM,MAAM,eAAe;AAC7D,UAAM,aAAa,cAAc,IAAI,MAAM,kBAAkB;AAC7D,UAAM,aAAa,cAAc,IAAI,MAAM,oBAAoB;AAC/D,QAAI,cAAc,YAAY;AAC5B,aAAO;AAAA,IACT,WAAW,cAAc,YAAY;AACnC,aAAO;AAAA,IACT,WAAW,oBAAoB,CAAC,eAAe,aAAa;AAC1D,aAAO;AAAA,IACT,WAAW,eAAe,aAAa;AACrC,aAAO;AAAA,IACT,WAAW,oBAAoB,kBAAkB;AAC/C,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AACA,MAAI,UAAU;AACd,SAAO,UAAU,MAAM,SAAS,GAAG;AACjC,QAAI,MAAM,UAAU,CAAC,EAAE,CAAC,MAAM,cAAc,MAAM,UAAU,CAAC,EAAE,CAAC,MAAM,YAAY;AAChF,UAAI,YAAY,MAAM,UAAU,CAAC,EAAE,CAAC;AACpC,UAAI,OAAO,MAAM,OAAO,EAAE,CAAC;AAC3B,UAAI,YAAY,MAAM,UAAU,CAAC,EAAE,CAAC;AACpC,YAAM,eAAe,iBAAiB,WAAW,IAAI;AACrD,UAAI,cAAc;AAChB,cAAM,eAAe,KAAK,UAAU,KAAK,SAAS,YAAY;AAC9D,oBAAY,UAAU,UAAU,GAAG,UAAU,SAAS,YAAY;AAClE,eAAO,eAAe,KAAK,UAAU,GAAG,KAAK,SAAS,YAAY;AAClE,oBAAY,eAAe;AAAA,MAC7B;AACA,UAAI,gBAAgB;AACpB,UAAI,WAAW;AACf,UAAI,gBAAgB;AACpB,UAAI,YAAY,yBAAyB,WAAW,IAAI,IAAI,yBAAyB,MAAM,SAAS;AACpG,aAAO,KAAK,OAAO,CAAC,MAAM,UAAU,OAAO,CAAC,GAAG;AAC7C,qBAAa,KAAK,OAAO,CAAC;AAC1B,eAAO,KAAK,UAAU,CAAC,IAAI,UAAU,OAAO,CAAC;AAC7C,oBAAY,UAAU,UAAU,CAAC;AACjC,cAAM,QAAQ,yBAAyB,WAAW,IAAI,IAAI,yBAAyB,MAAM,SAAS;AAClG,YAAI,SAAS,WAAW;AACtB,sBAAY;AACZ,0BAAgB;AAChB,qBAAW;AACX,0BAAgB;AAAA,QAClB;AAAA,MACF;AACA,UAAI,MAAM,UAAU,CAAC,EAAE,CAAC,MAAM,eAAe;AAC3C,YAAI,eAAe;AACjB,gBAAM,UAAU,CAAC,EAAE,CAAC,IAAI;AAAA,QAC1B,OAAO;AACL,gBAAM,OAAO,UAAU,GAAG,CAAC;AAC3B;AAAA,QACF;AACA,cAAM,OAAO,EAAE,CAAC,IAAI;AACpB,YAAI,eAAe;AACjB,gBAAM,UAAU,CAAC,EAAE,CAAC,IAAI;AAAA,QAC1B,OAAO;AACL,gBAAM,OAAO,UAAU,GAAG,CAAC;AAC3B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA;AAAA,EACF;AACF;AAuDA,SAAS,iBAAiB,OAAO;AAC/B,QAAM,KAAK,WAAW,YAAY,EAAE,CAAC;AACrC,MAAI,UAAU;AACd,MAAI,eAAe;AACnB,MAAI,eAAe;AACnB,MAAI,cAAc;AAClB,MAAI,cAAc;AAClB,MAAI;AACJ,SAAO,UAAU,MAAM,QAAQ;AAC7B,YAAQ,MAAM,OAAO,EAAE,CAAC,GAAG;AAAA,MACzB,KAAK;AACH;AACA,uBAAe,MAAM,OAAO,EAAE,CAAC;AAC/B;AACA;AAAA,MACF,KAAK;AACH;AACA,uBAAe,MAAM,OAAO,EAAE,CAAC;AAC/B;AACA;AAAA,MACF,KAAK;AACH,YAAI,eAAe,eAAe,GAAG;AACnC,cAAI,iBAAiB,KAAK,iBAAiB,GAAG;AAC5C,2BAAe,iBAAiB,aAAa,WAAW;AACxD,gBAAI,iBAAiB,GAAG;AACtB,kBAAI,UAAU,eAAe,eAAe,KAAK,MAAM,UAAU,eAAe,eAAe,CAAC,EAAE,CAAC,MAAM,YAAY;AACnH,sBAAM,UAAU,eAAe,eAAe,CAAC,EAAE,CAAC,KAAK,YAAY,UAAU,GAAG,YAAY;AAAA,cAC9F,OAAO;AACL,sBAAM,OAAO,GAAG,GAAG,WAAW,YAAY,YAAY,UAAU,GAAG,YAAY,CAAC,CAAC;AACjF;AAAA,cACF;AACA,4BAAc,YAAY,UAAU,YAAY;AAChD,4BAAc,YAAY,UAAU,YAAY;AAAA,YAClD;AACA,2BAAe,iBAAiB,aAAa,WAAW;AACxD,gBAAI,iBAAiB,GAAG;AACtB,oBAAM,OAAO,EAAE,CAAC,IAAI,YAAY,UAAU,YAAY,SAAS,YAAY,IAAI,MAAM,OAAO,EAAE,CAAC;AAC/F,4BAAc,YAAY,UAAU,GAAG,YAAY,SAAS,YAAY;AACxE,4BAAc,YAAY,UAAU,GAAG,YAAY,SAAS,YAAY;AAAA,YAC1E;AAAA,UACF;AACA,qBAAW,eAAe;AAC1B,gBAAM,OAAO,SAAS,eAAe,YAAY;AACjD,cAAI,YAAY,QAAQ;AACtB,kBAAM,OAAO,SAAS,GAAG,WAAW,aAAa,WAAW,CAAC;AAC7D;AAAA,UACF;AACA,cAAI,YAAY,QAAQ;AACtB,kBAAM,OAAO,SAAS,GAAG,WAAW,aAAa,WAAW,CAAC;AAC7D;AAAA,UACF;AACA;AAAA,QACF,WAAW,YAAY,KAAK,MAAM,UAAU,CAAC,EAAE,CAAC,MAAM,YAAY;AAChE,gBAAM,UAAU,CAAC,EAAE,CAAC,KAAK,MAAM,OAAO,EAAE,CAAC;AACzC,gBAAM,OAAO,SAAS,CAAC;AAAA,QACzB,OAAO;AACL;AAAA,QACF;AACA,uBAAe;AACf,uBAAe;AACf,sBAAc;AACd,sBAAc;AACd;AAAA,IACJ;AAAA,EACF;AACA,MAAI,MAAM,MAAM,SAAS,CAAC,EAAE,CAAC,MAAM;AACjC,UAAM,IAAI;AACZ,MAAI,UAAU;AACd,YAAU;AACV,SAAO,UAAU,MAAM,SAAS,GAAG;AACjC,QAAI,MAAM,UAAU,CAAC,EAAE,CAAC,MAAM,cAAc,MAAM,UAAU,CAAC,EAAE,CAAC,MAAM,YAAY;AAChF,UAAI,MAAM,OAAO,EAAE,CAAC,EAAE,UAAU,MAAM,OAAO,EAAE,CAAC,EAAE,SAAS,MAAM,UAAU,CAAC,EAAE,CAAC,EAAE,MAAM,MAAM,MAAM,UAAU,CAAC,EAAE,CAAC,GAAG;AAClH,cAAM,OAAO,EAAE,CAAC,IAAI,MAAM,UAAU,CAAC,EAAE,CAAC,IAAI,MAAM,OAAO,EAAE,CAAC,EAAE,UAAU,GAAG,MAAM,OAAO,EAAE,CAAC,EAAE,SAAS,MAAM,UAAU,CAAC,EAAE,CAAC,EAAE,MAAM;AAClI,cAAM,UAAU,CAAC,EAAE,CAAC,IAAI,MAAM,UAAU,CAAC,EAAE,CAAC,IAAI,MAAM,UAAU,CAAC,EAAE,CAAC;AACpE,cAAM,OAAO,UAAU,GAAG,CAAC;AAC3B,kBAAU;AAAA,MACZ,WAAW,MAAM,OAAO,EAAE,CAAC,EAAE,UAAU,GAAG,MAAM,UAAU,CAAC,EAAE,CAAC,EAAE,MAAM,MAAM,MAAM,UAAU,CAAC,EAAE,CAAC,GAAG;AACjG,cAAM,UAAU,CAAC,EAAE,CAAC,KAAK,MAAM,UAAU,CAAC,EAAE,CAAC;AAC7C,cAAM,OAAO,EAAE,CAAC,IAAI,MAAM,OAAO,EAAE,CAAC,EAAE,UAAU,MAAM,UAAU,CAAC,EAAE,CAAC,EAAE,MAAM,IAAI,MAAM,UAAU,CAAC,EAAE,CAAC;AACpG,cAAM,OAAO,UAAU,GAAG,CAAC;AAC3B,kBAAU;AAAA,MACZ;AAAA,IACF;AACA;AAAA,EACF;AACA,MAAI;AACF,qBAAiB,KAAK;AAC1B;;;AC5qBA,IAAM,WAAW,OAAO,OAAO;AAAA,EAC7B,eAAe;AAAA,EACf,aAAa;AAAA,EACb,sBAAsB;AAAA,EACtB,2BAA2B;AAAA,EAC3B,kBAAkB;AAAA,EAClB,iBAAiB;AAAA,EACjB,eAAe;AAAA,EACf,aAAa;AAAA,EACb,eAAe;AAAA,EACf,UAAU;AACZ,CAAC;AACD,SAAS,WAAW,QAAQ,SAAS;AACnC,MAAI,SAAS;AACX,cAAU,EAAE,GAAG,UAAU,GAAG,QAAQ;AAAA,EACtC,OAAO;AACL,cAAU;AAAA,EACZ;AACA,QAAM,SAAS,aAAa,OAAO;AACnC,SAAO,SAAS,MAAM;AACtB,SAAO,OAAO,SAAS;AACzB;AACA,IAAM,wBAAwB,OAAO,OAAO;AAAA,EAC1C;AAAA,EACA;AAAA,EACA;AACF,CAAC;AACD,SAAS,aAAa,SAAS;AAC7B,MAAI,OAAO;AACX,MAAI,UAA0B,oBAAI,IAAI;AACtC,QAAM,QAAQ,CAAC,QAAQ;AACrB,YAAQ;AAAA,EACV;AACA,SAAO;AAAA,IACL,WAAW;AACT,aAAO;AAAA,IACT;AAAA,IACA,aAAa;AACX,aAAO;AAAA,IACT;AAAA,IACA,SAAS,OAAO;AACd,UAAI,QAAQ,UAAU;AACpB,gBAAQ,QAAQ,SAAS,KAAK;AAAA,MAChC;AACA,YAAM,OAAO,UAAU,OAAO,SAAS,OAAO;AAC9C,aAAO,KAAK,IAAI,EAAE,KAAK;AAAA,IACzB;AAAA,IACA,OAAO,QAAQ;AACb,UAAI,UAAU,OAAO,OAAO,WAAW,YAAY;AACjD,eAAO,KAAK,OAAO,OAAO,OAAO,CAAC;AAAA,MACpC;AACA,YAAM,YAAY,OAAO,UAAU,SAAS,KAAK,MAAM;AACvD,UAAI,UAAU;AACd,YAAM,eAAe,UAAU;AAC/B,UAAI,eAAe,IAAI;AACrB,kBAAU,cAAc,YAAY;AAAA,MACtC,OAAO;AACL,kBAAU,UAAU,MAAM,GAAG,eAAe,CAAC;AAAA,MAC/C;AACA,gBAAU,QAAQ,YAAY;AAC9B,UAAI,eAAe;AACnB,WAAK,eAAe,QAAQ,IAAI,MAAM,OAAO,QAAQ;AACnD,gBAAQ,IAAI,QAAQ,QAAQ,IAAI;AAAA,MAClC,OAAO;AACL,eAAO,KAAK,SAAS,eAAe,eAAe,GAAG;AAAA,MACxD;AACA,UAAI,OAAO,WAAW,eAAe,OAAO,YAAY,OAAO,SAAS,MAAM,GAAG;AAC/E,cAAM,SAAS;AACf,eAAO,MAAM,OAAO,SAAS,MAAM,CAAC;AAAA,MACtC;AACA,UAAI,YAAY,YAAY,YAAY,cAAc,YAAY,iBAAiB;AACjF,YAAI,KAAK,OAAO,GAAG;AACjB,eAAK,OAAO,EAAE,MAAM;AAAA,QACtB,WAAW,CAAC,QAAQ,eAAe;AACjC,eAAK,OAAO,QAAQ,OAAO;AAAA,QAC7B;AAAA,MACF,OAAO;AACL,YAAI,OAAO,OAAO,KAAK,MAAM;AAC7B,YAAI,QAAQ,kBAAkB;AAC5B,iBAAO,KAAK,KAAK;AAAA,QACnB;AACA,YAAI,YAAY,CAAC;AACjB,YAAI,QAAQ,gBAAgB,SAAS,CAAC,iBAAiB,MAAM,GAAG;AAC9D,sBAAY;AAAA,QACd;AACA,YAAI,QAAQ,aAAa;AACvB,iBAAO,KAAK,OAAO,CAAC,QAAQ;AAC1B,mBAAO,CAAC,QAAQ,YAAY,GAAG;AAAA,UACjC,CAAC;AACD,sBAAY,UAAU,OAAO,CAAC,QAAQ;AACpC,mBAAO,CAAC,QAAQ,YAAY,GAAG;AAAA,UACjC,CAAC;AAAA,QACH;AACA,cAAM,aAAa,KAAK,SAAS,UAAU,UAAU,GAAG;AACxD,cAAM,iBAAiB,CAAC,QAAQ;AAC9B,eAAK,SAAS,GAAG;AACjB,gBAAM,GAAG;AACT,cAAI,CAAC,QAAQ,eAAe;AAC1B,iBAAK,SAAS,OAAO,GAAG,CAAC;AAAA,UAC3B;AACA,gBAAM,GAAG;AAAA,QACX;AACA,mBAAW,OAAO,MAAM;AACtB,yBAAe,GAAG;AAAA,QACpB;AACA,mBAAW,OAAO,WAAW;AAC3B,yBAAe,GAAG;AAAA,QACpB;AAAA,MACF;AAAA,IACF;AAAA,IACA,MAAM,KAAK,WAAW;AACpB,kBAAY,cAAc,SAAS,QAAQ,oBAAoB,QAAQ;AACvE,YAAM,WAAW,IAAI,SAAS,GAAG;AACjC,UAAI,CAAC,aAAa,IAAI,UAAU,GAAG;AACjC,mBAAW,SAAS,KAAK;AACvB,eAAK,SAAS,KAAK;AAAA,QACrB;AACA;AAAA,MACF;AACA,YAAM,mBAAmC,oBAAI,IAAI;AACjD,YAAM,UAAU,IAAI,IAAI,CAAC,UAAU;AACjC,cAAM,SAAS,aAAa,OAAO;AACnC,eAAO,SAAS,KAAK;AACrB,mBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,WAAW,GAAG;AAC9C,2BAAiB,IAAI,KAAK,KAAK;AAAA,QACjC;AACA,eAAO,OAAO,SAAS;AAAA,MACzB,CAAC;AACD,gBAAU;AACV,cAAQ,KAAK;AACb,aAAO,KAAK,MAAM,SAAS,KAAK;AAAA,IAClC;AAAA,IACA,KAAK,MAAM;AACT,aAAO,MAAM,UAAU,KAAK,OAAO,CAAC;AAAA,IACtC;AAAA,IACA,OAAO,KAAK;AACV,aAAO,MAAM,YAAY,IAAI,SAAS,CAAC;AAAA,IACzC;AAAA,IACA,OAAO,OAAO,MAAM;AAClB,YAAM,IAAI;AACV,UAAI,CAAC,OAAO;AACV;AAAA,MACF;AACA,YAAM,GAAG;AACT,UAAI,SAAS,OAAO,MAAM,YAAY,YAAY;AAChD,eAAO,KAAK;AAAA,UACV,MAAM,KAAK,MAAM,QAAQ,CAAC;AAAA,UAC1B;AAAA;AAAA,QAEF;AAAA,MACF;AAAA,IACF;AAAA,IACA,MAAM,KAAK;AACT,aAAO,MAAM,WAAW,IAAI,SAAS,CAAC;AAAA,IACxC;AAAA,IACA,QAAQ,MAAM;AACZ,aAAO,MAAM,UAAU,IAAI;AAAA,IAC7B;AAAA,IACA,OAAO,QAAQ;AACb,YAAM,YAAY,OAAO,SAAS,GAAG;AACrC,YAAM,MAAM;AAAA,IACd;AAAA,IACA,SAAS,IAAI;AACX,YAAM,KAAK;AACX,UAAI,iBAAiB,EAAE,GAAG;AACxB,aAAK,SAAS,UAAU;AAAA,MAC1B,OAAO;AACL,aAAK,SAAS,GAAG,SAAS,CAAC;AAAA,MAC7B;AACA,UAAI,QAAQ,yBAAyB,OAAO;AAC1C,aAAK,SAAS,mBAAmB,OAAO,GAAG,IAAI,CAAC;AAAA,MAClD;AACA,UAAI,QAAQ,2BAA2B;AACrC,aAAK,OAAO,EAAE;AAAA,MAChB;AAAA,IACF;AAAA,IACA,OAAO,QAAQ;AACb,aAAO,MAAM,YAAY,MAAM;AAAA,IACjC;AAAA,IACA,IAAI,KAAK;AACP,aAAO,MAAM,SAAS,IAAI,SAAS,CAAC;AAAA,IACtC;AAAA,IACA,OAAO;AACL,aAAO,MAAM,MAAM;AAAA,IACrB;AAAA,IACA,YAAY;AACV,aAAO,MAAM,WAAW;AAAA,IAC1B;AAAA,IACA,OAAO,OAAO;AACZ,aAAO,MAAM,WAAW,MAAM,SAAS,CAAC;AAAA,IAC1C;AAAA,IACA,WAAW,KAAK;AACd,YAAM,aAAa;AACnB,aAAO,KAAK,SAAS,MAAM,UAAU,MAAM,KAAK,GAAG,CAAC;AAAA,IACtD;AAAA,IACA,kBAAkB,KAAK;AACrB,YAAM,oBAAoB;AAC1B,aAAO,KAAK,SAAS,MAAM,UAAU,MAAM,KAAK,GAAG,CAAC;AAAA,IACtD;AAAA,IACA,UAAU,KAAK;AACb,YAAM,YAAY;AAClB,aAAO,KAAK,SAAS,MAAM,UAAU,MAAM,KAAK,GAAG,CAAC;AAAA,IACtD;AAAA,IACA,YAAY,KAAK;AACf,YAAM,cAAc;AACpB,aAAO,KAAK,SAAS,MAAM,UAAU,MAAM,KAAK,GAAG,CAAC;AAAA,IACtD;AAAA,IACA,WAAW,KAAK;AACd,YAAM,aAAa;AACnB,aAAO,KAAK,SAAS,MAAM,UAAU,MAAM,KAAK,GAAG,CAAC;AAAA,IACtD;AAAA,IACA,YAAY,KAAK;AACf,YAAM,cAAc;AACpB,aAAO,KAAK,SAAS,MAAM,UAAU,MAAM,KAAK,GAAG,CAAC;AAAA,IACtD;AAAA,IACA,WAAW,KAAK;AACd,YAAM,aAAa;AACnB,aAAO,KAAK,SAAS,MAAM,UAAU,MAAM,KAAK,GAAG,CAAC;AAAA,IACtD;AAAA,IACA,aAAa,KAAK;AAChB,YAAM,eAAe;AACrB,aAAO,KAAK,SAAS,MAAM,UAAU,MAAM,KAAK,GAAG,CAAC;AAAA,IACtD;AAAA,IACA,aAAa,KAAK;AAChB,YAAM,eAAe;AACrB,aAAO,KAAK,SAAS,MAAM,UAAU,MAAM,KAAK,GAAG,CAAC;AAAA,IACtD;AAAA,IACA,YAAY,KAAK;AACf,YAAM,cAAc;AACpB,aAAO,KAAK,SAAS,IAAI,WAAW,GAAG,CAAC;AAAA,IAC1C;AAAA,IACA,IAAI,KAAK;AACP,aAAO,MAAM,SAAS,IAAI,SAAS,CAAC;AAAA,IACtC;AAAA,IACA,IAAI,KAAK;AACP,YAAM,MAAM;AACZ,YAAM,MAAM,CAAC,GAAG,GAAG;AACnB,aAAO,KAAK,MAAM,KAAK,QAAQ,kBAAkB,KAAK;AAAA,IACxD;AAAA,IACA,IAAI,KAAK;AACP,YAAM,MAAM;AACZ,YAAM,MAAM,CAAC,GAAG,GAAG;AACnB,aAAO,KAAK,MAAM,KAAK,QAAQ,kBAAkB,KAAK;AAAA,IACxD;AAAA,IACA,KAAK,MAAM;AACT,YAAM,OAAO;AACb,aAAO,KAAK,SAAS,CAAC,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,WAAW,CAAC;AAAA,IAC1E;AAAA,IACA,OAAO;AACL,UAAI,QAAQ,eAAe;AACzB,eAAO,MAAM,QAAQ;AAAA,MACvB;AACA,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,IACA,YAAY;AACV,aAAO,MAAM,WAAW;AAAA,IAC1B;AAAA,IACA,OAAO,QAAQ;AACb,aAAO,MAAM,YAAY,OAAO,SAAS,CAAC;AAAA,IAC5C;AAAA;AAAA,IAEA,UAAU;AACR,aAAO,MAAM,SAAS;AAAA,IACxB;AAAA,IACA,QAAQ;AACN,aAAO,MAAM,OAAO;AAAA,IACtB;AAAA,IACA,OAAO;AACL,aAAO,MAAM,MAAM;AAAA,IACrB;AAAA,IACA,MAAM;AACJ,aAAO,MAAM,KAAK;AAAA,IACpB;AAAA,IACA,MAAM;AACJ,aAAO,MAAM,KAAK;AAAA,IACpB;AAAA,IACA,MAAM;AACJ,aAAO,MAAM,KAAK;AAAA,IACpB;AAAA,IACA,cAAc;AACZ,aAAO,MAAM,aAAa;AAAA,IAC5B;AAAA,IACA,gBAAgB;AACd,aAAO,MAAM,eAAe;AAAA,IAC9B;AAAA,IACA,aAAa;AACX,aAAO,MAAM,YAAY;AAAA,IAC3B;AAAA,IACA,OAAO;AACL,aAAO,MAAM,MAAM;AAAA,IACrB;AAAA,IACA,UAAU;AACR,aAAO,MAAM,SAAS;AAAA,IACxB;AAAA,IACA,aAAa;AACX,aAAO,MAAM,YAAY;AAAA,IAC3B;AAAA,IACA,aAAa;AACX,aAAO,MAAM,YAAY;AAAA,IAC3B;AAAA,IACA,WAAW;AACT,aAAO,MAAM,UAAU;AAAA,IACzB;AAAA,IACA,SAAS;AACP,aAAO,MAAM,QAAQ;AAAA,IACvB;AAAA,IACA,UAAU;AACR,aAAO,MAAM,SAAS;AAAA,IACxB;AAAA,IACA,UAAU;AACR,aAAO,MAAM,SAAS;AAAA,IACxB;AAAA,EACF;AACF;AACA,IAAM,aAAa;AACnB,IAAM,mBAAmB,WAAW;AACpC,SAAS,iBAAiB,GAAG;AAC3B,MAAI,OAAO,MAAM,YAAY;AAC3B,WAAO;AAAA,EACT;AACA,SAAO,SAAS,UAAU,SAAS,KAAK,CAAC,EAAE,MAAM,CAAC,gBAAgB,MAAM;AAC1E;AAEA,IAAM,YAAN,MAAM,WAAU;AAAA,EACd,YAAY,OAAO,UAAU;AAC3B,YAAQ,KAAK,QAAQ,SAAS,CAAC;AAC/B,SAAK,WAAW,aAAa,SAAS,MAAM,SAAS,IAAI;AAAA,EAC3D;AAAA,EACA,SAAS,SAAS;AAChB,YAAQ,WAAW,KAAK,UAAU,IAAI;AAAA,EACxC;AAAA,EACA,OAAO,WAAW;AAChB,SAAK,MAAM;AACX,QAAI,KAAK,WAAW,GAAG;AACrB,eAAS,IAAI,GAAG,IAAI,UAAU,UAAU,KAAK;AAC3C,cAAM,WAAW,UAAU,MAAM,MAAM,CAAC,MAAM,KAAK,IAAI,IAAI,IAAI;AAC/D,aAAK,MAAM,KAAK,WAAW,MAAM,CAAC,KAAK,YAAY,MAAM,KAAK,WAAW,KAAK,IAAI;AAAA,MACpF;AAAA,IACF,OAAO;AACL,eAAS,IAAI,GAAG,IAAI,UAAU,UAAU,KAAK,GAAG;AAC9C,aAAK,MAAM,KAAK,WAAW,MAAM,CAAC,IAAI,UAAU,MAAM,MAAM,CAAC;AAAA,MAC/D;AAAA,IACF;AACA,SAAK,YAAY,UAAU;AAC3B,WAAO;AAAA,EACT;AAAA,EACA,QAAQ;AACN,SAAK,MAAM,KAAK,aAAa,CAAC,KAAK,cAAc,KAAK,KAAK,WAAW,IAAI;AAC1E,SAAK,MAAM,SAAS,KAAK,KAAK,KAAK,WAAW,CAAC;AAAA,EACjD;AAAA,EACA,QAAQ;AACN,WAAO,IAAI,WAAU,CAAC,GAAG,KAAK,KAAK,CAAC;AAAA,EACtC;AACF;AACA,IAAM,MAAM;AAAA,EACV,UAAU,WAAW;AACnB,UAAM,WAAW,CAAC;AAClB,aAAS,IAAI,GAAG,IAAI,UAAU,UAAU,KAAK;AAC3C,YAAM,OAAO,UAAU,MAAM,MAAM,CAAC,MAAM,KAAK,IAAI,IAAI,IAAI;AAC3D,eAAS,MAAM,SAAS,GAAG,SAAS,EAAE,IAAI,OAAO,IAAI,SAAS,EAAE,CAAC;AAAA,IACnE;AACA,WAAO,SAAS,KAAK,EAAE;AAAA,EACzB;AACF;AACA,IAAM,SAAS;AAAA,EACb,UAAU,WAAW;AACnB,UAAM,SAAS;AACf,UAAM,cAAc,CAAC;AACrB,aAAS,IAAI,GAAG,IAAI,UAAU,UAAU,KAAK,GAAG;AAC9C,YAAM,QAAQ,UAAU,MAAM,MAAM,CAAC,MAAM,KAAK,IAAI,IAAI,IAAI;AAC5D,YAAM,QAAQ,UAAU,MAAM,IAAI,MAAM,CAAC,MAAM,MAAM,IAAI,KAAK,IAAI,IAAI;AACtE,YAAM,QAAQ,UAAU,MAAM,IAAI,MAAM,CAAC,MAAM,MAAM,IAAI,KAAK,IAAI,IAAI;AACtE,YAAM,UAAU,SAAS,KAAK,SAAS,IAAI;AAC3C,eAAS,IAAI,GAAG,IAAI,KAAK,IAAI,IAAI,IAAI,IAAI,UAAU,WAAW,GAAG,KAAK;AACpE,oBAAY,KAAK,OAAO,OAAO,YAAY,KAAK,IAAI,KAAK,EAAE,CAAC;AAAA,MAC9D;AAAA,IACF;AACA,WAAO,YAAY,KAAK,EAAE;AAAA,EAC5B;AACF;AACA,IAAM,SAAS;AAAA,EACb,MAAM,WAAW;AACf,UAAM,kBAAkB,UAAU;AAClC,UAAM,QAAQ,CAAC;AACf,aAAS,IAAI,GAAG,IAAI,iBAAiB,KAAK;AACxC,YAAM,MAAM,CAAC,MAAM,UAAU,WAAW,CAAC,IAAI,QAAQ,KAAK,IAAI,IAAI;AAAA,IACpE;AACA,WAAO,IAAI,UAAU,OAAO,eAAe;AAAA,EAC7C;AACF;AACA,IAAM,OAAO;AAAA,EACX,MAAM,SAAS;AACb,WAAO,OAAO,MAAM,SAAS,mBAAmB,OAAO,CAAC,CAAC;AAAA,EAC3D;AACF;AACA,IAAM,yBAAN,MAA6B;AAAA,EAC3B,cAAc;AACZ,SAAK,QAAQ,IAAI,UAAU;AAC3B,SAAK,cAAc;AACnB,SAAK,iBAAiB;AACtB,SAAK,YAAY,MAAM;AAAA,EACzB;AAAA,EACA,QAAQ;AACN,SAAK,QAAQ,IAAI,UAAU;AAC3B,SAAK,cAAc;AAAA,EACrB;AAAA,EACA,QAAQ,MAAM;AACZ,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,KAAK,MAAM,IAAI;AAAA,IACxB;AACA,SAAK,MAAM,OAAO,IAAI;AACtB,SAAK,eAAe,KAAK;AAAA,EAC3B;AAAA;AAAA,EAEA,gBAAgB,YAAY,SAAS;AAAA,EACrC;AAAA,EACA,SAAS,SAAS;AAChB,QAAI;AACJ,QAAI,eAAe,KAAK,MAAM,YAAY,KAAK,YAAY;AAC3D,QAAI,SAAS;AACX,qBAAe,KAAK,KAAK,YAAY;AAAA,IACvC,OAAO;AACL,qBAAe,KAAK,KAAK,eAAe,KAAK,KAAK,gBAAgB,CAAC;AAAA,IACrE;AACA,UAAM,cAAc,eAAe,KAAK;AACxC,UAAM,cAAc,KAAK,IAAI,cAAc,GAAG,KAAK,MAAM,QAAQ;AACjE,QAAI,aAAa;AACf,eAAS,SAAS,GAAG,SAAS,aAAa,UAAU,KAAK,WAAW;AACnE,aAAK,gBAAgB,KAAK,MAAM,OAAO,MAAM;AAAA,MAC/C;AACA,uBAAiB,KAAK,MAAM,MAAM,OAAO,GAAG,WAAW;AACvD,WAAK,MAAM,YAAY;AAAA,IACzB;AACA,WAAO,IAAI,UAAU,gBAAgB,WAAW;AAAA,EAClD;AACF;AACA,IAAM,SAAN,cAAqB,uBAAuB;AAAA,EAC1C,OAAO,eAAe;AACpB,SAAK,QAAQ,aAAa;AAC1B,SAAK,SAAS;AACd,WAAO;AAAA,EACT;AAAA,EACA,SAAS,eAAe;AACtB,QAAI,eAAe;AACjB,WAAK,QAAQ,aAAa;AAAA,IAC5B;AAAA,EACF;AACF;AAEA,IAAM,IAAI;AAAA,EACR;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AACA,IAAM,IAAI;AAAA,EACR;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AACA,IAAM,IAAI,CAAC;AACX,IAAM,SAAN,cAAqB,OAAO;AAAA,EAC1B,cAAc;AACZ,UAAM,GAAG,SAAS;AAClB,SAAK,QAAQ,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC;AAAA,EACnC;AAAA,EACA,QAAQ;AACN,UAAM,MAAM;AACZ,SAAK,QAAQ,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC;AAAA,EACnC;AAAA,EACA,gBAAgB,GAAG,QAAQ;AACzB,UAAM,KAAK,KAAK,MAAM;AACtB,QAAI,IAAI,GAAG,CAAC;AACZ,QAAI,IAAI,GAAG,CAAC;AACZ,QAAI,IAAI,GAAG,CAAC;AACZ,QAAI,IAAI,GAAG,CAAC;AACZ,QAAI,IAAI,GAAG,CAAC;AACZ,QAAI,IAAI,GAAG,CAAC;AACZ,QAAI,IAAI,GAAG,CAAC;AACZ,QAAIA,KAAI,GAAG,CAAC;AACZ,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,UAAI,IAAI,IAAI;AACV,UAAE,CAAC,IAAI,EAAE,SAAS,CAAC,IAAI;AAAA,MACzB,OAAO;AACL,cAAM,UAAU,EAAE,IAAI,EAAE;AACxB,cAAM,UAAU,WAAW,KAAK,YAAY,MAAM,WAAW,KAAK,YAAY,MAAM,YAAY;AAChG,cAAM,UAAU,EAAE,IAAI,CAAC;AACvB,cAAM,UAAU,WAAW,KAAK,YAAY,OAAO,WAAW,KAAK,YAAY,MAAM,YAAY;AACjG,UAAE,CAAC,IAAI,SAAS,EAAE,IAAI,CAAC,IAAI,SAAS,EAAE,IAAI,EAAE;AAAA,MAC9C;AACA,YAAM,KAAK,IAAI,IAAI,CAAC,IAAI;AACxB,YAAM,MAAM,IAAI,IAAI,IAAI,IAAI,IAAI;AAChC,YAAM,UAAU,KAAK,KAAK,MAAM,MAAM,KAAK,KAAK,MAAM,OAAO,KAAK,KAAK,MAAM;AAC7E,YAAM,UAAU,KAAK,KAAK,MAAM,MAAM,KAAK,KAAK,MAAM,OAAO,KAAK,IAAI,MAAM;AAC5E,YAAM,KAAKA,KAAI,SAAS,KAAK,EAAE,CAAC,IAAI,EAAE,CAAC;AACvC,YAAM,KAAK,SAAS;AACpB,MAAAA,KAAI;AACJ,UAAI;AACJ,UAAI;AACJ,UAAI,IAAI,KAAK;AACb,UAAI;AACJ,UAAI;AACJ,UAAI;AACJ,UAAI,KAAK,KAAK;AAAA,IAChB;AACA,OAAG,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI;AACpB,OAAG,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI;AACpB,OAAG,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI;AACpB,OAAG,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI;AACpB,OAAG,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI;AACpB,OAAG,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI;AACpB,OAAG,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI;AACpB,OAAG,CAAC,IAAI,GAAG,CAAC,IAAIA,KAAI;AAAA,EACtB;AAAA,EACA,SAAS,eAAe;AACtB,UAAM,SAAS,aAAa;AAC5B,UAAM,aAAa,KAAK,cAAc;AACtC,UAAM,YAAY,KAAK,MAAM,WAAW;AACxC,SAAK,MAAM,MAAM,cAAc,CAAC,KAAK,OAAO,KAAK,YAAY;AAC7D,SAAK,MAAM,OAAO,YAAY,OAAO,KAAK,KAAK,EAAE,IAAI,KAAK;AAAA,MACxD,aAAa;AAAA,IACf;AACA,SAAK,MAAM,OAAO,YAAY,OAAO,KAAK,KAAK,EAAE,IAAI;AACrD,SAAK,MAAM,WAAW,KAAK,MAAM,MAAM,SAAS;AAChD,SAAK,SAAS;AACd,WAAO,KAAK;AAAA,EACd;AACF;AAIA,SAAS,aAAa,SAAS;AAC7B,SAAO,IAAI,OAAO,EAAE,SAAS,OAAO,EAAE,SAAS,MAAM;AACvD;AAEA,SAAS,KAAK,QAAQ,UAAU,CAAC,GAAG;AAClC,QAAM,SAAS,OAAO,WAAW,WAAW,SAAS,WAAW,QAAQ,OAAO;AAC/E,SAAO,aAAa,MAAM,EAAE,MAAM,GAAG,EAAE;AACzC;;;AC1lBA,SAAS,uBAAuB,oBAAoB,UAAU,CAAC,GAAG;AAChE,QAAM,QAAQ,cAAc,IAAI,CAAC,CAAC;AAClC,MAAI,WAAW;AACf,MAAI,UAAU;AACd,WAAS,OAAO,MAAM,WAAW,CAAC,GAAG;AACnC,eAAW;AACX,UAAM,YAAY,mBAAmB,IAAI;AACzC,KAAC,EAAE,MAAM,UAAU,IAAI,QAAQ,IAAI,cAAc,UAAU,WAAW;AAAA,MACpE,GAAG;AAAA,MACH,GAAG;AAAA,IACL,CAAC;AACD,WAAO;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACA,SAAO;AAAA,IACL,IAAI,UAAU;AACZ,aAAO;AAAA,IACT;AAAA,IACA,IAAI,WAAW;AACb,aAAO;AAAA,IACT;AAAA,IACA;AAAA,IACA,QAAQ;AACN,iBAAW;AACX,gBAAU;AAAA,IACZ;AAAA,EACF;AACF;AACA,SAAS,kBAAkB,aAAa,MAAM,SAAS;AACrD,QAAM,SAAS,YAAY,aAAa,MAAM,OAAO;AACrD,SAAO;AAAA,IACL,GAAG;AAAA,MACD;AAAA,MACA,OAAO;AAAA;AAAA,MAEP,KAAK,UAAU,CAAC,QAAQ,MAAM,YAAY,UAAU,QAAQ,SAAS,QAAQ,KAAK,CAAC;AAAA,IACrF;AAAA,IACA,IAAI,OAAO;AAAA,IACX,IAAI,OAAO;AAAA,IACX,WAAW,OAAO;AAAA,IAClB,WAAW,OAAO;AAAA,IAClB,MAAM,QAAQ;AAAA,EAChB;AACF;AACA,SAAS,cAAc,MAAM,QAAQ,OAAO,IAAI;AAC9C,QAAM,SAAS,KAAK,OAAO,IAAI;AAC/B,MAAI,aAAa;AACjB,QAAM,QAAQ,sBAAsB,MAAM,EAAE,QAAQ,CAAC,SAAS;AAC5D,UAAM,SAAS,KAAK,KAAK,SAAS,CAAC;AACnC,QAAI,CAAC;AACH,oBAAc;AAAA;AAEd,mBAAa,OAAO,SAAS,OAAO,QAAQ;AAC9C,WAAO;AAAA,MACL,GAAG;AAAA,MACH;AAAA,QACE,SAAS;AAAA,QACT,QAAQ;AAAA,MACV;AAAA,IACF;AAAA,EACF,CAAC,EAAE,IAAI,CAAC,OAAO,QAAQ;AACrB,UAAM,IAAI;AACV,MAAE,MAAM,GAAG,MAAM,IAAI,GAAG;AACxB,WAAO;AAAA,EACT,CAAC;AACD,SAAO;AAAA,IACL;AAAA,IACA,MAAM;AAAA,IACN,QAAQ;AAAA,EACV;AACF;AACA,SAAS,sBAAsB,QAAQ;AACrC,SAAO,OAAO,IAAI,CAAC,SAAS;AAC1B,WAAO,KAAK,QAAQ,CAAC,UAAU;AAC7B,UAAI,MAAM,QAAQ,MAAM,OAAO;AAC7B,eAAO;AACT,YAAM,QAAQ,MAAM,QAAQ,MAAM,mBAAmB;AACrD,UAAI,CAAC;AACH,eAAO;AACT,YAAM,CAAC,EAAE,SAAS,SAAS,QAAQ,IAAI;AACvC,UAAI,CAAC,WAAW,CAAC;AACf,eAAO;AACT,YAAM,WAAW,CAAC;AAAA,QAChB,GAAG;AAAA,QACH,QAAQ,MAAM,SAAS,QAAQ;AAAA,QAC/B;AAAA,MACF,CAAC;AACD,UAAI,SAAS;AACX,iBAAS,QAAQ;AAAA,UACf,SAAS;AAAA,UACT,QAAQ,MAAM;AAAA,QAChB,CAAC;AAAA,MACH;AACA,UAAI,UAAU;AACZ,iBAAS,KAAK;AAAA,UACZ,SAAS;AAAA,UACT,QAAQ,MAAM,SAAS,QAAQ,SAAS,QAAQ;AAAA,QAClD,CAAC;AAAA,MACH;AACA,aAAO;AAAA,IACT,CAAC;AAAA,EACH,CAAC;AACH;AACA,SAAS,WAAW,OAAO,SAAS;AAClC,MAAI,aAAa;AACjB,QAAM,MAAM,MAAM;AAClB,MAAI,QAAQ;AACZ,QAAM,SAAS,CAAC;AAChB,WAAS,SAAS;AAChB,QAAI,UAAU,GAAG;AACf;AACA,aAAO;AAAA,IACT;AACA,WAAO,GAAG,GAAG,IAAI,OAAO;AAAA,EAC1B;AACA,aAAW,UAAU,SAAS;AAC5B,QAAI,SAAS,YAAY;AACvB,aAAO,KAAK;AAAA,QACV,GAAG;AAAA,QACH,SAAS,MAAM,QAAQ,MAAM,YAAY,MAAM;AAAA,QAC/C,QAAQ,MAAM,SAAS;AAAA,QACvB,KAAK,OAAO;AAAA,MACd,CAAC;AAAA,IACH;AACA,iBAAa;AAAA,EACf;AACA,MAAI,aAAa,MAAM,QAAQ,QAAQ;AACrC,WAAO,KAAK;AAAA,MACV,GAAG;AAAA,MACH,SAAS,MAAM,QAAQ,MAAM,UAAU;AAAA,MACvC,QAAQ,MAAM,SAAS;AAAA,MACvB,KAAK,OAAO;AAAA,IACd,CAAC;AAAA,EACH;AACA,SAAO;AACT;AACA,SAAS,YAAY,QAAQ,aAAa;AACxC,QAAM,SAAS,MAAM,KAAK,uBAAuB,MAAM,cAAc,IAAI,IAAI,WAAW,CAAC,EAAE,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AAC/G,MAAI,CAAC,OAAO;AACV,WAAO;AACT,SAAO,OAAO,QAAQ,CAAC,UAAU;AAC/B,UAAM,qBAAqB,OAAO,OAAO,CAAC,MAAM,MAAM,SAAS,KAAK,IAAI,MAAM,SAAS,MAAM,QAAQ,MAAM,EAAE,IAAI,CAAC,MAAM,IAAI,MAAM,MAAM,EAAE,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AAC9J,QAAI,CAAC,mBAAmB;AACtB,aAAO;AACT,WAAO,WAAW,OAAO,kBAAkB;AAAA,EAC7C,CAAC;AACH;AACA,SAAS,cAAc,MAAM,IAAI,UAAU,CAAC,GAAG;AAC7C,QAAM;AAAA,IACJ,aAAa,oBAAoB;AAAA,IACjC,kBAAkB;AAAA,EACpB,IAAI;AACJ,QAAM,UAAU,gBAAgB,KAAK,MAAM,GAAG,MAAM,OAAO;AAC3D,QAAM,aAAa,oBAAoB,YAAY,KAAK,QAAQ,QAAQ,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,KAAK;AACvG,QAAM,WAAW,oBAAoB,YAAY,GAAG,QAAQ,QAAQ,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,IAAI,GAAG;AAC/F,QAAM,cAA8B,oBAAI,IAAI;AAC5C,UAAQ,QAAQ,CAAC,UAAU;AAjK7B;AAkKI,UAAM,UAAU,WAAW,OAAO,CAAC,MAAM,EAAE,UAAU,MAAM,KAAK,CAAC,KAAK,EAAE,SAAS,EAAE,QAAQ,UAAU,MAAM,KAAK,CAAC,CAAC;AAClH,UAAM,UAAU,SAAS,OAAO,CAAC,MAAM,EAAE,UAAU,MAAM,GAAG,CAAC,KAAK,EAAE,SAAS,EAAE,QAAQ,UAAU,MAAM,GAAG,CAAC,CAAC;AAC5G,QAAI,OAAO;AACX,QAAI,OAAO;AACX,WAAO,OAAO,QAAQ,UAAU,OAAO,QAAQ,QAAQ;AACrD,UAAI,CAAC,QAAQ,IAAI,KAAK,CAAC,QAAQ,IAAI;AACjC;AACF,UAAI,QAAQ,IAAI,EAAE,YAAY,QAAQ,IAAI,EAAE,SAAS;AACnD,gBAAQ,IAAI,EAAE,MAAM,QAAQ,IAAI,EAAE;AAClC,oBAAY,IAAI,QAAQ,IAAI,EAAE,GAAG;AACjC;AACA;AAAA,MACF,aAAW,aAAQ,OAAO,CAAC,MAAhB,mBAAmB,aAAY,QAAQ,IAAI,EAAE,SAAS;AAC/D;AAAA,MACF,WAAW,QAAQ,IAAI,EAAE,cAAY,aAAQ,OAAO,CAAC,MAAhB,mBAAmB,UAAS;AAC/D;AAAA,MACF,OAAO;AACL;AACA;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACD,MAAI,iBAAiB;AACnB,eAAW,SAAS,YAAY;AAC9B,UAAI,YAAY,IAAI,MAAM,GAAG;AAC3B;AACF,UAAI,MAAM,QAAQ,SAAS,KAAK,CAAC,MAAM,QAAQ,MAAM,aAAa;AAChE;AACF,YAAM,UAAU,SAAS,KAAK,CAAC,MAAM,EAAE,YAAY,MAAM,WAAW,CAAC,YAAY,IAAI,EAAE,GAAG,CAAC;AAC3F,UAAI,SAAS;AACX,gBAAQ,MAAM,MAAM;AACpB,oBAAY,IAAI,MAAM,GAAG;AAAA,MAC3B;AAAA,IACF;AAAA,EACF;AACA,SAAO;AAAA,IACL,MAAM,WAAW,WAAW,KAAK,OAAO,SAAS,OAAO,EAAE,GAAG,MAAM,QAAQ,WAAW;AAAA,IACtF,IAAI,SAAS,WAAW,GAAG,OAAO,SAAS,KAAK,EAAE,GAAG,IAAI,QAAQ,SAAS;AAAA,EAC5E;AACF;AACA,SAAS,gBAAgB,GAAG,GAAG,UAAU,CAAC,GAAG;AA1M7C;AA2ME,MAAI,QAAQ,SAAK,GAAG,CAAC;AACrB,YAAQ,aAAQ,gBAAR,iCAAsB,WAAU;AACxC,MAAI,WAAW;AACf,MAAI,WAAW;AACf,QAAM,UAAU,CAAC;AACjB,aAAW,CAAC,IAAI,IAAI,KAAK,OAAO;AAC9B,QAAI,OAAO,GAAG;AACZ,cAAQ,KAAK;AAAA,QACX,MAAM,CAAC,SAAS,QAAQ,SAAS,SAAS,KAAK,MAAM;AAAA,QACrD,IAAI,CAAC,SAAS,QAAQ,SAAS,SAAS,KAAK,MAAM;AAAA,QACnD,SAAS;AAAA,MACX,CAAC;AACD,kBAAY;AACZ,kBAAY;AAAA,IACd,WAAW,OAAO,IAAI;AACpB,kBAAY;AAAA,IACd,WAAW,OAAO,GAAG;AACnB,kBAAY;AAAA,IACd;AAAA,EACF;AACA,MAAI,aAAa,KAAK,aAAa;AACjC,UAAM,IAAI,MAAM,kBAAkB;AACpC,SAAO;AACT;;;AClOA,IAAI,YAAY,OAAO;AACvB,IAAI,kBAAkB,CAAC,KAAK,KAAK,UAAU,OAAO,MAAM,UAAU,KAAK,KAAK,EAAE,YAAY,MAAM,cAAc,MAAM,UAAU,MAAM,MAAM,CAAC,IAAI,IAAI,GAAG,IAAI;AAC1J,IAAI,gBAAgB,CAAC,KAAK,KAAK,UAAU;AACvC,kBAAgB,KAAK,OAAO,QAAQ,WAAW,MAAM,KAAK,KAAK,KAAK;AACpE,SAAO;AACT;AACA,IAAM,eAAe;AACrB,IAAM,mBAAmB,GAAG,YAAY;AACxC,IAAM,iBAAiB,GAAG,YAAY;AACtC,IAAM,qBAAqB,GAAG,YAAY;AAC1C,IAAM,mBAAmB,GAAG,YAAY;AACxC,IAAM,iBAAiB,GAAG,YAAY;AACtC,IAAM,qBAAqB,GAAG,YAAY;AAC1C,IAAM,aAAa,GAAG,YAAY;AAClC,IAAM,yBAAyB,GAAG,YAAY;AAC9C,IAAM,0BAA0B,GAAG,YAAY;AAC/C,IAAMC,kBAAiB;AAAA,EACrB,aAAa;AAAA,EACb,UAAU;AAAA,EACV,WAAW;AAAA,EACX,YAAY;AAAA,EACZ,YAAY;AAAA,EACZ,gBAAgB;AAAA,EAChB,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,kBAAkB;AAAA,EAClB,gBAAgB;AAClB;AACA,IAAM,oBAAN,MAAwB;AAAA,EACtB,YAAY,QAAQ,UAAU,CAAC,GAAG;AAChC,kBAAc,MAAM,UAA0B,oBAAI,IAAI,CAAC;AACvD,kBAAc,MAAM,WAAW;AAC/B,kBAAc,MAAM,QAAQ;AAC5B,kBAAc,MAAM,oBAAoB,CAAC,CAAC;AAC1C,kBAAc,MAAM,SAAS;AAC7B,kBAAc,MAAM,iBAAiB,IAAI;AACzC,SAAK,UAAU;AAAA,MACb,GAAGA;AAAA,MACH,GAAG;AAAA,IACL;AACA,QAAI,OAAO,WAAW;AACpB,WAAK,YAAY,SAAS,cAAc,MAAM;AAAA;AAE9C,WAAK,YAAY;AACnB,SAAK,SAAS,SAAS,cAAc,MAAM;AAC3C,SAAK,OAAO,MAAM,WAAW;AAC7B,SAAK,OAAO,MAAM,MAAM;AACxB,SAAK,OAAO,MAAM,OAAO;AACzB,SAAK,OAAO,MAAM,SAAS;AAC3B,SAAK,OAAO,MAAM,QAAQ;AAC1B,SAAK,UAAU,QAAQ,KAAK,MAAM;AAAA,EACpC;AAAA,EACA,oBAAoB,IAAI,OAAO;AAC7B,QAAI,MAAM,YAAY,MAAM;AAC1B,SAAG,cAAc,MAAM;AACvB,SAAG,UAAU,IAAI,GAAG,YAAY,OAAO;AAAA,IACzC;AAAA,EACF;AAAA,EACA,kBAAkB,IAAI,OAAO;AAC3B,QAAI,MAAM;AACR,SAAG,aAAa,SAAS,MAAM,SAAS;AAC1C,QAAI,MAAM;AACR,SAAG,MAAM,QAAQ,MAAM;AACzB,QAAI,MAAM;AACR,SAAG,MAAM,kBAAkB,MAAM;AAAA,EACrC;AAAA,EACA,aAAa,IAAI,OAAO;AACtB,SAAK,oBAAoB,IAAI,KAAK;AAClC,SAAK,kBAAkB,IAAI,KAAK;AAAA,EAClC;AAAA,EACA,oBAAoB,MAAM;AACxB,QAAI,CAAC,KAAK,QAAQ;AAChB;AACF,QAAI,KAAK;AACP,WAAK,UAAU,MAAM,kBAAkB,KAAK;AAC9C,QAAI,KAAK;AACP,WAAK,UAAU,MAAM,QAAQ,KAAK;AACpC,QAAI,KAAK,WAAW;AAClB,YAAM,QAAQ,KAAK,UAAU,MAAM,GAAG;AACtC,iBAAW,QAAQ,OAAO;AACxB,cAAM,CAAC,KAAK,KAAK,IAAI,KAAK,MAAM,GAAG;AACnC,YAAI,OAAO;AACT,eAAK,UAAU,MAAM,YAAY,IAAI,KAAK,GAAG,MAAM,KAAK,CAAC;AAAA,MAC7D;AAAA,IACF;AAAA,EACF;AAAA,EACA,sBAAsB,IAAI,IAAI;AAC5B,QAAI,WAAW;AACf,QAAI,UAAU,MAAM;AAAA,IACpB;AACA,UAAM,UAAU,IAAI,QAAQ,CAAC,aAAa;AACxC,YAAM,SAAS,CAAC,MAAM;AACpB,YAAI,CAAC,KAAK,EAAE,WAAW;AACrB;AACF,gBAAQ;AAAA,MACV;AACA,gBAAU,MAAM;AACd,YAAI;AACF;AACF,mBAAW;AACX,WAAG,oBAAoB,iBAAiB,MAAM;AAC9C,WAAG;AACH,iBAAS;AAAA,MACX;AACA,SAAG,iBAAiB,iBAAiB,MAAM;AAAA,IAC7C,CAAC;AACD,YAAQ,UAAU;AAClB,WAAO;AAAA,EACT;AAAA,EACA,kBAAkB;AAChB,SAAK,UAAU,MAAM,YAAY,kBAAkB,GAAG,KAAK,QAAQ,QAAQ,IAAI;AAC/E,SAAK,UAAU,MAAM,YAAY,oBAAoB,GAAG,KAAK,QAAQ,SAAS,EAAE;AAChF,SAAK,UAAU,MAAM,YAAY,qBAAqB,GAAG,KAAK,QAAQ,UAAU,EAAE;AAClF,SAAK,UAAU,MAAM,YAAY,qBAAqB,GAAG,KAAK,QAAQ,UAAU,EAAE;AAClF,SAAK,UAAU,MAAM,YAAY,yBAAyB,GAAG,KAAK,QAAQ,cAAc,EAAE;AAC1F,SAAK,UAAU,MAAM,YAAY,gBAAgB,KAAK,QAAQ,MAAM;AACpE,SAAK,UAAU,MAAM,YAAY,iBAAiB,GAAG;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA,EAIA,QAAQ,MAAM;AACZ,UAAM,YAA4B,oBAAI,IAAI;AAC1C,UAAM,cAAc,KAAK,OAAO,IAAI,CAAC,UAAU;AAC7C,UAAI,KAAK,OAAO,IAAI,MAAM,GAAG,GAAG;AAC9B,cAAM,KAAK,KAAK,OAAO,IAAI,MAAM,GAAG;AACpC,aAAK,aAAa,IAAI,KAAK;AAC3B,kBAAU,IAAI,MAAM,KAAK,EAAE;AAC3B,aAAK,OAAO,OAAO,MAAM,GAAG;AAC5B,eAAO;AAAA,MACT,OAAO;AACL,cAAM,KAAK,SAAS,cAAc,MAAM,YAAY,OAAO,OAAO,MAAM;AACxE,aAAK,aAAa,IAAI,KAAK;AAC3B,kBAAU,IAAI,MAAM,KAAK,EAAE;AAC3B,eAAO;AAAA,MACT;AAAA,IACF,CAAC;AACD,SAAK,UAAU;AAAA,MACb,KAAK;AAAA,MACL,GAAG;AAAA,IACL;AACA,SAAK,oBAAoB,IAAI;AAC7B,SAAK,SAAS;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,MAAM;AACX,SAAK,gBAAgB;AACrB,UAAM,YAA4B,oBAAI,IAAI;AAC1C,UAAM,OAAO,CAAC;AACd,UAAM,QAAQ,CAAC;AACf,UAAM,QAAQ,CAAC;AACf,UAAM,WAAW,CAAC;AAClB,SAAK,iBAAiB,QAAQ,CAAC,MAAM,EAAE,QAAQ,CAAC;AAChD,SAAK,mBAAmB,CAAC;AACzB,UAAM,aAAa,CAAC;AACpB,UAAM;AAAA,MACJ,aAAa;AAAA,IACf,IAAI,KAAK;AACT,UAAM,WAA2B,oBAAI,IAAI;AACzC,QAAI,aAAa,KAAK,OAAO,sBAAsB;AACnD,UAAM,gBAAgB,KAAK,UAAU,sBAAsB;AAC3D,eAAW,MAAM,KAAK,OAAO,OAAO,GAAG;AACrC,YAAM,OAAO,GAAG,sBAAsB;AACtC,eAAS,IAAI,IAAI,EAAE,GAAG,KAAK,IAAI,WAAW,GAAG,GAAG,KAAK,IAAI,WAAW,EAAE,CAAC;AAAA,IACzE;AACA,UAAM,cAAc,KAAK,OAAO,IAAI,CAAC,UAAU;AAC7C,UAAI,KAAK,OAAO,IAAI,MAAM,GAAG,GAAG;AAC9B,cAAM,KAAK,KAAK,OAAO,IAAI,MAAM,GAAG;AACpC,aAAK,oBAAoB,IAAI,KAAK;AAClC,mBAAW,KAAK,MAAM;AACpB,eAAK,kBAAkB,IAAI,KAAK;AAAA,QAClC,CAAC;AACD,aAAK,KAAK,EAAE;AACZ,kBAAU,IAAI,MAAM,KAAK,EAAE;AAC3B,aAAK,OAAO,OAAO,MAAM,GAAG;AAC5B,eAAO;AAAA,MACT,OAAO;AACL,cAAM,KAAK,SAAS,cAAc,MAAM,YAAY,OAAO,OAAO,MAAM;AACxE,aAAK,aAAa,IAAI,KAAK;AAC3B,cAAM,KAAK,EAAE;AACb,kBAAU,IAAI,MAAM,KAAK,EAAE;AAC3B,eAAO;AAAA,MACT;AAAA,IACF,CAAC;AACD,eAAW,CAAC,GAAG,EAAE,KAAK,KAAK,QAAQ;AACjC,UAAI,GAAG,YAAY;AACjB;AACF,YAAM,KAAK,EAAE;AAAA,IACf;AACA,eAAW,MAAM;AACf,SAAG,MAAM,WAAW;AACtB,SAAK,UAAU;AAAA,MACb,KAAK;AAAA,MACL,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AACA,SAAK,SAAS;AACd,UAAM,QAAQ,CAAC,IAAI,QAAQ;AACzB,SAAG,MAAM,WAAW;AACpB,YAAM,MAAM,SAAS,IAAI,EAAE;AAC3B,SAAG,MAAM,MAAM,GAAG,IAAI,IAAI,KAAK;AAC/B,SAAG,MAAM,OAAO,GAAG,IAAI,IAAI,KAAK;AAChC,UAAI,KAAK,QAAQ;AACf,WAAG,MAAM,YAAY,iBAAiB,GAAG,MAAM,KAAK,QAAQ,OAAO,IAAI;AAAA;AAEvE,WAAG,MAAM,eAAe,eAAe;AACzC,SAAG,UAAU,IAAI,gBAAgB;AACjC,SAAG,UAAU,IAAI,kBAAkB;AACnC,iBAAW,QAAQ,MAAM;AACvB,WAAG,UAAU,OAAO,gBAAgB;AACpC,WAAG,UAAU,IAAI,cAAc;AAAA,MACjC,CAAC;AACD,eAAS;AAAA,QACP,KAAK,sBAAsB,IAAI,MAAM;AACnC,aAAG,UAAU,OAAO,gBAAgB;AACpC,aAAG,UAAU,OAAO,kBAAkB;AACtC,aAAG,UAAU,OAAO,cAAc;AAClC,aAAG,OAAO;AAAA,QACZ,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AACD,QAAI,CAAC,KAAK,eAAe;AACvB,YAAM,QAAQ,CAAC,IAAI,QAAQ;AACzB,WAAG,UAAU,IAAI,gBAAgB;AACjC,WAAG,UAAU,IAAI,kBAAkB;AACnC,YAAI,KAAK,QAAQ;AACf,aAAG,MAAM,YAAY,iBAAiB,GAAG,MAAM,KAAK,QAAQ,OAAO,IAAI;AAAA;AAEvE,aAAG,MAAM,eAAe,eAAe;AACzC,mBAAW,KAAK,MAAM;AACpB,aAAG,UAAU,OAAO,gBAAgB;AACpC,aAAG,UAAU,IAAI,cAAc;AAAA,QACjC,CAAC;AACD,iBAAS;AAAA,UACP,KAAK,sBAAsB,IAAI,MAAM;AACnC,eAAG,UAAU,OAAO,gBAAgB;AACpC,eAAG,UAAU,OAAO,kBAAkB;AACtC,eAAG,UAAU,OAAO,cAAc;AAAA,UACpC,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AAAA,IACH;AACA,iBAAa,KAAK,OAAO,sBAAsB;AAC/C,SAAK,QAAQ,CAAC,IAAI,QAAQ;AACxB,YAAM,UAAU,GAAG,sBAAsB;AACzC,YAAM,SAAS,EAAE,GAAG,QAAQ,IAAI,WAAW,GAAG,GAAG,QAAQ,IAAI,WAAW,EAAE;AAC1E,YAAM,SAAS,SAAS,IAAI,EAAE;AAC9B,SAAG,MAAM,qBAAqB,GAAG,MAAM,kBAAkB;AACzD,YAAM,MAAM,OAAO,IAAI,OAAO,KAAK;AACnC,YAAM,MAAM,OAAO,IAAI,OAAO,KAAK;AACnC,SAAG,MAAM,YAAY,aAAa,EAAE,OAAO,EAAE;AAC7C,UAAI,KAAK,QAAQ;AACf,WAAG,MAAM,YAAY,iBAAiB,GAAG,MAAM,KAAK,QAAQ,OAAO,IAAI;AAAA;AAEvE,WAAG,MAAM,eAAe,eAAe;AACzC,iBAAW,QAAQ,MAAM;AACvB,WAAG,UAAU,IAAI,UAAU;AAC3B,WAAG,MAAM,YAAY,GAAG,MAAM,qBAAqB,GAAG,MAAM,kBAAkB;AAAA,MAChF,CAAC;AACD,eAAS;AAAA,QACP,KAAK,sBAAsB,IAAI,MAAM;AACnC,aAAG,UAAU,OAAO,UAAU;AAAA,QAChC,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AACD,QAAI,KAAK,QAAQ,oBAAoB,CAAC,KAAK,eAAe;AACxD,YAAM,UAAU,KAAK,UAAU,sBAAsB;AACrD,UAAI,QAAQ,UAAU,cAAc,SAAS,QAAQ,WAAW,cAAc,QAAQ;AACpF,aAAK,UAAU,MAAM,qBAAqB,KAAK,UAAU,MAAM,kBAAkB;AACjF,aAAK,UAAU,MAAM,SAAS,GAAG,cAAc,SAAS,KAAK;AAC7D,aAAK,UAAU,MAAM,QAAQ,GAAG,cAAc,QAAQ,KAAK;AAC3D,mBAAW,QAAQ,MAAM;AACvB,eAAK,UAAU,UAAU,IAAI,sBAAsB;AACnD,eAAK,UAAU,MAAM,qBAAqB,KAAK,UAAU,MAAM,kBAAkB;AACjF,eAAK,UAAU,MAAM,SAAS,GAAG,QAAQ,SAAS,KAAK;AACvD,eAAK,UAAU,MAAM,QAAQ,GAAG,QAAQ,QAAQ,KAAK;AAAA,QACvD,CAAC;AACD,iBAAS;AAAA,UACP,KAAK,sBAAsB,KAAK,WAAW,MAAM;AAC/C,iBAAK,UAAU,UAAU,OAAO,sBAAsB;AACtD,iBAAK,UAAU,MAAM,SAAS,KAAK,UAAU,MAAM,QAAQ;AAAA,UAC7D,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AACA,QAAI,KAAK,QAAQ,gBAAgB;AAC/B,UAAI,KAAK,eAAe;AACtB,aAAK,oBAAoB,IAAI;AAAA,MAC/B,OAAO;AACL,mBAAW,KAAK,MAAM;AACpB,eAAK,UAAU,UAAU,IAAI,uBAAuB;AACpD,eAAK,oBAAoB,IAAI;AAAA,QAC/B,CAAC;AACD,iBAAS;AAAA,UACP,KAAK,sBAAsB,KAAK,WAAW,MAAM;AAC/C,iBAAK,UAAU,UAAU,OAAO,uBAAuB;AAAA,UACzD,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AACA,gBAAY;AACZ,eAAW,QAAQ,CAAC,OAAO,GAAG,CAAC;AAC/B,SAAK,gBAAgB;AACrB,SAAK,mBAAmB;AACxB,WAAO,QAAQ,IAAI,QAAQ,EAAE,KAAK;AAAA,EACpC;AACF;AACA,SAAS,cAAc;AACrB,SAAO,SAAS,KAAK;AACvB;;;AJlTA,IAAM,yBAAyC,gBAAgB;AAAA,EAC7D,MAAM;AAAA,EACN,OAAO;AAAA,IACL,SAAS;AAAA,MACP,MAAM;AAAA,MACN,SAAS;AAAA,IACX;AAAA,IACA,QAAQ;AAAA,MACN,MAAM;AAAA,MACN,UAAU;AAAA,IACZ;AAAA,IACA,UAAU;AAAA,MACR,MAAM;AAAA,MACN,UAAU;AAAA,IACZ;AAAA,IACA,SAAS;AAAA,MACP,MAAM;AAAA,IACR;AAAA,EACF;AAAA,EACA,OAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AAAA,EACA,MAAM,OAAO,EAAE,KAAK,GAAG;AACrB,UAAM,YAAY,IAAI;AACtB,QAAI,YAAY;AAChB,cAAU,MAAM;AACd,gBAAU,MAAM,YAAY;AAC5B,kBAAY;AACZ,YAAM,WAAW,IAAI,kBAAkB,UAAU,KAAK;AACtD;AAAA,QACE,MAAM,MAAM;AAAA,QACZ,OAAO,WAAW;AAChB,iBAAO,OAAO,SAAS,SAAS,MAAM,OAAO;AAC7C,cAAI,MAAM,SAAS;AACjB,gBAAI,MAAM;AACR,uBAAS,QAAQ,MAAM,QAAQ;AACjC,kBAAM,SAAS;AACf,kBAAM,UAAU,SAAS,OAAO,MAAM;AACtC,kBAAM,SAAS;AACf,iBAAK,OAAO;AACZ,kBAAM;AACN,iBAAK,KAAK;AAAA,UACZ,OAAO;AACL,qBAAS,QAAQ,MAAM;AAAA,UACzB;AAAA,QACF;AAAA,QACA,EAAE,WAAW,KAAK;AAAA,MACpB;AAAA,IACF,CAAC;AACD,WAAO,MAAM;AAAA,MACX;AAAA,MACA,EAAE,KAAK,WAAW,OAAO,6BAA6B;AAAA;AAAA,MAEtD,YAAY,SAAS,WAAW,MAAM,OAAO,QAAQ,CAAC,UAAU;AAC9D,YAAI,MAAM,YAAY;AACpB,iBAAO,EAAE,MAAM,EAAE,KAAK,MAAM,IAAI,CAAC;AACnC,eAAO;AAAA,UACL;AAAA,UACA;AAAA,YACE,OAAO,CAAC,EAAE,OAAO,MAAM,MAAM,GAAG,MAAM,SAAS;AAAA,YAC/C,OAAO;AAAA,YACP,KAAK,MAAM;AAAA,UACb;AAAA,UACA,MAAM;AAAA,QACR;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AACF,CAAC;AAED,IAAM,iBAAiC,gBAAgB;AAAA,EACrD,MAAM;AAAA,EACN,OAAO;AAAA,IACL,aAAa;AAAA,MACX,MAAM;AAAA,MACN,UAAU;AAAA,IACZ;AAAA,IACA,MAAM;AAAA,MACJ,MAAM;AAAA,MACN,UAAU;AAAA,IACZ;AAAA,IACA,OAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAU;AAAA,IACZ;AAAA,IACA,MAAM;AAAA,MACJ,MAAM;AAAA,MACN,UAAU;AAAA,IACZ;AAAA,IACA,SAAS;AAAA,MACP,MAAM;AAAA,MACN,SAAS,OAAO,CAAC;AAAA,IACnB;AAAA,EACF;AAAA,EACA,OAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AAAA,EACA,MAAM,OAAO,EAAE,KAAK,GAAG;AACrB,UAAM,UAAU;AAAA,MACd,CAAC,SAAS,kBAAkB,MAAM,aAAa,MAAM;AAAA,QACnD,MAAM,MAAM;AAAA,QACZ,OAAO,MAAM;AAAA,MACf,CAAC;AAAA,MACD,MAAM;AAAA,IACR;AACA,UAAM,SAAS,SAAS,MAAM,QAAQ,OAAO,MAAM,IAAI,CAAC;AACxD,WAAO,MAAM,EAAE,wBAAwB;AAAA,MACrC,QAAQ,OAAO,MAAM;AAAA,MACrB,SAAS,MAAM;AAAA,MACf,UAAU,OAAO,MAAM;AAAA,MACvB,SAAS,MAAM,KAAK,OAAO;AAAA,MAC3B,OAAO,MAAM,KAAK,KAAK;AAAA,IACzB,CAAC;AAAA,EACH;AACF,CAAC;AAED,IAAM,4BAA4C,gBAAgB;AAAA,EAChE,MAAM;AAAA,EACN,OAAO;AAAA,IACL,OAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAU;AAAA,IACZ;AAAA,IACA,MAAM;AAAA,MACJ,MAAM;AAAA,MACN,SAAS;AAAA,IACX;AAAA,IACA,SAAS;AAAA,MACP,MAAM;AAAA,MACN,SAAS;AAAA,IACX;AAAA,IACA,SAAS;AAAA,MACP,MAAM;AAAA,MACN,SAAS,OAAO,CAAC;AAAA,IACnB;AAAA,EACF;AAAA,EACA,OAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AAAA,EACA,MAAM,OAAO,EAAE,KAAK,GAAG;AACrB,UAAM,QAAQ,cAAc,IAAI,CAAC,CAAC;AAClC,QAAI,WAAW;AACf,UAAM,SAAS,SAAS,MAAM;AAC5B,YAAM,MAAM;AAAA,QACV;AAAA,QACA,MAAM,MAAM,KAAK,IAAI,MAAM,MAAM,MAAM,MAAM,SAAS,CAAC,CAAC;AAAA,QACxD,MAAM;AAAA,MACR;AACA,iBAAW,IAAI;AACf,aAAO;AAAA,IACT,CAAC;AACD,WAAO,MAAM,EAAE,wBAAwB;AAAA,MACrC,QAAQ,OAAO,MAAM;AAAA,MACrB,UAAU,OAAO,MAAM;AAAA,MACvB,SAAS,MAAM;AAAA,MACf,SAAS,MAAM;AAAA,MACf,SAAS,MAAM,KAAK,OAAO;AAAA,MAC3B,OAAO,MAAM,KAAK,KAAK;AAAA,IACzB,CAAC;AAAA,EACH;AACF,CAAC;AAED,SAAS,QAAQ,KAAK;AACpB,MAAI,UAAU,kBAAkB,cAAc;AAC9C,MAAI,UAAU,6BAA6B,yBAAyB;AACpE,MAAI,UAAU,0BAA0B,sBAAsB;AAChE;",
  "names": ["h", "defaultOptions"]
}
