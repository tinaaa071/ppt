{
  "version": 3,
  "sources": ["../../roughjs/bin/math.js", "../../hachure-fill/bin/hachure.js", "../../roughjs/bin/fillers/scan-line-hachure.js", "../../roughjs/bin/fillers/hachure-filler.js", "../../roughjs/bin/geometry.js", "../../roughjs/bin/fillers/zigzag-filler.js", "../../roughjs/bin/fillers/hatch-filler.js", "../../roughjs/bin/fillers/dot-filler.js", "../../roughjs/bin/fillers/dashed-filler.js", "../../roughjs/bin/fillers/zigzag-line-filler.js", "../../roughjs/bin/fillers/filler.js", "../../path-data-parser/lib/parser.js", "../../path-data-parser/lib/absolutize.js", "../../path-data-parser/lib/normalize.js", "../../roughjs/bin/renderer.js", "../../points-on-curve/lib/curve-to-bezier.js", "../../points-on-curve/lib/index.js", "../../points-on-path/lib/index.js", "../../roughjs/bin/generator.js", "../../@slidev/rough-notation/dist/index.mjs"],
  "sourcesContent": ["export function randomSeed() {\n    return Math.floor(Math.random() * 2 ** 31);\n}\nexport class Random {\n    constructor(seed) {\n        this.seed = seed;\n    }\n    next() {\n        if (this.seed) {\n            return ((2 ** 31 - 1) & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31;\n        }\n        else {\n            return Math.random();\n        }\n    }\n}\n", "function rotatePoints(points, center, degrees) {\n    if (points && points.length) {\n        const [cx, cy] = center;\n        const angle = (Math.PI / 180) * degrees;\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        for (const p of points) {\n            const [x, y] = p;\n            p[0] = ((x - cx) * cos) - ((y - cy) * sin) + cx;\n            p[1] = ((x - cx) * sin) + ((y - cy) * cos) + cy;\n        }\n    }\n}\nfunction rotateLines(lines, center, degrees) {\n    const points = [];\n    lines.forEach((line) => points.push(...line));\n    rotatePoints(points, center, degrees);\n}\nfunction areSamePoints(p1, p2) {\n    return p1[0] === p2[0] && p1[1] === p2[1];\n}\nexport function hachureLines(polygons, hachureGap, hachureAngle, hachureStepOffset = 1) {\n    const angle = hachureAngle;\n    const gap = Math.max(hachureGap, 0.1);\n    const polygonList = (polygons[0] && polygons[0][0] && (typeof polygons[0][0] === 'number')) ? [polygons] : polygons;\n    const rotationCenter = [0, 0];\n    if (angle) {\n        for (const polygon of polygonList) {\n            rotatePoints(polygon, rotationCenter, angle);\n        }\n    }\n    const lines = straightHachureLines(polygonList, gap, hachureStepOffset);\n    if (angle) {\n        for (const polygon of polygonList) {\n            rotatePoints(polygon, rotationCenter, -angle);\n        }\n        rotateLines(lines, rotationCenter, -angle);\n    }\n    return lines;\n}\nfunction straightHachureLines(polygons, gap, hachureStepOffset) {\n    const vertexArray = [];\n    for (const polygon of polygons) {\n        const vertices = [...polygon];\n        if (!areSamePoints(vertices[0], vertices[vertices.length - 1])) {\n            vertices.push([vertices[0][0], vertices[0][1]]);\n        }\n        if (vertices.length > 2) {\n            vertexArray.push(vertices);\n        }\n    }\n    const lines = [];\n    gap = Math.max(gap, 0.1);\n    // Create sorted edges table\n    const edges = [];\n    for (const vertices of vertexArray) {\n        for (let i = 0; i < vertices.length - 1; i++) {\n            const p1 = vertices[i];\n            const p2 = vertices[i + 1];\n            if (p1[1] !== p2[1]) {\n                const ymin = Math.min(p1[1], p2[1]);\n                edges.push({\n                    ymin,\n                    ymax: Math.max(p1[1], p2[1]),\n                    x: ymin === p1[1] ? p1[0] : p2[0],\n                    islope: (p2[0] - p1[0]) / (p2[1] - p1[1]),\n                });\n            }\n        }\n    }\n    edges.sort((e1, e2) => {\n        if (e1.ymin < e2.ymin) {\n            return -1;\n        }\n        if (e1.ymin > e2.ymin) {\n            return 1;\n        }\n        if (e1.x < e2.x) {\n            return -1;\n        }\n        if (e1.x > e2.x) {\n            return 1;\n        }\n        if (e1.ymax === e2.ymax) {\n            return 0;\n        }\n        return (e1.ymax - e2.ymax) / Math.abs((e1.ymax - e2.ymax));\n    });\n    if (!edges.length) {\n        return lines;\n    }\n    // Start scanning\n    let activeEdges = [];\n    let y = edges[0].ymin;\n    let iteration = 0;\n    while (activeEdges.length || edges.length) {\n        if (edges.length) {\n            let ix = -1;\n            for (let i = 0; i < edges.length; i++) {\n                if (edges[i].ymin > y) {\n                    break;\n                }\n                ix = i;\n            }\n            const removed = edges.splice(0, ix + 1);\n            removed.forEach((edge) => {\n                activeEdges.push({ s: y, edge });\n            });\n        }\n        activeEdges = activeEdges.filter((ae) => {\n            if (ae.edge.ymax <= y) {\n                return false;\n            }\n            return true;\n        });\n        activeEdges.sort((ae1, ae2) => {\n            if (ae1.edge.x === ae2.edge.x) {\n                return 0;\n            }\n            return (ae1.edge.x - ae2.edge.x) / Math.abs((ae1.edge.x - ae2.edge.x));\n        });\n        // fill between the edges\n        if ((hachureStepOffset !== 1) || (iteration % gap === 0)) {\n            if (activeEdges.length > 1) {\n                for (let i = 0; i < activeEdges.length; i = i + 2) {\n                    const nexti = i + 1;\n                    if (nexti >= activeEdges.length) {\n                        break;\n                    }\n                    const ce = activeEdges[i].edge;\n                    const ne = activeEdges[nexti].edge;\n                    lines.push([\n                        [Math.round(ce.x), y],\n                        [Math.round(ne.x), y],\n                    ]);\n                }\n            }\n        }\n        y += hachureStepOffset;\n        activeEdges.forEach((ae) => {\n            ae.edge.x = ae.edge.x + (hachureStepOffset * ae.edge.islope);\n        });\n        iteration++;\n    }\n    return lines;\n}\n", "import { hachureLines } from 'hachure-fill';\nexport function polygonHachureLines(polygonList, o) {\n    var _a;\n    const angle = o.hachureAngle + 90;\n    let gap = o.hachureGap;\n    if (gap < 0) {\n        gap = o.strokeWidth * 4;\n    }\n    gap = Math.round(Math.max(gap, 0.1));\n    let skipOffset = 1;\n    if (o.roughness >= 1) {\n        if ((((_a = o.randomizer) === null || _a === void 0 ? void 0 : _a.next()) || Math.random()) > 0.7) {\n            skipOffset = gap;\n        }\n    }\n    return hachureLines(polygonList, gap, angle, skipOffset || 1);\n}\n", "import { polygonHachureLines } from './scan-line-hachure';\nexport class HachureFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        return this._fillPolygons(polygonList, o);\n    }\n    _fillPolygons(polygonList, o) {\n        const lines = polygonHachureLines(polygonList, o);\n        const ops = this.renderLines(lines, o);\n        return { type: 'fillSketch', ops };\n    }\n    renderLines(lines, o) {\n        const ops = [];\n        for (const line of lines) {\n            ops.push(...this.helper.doubleLineOps(line[0][0], line[0][1], line[1][0], line[1][1], o));\n        }\n        return ops;\n    }\n}\n", "export function lineLength(line) {\n    const p1 = line[0];\n    const p2 = line[1];\n    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\n", "import { HachureFiller } from './hachure-filler';\nimport { polygonHachureLines } from './scan-line-hachure';\nimport { lineLength } from '../geometry';\nexport class ZigZagFiller extends HachureFiller {\n    fillPolygons(polygonList, o) {\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        const o2 = Object.assign({}, o, { hachureGap: gap });\n        const lines = polygonHachureLines(polygonList, o2);\n        const zigZagAngle = (Math.PI / 180) * o.hachureAngle;\n        const zigzagLines = [];\n        const dgx = gap * 0.5 * Math.cos(zigZagAngle);\n        const dgy = gap * 0.5 * Math.sin(zigZagAngle);\n        for (const [p1, p2] of lines) {\n            if (lineLength([p1, p2])) {\n                zigzagLines.push([\n                    [p1[0] - dgx, p1[1] + dgy],\n                    [...p2],\n                ], [\n                    [p1[0] + dgx, p1[1] - dgy],\n                    [...p2],\n                ]);\n            }\n        }\n        const ops = this.renderLines(zigzagLines, o);\n        return { type: 'fillSketch', ops };\n    }\n}\n", "import { HachureFiller } from './hachure-filler';\nexport class HatchFiller extends HachureFiller {\n    fillPolygons(polygonList, o) {\n        const set = this._fillPolygons(polygonList, o);\n        const o2 = Object.assign({}, o, { hachureAngle: o.hachureAngle + 90 });\n        const set2 = this._fillPolygons(polygonList, o2);\n        set.ops = set.ops.concat(set2.ops);\n        return set;\n    }\n}\n", "import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DotFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        o = Object.assign({}, o, { hachureAngle: 0 });\n        const lines = polygonHachureLines(polygonList, o);\n        return this.dotsOnLines(lines, o);\n    }\n    dotsOnLines(lines, o) {\n        const ops = [];\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const ro = gap / 4;\n        for (const line of lines) {\n            const length = lineLength(line);\n            const dl = length / gap;\n            const count = Math.ceil(dl) - 1;\n            const offset = length - (count * gap);\n            const x = ((line[0][0] + line[1][0]) / 2) - (gap / 4);\n            const minY = Math.min(line[0][1], line[1][1]);\n            for (let i = 0; i < count; i++) {\n                const y = minY + offset + (i * gap);\n                const cx = (x - ro) + Math.random() * 2 * ro;\n                const cy = (y - ro) + Math.random() * 2 * ro;\n                const el = this.helper.ellipse(cx, cy, fweight, fweight, o);\n                ops.push(...el.ops);\n            }\n        }\n        return { type: 'fillSketch', ops };\n    }\n}\n", "import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DashedFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        const lines = polygonHachureLines(polygonList, o);\n        return { type: 'fillSketch', ops: this.dashedLine(lines, o) };\n    }\n    dashedLine(lines, o) {\n        const offset = o.dashOffset < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashOffset;\n        const gap = o.dashGap < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashGap;\n        const ops = [];\n        lines.forEach((line) => {\n            const length = lineLength(line);\n            const count = Math.floor(length / (offset + gap));\n            const startOffset = (length + gap - (count * (offset + gap))) / 2;\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * (offset + gap);\n                const lend = lstart + offset;\n                const start = [p1[0] + (lstart * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha) + (startOffset * Math.sin(alpha))];\n                const end = [p1[0] + (lend * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha)) + (startOffset * Math.sin(alpha))];\n                ops.push(...this.helper.doubleLineOps(start[0], start[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n", "import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class ZigZagLineFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        const gap = o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap;\n        const zo = o.zigzagOffset < 0 ? gap : o.zigzagOffset;\n        o = Object.assign({}, o, { hachureGap: gap + zo });\n        const lines = polygonHachureLines(polygonList, o);\n        return { type: 'fillSketch', ops: this.zigzagLines(lines, zo, o) };\n    }\n    zigzagLines(lines, zo, o) {\n        const ops = [];\n        lines.forEach((line) => {\n            const length = lineLength(line);\n            const count = Math.round(length / (2 * zo));\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * 2 * zo;\n                const lend = (i + 1) * 2 * zo;\n                const dz = Math.sqrt(2 * Math.pow(zo, 2));\n                const start = [p1[0] + (lstart * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha)];\n                const end = [p1[0] + (lend * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha))];\n                const middle = [start[0] + dz * Math.cos(alpha + Math.PI / 4), start[1] + dz * Math.sin(alpha + Math.PI / 4)];\n                ops.push(...this.helper.doubleLineOps(start[0], start[1], middle[0], middle[1], o), ...this.helper.doubleLineOps(middle[0], middle[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n", "import { HachureFiller } from './hachure-filler';\nimport { ZigZagFiller } from './zigzag-filler';\nimport { HatchFiller } from './hatch-filler';\nimport { DotFiller } from './dot-filler';\nimport { DashedFiller } from './dashed-filler';\nimport { ZigZagLineFiller } from './zigzag-line-filler';\nconst fillers = {};\nexport function getFiller(o, helper) {\n    let fillerName = o.fillStyle || 'hachure';\n    if (!fillers[fillerName]) {\n        switch (fillerName) {\n            case 'zigzag':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new ZigZagFiller(helper);\n                }\n                break;\n            case 'cross-hatch':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new HatchFiller(helper);\n                }\n                break;\n            case 'dots':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new DotFiller(helper);\n                }\n                break;\n            case 'dashed':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new DashedFiller(helper);\n                }\n                break;\n            case 'zigzag-line':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new ZigZagLineFiller(helper);\n                }\n                break;\n            case 'hachure':\n            default:\n                fillerName = 'hachure';\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new HachureFiller(helper);\n                }\n                break;\n        }\n    }\n    return fillers[fillerName];\n}\n", "const COMMAND = 0;\nconst NUMBER = 1;\nconst EOD = 2;\nconst PARAMS = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };\nfunction tokenize(d) {\n    const tokens = new Array();\n    while (d !== '') {\n        if (d.match(/^([ \\t\\r\\n,]+)/)) {\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n            tokens[tokens.length] = { type: COMMAND, text: RegExp.$1 };\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n            tokens[tokens.length] = { type: NUMBER, text: `${parseFloat(RegExp.$1)}` };\n            d = d.substr(RegExp.$1.length);\n        }\n        else {\n            return [];\n        }\n    }\n    tokens[tokens.length] = { type: EOD, text: '' };\n    return tokens;\n}\nfunction isType(token, type) {\n    return token.type === type;\n}\nexport function parsePath(d) {\n    const segments = [];\n    const tokens = tokenize(d);\n    let mode = 'BOD';\n    let index = 0;\n    let token = tokens[index];\n    while (!isType(token, EOD)) {\n        let paramsCount = 0;\n        const params = [];\n        if (mode === 'BOD') {\n            if (token.text === 'M' || token.text === 'm') {\n                index++;\n                paramsCount = PARAMS[token.text];\n                mode = token.text;\n            }\n            else {\n                return parsePath('M0,0' + d);\n            }\n        }\n        else if (isType(token, NUMBER)) {\n            paramsCount = PARAMS[mode];\n        }\n        else {\n            index++;\n            paramsCount = PARAMS[token.text];\n            mode = token.text;\n        }\n        if ((index + paramsCount) < tokens.length) {\n            for (let i = index; i < index + paramsCount; i++) {\n                const numbeToken = tokens[i];\n                if (isType(numbeToken, NUMBER)) {\n                    params[params.length] = +numbeToken.text;\n                }\n                else {\n                    throw new Error('Param not a number: ' + mode + ',' + numbeToken.text);\n                }\n            }\n            if (typeof PARAMS[mode] === 'number') {\n                const segment = { key: mode, data: params };\n                segments.push(segment);\n                index += paramsCount;\n                token = tokens[index];\n                if (mode === 'M')\n                    mode = 'L';\n                if (mode === 'm')\n                    mode = 'l';\n            }\n            else {\n                throw new Error('Bad segment: ' + mode);\n            }\n        }\n        else {\n            throw new Error('Path data ended short');\n        }\n    }\n    return segments;\n}\nexport function serialize(segments) {\n    const tokens = [];\n    for (const { key, data } of segments) {\n        tokens.push(key);\n        switch (key) {\n            case 'C':\n            case 'c':\n                tokens.push(data[0], `${data[1]},`, data[2], `${data[3]},`, data[4], data[5]);\n                break;\n            case 'S':\n            case 's':\n            case 'Q':\n            case 'q':\n                tokens.push(data[0], `${data[1]},`, data[2], data[3]);\n                break;\n            default:\n                tokens.push(...data);\n                break;\n        }\n    }\n    return tokens.join(' ');\n}\n", "// Translate relative commands to absolute commands\nexport function absolutize(segments) {\n    let cx = 0, cy = 0;\n    let subx = 0, suby = 0;\n    const out = [];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M':\n                out.push({ key: 'M', data: [...data] });\n                [cx, cy] = data;\n                [subx, suby] = data;\n                break;\n            case 'm':\n                cx += data[0];\n                cy += data[1];\n                out.push({ key: 'M', data: [cx, cy] });\n                subx = cx;\n                suby = cy;\n                break;\n            case 'L':\n                out.push({ key: 'L', data: [...data] });\n                [cx, cy] = data;\n                break;\n            case 'l':\n                cx += data[0];\n                cy += data[1];\n                out.push({ key: 'L', data: [cx, cy] });\n                break;\n            case 'C':\n                out.push({ key: 'C', data: [...data] });\n                cx = data[4];\n                cy = data[5];\n                break;\n            case 'c': {\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\n                out.push({ key: 'C', data: newdata });\n                cx = newdata[4];\n                cy = newdata[5];\n                break;\n            }\n            case 'Q':\n                out.push({ key: 'Q', data: [...data] });\n                cx = data[2];\n                cy = data[3];\n                break;\n            case 'q': {\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\n                out.push({ key: 'Q', data: newdata });\n                cx = newdata[2];\n                cy = newdata[3];\n                break;\n            }\n            case 'A':\n                out.push({ key: 'A', data: [...data] });\n                cx = data[5];\n                cy = data[6];\n                break;\n            case 'a':\n                cx += data[5];\n                cy += data[6];\n                out.push({ key: 'A', data: [data[0], data[1], data[2], data[3], data[4], cx, cy] });\n                break;\n            case 'H':\n                out.push({ key: 'H', data: [...data] });\n                cx = data[0];\n                break;\n            case 'h':\n                cx += data[0];\n                out.push({ key: 'H', data: [cx] });\n                break;\n            case 'V':\n                out.push({ key: 'V', data: [...data] });\n                cy = data[0];\n                break;\n            case 'v':\n                cy += data[0];\n                out.push({ key: 'V', data: [cy] });\n                break;\n            case 'S':\n                out.push({ key: 'S', data: [...data] });\n                cx = data[2];\n                cy = data[3];\n                break;\n            case 's': {\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\n                out.push({ key: 'S', data: newdata });\n                cx = newdata[2];\n                cy = newdata[3];\n                break;\n            }\n            case 'T':\n                out.push({ key: 'T', data: [...data] });\n                cx = data[0];\n                cy = data[1];\n                break;\n            case 't':\n                cx += data[0];\n                cy += data[1];\n                out.push({ key: 'T', data: [cx, cy] });\n                break;\n            case 'Z':\n            case 'z':\n                out.push({ key: 'Z', data: [] });\n                cx = subx;\n                cy = suby;\n                break;\n        }\n    }\n    return out;\n}\n", "// Normalize path to include only M, L, C, and Z commands\nexport function normalize(segments) {\n    const out = [];\n    let lastType = '';\n    let cx = 0, cy = 0;\n    let subx = 0, suby = 0;\n    let lcx = 0, lcy = 0;\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M':\n                out.push({ key: 'M', data: [...data] });\n                [cx, cy] = data;\n                [subx, suby] = data;\n                break;\n            case 'C':\n                out.push({ key: 'C', data: [...data] });\n                cx = data[4];\n                cy = data[5];\n                lcx = data[2];\n                lcy = data[3];\n                break;\n            case 'L':\n                out.push({ key: 'L', data: [...data] });\n                [cx, cy] = data;\n                break;\n            case 'H':\n                cx = data[0];\n                out.push({ key: 'L', data: [cx, cy] });\n                break;\n            case 'V':\n                cy = data[0];\n                out.push({ key: 'L', data: [cx, cy] });\n                break;\n            case 'S': {\n                let cx1 = 0, cy1 = 0;\n                if (lastType === 'C' || lastType === 'S') {\n                    cx1 = cx + (cx - lcx);\n                    cy1 = cy + (cy - lcy);\n                }\n                else {\n                    cx1 = cx;\n                    cy1 = cy;\n                }\n                out.push({ key: 'C', data: [cx1, cy1, ...data] });\n                lcx = data[0];\n                lcy = data[1];\n                cx = data[2];\n                cy = data[3];\n                break;\n            }\n            case 'T': {\n                const [x, y] = data;\n                let x1 = 0, y1 = 0;\n                if (lastType === 'Q' || lastType === 'T') {\n                    x1 = cx + (cx - lcx);\n                    y1 = cy + (cy - lcy);\n                }\n                else {\n                    x1 = cx;\n                    y1 = cy;\n                }\n                const cx1 = cx + 2 * (x1 - cx) / 3;\n                const cy1 = cy + 2 * (y1 - cy) / 3;\n                const cx2 = x + 2 * (x1 - x) / 3;\n                const cy2 = y + 2 * (y1 - y) / 3;\n                out.push({ key: 'C', data: [cx1, cy1, cx2, cy2, x, y] });\n                lcx = x1;\n                lcy = y1;\n                cx = x;\n                cy = y;\n                break;\n            }\n            case 'Q': {\n                const [x1, y1, x, y] = data;\n                const cx1 = cx + 2 * (x1 - cx) / 3;\n                const cy1 = cy + 2 * (y1 - cy) / 3;\n                const cx2 = x + 2 * (x1 - x) / 3;\n                const cy2 = y + 2 * (y1 - y) / 3;\n                out.push({ key: 'C', data: [cx1, cy1, cx2, cy2, x, y] });\n                lcx = x1;\n                lcy = y1;\n                cx = x;\n                cy = y;\n                break;\n            }\n            case 'A': {\n                const r1 = Math.abs(data[0]);\n                const r2 = Math.abs(data[1]);\n                const angle = data[2];\n                const largeArcFlag = data[3];\n                const sweepFlag = data[4];\n                const x = data[5];\n                const y = data[6];\n                if (r1 === 0 || r2 === 0) {\n                    out.push({ key: 'C', data: [cx, cy, x, y, x, y] });\n                    cx = x;\n                    cy = y;\n                }\n                else {\n                    if (cx !== x || cy !== y) {\n                        const curves = arcToCubicCurves(cx, cy, x, y, r1, r2, angle, largeArcFlag, sweepFlag);\n                        curves.forEach(function (curve) {\n                            out.push({ key: 'C', data: curve });\n                        });\n                        cx = x;\n                        cy = y;\n                    }\n                }\n                break;\n            }\n            case 'Z':\n                out.push({ key: 'Z', data: [] });\n                cx = subx;\n                cy = suby;\n                break;\n        }\n        lastType = key;\n    }\n    return out;\n}\nfunction degToRad(degrees) {\n    return (Math.PI * degrees) / 180;\n}\nfunction rotate(x, y, angleRad) {\n    const X = x * Math.cos(angleRad) - y * Math.sin(angleRad);\n    const Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);\n    return [X, Y];\n}\nfunction arcToCubicCurves(x1, y1, x2, y2, r1, r2, angle, largeArcFlag, sweepFlag, recursive) {\n    const angleRad = degToRad(angle);\n    let params = [];\n    let f1 = 0, f2 = 0, cx = 0, cy = 0;\n    if (recursive) {\n        [f1, f2, cx, cy] = recursive;\n    }\n    else {\n        [x1, y1] = rotate(x1, y1, -angleRad);\n        [x2, y2] = rotate(x2, y2, -angleRad);\n        const x = (x1 - x2) / 2;\n        const y = (y1 - y2) / 2;\n        let h = (x * x) / (r1 * r1) + (y * y) / (r2 * r2);\n        if (h > 1) {\n            h = Math.sqrt(h);\n            r1 = h * r1;\n            r2 = h * r2;\n        }\n        const sign = (largeArcFlag === sweepFlag) ? -1 : 1;\n        const r1Pow = r1 * r1;\n        const r2Pow = r2 * r2;\n        const left = r1Pow * r2Pow - r1Pow * y * y - r2Pow * x * x;\n        const right = r1Pow * y * y + r2Pow * x * x;\n        const k = sign * Math.sqrt(Math.abs(left / right));\n        cx = k * r1 * y / r2 + (x1 + x2) / 2;\n        cy = k * -r2 * x / r1 + (y1 + y2) / 2;\n        f1 = Math.asin(parseFloat(((y1 - cy) / r2).toFixed(9)));\n        f2 = Math.asin(parseFloat(((y2 - cy) / r2).toFixed(9)));\n        if (x1 < cx) {\n            f1 = Math.PI - f1;\n        }\n        if (x2 < cx) {\n            f2 = Math.PI - f2;\n        }\n        if (f1 < 0) {\n            f1 = Math.PI * 2 + f1;\n        }\n        if (f2 < 0) {\n            f2 = Math.PI * 2 + f2;\n        }\n        if (sweepFlag && f1 > f2) {\n            f1 = f1 - Math.PI * 2;\n        }\n        if (!sweepFlag && f2 > f1) {\n            f2 = f2 - Math.PI * 2;\n        }\n    }\n    let df = f2 - f1;\n    if (Math.abs(df) > (Math.PI * 120 / 180)) {\n        const f2old = f2;\n        const x2old = x2;\n        const y2old = y2;\n        if (sweepFlag && f2 > f1) {\n            f2 = f1 + (Math.PI * 120 / 180) * (1);\n        }\n        else {\n            f2 = f1 + (Math.PI * 120 / 180) * (-1);\n        }\n        x2 = cx + r1 * Math.cos(f2);\n        y2 = cy + r2 * Math.sin(f2);\n        params = arcToCubicCurves(x2, y2, x2old, y2old, r1, r2, angle, 0, sweepFlag, [f2, f2old, cx, cy]);\n    }\n    df = f2 - f1;\n    const c1 = Math.cos(f1);\n    const s1 = Math.sin(f1);\n    const c2 = Math.cos(f2);\n    const s2 = Math.sin(f2);\n    const t = Math.tan(df / 4);\n    const hx = 4 / 3 * r1 * t;\n    const hy = 4 / 3 * r2 * t;\n    const m1 = [x1, y1];\n    const m2 = [x1 + hx * s1, y1 - hy * c1];\n    const m3 = [x2 + hx * s2, y2 - hy * c2];\n    const m4 = [x2, y2];\n    m2[0] = 2 * m1[0] - m2[0];\n    m2[1] = 2 * m1[1] - m2[1];\n    if (recursive) {\n        return [m2, m3, m4].concat(params);\n    }\n    else {\n        params = [m2, m3, m4].concat(params);\n        const curves = [];\n        for (let i = 0; i < params.length; i += 3) {\n            const r1 = rotate(params[i][0], params[i][1], angleRad);\n            const r2 = rotate(params[i + 1][0], params[i + 1][1], angleRad);\n            const r3 = rotate(params[i + 2][0], params[i + 2][1], angleRad);\n            curves.push([r1[0], r1[1], r2[0], r2[1], r3[0], r3[1]]);\n        }\n        return curves;\n    }\n}\n", "import { getFiller } from './fillers/filler.js';\nimport { Random } from './math.js';\nimport { parsePath, normalize, absolutize } from 'path-data-parser';\nconst helper = {\n    randOffset,\n    randOffsetWithRange,\n    ellipse,\n    doubleLineOps: doubleLineFillOps,\n};\nexport function line(x1, y1, x2, y2, o) {\n    return { type: 'path', ops: _doubleLine(x1, y1, x2, y2, o) };\n}\nexport function linearPath(points, close, o) {\n    const len = (points || []).length;\n    if (len > 2) {\n        const ops = [];\n        for (let i = 0; i < (len - 1); i++) {\n            ops.push(..._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n        }\n        if (close) {\n            ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n        }\n        return { type: 'path', ops };\n    }\n    else if (len === 2) {\n        return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n    }\n    return { type: 'path', ops: [] };\n}\nexport function polygon(points, o) {\n    return linearPath(points, true, o);\n}\nexport function rectangle(x, y, width, height, o) {\n    const points = [\n        [x, y],\n        [x + width, y],\n        [x + width, y + height],\n        [x, y + height],\n    ];\n    return polygon(points, o);\n}\nexport function curve(inputPoints, o) {\n    if (inputPoints.length) {\n        const p1 = inputPoints[0];\n        const pointsList = (typeof p1[0] === 'number') ? [inputPoints] : inputPoints;\n        const o1 = _curveWithOffset(pointsList[0], 1 * (1 + o.roughness * 0.2), o);\n        const o2 = o.disableMultiStroke ? [] : _curveWithOffset(pointsList[0], 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n        for (let i = 1; i < pointsList.length; i++) {\n            const points = pointsList[i];\n            if (points.length) {\n                const underlay = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n                const overlay = o.disableMultiStroke ? [] : _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n                for (const item of underlay) {\n                    if (item.op !== 'move') {\n                        o1.push(item);\n                    }\n                }\n                for (const item of overlay) {\n                    if (item.op !== 'move') {\n                        o2.push(item);\n                    }\n                }\n            }\n        }\n        return { type: 'path', ops: o1.concat(o2) };\n    }\n    return { type: 'path', ops: [] };\n}\nexport function ellipse(x, y, width, height, o) {\n    const params = generateEllipseParams(width, height, o);\n    return ellipseWithParams(x, y, o, params).opset;\n}\nexport function generateEllipseParams(width, height, o) {\n    const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n    const stepCount = Math.ceil(Math.max(o.curveStepCount, (o.curveStepCount / Math.sqrt(200)) * psq));\n    const increment = (Math.PI * 2) / stepCount;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    const curveFitRandomness = 1 - o.curveFitting;\n    rx += _offsetOpt(rx * curveFitRandomness, o);\n    ry += _offsetOpt(ry * curveFitRandomness, o);\n    return { increment, rx, ry };\n}\nexport function ellipseWithParams(x, y, o, ellipseParams) {\n    const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n    let o1 = _curve(ap1, null, o);\n    if ((!o.disableMultiStroke) && (o.roughness !== 0)) {\n        const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n        const o2 = _curve(ap2, null, o);\n        o1 = o1.concat(o2);\n    }\n    return {\n        estimatedPoints: cp1,\n        opset: { type: 'path', ops: o1 },\n    };\n}\nexport function arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n    const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n    const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n    if (!o.disableMultiStroke) {\n        const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n        ops.push(...o2);\n    }\n    if (closed) {\n        if (roughClosure) {\n            ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n        }\n        else {\n            ops.push({ op: 'lineTo', data: [cx, cy] }, { op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n        }\n    }\n    return { type: 'path', ops };\n}\nexport function svgPath(path, o) {\n    const segments = normalize(absolutize(parsePath(path)));\n    const ops = [];\n    let first = [0, 0];\n    let current = [0, 0];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M': {\n                current = [data[0], data[1]];\n                first = [data[0], data[1]];\n                break;\n            }\n            case 'L':\n                ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o));\n                current = [data[0], data[1]];\n                break;\n            case 'C': {\n                const [x1, y1, x2, y2, x, y] = data;\n                ops.push(..._bezierTo(x1, y1, x2, y2, x, y, current, o));\n                current = [x, y];\n                break;\n            }\n            case 'Z':\n                ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o));\n                current = [first[0], first[1]];\n                break;\n        }\n    }\n    return { type: 'path', ops };\n}\n// Fills\nexport function solidFillPolygon(polygonList, o) {\n    const ops = [];\n    for (const points of polygonList) {\n        if (points.length) {\n            const offset = o.maxRandomnessOffset || 0;\n            const len = points.length;\n            if (len > 2) {\n                ops.push({ op: 'move', data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)] });\n                for (let i = 1; i < len; i++) {\n                    ops.push({ op: 'lineTo', data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)] });\n                }\n            }\n        }\n    }\n    return { type: 'fillPath', ops };\n}\nexport function patternFillPolygons(polygonList, o) {\n    return getFiller(o, helper).fillPolygons(polygonList, o);\n}\nexport function patternFillArc(x, y, width, height, start, stop, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const increment = (stp - strt) / o.curveStepCount;\n    const points = [];\n    for (let angle = strt; angle <= stp; angle = angle + increment) {\n        points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n    }\n    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n    points.push([cx, cy]);\n    return patternFillPolygons([points], o);\n}\nexport function randOffset(x, o) {\n    return _offsetOpt(x, o);\n}\nexport function randOffsetWithRange(min, max, o) {\n    return _offset(min, max, o);\n}\nexport function doubleLineFillOps(x1, y1, x2, y2, o) {\n    return _doubleLine(x1, y1, x2, y2, o, true);\n}\n// Private helpers\nfunction cloneOptionsAlterSeed(ops) {\n    const result = Object.assign({}, ops);\n    result.randomizer = undefined;\n    if (ops.seed) {\n        result.seed = ops.seed + 1;\n    }\n    return result;\n}\nfunction random(ops) {\n    if (!ops.randomizer) {\n        ops.randomizer = new Random(ops.seed || 0);\n    }\n    return ops.randomizer.next();\n}\nfunction _offset(min, max, ops, roughnessGain = 1) {\n    return ops.roughness * roughnessGain * ((random(ops) * (max - min)) + min);\n}\nfunction _offsetOpt(x, ops, roughnessGain = 1) {\n    return _offset(-x, x, ops, roughnessGain);\n}\nfunction _doubleLine(x1, y1, x2, y2, o, filling = false) {\n    const singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;\n    const o1 = _line(x1, y1, x2, y2, o, true, false);\n    if (singleStroke) {\n        return o1;\n    }\n    const o2 = _line(x1, y1, x2, y2, o, true, true);\n    return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n    const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n    const length = Math.sqrt(lengthSq);\n    let roughnessGain = 1;\n    if (length < 200) {\n        roughnessGain = 1;\n    }\n    else if (length > 500) {\n        roughnessGain = 0.4;\n    }\n    else {\n        roughnessGain = (-0.0016668) * length + 1.233334;\n    }\n    let offset = o.maxRandomnessOffset || 0;\n    if ((offset * offset * 100) > lengthSq) {\n        offset = length / 10;\n    }\n    const halfOffset = offset / 2;\n    const divergePoint = 0.2 + random(o) * 0.2;\n    let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n    let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n    midDispX = _offsetOpt(midDispX, o, roughnessGain);\n    midDispY = _offsetOpt(midDispY, o, roughnessGain);\n    const ops = [];\n    const randomHalf = () => _offsetOpt(halfOffset, o, roughnessGain);\n    const randomFull = () => _offsetOpt(offset, o, roughnessGain);\n    const preserveVertices = o.preserveVertices;\n    if (move) {\n        if (overlay) {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : randomHalf()),\n                    y1 + (preserveVertices ? 0 : randomHalf()),\n                ],\n            });\n        }\n        else {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                    y1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                ],\n            });\n        }\n    }\n    if (overlay) {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(),\n                x2 + (preserveVertices ? 0 : randomHalf()),\n                y2 + (preserveVertices ? 0 : randomHalf()),\n            ],\n        });\n    }\n    else {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomFull(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(),\n                x2 + (preserveVertices ? 0 : randomFull()),\n                y2 + (preserveVertices ? 0 : randomFull()),\n            ],\n        });\n    }\n    return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n    if (!points.length) {\n        return [];\n    }\n    const ps = [];\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    for (let i = 1; i < points.length; i++) {\n        ps.push([\n            points[i][0] + _offsetOpt(offset, o),\n            points[i][1] + _offsetOpt(offset, o),\n        ]);\n        if (i === (points.length - 1)) {\n            ps.push([\n                points[i][0] + _offsetOpt(offset, o),\n                points[i][1] + _offsetOpt(offset, o),\n            ]);\n        }\n    }\n    return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n    const len = points.length;\n    const ops = [];\n    if (len > 3) {\n        const b = [];\n        const s = 1 - o.curveTightness;\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        for (let i = 1; (i + 2) < len; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n        }\n        if (closePoint && closePoint.length === 2) {\n            const ro = o.maxRandomnessOffset;\n            ops.push({ op: 'lineTo', data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)] });\n        }\n    }\n    else if (len === 3) {\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                points[1][0], points[1][1],\n                points[2][0], points[2][1],\n                points[2][0], points[2][1],\n            ],\n        });\n    }\n    else if (len === 2) {\n        ops.push(..._line(points[0][0], points[0][1], points[1][0], points[1][1], o, true, true));\n    }\n    return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n    const coreOnly = o.roughness === 0;\n    const corePoints = [];\n    const allPoints = [];\n    if (coreOnly) {\n        increment = increment / 4;\n        allPoints.push([\n            cx + rx * Math.cos(-increment),\n            cy + ry * Math.sin(-increment),\n        ]);\n        for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {\n            const p = [\n                cx + rx * Math.cos(angle),\n                cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            cx + rx * Math.cos(0),\n            cy + ry * Math.sin(0),\n        ]);\n        allPoints.push([\n            cx + rx * Math.cos(increment),\n            cy + ry * Math.sin(increment),\n        ]);\n    }\n    else {\n        const radOffset = _offsetOpt(0.5, o) - (Math.PI / 2);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n        ]);\n        const endAngle = Math.PI * 2 + radOffset - 0.01;\n        for (let angle = radOffset; angle < endAngle; angle = angle + increment) {\n            const p = [\n                _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n                _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n            _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5),\n        ]);\n    }\n    return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n    const radOffset = strt + _offsetOpt(0.1, o);\n    const points = [];\n    points.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n    ]);\n    for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n        points.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n        ]);\n    }\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, current, o) {\n    const ops = [];\n    const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];\n    let f = [0, 0];\n    const iterations = o.disableMultiStroke ? 1 : 2;\n    const preserveVertices = o.preserveVertices;\n    for (let i = 0; i < iterations; i++) {\n        if (i === 0) {\n            ops.push({ op: 'move', data: [current[0], current[1]] });\n        }\n        else {\n            ops.push({ op: 'move', data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o))] });\n        }\n        f = preserveVertices ? [x, y] : [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o),\n                x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o),\n                f[0], f[1],\n            ],\n        });\n    }\n    return ops;\n}\n", "function clone(p) {\n    return [...p];\n}\nexport function curveToBezier(pointsIn, curveTightness = 0) {\n    const len = pointsIn.length;\n    if (len < 3) {\n        throw new Error('A curve must have at least three points.');\n    }\n    const out = [];\n    if (len === 3) {\n        out.push(clone(pointsIn[0]), clone(pointsIn[1]), clone(pointsIn[2]), clone(pointsIn[2]));\n    }\n    else {\n        const points = [];\n        points.push(pointsIn[0], pointsIn[0]);\n        for (let i = 1; i < pointsIn.length; i++) {\n            points.push(pointsIn[i]);\n            if (i === (pointsIn.length - 1)) {\n                points.push(pointsIn[i]);\n            }\n        }\n        const b = [];\n        const s = 1 - curveTightness;\n        out.push(clone(points[0]));\n        for (let i = 1; (i + 2) < points.length; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            out.push(b[1], b[2], b[3]);\n        }\n    }\n    return out;\n}\n", "// distance between 2 points\nfunction distance(p1, p2) {\n    return Math.sqrt(distanceSq(p1, p2));\n}\n// distance between 2 points squared\nfunction distanceSq(p1, p2) {\n    return Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2);\n}\n// Sistance squared from a point p to the line segment vw\nfunction distanceToSegmentSq(p, v, w) {\n    const l2 = distanceSq(v, w);\n    if (l2 === 0) {\n        return distanceSq(p, v);\n    }\n    let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n    t = Math.max(0, Math.min(1, t));\n    return distanceSq(p, lerp(v, w, t));\n}\nfunction lerp(a, b, t) {\n    return [\n        a[0] + (b[0] - a[0]) * t,\n        a[1] + (b[1] - a[1]) * t,\n    ];\n}\n// Adapted from https://seant23.wordpress.com/2010/11/12/offset-bezier-curves/\nfunction flatness(points, offset) {\n    const p1 = points[offset + 0];\n    const p2 = points[offset + 1];\n    const p3 = points[offset + 2];\n    const p4 = points[offset + 3];\n    let ux = 3 * p2[0] - 2 * p1[0] - p4[0];\n    ux *= ux;\n    let uy = 3 * p2[1] - 2 * p1[1] - p4[1];\n    uy *= uy;\n    let vx = 3 * p3[0] - 2 * p4[0] - p1[0];\n    vx *= vx;\n    let vy = 3 * p3[1] - 2 * p4[1] - p1[1];\n    vy *= vy;\n    if (ux < vx) {\n        ux = vx;\n    }\n    if (uy < vy) {\n        uy = vy;\n    }\n    return ux + uy;\n}\nfunction getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints) {\n    const outPoints = newPoints || [];\n    if (flatness(points, offset) < tolerance) {\n        const p0 = points[offset + 0];\n        if (outPoints.length) {\n            const d = distance(outPoints[outPoints.length - 1], p0);\n            if (d > 1) {\n                outPoints.push(p0);\n            }\n        }\n        else {\n            outPoints.push(p0);\n        }\n        outPoints.push(points[offset + 3]);\n    }\n    else {\n        // subdivide\n        const t = .5;\n        const p1 = points[offset + 0];\n        const p2 = points[offset + 1];\n        const p3 = points[offset + 2];\n        const p4 = points[offset + 3];\n        const q1 = lerp(p1, p2, t);\n        const q2 = lerp(p2, p3, t);\n        const q3 = lerp(p3, p4, t);\n        const r1 = lerp(q1, q2, t);\n        const r2 = lerp(q2, q3, t);\n        const red = lerp(r1, r2, t);\n        getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);\n        getPointsOnBezierCurveWithSplitting([red, r2, q3, p4], 0, tolerance, outPoints);\n    }\n    return outPoints;\n}\nexport function simplify(points, distance) {\n    return simplifyPoints(points, 0, points.length, distance);\n}\n// Ramer–Douglas–Peucker algorithm\n// https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\nfunction simplifyPoints(points, start, end, epsilon, newPoints) {\n    const outPoints = newPoints || [];\n    // find the most distance point from the endpoints\n    const s = points[start];\n    const e = points[end - 1];\n    let maxDistSq = 0;\n    let maxNdx = 1;\n    for (let i = start + 1; i < end - 1; ++i) {\n        const distSq = distanceToSegmentSq(points[i], s, e);\n        if (distSq > maxDistSq) {\n            maxDistSq = distSq;\n            maxNdx = i;\n        }\n    }\n    // if that point is too far, split\n    if (Math.sqrt(maxDistSq) > epsilon) {\n        simplifyPoints(points, start, maxNdx + 1, epsilon, outPoints);\n        simplifyPoints(points, maxNdx, end, epsilon, outPoints);\n    }\n    else {\n        if (!outPoints.length) {\n            outPoints.push(s);\n        }\n        outPoints.push(e);\n    }\n    return outPoints;\n}\nexport function pointsOnBezierCurves(points, tolerance = 0.15, distance) {\n    const newPoints = [];\n    const numSegments = (points.length - 1) / 3;\n    for (let i = 0; i < numSegments; i++) {\n        const offset = i * 3;\n        getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints);\n    }\n    if (distance && distance > 0) {\n        return simplifyPoints(newPoints, 0, newPoints.length, distance);\n    }\n    return newPoints;\n}\n", "import { pointsOnBezierCurves, simplify } from 'points-on-curve';\nimport { parsePath, absolutize, normalize } from 'path-data-parser';\nexport function pointsOnPath(path, tolerance, distance) {\n    const segments = parsePath(path);\n    const normalized = normalize(absolutize(segments));\n    const sets = [];\n    let currentPoints = [];\n    let start = [0, 0];\n    let pendingCurve = [];\n    const appendPendingCurve = () => {\n        if (pendingCurve.length >= 4) {\n            currentPoints.push(...pointsOnBezierCurves(pendingCurve, tolerance));\n        }\n        pendingCurve = [];\n    };\n    const appendPendingPoints = () => {\n        appendPendingCurve();\n        if (currentPoints.length) {\n            sets.push(currentPoints);\n            currentPoints = [];\n        }\n    };\n    for (const { key, data } of normalized) {\n        switch (key) {\n            case 'M':\n                appendPendingPoints();\n                start = [data[0], data[1]];\n                currentPoints.push(start);\n                break;\n            case 'L':\n                appendPendingCurve();\n                currentPoints.push([data[0], data[1]]);\n                break;\n            case 'C':\n                if (!pendingCurve.length) {\n                    const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start;\n                    pendingCurve.push([lastPoint[0], lastPoint[1]]);\n                }\n                pendingCurve.push([data[0], data[1]]);\n                pendingCurve.push([data[2], data[3]]);\n                pendingCurve.push([data[4], data[5]]);\n                break;\n            case 'Z':\n                appendPendingCurve();\n                currentPoints.push([start[0], start[1]]);\n                break;\n        }\n    }\n    appendPendingPoints();\n    if (!distance) {\n        return sets;\n    }\n    const out = [];\n    for (const set of sets) {\n        const simplifiedSet = simplify(set, distance);\n        if (simplifiedSet.length) {\n            out.push(simplifiedSet);\n        }\n    }\n    return out;\n}\n", "import { line, solidFillPolygon, patternFillPolygons, rectangle, ellipseWithParams, generateEllipseParams, linearPath, arc, patternFillArc, curve, svgPath } from './renderer.js';\nimport { randomSeed } from './math.js';\nimport { curveToBezier } from 'points-on-curve/lib/curve-to-bezier.js';\nimport { pointsOnBezierCurves } from 'points-on-curve';\nimport { pointsOnPath } from 'points-on-path';\nconst NOS = 'none';\nexport class RoughGenerator {\n    constructor(config) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveFitting: 0.95,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1,\n            dashOffset: -1,\n            dashGap: -1,\n            zigzagOffset: -1,\n            seed: 0,\n            disableMultiStroke: false,\n            disableMultiStrokeFill: false,\n            preserveVertices: false,\n            fillShapeRoughnessGain: 0.8,\n        };\n        this.config = config || {};\n        if (this.config.options) {\n            this.defaultOptions = this._o(this.config.options);\n        }\n    }\n    static newSeed() {\n        return randomSeed();\n    }\n    _o(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _d(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._o(options);\n        return this._d('line', [line(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = rectangle(x, y, width, height, o);\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([points], o));\n            }\n            else {\n                paths.push(patternFillPolygons([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const ellipseParams = generateEllipseParams(width, height, o);\n        const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillPolygons([ellipseResponse.estimatedPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(ellipseResponse.opset);\n        }\n        return this._d('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._o(options);\n        return this._d('linearPath', [linearPath(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = arc(x, y, width, height, start, stop, closed, true, o);\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const fillOptions = Object.assign({}, o);\n                fillOptions.disableMultiStroke = true;\n                const shape = arc(x, y, width, height, start, stop, true, false, fillOptions);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = curve(points, o);\n        if (o.fill && o.fill !== NOS) {\n            if (o.fillStyle === 'solid') {\n                const fillShape = curve(points, Object.assign(Object.assign({}, o), { disableMultiStroke: true, roughness: o.roughness ? (o.roughness + o.fillShapeRoughnessGain) : 0 }));\n                paths.push({\n                    type: 'fillPath',\n                    ops: this._mergedShape(fillShape.ops),\n                });\n            }\n            else {\n                const polyPoints = [];\n                const inputPoints = points;\n                if (inputPoints.length) {\n                    const p1 = inputPoints[0];\n                    const pointsList = (typeof p1[0] === 'number') ? [inputPoints] : inputPoints;\n                    for (const points of pointsList) {\n                        if (points.length < 3) {\n                            polyPoints.push(...points);\n                        }\n                        else if (points.length === 3) {\n                            polyPoints.push(...pointsOnBezierCurves(curveToBezier([\n                                points[0],\n                                points[0],\n                                points[1],\n                                points[2],\n                            ]), 10, (1 + o.roughness) / 2));\n                        }\n                        else {\n                            polyPoints.push(...pointsOnBezierCurves(curveToBezier(points), 10, (1 + o.roughness) / 2));\n                        }\n                    }\n                }\n                if (polyPoints.length) {\n                    paths.push(patternFillPolygons([polyPoints], o));\n                }\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('curve', paths, o);\n    }\n    polygon(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = linearPath(points, true, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([points], o));\n            }\n            else {\n                paths.push(patternFillPolygons([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._o(options);\n        const paths = [];\n        if (!d) {\n            return this._d('path', paths, o);\n        }\n        d = (d || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n        const hasFill = o.fill && o.fill !== 'transparent' && o.fill !== NOS;\n        const hasStroke = o.stroke !== NOS;\n        const simplified = !!(o.simplification && (o.simplification < 1));\n        const distance = simplified ? (4 - 4 * (o.simplification || 1)) : ((1 + o.roughness) / 2);\n        const sets = pointsOnPath(d, 1, distance);\n        const shape = svgPath(d, o);\n        if (hasFill) {\n            if (o.fillStyle === 'solid') {\n                if (sets.length === 1) {\n                    const fillShape = svgPath(d, Object.assign(Object.assign({}, o), { disableMultiStroke: true, roughness: o.roughness ? (o.roughness + o.fillShapeRoughnessGain) : 0 }));\n                    paths.push({\n                        type: 'fillPath',\n                        ops: this._mergedShape(fillShape.ops),\n                    });\n                }\n                else {\n                    paths.push(solidFillPolygon(sets, o));\n                }\n            }\n            else {\n                paths.push(patternFillPolygons(sets, o));\n            }\n        }\n        if (hasStroke) {\n            if (simplified) {\n                sets.forEach((set) => {\n                    paths.push(linearPath(set, false, o));\n                });\n            }\n            else {\n                paths.push(shape);\n            }\n        }\n        return this._d('path', paths, o);\n    }\n    opsToPath(drawing, fixedDecimals) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: NOS,\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS,\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || NOS,\n            strokeWidth: fweight,\n            fill: NOS,\n        };\n    }\n    _mergedShape(input) {\n        return input.filter((d, i) => {\n            if (i === 0) {\n                return true;\n            }\n            if (d.op === 'move') {\n                return false;\n            }\n            return true;\n        });\n    }\n}\n", "import { randomSeed } from 'roughjs/bin/math';\nimport { line, ellipse, linearPath, rectangle } from 'roughjs/bin/renderer';\nimport { RoughGenerator } from 'roughjs/bin/generator';\n\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nconst DEFAULT_ANIMATION_DURATION = 800;\n\nlet defaultOptions = null;\nfunction getDefaultOptions() {\n  if (!defaultOptions) {\n    const gen = new RoughGenerator();\n    defaultOptions = gen.defaultOptions;\n  }\n  return defaultOptions;\n}\nfunction getOptions(type, seed, overrides) {\n  return {\n    ...getDefaultOptions(),\n    maxRandomnessOffset: 2,\n    roughness: type === \"highlight\" ? 3 : 1.5,\n    bowing: 1,\n    stroke: \"#000\",\n    strokeWidth: 1.5,\n    curveTightness: 0,\n    curveFitting: 0.95,\n    curveStepCount: 9,\n    fillStyle: \"hachure\",\n    fillWeight: -1,\n    hachureAngle: -41,\n    hachureGap: -1,\n    dashOffset: -1,\n    dashGap: -1,\n    zigzagOffset: -1,\n    // combineNestedSvgPaths: false,\n    disableMultiStroke: type !== \"double\",\n    disableMultiStrokeFill: false,\n    seed,\n    ...overrides\n  };\n}\nfunction parsePadding(config) {\n  const p = config.padding;\n  if (p || p === 0) {\n    if (typeof p === \"number\") {\n      return [p, p, p, p];\n    } else if (Array.isArray(p)) {\n      const pa = p;\n      if (pa.length) {\n        switch (pa.length) {\n          case 4:\n            return [...pa];\n          case 1:\n            return [pa[0], pa[0], pa[0], pa[0]];\n          case 2:\n            return [...pa, ...pa];\n          case 3:\n            return [...pa, pa[1]];\n          default:\n            return [pa[0], pa[1], pa[2], pa[3]];\n        }\n      }\n    }\n  }\n  return [5, 5, 5, 5];\n}\nfunction renderAnnotation(svg, rect, config, animationGroupDelay, animationDuration, seed) {\n  const opList = [];\n  let strokeWidth = config.strokeWidth || 2;\n  const padding = parsePadding(config);\n  const animate = config.animate === void 0 ? true : !!config.animate;\n  const iterations = config.iterations || 2;\n  const rtl = config.rtl ? 1 : 0;\n  const o = getOptions(\"single\", seed, config);\n  switch (config.type) {\n    case \"underline\": {\n      const y = rect.y + rect.h + padding[2];\n      for (let i = rtl; i < iterations + rtl; i++) {\n        if (i % 2)\n          opList.push(line(rect.x + rect.w, y, rect.x, y, o));\n        else\n          opList.push(line(rect.x, y, rect.x + rect.w, y, o));\n      }\n      break;\n    }\n    case \"strike-through\": {\n      const y = rect.y + rect.h / 2;\n      for (let i = rtl; i < iterations + rtl; i++) {\n        if (i % 2)\n          opList.push(line(rect.x + rect.w, y, rect.x, y, o));\n        else\n          opList.push(line(rect.x, y, rect.x + rect.w, y, o));\n      }\n      break;\n    }\n    case \"box\": {\n      const x = rect.x - padding[3];\n      const y = rect.y - padding[0];\n      const width = rect.w + (padding[1] + padding[3]);\n      const height = rect.h + (padding[0] + padding[2]);\n      for (let i = 0; i < iterations; i++)\n        opList.push(rectangle(x, y, width, height, o));\n      break;\n    }\n    case \"bracket\": {\n      const brackets = Array.isArray(config.brackets) ? config.brackets : config.brackets ? [config.brackets] : [\"right\"];\n      const lx = rect.x - padding[3] * 2;\n      const rx = rect.x + rect.w + padding[1] * 2;\n      const ty = rect.y - padding[0] * 2;\n      const by = rect.y + rect.h + padding[2] * 2;\n      for (const br of brackets) {\n        let points;\n        switch (br) {\n          case \"bottom\":\n            points = [\n              [lx, rect.y + rect.h],\n              [lx, by],\n              [rx, by],\n              [rx, rect.y + rect.h]\n            ];\n            break;\n          case \"top\":\n            points = [\n              [lx, rect.y],\n              [lx, ty],\n              [rx, ty],\n              [rx, rect.y]\n            ];\n            break;\n          case \"left\":\n            points = [\n              [rect.x, ty],\n              [lx, ty],\n              [lx, by],\n              [rect.x, by]\n            ];\n            break;\n          case \"right\":\n            points = [\n              [rect.x + rect.w, ty],\n              [rx, ty],\n              [rx, by],\n              [rect.x + rect.w, by]\n            ];\n            break;\n        }\n        if (points)\n          opList.push(linearPath(points, false, o));\n      }\n      break;\n    }\n    case \"crossed-off\": {\n      const x = rect.x;\n      const y = rect.y;\n      const x2 = x + rect.w;\n      const y2 = y + rect.h;\n      for (let i = rtl; i < iterations + rtl; i++) {\n        if (i % 2)\n          opList.push(line(x2, y2, x, y, o));\n        else\n          opList.push(line(x, y, x2, y2, o));\n      }\n      for (let i = rtl; i < iterations + rtl; i++) {\n        if (i % 2)\n          opList.push(line(x, y2, x2, y, o));\n        else\n          opList.push(line(x2, y, x, y2, o));\n      }\n      break;\n    }\n    case \"circle\": {\n      const doubleO = getOptions(\"double\", seed, config);\n      const width = rect.w + (padding[1] + padding[3]);\n      const height = rect.h + (padding[0] + padding[2]);\n      const x = rect.x - padding[3] + width / 2;\n      const y = rect.y - padding[0] + height / 2;\n      const fullItr = Math.floor(iterations / 2);\n      const singleItr = iterations - fullItr * 2;\n      for (let i = 0; i < fullItr; i++)\n        opList.push(ellipse(x, y, width, height, doubleO));\n      for (let i = 0; i < singleItr; i++)\n        opList.push(ellipse(x, y, width, height, o));\n      break;\n    }\n    case \"highlight\": {\n      const o2 = getOptions(\"highlight\", seed, config);\n      strokeWidth = rect.h * 0.95;\n      const y = rect.y + rect.h / 2;\n      for (let i = rtl; i < iterations + rtl; i++) {\n        if (i % 2)\n          opList.push(line(rect.x + rect.w, y, rect.x, y, o2));\n        else\n          opList.push(line(rect.x, y, rect.x + rect.w, y, o2));\n      }\n      break;\n    }\n  }\n  if (opList.length) {\n    const pathStrings = opsToPath(opList);\n    const lengths = [];\n    const pathElements = [];\n    let totalLength = 0;\n    const setAttr = (p, an, av) => p.setAttribute(an, av);\n    for (const d of pathStrings) {\n      const path = document.createElementNS(SVG_NS, \"path\");\n      setAttr(path, \"d\", d);\n      setAttr(path, \"fill\", \"none\");\n      setAttr(path, \"stroke\", config.color || \"currentColor\");\n      setAttr(path, \"stroke-width\", `${strokeWidth}`);\n      if (config.opacity !== void 0)\n        setAttr(path, \"style\", `opacity:${config.opacity}`);\n      if (animate) {\n        const length = path.getTotalLength();\n        lengths.push(length);\n        totalLength += length;\n      }\n      svg.appendChild(path);\n      pathElements.push(path);\n    }\n    if (animate) {\n      let durationOffset = 0;\n      for (let i = 0; i < pathElements.length; i++) {\n        const path = pathElements[i];\n        const length = lengths[i];\n        const duration = totalLength ? animationDuration * (length / totalLength) : 0;\n        const delay = animationGroupDelay + durationOffset;\n        const style = path.style;\n        style.strokeDashoffset = `${length}`;\n        style.strokeDasharray = `${length}`;\n        style.animation = `rough-notation-dash ${duration}ms ease-out ${delay}ms forwards`;\n        durationOffset += duration;\n      }\n      return sleep(animationDuration + animationGroupDelay);\n    }\n  }\n  return sleep(0);\n}\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction opsToPath(opList) {\n  const paths = [];\n  for (const drawing of opList) {\n    let path = \"\";\n    for (const item of drawing.ops) {\n      const data = item.data;\n      switch (item.op) {\n        case \"move\":\n          if (path.trim())\n            paths.push(path.trim());\n          path = `M${data[0]} ${data[1]} `;\n          break;\n        case \"bcurveTo\":\n          path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n          break;\n        case \"lineTo\":\n          path += `L${data[0]} ${data[1]} `;\n          break;\n      }\n    }\n    if (path.trim())\n      paths.push(path.trim());\n  }\n  return paths;\n}\n\nfunction ensureKeyframes() {\n  if (!window.__rno_kf_s) {\n    const style = window.__rno_kf_s = document.createElement(\"style\");\n    style.textContent = `@keyframes rough-notation-dash { to { stroke-dashoffset: 0; } }`;\n    document.head.appendChild(style);\n  }\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass RoughAnnotationImpl {\n  constructor(e, config) {\n    __publicField(this, \"_state\", \"unattached\");\n    __publicField(this, \"_config\");\n    __publicField(this, \"_resizing\", false);\n    __publicField(this, \"_ro\");\n    // ResizeObserver is not supported in typescript std lib yet\n    __publicField(this, \"_seed\", randomSeed());\n    __publicField(this, \"_e\");\n    __publicField(this, \"_svg\");\n    __publicField(this, \"_lastSizes\", []);\n    __publicField(this, \"_animationDelay\", 0);\n    __publicField(this, \"_resizeListener\", () => {\n      if (!this._resizing) {\n        this._resizing = true;\n        setTimeout(() => {\n          this._resizing = false;\n          if (this._state === \"showing\") {\n            if (this.haveRectsChanged())\n              this.show();\n          }\n        }, 400);\n      }\n    });\n    __publicField(this, \"pendingRefresh\");\n    this._e = e;\n    this._config = JSON.parse(JSON.stringify(config));\n    this.attach();\n  }\n  getConfig(key) {\n    return this._config[key];\n  }\n  setConfig(key, value) {\n    if (this._config[key] !== value) {\n      this._config[key] = value;\n      this.refresh();\n    }\n  }\n  get animate() {\n    return this._config.animate;\n  }\n  set animate(value) {\n    this._config.animate = value;\n  }\n  get animationDuration() {\n    return this._config.animationDuration;\n  }\n  set animationDuration(value) {\n    this._config.animationDuration = value;\n  }\n  get iterations() {\n    return this._config.iterations;\n  }\n  set iterations(value) {\n    this._config.iterations = value;\n  }\n  get color() {\n    return this._config.color;\n  }\n  set color(value) {\n    if (this._config.color !== value) {\n      this._config.color = value;\n      this.refresh();\n    }\n  }\n  get class() {\n    return this._config.class;\n  }\n  set class(value) {\n    if (this._config.class !== value) {\n      this._config.class = value;\n      if (this._svg)\n        this._svg.setAttribute(\"class\", [\"rough-annotation\", this._config.class || \"\"].filter(Boolean).join(\" \"));\n    }\n  }\n  get strokeWidth() {\n    return this._config.strokeWidth;\n  }\n  set strokeWidth(value) {\n    if (this._config.strokeWidth !== value) {\n      this._config.strokeWidth = value;\n      this.refresh();\n    }\n  }\n  get padding() {\n    return this._config.padding;\n  }\n  set padding(value) {\n    if (this._config.padding !== value) {\n      this._config.padding = value;\n      this.refresh();\n    }\n  }\n  attach() {\n    if (this._state === \"unattached\" && this._e.parentElement) {\n      ensureKeyframes();\n      const svg = this._svg = document.createElementNS(SVG_NS, \"svg\");\n      svg.setAttribute(\"class\", [\"rough-annotation\", this._config.class || \"\"].filter(Boolean).join(\" \"));\n      const style = svg.style;\n      style.position = \"absolute\";\n      style.top = \"0\";\n      style.left = \"0\";\n      style.overflow = \"visible\";\n      style.pointerEvents = \"none\";\n      style.width = \"100px\";\n      style.height = \"100px\";\n      const prepend = this._config.type === \"highlight\";\n      this._e.insertAdjacentElement(prepend ? \"beforebegin\" : \"afterend\", svg);\n      this._state = \"not-showing\";\n      if (prepend) {\n        const computedPos = window.getComputedStyle(this._e).position;\n        const unpositioned = !computedPos || computedPos === \"static\";\n        if (unpositioned)\n          this._e.style.position = \"relative\";\n      }\n      this.attachListeners();\n    }\n  }\n  detachListeners() {\n    window.removeEventListener(\"resize\", this._resizeListener);\n    if (this._ro)\n      this._ro.unobserve(this._e);\n  }\n  attachListeners() {\n    this.detachListeners();\n    window.addEventListener(\"resize\", this._resizeListener, { passive: true });\n    if (!this._ro && \"ResizeObserver\" in window) {\n      this._ro = new window.ResizeObserver((entries) => {\n        for (const entry of entries) {\n          if (entry.contentRect)\n            this._resizeListener();\n        }\n      });\n    }\n    if (this._ro)\n      this._ro.observe(this._e);\n  }\n  haveRectsChanged() {\n    if (this._lastSizes.length) {\n      const newRects = this.rects();\n      if (newRects.length === this._lastSizes.length) {\n        for (let i = 0; i < newRects.length; i++) {\n          if (!this.isSameRect(newRects[i], this._lastSizes[i]))\n            return true;\n        }\n      } else {\n        return true;\n      }\n    }\n    return false;\n  }\n  isSameRect(rect1, rect2) {\n    const si = (a, b) => Math.round(a) === Math.round(b);\n    return si(rect1.x, rect2.x) && si(rect1.y, rect2.y) && si(rect1.w, rect2.w) && si(rect1.h, rect2.h);\n  }\n  isShowing() {\n    return this._state !== \"not-showing\";\n  }\n  refresh() {\n    if (this.isShowing() && !this.pendingRefresh) {\n      this.pendingRefresh = Promise.resolve().then(() => {\n        if (this.isShowing())\n          this.show();\n        delete this.pendingRefresh;\n      });\n    }\n  }\n  async show() {\n    switch (this._state) {\n      case \"unattached\":\n        break;\n      case \"showing\":\n        this.hide();\n        if (this._svg)\n          await this.render(this._svg, true);\n        break;\n      case \"not-showing\":\n        this.attach();\n        if (this._svg)\n          await this.render(this._svg, false);\n        break;\n    }\n  }\n  hide() {\n    if (this._svg) {\n      while (this._svg.lastChild)\n        this._svg.removeChild(this._svg.lastChild);\n    }\n    this._state = \"not-showing\";\n  }\n  remove() {\n    if (this._svg && this._svg.parentElement)\n      this._svg.parentElement.removeChild(this._svg);\n    this._svg = void 0;\n    this._state = \"unattached\";\n    this.detachListeners();\n  }\n  async render(svg, ensureNoAnimation) {\n    let config = this._config;\n    if (ensureNoAnimation) {\n      config = JSON.parse(JSON.stringify(this._config));\n      config.animate = false;\n    }\n    const rects = this.rects();\n    let totalWidth = 0;\n    rects.forEach((rect) => totalWidth += rect.w);\n    const totalDuration = config.animationDuration || DEFAULT_ANIMATION_DURATION;\n    let delay = 0;\n    const promises = [];\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      const ad = totalDuration * (rect.w / totalWidth);\n      promises.push(\n        renderAnnotation(svg, rects[i], config, delay + this._animationDelay + (this._config.delay || 0), ad, this._seed)\n      );\n      delay += ad;\n    }\n    this._lastSizes = rects;\n    this._state = \"showing\";\n    return await Promise.all(promises);\n  }\n  rects() {\n    const ret = [];\n    if (this._svg) {\n      if (this._config.multiline) {\n        const elementRects = this._e.getClientRects();\n        for (let i = 0; i < elementRects.length; i++)\n          ret.push(this.svgRect(this._svg, elementRects[i]));\n      } else {\n        ret.push(this.svgRect(this._svg, this._e.getBoundingClientRect()));\n      }\n    }\n    return ret;\n  }\n  svgRect(svg, bounds) {\n    const rect1 = svg.getBoundingClientRect();\n    const rect2 = bounds;\n    return {\n      x: (rect2.x || rect2.left) - (rect1.x || rect1.left),\n      y: (rect2.y || rect2.top) - (rect1.y || rect1.top),\n      w: rect2.width,\n      h: rect2.height\n    };\n  }\n}\nfunction annotate(element, config) {\n  return new RoughAnnotationImpl(element, config);\n}\nfunction annotationGroup(annotations) {\n  let delay = 0;\n  for (const a of annotations) {\n    const ai = a;\n    ai._animationDelay = delay;\n    const duration = ai.animationDuration === 0 ? 0 : ai.animationDuration || DEFAULT_ANIMATION_DURATION;\n    delay += duration;\n  }\n  const list = [...annotations];\n  return {\n    show() {\n      for (const a of list)\n        a.show();\n    },\n    hide() {\n      for (const a of list)\n        a.hide();\n    }\n  };\n}\n\nexport { annotate, annotationGroup };\n"],
  "mappings": "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",
  "names": ["line", "polygon", "helper", "line", "line", "helper", "line", "helper", "line", "helper", "line", "helper", "curve", "r1", "r2", "distance", "distance", "points", "distance"]
}
