import {
  $,
  $window,
  AmbiguousCharacters,
  BugIndicatingError,
  CachedFunction,
  CancellationToken,
  CancellationTokenSource,
  ContextViewService,
  DebounceEmitter,
  DeferredPromise,
  Delayer,
  Dimension,
  Disposable,
  DisposableMap,
  DisposableStore,
  Emitter,
  Event,
  EventBufferer,
  EventHelper,
  EventType,
  FileAccess,
  GlobalIdleValue,
  GraphemeIterator,
  IInstantiationService,
  ILayoutService,
  IMMUTABLE_CODE_TO_KEY_CODE,
  ImmortalReference,
  IntervalTimer,
  InvisibleCharacters,
  Iterable,
  KeyChord,
  KeyCodeChord,
  KeyCodeUtils,
  Lazy,
  LinkedList,
  MicrotaskDelay,
  MicrotaskEmitter,
  ModifierKeyEmitter,
  MutableDisposable,
  NotSupportedError,
  OS,
  PauseableEmitter,
  Promises,
  Range,
  Relay,
  ResolvedChord,
  ResolvedKeybinding,
  RunOnceScheduler,
  Schemas,
  StandardKeyboardEvent,
  StandardMouseEvent,
  StandardWheelEvent,
  StopWatch,
  StringSHA1,
  ThrottledDelayer,
  TimeoutTimer,
  UNUSUAL_LINE_TERMINATORS,
  URI,
  UTF8_BOM_CHARACTER,
  WindowIntervalTimer,
  _util,
  addDisposableListener,
  addHook,
  addMatchMediaChangeListener,
  addStandardDisposableListener,
  after,
  animate,
  append,
  asCSSPropertyValue,
  asCSSUrl,
  asCssValueWithDefault,
  basename,
  basicMarkupHtmlTags,
  canceled,
  clearNode,
  combinedDisposable,
  compare,
  compareIgnoreCase,
  compareSubstring,
  compareSubstringIgnoreCase,
  containsRTL,
  containsUnusualLineTerminators,
  convertSimple2RegExpPattern,
  createCSSRule,
  createCancelablePromise,
  createDecorator,
  createRegExp,
  createSingleCallFunction,
  createStyleSheet,
  decodeKeybinding,
  dirname,
  disposableTimeout,
  dispose,
  doHash,
  equalsIgnoreCase,
  escape,
  escapeRegExpCharacters,
  extname,
  firstNonWhitespaceIndex,
  format,
  getActiveDocument,
  getActiveElement,
  getClientArea,
  getContentHeight,
  getContentWidth,
  getDomNodePagePosition,
  getDomNodeZoomLevel,
  getLeadingWhitespace,
  getNextCodePoint,
  getTopLeftOffset,
  getTotalHeight,
  getTotalWidth,
  getWindow,
  getZoomFactor,
  hasParentWithClass,
  hash,
  hookDomPurifyHrefAndSrcSanitizer,
  htmlAttributeEncodeValue,
  illegalArgument,
  illegalState,
  init_async,
  init_browser,
  init_cache,
  init_cancellation,
  init_dom,
  init_dompurify,
  init_errors,
  init_event,
  init_functional,
  init_hash,
  init_instantiation,
  init_iterator,
  init_keyCodes,
  init_keybindings,
  init_keyboardEvent,
  init_lazy,
  init_lifecycle,
  init_linkedList,
  init_mouseEvent,
  init_network,
  init_nls,
  init_path,
  init_platform,
  init_stopwatch,
  init_strings,
  init_symbols,
  init_uri,
  init_window,
  isActiveElement,
  isAncestor,
  isAncestorOfActiveElement,
  isBasicASCII,
  isCancellationError,
  isChrome,
  isChrome2,
  isDisposable,
  isEdge,
  isEmojiImprecise,
  isEventLike,
  isFalsyOrWhitespace,
  isFirefox,
  isFirefox2,
  isFullWidthCharacter,
  isHighSurrogate,
  isIOS,
  isInShadowDOM,
  isKeyboardEvent,
  isLinux,
  isLittleEndian,
  isMacintosh,
  isMobile,
  isMouseEvent,
  isSafari,
  isSafari2,
  isThenable,
  isUpperAsciiLetter,
  isWeb,
  isWebkitWebView,
  isWindows,
  lastNonWhitespaceIndex,
  layout,
  localize,
  ltrim,
  mainWindow,
  markAsSingleton,
  matchesScheme,
  matchesSomeScheme,
  normalize,
  onDidRegisterWindow,
  onUnexpectedError,
  onWillUnregisterWindow,
  posix,
  prepend,
  regExpLeadsToEndlessLoop,
  relative,
  removeHook,
  reset,
  resolve,
  rtrim,
  runWhenGlobalIdle,
  sanitize,
  scheduleAtNextAnimationFrame,
  sep,
  setTimeout0,
  show,
  singleLetterHash,
  splitLines,
  startsWithIgnoreCase,
  startsWithUTF8BOM,
  stringHash,
  timeout,
  toDisposable,
  trackFocus,
  transformErrorForSerialization,
  uriToFsPath,
  windowOpenNoOpener
} from "./chunk-IE4M7XMW.js";
import {
  SyncDescriptor,
  init_descriptors
} from "./chunk-OFESTM2N.js";
import {
  __esm
} from "./chunk-BYPFWIQ6.js";

// node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js
function createWordRegExp(allowInWords = "") {
  let source = "(-?\\d*\\.\\d\\w*)|([^";
  for (const sep2 of USUAL_WORD_SEPARATORS) {
    if (allowInWords.indexOf(sep2) >= 0) {
      continue;
    }
    source += "\\" + sep2;
  }
  source += "\\s]+)";
  return new RegExp(source, "g");
}
function ensureValidWordDefinition(wordDefinition) {
  let result = DEFAULT_WORD_REGEXP;
  if (wordDefinition && wordDefinition instanceof RegExp) {
    if (!wordDefinition.global) {
      let flags = "g";
      if (wordDefinition.ignoreCase) {
        flags += "i";
      }
      if (wordDefinition.multiline) {
        flags += "m";
      }
      if (wordDefinition.unicode) {
        flags += "u";
      }
      result = new RegExp(wordDefinition.source, flags);
    } else {
      result = wordDefinition;
    }
  }
  result.lastIndex = 0;
  return result;
}
function getWordAtText(column, wordDefinition, text, textOffset, config) {
  wordDefinition = ensureValidWordDefinition(wordDefinition);
  if (!config) {
    config = Iterable.first(_defaultConfig);
  }
  if (text.length > config.maxLen) {
    let start = column - config.maxLen / 2;
    if (start < 0) {
      start = 0;
    } else {
      textOffset += start;
    }
    text = text.substring(start, column + config.maxLen / 2);
    return getWordAtText(column, wordDefinition, text, textOffset, config);
  }
  const t1 = Date.now();
  const pos = column - 1 - textOffset;
  let prevRegexIndex = -1;
  let match2 = null;
  for (let i = 1; ; i++) {
    if (Date.now() - t1 >= config.timeBudget) {
      break;
    }
    const regexIndex = pos - config.windowSize * i;
    wordDefinition.lastIndex = Math.max(0, regexIndex);
    const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);
    if (!thisMatch && match2) {
      break;
    }
    match2 = thisMatch;
    if (regexIndex <= 0) {
      break;
    }
    prevRegexIndex = regexIndex;
  }
  if (match2) {
    const result = {
      word: match2[0],
      startColumn: textOffset + 1 + match2.index,
      endColumn: textOffset + 1 + match2.index + match2[0].length
    };
    wordDefinition.lastIndex = 0;
    return result;
  }
  return null;
}
function _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {
  let match2;
  while (match2 = wordDefinition.exec(text)) {
    const matchIndex = match2.index || 0;
    if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
      return match2;
    } else if (stopPos > 0 && matchIndex > stopPos) {
      return null;
    }
  }
  return null;
}
var USUAL_WORD_SEPARATORS, DEFAULT_WORD_REGEXP, _defaultConfig;
var init_wordHelper = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js"() {
    init_iterator();
    init_linkedList();
    USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
    DEFAULT_WORD_REGEXP = createWordRegExp();
    _defaultConfig = new LinkedList();
    _defaultConfig.unshift({
      maxLen: 1e3,
      windowSize: 15,
      timeBudget: 150
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js
function appendEntry(target, key, value) {
  if (target.has(key)) {
    target.get(key).push(value);
  } else {
    target.set(key, [value]);
  }
}
var IndentAction, StandardAutoClosingPairConditional, AutoClosingPairs;
var init_languageConfiguration = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js"() {
    (function(IndentAction3) {
      IndentAction3[IndentAction3["None"] = 0] = "None";
      IndentAction3[IndentAction3["Indent"] = 1] = "Indent";
      IndentAction3[IndentAction3["IndentOutdent"] = 2] = "IndentOutdent";
      IndentAction3[IndentAction3["Outdent"] = 3] = "Outdent";
    })(IndentAction || (IndentAction = {}));
    StandardAutoClosingPairConditional = class {
      constructor(source) {
        this._neutralCharacter = null;
        this._neutralCharacterSearched = false;
        this.open = source.open;
        this.close = source.close;
        this._inString = true;
        this._inComment = true;
        this._inRegEx = true;
        if (Array.isArray(source.notIn)) {
          for (let i = 0, len = source.notIn.length; i < len; i++) {
            const notIn = source.notIn[i];
            switch (notIn) {
              case "string":
                this._inString = false;
                break;
              case "comment":
                this._inComment = false;
                break;
              case "regex":
                this._inRegEx = false;
                break;
            }
          }
        }
      }
      isOK(standardToken) {
        switch (standardToken) {
          case 0:
            return true;
          case 1:
            return this._inComment;
          case 2:
            return this._inString;
          case 3:
            return this._inRegEx;
        }
      }
      shouldAutoClose(context, column) {
        if (context.getTokenCount() === 0) {
          return true;
        }
        const tokenIndex = context.findTokenIndexAtOffset(column - 2);
        const standardTokenType = context.getStandardTokenType(tokenIndex);
        return this.isOK(standardTokenType);
      }
      _findNeutralCharacterInRange(fromCharCode, toCharCode) {
        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {
          const character = String.fromCharCode(charCode);
          if (!this.open.includes(character) && !this.close.includes(character)) {
            return character;
          }
        }
        return null;
      }
      /**
       * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close
       */
      findNeutralCharacter() {
        if (!this._neutralCharacterSearched) {
          this._neutralCharacterSearched = true;
          if (!this._neutralCharacter) {
            this._neutralCharacter = this._findNeutralCharacterInRange(
              48,
              57
              /* CharCode.Digit9 */
            );
          }
          if (!this._neutralCharacter) {
            this._neutralCharacter = this._findNeutralCharacterInRange(
              97,
              122
              /* CharCode.z */
            );
          }
          if (!this._neutralCharacter) {
            this._neutralCharacter = this._findNeutralCharacterInRange(
              65,
              90
              /* CharCode.Z */
            );
          }
        }
        return this._neutralCharacter;
      }
    };
    AutoClosingPairs = class {
      constructor(autoClosingPairs) {
        this.autoClosingPairsOpenByStart = /* @__PURE__ */ new Map();
        this.autoClosingPairsOpenByEnd = /* @__PURE__ */ new Map();
        this.autoClosingPairsCloseByStart = /* @__PURE__ */ new Map();
        this.autoClosingPairsCloseByEnd = /* @__PURE__ */ new Map();
        this.autoClosingPairsCloseSingleChar = /* @__PURE__ */ new Map();
        for (const pair of autoClosingPairs) {
          appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);
          appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);
          appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);
          appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);
          if (pair.close.length === 1 && pair.open.length === 1) {
            appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);
          }
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js
function createScopedLineTokens(context, offset) {
  const tokenCount = context.getCount();
  const tokenIndex = context.findTokenIndexAtOffset(offset);
  const desiredLanguageId = context.getLanguageId(tokenIndex);
  let lastTokenIndex = tokenIndex;
  while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {
    lastTokenIndex++;
  }
  let firstTokenIndex = tokenIndex;
  while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {
    firstTokenIndex--;
  }
  return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));
}
function ignoreBracketsInToken(standardTokenType) {
  return (standardTokenType & 3) !== 0;
}
var ScopedLineTokens;
var init_supports = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js"() {
    ScopedLineTokens = class {
      constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {
        this._scopedLineTokensBrand = void 0;
        this._actual = actual;
        this.languageId = languageId;
        this._firstTokenIndex = firstTokenIndex;
        this._lastTokenIndex = lastTokenIndex;
        this.firstCharOffset = firstCharOffset;
        this._lastCharOffset = lastCharOffset;
      }
      getLineContent() {
        const actualLineContent = this._actual.getLineContent();
        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);
      }
      getActualLineContentBefore(offset) {
        const actualLineContent = this._actual.getLineContent();
        return actualLineContent.substring(0, this.firstCharOffset + offset);
      }
      getTokenCount() {
        return this._lastTokenIndex - this._firstTokenIndex;
      }
      findTokenIndexAtOffset(offset) {
        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;
      }
      getStandardTokenType(tokenIndex) {
        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js
var CharacterPairSupport;
var init_characterPair = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js"() {
    init_languageConfiguration();
    CharacterPairSupport = class _CharacterPairSupport {
      constructor(config) {
        if (config.autoClosingPairs) {
          this._autoClosingPairs = config.autoClosingPairs.map((el) => new StandardAutoClosingPairConditional(el));
        } else if (config.brackets) {
          this._autoClosingPairs = config.brackets.map((b) => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));
        } else {
          this._autoClosingPairs = [];
        }
        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {
          const docComment = config.__electricCharacterSupport.docComment;
          this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || "" }));
        }
        this._autoCloseBeforeForQuotes = typeof config.autoCloseBefore === "string" ? config.autoCloseBefore : _CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES;
        this._autoCloseBeforeForBrackets = typeof config.autoCloseBefore === "string" ? config.autoCloseBefore : _CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS;
        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;
      }
      getAutoClosingPairs() {
        return this._autoClosingPairs;
      }
      getAutoCloseBeforeSet(forQuotes) {
        return forQuotes ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets;
      }
      getSurroundingPairs() {
        return this._surroundingPairs;
      }
    };
    CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ";:.,=}])> \n	";
    CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = "'\"`;:.,=}])> \n	";
  }
});

// node_modules/monaco-editor/esm/vs/base/common/arrays.js
function tail(array, n = 0) {
  return array[array.length - (1 + n)];
}
function tail2(arr) {
  if (arr.length === 0) {
    throw new Error("Invalid tail call");
  }
  return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];
}
function equals(one, other, itemEquals = (a, b) => a === b) {
  if (one === other) {
    return true;
  }
  if (!one || !other) {
    return false;
  }
  if (one.length !== other.length) {
    return false;
  }
  for (let i = 0, len = one.length; i < len; i++) {
    if (!itemEquals(one[i], other[i])) {
      return false;
    }
  }
  return true;
}
function removeFastWithoutKeepingOrder(array, index) {
  const last = array.length - 1;
  if (index < last) {
    array[index] = array[last];
  }
  array.pop();
}
function binarySearch(array, key, comparator) {
  return binarySearch2(array.length, (i) => comparator(array[i], key));
}
function binarySearch2(length, compareToKey) {
  let low = 0, high = length - 1;
  while (low <= high) {
    const mid = (low + high) / 2 | 0;
    const comp = compareToKey(mid);
    if (comp < 0) {
      low = mid + 1;
    } else if (comp > 0) {
      high = mid - 1;
    } else {
      return mid;
    }
  }
  return -(low + 1);
}
function quickSelect(nth, data, compare2) {
  nth = nth | 0;
  if (nth >= data.length) {
    throw new TypeError("invalid index");
  }
  const pivotValue = data[Math.floor(data.length * Math.random())];
  const lower = [];
  const higher = [];
  const pivots = [];
  for (const value of data) {
    const val = compare2(value, pivotValue);
    if (val < 0) {
      lower.push(value);
    } else if (val > 0) {
      higher.push(value);
    } else {
      pivots.push(value);
    }
  }
  if (nth < lower.length) {
    return quickSelect(nth, lower, compare2);
  } else if (nth < lower.length + pivots.length) {
    return pivots[0];
  } else {
    return quickSelect(nth - (lower.length + pivots.length), higher, compare2);
  }
}
function groupBy(data, compare2) {
  const result = [];
  let currentGroup = void 0;
  for (const element of data.slice(0).sort(compare2)) {
    if (!currentGroup || compare2(currentGroup[0], element) !== 0) {
      currentGroup = [element];
      result.push(currentGroup);
    } else {
      currentGroup.push(element);
    }
  }
  return result;
}
function* groupAdjacentBy(items, shouldBeGrouped) {
  let currentGroup;
  let last;
  for (const item of items) {
    if (last !== void 0 && shouldBeGrouped(last, item)) {
      currentGroup.push(item);
    } else {
      if (currentGroup) {
        yield currentGroup;
      }
      currentGroup = [item];
    }
    last = item;
  }
  if (currentGroup) {
    yield currentGroup;
  }
}
function forEachAdjacent(arr, f) {
  for (let i = 0; i <= arr.length; i++) {
    f(i === 0 ? void 0 : arr[i - 1], i === arr.length ? void 0 : arr[i]);
  }
}
function forEachWithNeighbors(arr, f) {
  for (let i = 0; i < arr.length; i++) {
    f(i === 0 ? void 0 : arr[i - 1], arr[i], i + 1 === arr.length ? void 0 : arr[i + 1]);
  }
}
function coalesce(array) {
  return array.filter((e) => !!e);
}
function coalesceInPlace(array) {
  let to = 0;
  for (let i = 0; i < array.length; i++) {
    if (!!array[i]) {
      array[to] = array[i];
      to += 1;
    }
  }
  array.length = to;
}
function isFalsyOrEmpty(obj) {
  return !Array.isArray(obj) || obj.length === 0;
}
function isNonEmptyArray(obj) {
  return Array.isArray(obj) && obj.length > 0;
}
function distinct(array, keyFn = (value) => value) {
  const seen = /* @__PURE__ */ new Set();
  return array.filter((element) => {
    const key = keyFn(element);
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
}
function firstOrDefault(array, notFoundValue) {
  return array.length > 0 ? array[0] : notFoundValue;
}
function range(arg, to) {
  let from = typeof to === "number" ? arg : 0;
  if (typeof to === "number") {
    from = arg;
  } else {
    from = 0;
    to = arg;
  }
  const result = [];
  if (from <= to) {
    for (let i = from; i < to; i++) {
      result.push(i);
    }
  } else {
    for (let i = from; i > to; i--) {
      result.push(i);
    }
  }
  return result;
}
function arrayInsert(target, insertIndex, insertArr) {
  const before = target.slice(0, insertIndex);
  const after2 = target.slice(insertIndex);
  return before.concat(insertArr, after2);
}
function pushToStart(arr, value) {
  const index = arr.indexOf(value);
  if (index > -1) {
    arr.splice(index, 1);
    arr.unshift(value);
  }
}
function pushToEnd(arr, value) {
  const index = arr.indexOf(value);
  if (index > -1) {
    arr.splice(index, 1);
    arr.push(value);
  }
}
function pushMany(arr, items) {
  for (const item of items) {
    arr.push(item);
  }
}
function asArray(x) {
  return Array.isArray(x) ? x : [x];
}
function insertInto(array, start, newItems) {
  const startIdx = getActualStartIndex(array, start);
  const originalLength = array.length;
  const newItemsLength = newItems.length;
  array.length = originalLength + newItemsLength;
  for (let i = originalLength - 1; i >= startIdx; i--) {
    array[i + newItemsLength] = array[i];
  }
  for (let i = 0; i < newItemsLength; i++) {
    array[i + startIdx] = newItems[i];
  }
}
function splice(array, start, deleteCount, newItems) {
  const index = getActualStartIndex(array, start);
  let result = array.splice(index, deleteCount);
  if (result === void 0) {
    result = [];
  }
  insertInto(array, index, newItems);
  return result;
}
function getActualStartIndex(array, start) {
  return start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);
}
function compareBy(selector, comparator) {
  return (a, b) => comparator(selector(a), selector(b));
}
function tieBreakComparators(...comparators) {
  return (item1, item2) => {
    for (const comparator of comparators) {
      const result = comparator(item1, item2);
      if (!CompareResult.isNeitherLessOrGreaterThan(result)) {
        return result;
      }
    }
    return CompareResult.neitherLessOrGreaterThan;
  };
}
function reverseOrder(comparator) {
  return (a, b) => -comparator(a, b);
}
var CompareResult, numberComparator, booleanComparator, ArrayQueue, CallbackIterable;
var init_arrays = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/arrays.js"() {
    (function(CompareResult2) {
      function isLessThan(result) {
        return result < 0;
      }
      CompareResult2.isLessThan = isLessThan;
      function isLessThanOrEqual(result) {
        return result <= 0;
      }
      CompareResult2.isLessThanOrEqual = isLessThanOrEqual;
      function isGreaterThan(result) {
        return result > 0;
      }
      CompareResult2.isGreaterThan = isGreaterThan;
      function isNeitherLessOrGreaterThan(result) {
        return result === 0;
      }
      CompareResult2.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;
      CompareResult2.greaterThan = 1;
      CompareResult2.lessThan = -1;
      CompareResult2.neitherLessOrGreaterThan = 0;
    })(CompareResult || (CompareResult = {}));
    numberComparator = (a, b) => a - b;
    booleanComparator = (a, b) => numberComparator(a ? 1 : 0, b ? 1 : 0);
    ArrayQueue = class {
      /**
       * Constructs a queue that is backed by the given array. Runtime is O(1).
      */
      constructor(items) {
        this.items = items;
        this.firstIdx = 0;
        this.lastIdx = this.items.length - 1;
      }
      get length() {
        return this.lastIdx - this.firstIdx + 1;
      }
      /**
       * Consumes elements from the beginning of the queue as long as the predicate returns true.
       * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).
      */
      takeWhile(predicate) {
        let startIdx = this.firstIdx;
        while (startIdx < this.items.length && predicate(this.items[startIdx])) {
          startIdx++;
        }
        const result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);
        this.firstIdx = startIdx;
        return result;
      }
      /**
       * Consumes elements from the end of the queue as long as the predicate returns true.
       * If no elements were consumed, `null` is returned.
       * The result has the same order as the underlying array!
      */
      takeFromEndWhile(predicate) {
        let endIdx = this.lastIdx;
        while (endIdx >= 0 && predicate(this.items[endIdx])) {
          endIdx--;
        }
        const result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);
        this.lastIdx = endIdx;
        return result;
      }
      peek() {
        if (this.length === 0) {
          return void 0;
        }
        return this.items[this.firstIdx];
      }
      dequeue() {
        const result = this.items[this.firstIdx];
        this.firstIdx++;
        return result;
      }
      takeCount(count) {
        const result = this.items.slice(this.firstIdx, this.firstIdx + count);
        this.firstIdx += count;
        return result;
      }
    };
    CallbackIterable = class _CallbackIterable {
      constructor(iterate) {
        this.iterate = iterate;
      }
      toArray() {
        const result = [];
        this.iterate((item) => {
          result.push(item);
          return true;
        });
        return result;
      }
      filter(predicate) {
        return new _CallbackIterable((cb) => this.iterate((item) => predicate(item) ? cb(item) : true));
      }
      map(mapFn) {
        return new _CallbackIterable((cb) => this.iterate((item) => cb(mapFn(item))));
      }
      findLast(predicate) {
        let result;
        this.iterate((item) => {
          if (predicate(item)) {
            result = item;
          }
          return true;
        });
        return result;
      }
      findLastMaxBy(comparator) {
        let result;
        let first = true;
        this.iterate((item) => {
          if (first || CompareResult.isGreaterThan(comparator(item, result))) {
            first = false;
            result = item;
          }
          return true;
        });
        return result;
      }
    };
    CallbackIterable.empty = new CallbackIterable((_callback) => {
    });
  }
});

// node_modules/monaco-editor/esm/vs/base/common/buffer.js
function readUInt16LE(source, offset) {
  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0;
}
function writeUInt16LE(destination, value, offset) {
  destination[offset + 0] = value & 255;
  value = value >>> 8;
  destination[offset + 1] = value & 255;
}
function readUInt32BE(source, offset) {
  return source[offset] * 2 ** 24 + source[offset + 1] * 2 ** 16 + source[offset + 2] * 2 ** 8 + source[offset + 3];
}
function writeUInt32BE(destination, value, offset) {
  destination[offset + 3] = value;
  value = value >>> 8;
  destination[offset + 2] = value;
  value = value >>> 8;
  destination[offset + 1] = value;
  value = value >>> 8;
  destination[offset] = value;
}
function readUInt8(source, offset) {
  return source[offset];
}
function writeUInt8(destination, value, offset) {
  destination[offset] = value;
}
var hasBuffer, indexOfTable, textDecoder, VSBuffer;
var init_buffer = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/buffer.js"() {
    init_lazy();
    hasBuffer = typeof Buffer !== "undefined";
    indexOfTable = new Lazy(() => new Uint8Array(256));
    VSBuffer = class _VSBuffer {
      /**
       * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
       * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
       * which is not transferrable.
       */
      static wrap(actual) {
        if (hasBuffer && !Buffer.isBuffer(actual)) {
          actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);
        }
        return new _VSBuffer(actual);
      }
      constructor(buffer) {
        this.buffer = buffer;
        this.byteLength = this.buffer.byteLength;
      }
      toString() {
        if (hasBuffer) {
          return this.buffer.toString();
        } else {
          if (!textDecoder) {
            textDecoder = new TextDecoder();
          }
          return textDecoder.decode(this.buffer);
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js
function getUTF16LE_TextDecoder() {
  if (!_utf16LE_TextDecoder) {
    _utf16LE_TextDecoder = new TextDecoder("UTF-16LE");
  }
  return _utf16LE_TextDecoder;
}
function getUTF16BE_TextDecoder() {
  if (!_utf16BE_TextDecoder) {
    _utf16BE_TextDecoder = new TextDecoder("UTF-16BE");
  }
  return _utf16BE_TextDecoder;
}
function getPlatformTextDecoder() {
  if (!_platformTextDecoder) {
    _platformTextDecoder = isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();
  }
  return _platformTextDecoder;
}
function decodeUTF16LE(source, offset, len) {
  const view = new Uint16Array(source.buffer, offset, len);
  if (len > 0 && (view[0] === 65279 || view[0] === 65534)) {
    return compatDecodeUTF16LE(source, offset, len);
  }
  return getUTF16LE_TextDecoder().decode(view);
}
function compatDecodeUTF16LE(source, offset, len) {
  const result = [];
  let resultLen = 0;
  for (let i = 0; i < len; i++) {
    const charCode = readUInt16LE(source, offset);
    offset += 2;
    result[resultLen++] = String.fromCharCode(charCode);
  }
  return result.join("");
}
var _utf16LE_TextDecoder, _utf16BE_TextDecoder, _platformTextDecoder, StringBuilder;
var init_stringBuilder = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js"() {
    init_strings();
    init_platform();
    init_buffer();
    StringBuilder = class {
      constructor(capacity) {
        this._capacity = capacity | 0;
        this._buffer = new Uint16Array(this._capacity);
        this._completedStrings = null;
        this._bufferLength = 0;
      }
      reset() {
        this._completedStrings = null;
        this._bufferLength = 0;
      }
      build() {
        if (this._completedStrings !== null) {
          this._flushBuffer();
          return this._completedStrings.join("");
        }
        return this._buildBuffer();
      }
      _buildBuffer() {
        if (this._bufferLength === 0) {
          return "";
        }
        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);
        return getPlatformTextDecoder().decode(view);
      }
      _flushBuffer() {
        const bufferString = this._buildBuffer();
        this._bufferLength = 0;
        if (this._completedStrings === null) {
          this._completedStrings = [bufferString];
        } else {
          this._completedStrings[this._completedStrings.length] = bufferString;
        }
      }
      /**
       * Append a char code (<2^16)
       */
      appendCharCode(charCode) {
        const remainingSpace = this._capacity - this._bufferLength;
        if (remainingSpace <= 1) {
          if (remainingSpace === 0 || isHighSurrogate(charCode)) {
            this._flushBuffer();
          }
        }
        this._buffer[this._bufferLength++] = charCode;
      }
      /**
       * Append an ASCII char code (<2^8)
       */
      appendASCIICharCode(charCode) {
        if (this._bufferLength === this._capacity) {
          this._flushBuffer();
        }
        this._buffer[this._bufferLength++] = charCode;
      }
      appendString(str) {
        const strLen = str.length;
        if (this._bufferLength + strLen >= this._capacity) {
          this._flushBuffer();
          this._completedStrings[this._completedStrings.length] = str;
          return;
        }
        for (let i = 0; i < strLen; i++) {
          this._buffer[this._bufferLength++] = str.charCodeAt(i);
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/position.js
var Position;
var init_position = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/position.js"() {
    Position = class _Position {
      constructor(lineNumber, column) {
        this.lineNumber = lineNumber;
        this.column = column;
      }
      /**
       * Create a new position from this position.
       *
       * @param newLineNumber new line number
       * @param newColumn new column
       */
      with(newLineNumber = this.lineNumber, newColumn = this.column) {
        if (newLineNumber === this.lineNumber && newColumn === this.column) {
          return this;
        } else {
          return new _Position(newLineNumber, newColumn);
        }
      }
      /**
       * Derive a new position from this position.
       *
       * @param deltaLineNumber line number delta
       * @param deltaColumn column delta
       */
      delta(deltaLineNumber = 0, deltaColumn = 0) {
        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
      }
      /**
       * Test if this position equals other position
       */
      equals(other) {
        return _Position.equals(this, other);
      }
      /**
       * Test if position `a` equals position `b`
       */
      static equals(a, b) {
        if (!a && !b) {
          return true;
        }
        return !!a && !!b && a.lineNumber === b.lineNumber && a.column === b.column;
      }
      /**
       * Test if this position is before other position.
       * If the two positions are equal, the result will be false.
       */
      isBefore(other) {
        return _Position.isBefore(this, other);
      }
      /**
       * Test if position `a` is before position `b`.
       * If the two positions are equal, the result will be false.
       */
      static isBefore(a, b) {
        if (a.lineNumber < b.lineNumber) {
          return true;
        }
        if (b.lineNumber < a.lineNumber) {
          return false;
        }
        return a.column < b.column;
      }
      /**
       * Test if this position is before other position.
       * If the two positions are equal, the result will be true.
       */
      isBeforeOrEqual(other) {
        return _Position.isBeforeOrEqual(this, other);
      }
      /**
       * Test if position `a` is before position `b`.
       * If the two positions are equal, the result will be true.
       */
      static isBeforeOrEqual(a, b) {
        if (a.lineNumber < b.lineNumber) {
          return true;
        }
        if (b.lineNumber < a.lineNumber) {
          return false;
        }
        return a.column <= b.column;
      }
      /**
       * A function that compares positions, useful for sorting
       */
      static compare(a, b) {
        const aLineNumber = a.lineNumber | 0;
        const bLineNumber = b.lineNumber | 0;
        if (aLineNumber === bLineNumber) {
          const aColumn = a.column | 0;
          const bColumn = b.column | 0;
          return aColumn - bColumn;
        }
        return aLineNumber - bLineNumber;
      }
      /**
       * Clone this position.
       */
      clone() {
        return new _Position(this.lineNumber, this.column);
      }
      /**
       * Convert to a human-readable representation.
       */
      toString() {
        return "(" + this.lineNumber + "," + this.column + ")";
      }
      // ---
      /**
       * Create a `Position` from an `IPosition`.
       */
      static lift(pos) {
        return new _Position(pos.lineNumber, pos.column);
      }
      /**
       * Test if `obj` is an `IPosition`.
       */
      static isIPosition(obj) {
        return obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
      }
      toJSON() {
        return {
          lineNumber: this.lineNumber,
          column: this.column
        };
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/range.js
var Range2;
var init_range = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/range.js"() {
    init_position();
    Range2 = class _Range {
      constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
        if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
          this.startLineNumber = endLineNumber;
          this.startColumn = endColumn;
          this.endLineNumber = startLineNumber;
          this.endColumn = startColumn;
        } else {
          this.startLineNumber = startLineNumber;
          this.startColumn = startColumn;
          this.endLineNumber = endLineNumber;
          this.endColumn = endColumn;
        }
      }
      /**
       * Test if this range is empty.
       */
      isEmpty() {
        return _Range.isEmpty(this);
      }
      /**
       * Test if `range` is empty.
       */
      static isEmpty(range2) {
        return range2.startLineNumber === range2.endLineNumber && range2.startColumn === range2.endColumn;
      }
      /**
       * Test if position is in this range. If the position is at the edges, will return true.
       */
      containsPosition(position) {
        return _Range.containsPosition(this, position);
      }
      /**
       * Test if `position` is in `range`. If the position is at the edges, will return true.
       */
      static containsPosition(range2, position) {
        if (position.lineNumber < range2.startLineNumber || position.lineNumber > range2.endLineNumber) {
          return false;
        }
        if (position.lineNumber === range2.startLineNumber && position.column < range2.startColumn) {
          return false;
        }
        if (position.lineNumber === range2.endLineNumber && position.column > range2.endColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if `position` is in `range`. If the position is at the edges, will return false.
       * @internal
       */
      static strictContainsPosition(range2, position) {
        if (position.lineNumber < range2.startLineNumber || position.lineNumber > range2.endLineNumber) {
          return false;
        }
        if (position.lineNumber === range2.startLineNumber && position.column <= range2.startColumn) {
          return false;
        }
        if (position.lineNumber === range2.endLineNumber && position.column >= range2.endColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if range is in this range. If the range is equal to this range, will return true.
       */
      containsRange(range2) {
        return _Range.containsRange(this, range2);
      }
      /**
       * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
       */
      static containsRange(range2, otherRange) {
        if (otherRange.startLineNumber < range2.startLineNumber || otherRange.endLineNumber < range2.startLineNumber) {
          return false;
        }
        if (otherRange.startLineNumber > range2.endLineNumber || otherRange.endLineNumber > range2.endLineNumber) {
          return false;
        }
        if (otherRange.startLineNumber === range2.startLineNumber && otherRange.startColumn < range2.startColumn) {
          return false;
        }
        if (otherRange.endLineNumber === range2.endLineNumber && otherRange.endColumn > range2.endColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
       */
      strictContainsRange(range2) {
        return _Range.strictContainsRange(this, range2);
      }
      /**
       * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
       */
      static strictContainsRange(range2, otherRange) {
        if (otherRange.startLineNumber < range2.startLineNumber || otherRange.endLineNumber < range2.startLineNumber) {
          return false;
        }
        if (otherRange.startLineNumber > range2.endLineNumber || otherRange.endLineNumber > range2.endLineNumber) {
          return false;
        }
        if (otherRange.startLineNumber === range2.startLineNumber && otherRange.startColumn <= range2.startColumn) {
          return false;
        }
        if (otherRange.endLineNumber === range2.endLineNumber && otherRange.endColumn >= range2.endColumn) {
          return false;
        }
        return true;
      }
      /**
       * A reunion of the two ranges.
       * The smallest position will be used as the start point, and the largest one as the end point.
       */
      plusRange(range2) {
        return _Range.plusRange(this, range2);
      }
      /**
       * A reunion of the two ranges.
       * The smallest position will be used as the start point, and the largest one as the end point.
       */
      static plusRange(a, b) {
        let startLineNumber;
        let startColumn;
        let endLineNumber;
        let endColumn;
        if (b.startLineNumber < a.startLineNumber) {
          startLineNumber = b.startLineNumber;
          startColumn = b.startColumn;
        } else if (b.startLineNumber === a.startLineNumber) {
          startLineNumber = b.startLineNumber;
          startColumn = Math.min(b.startColumn, a.startColumn);
        } else {
          startLineNumber = a.startLineNumber;
          startColumn = a.startColumn;
        }
        if (b.endLineNumber > a.endLineNumber) {
          endLineNumber = b.endLineNumber;
          endColumn = b.endColumn;
        } else if (b.endLineNumber === a.endLineNumber) {
          endLineNumber = b.endLineNumber;
          endColumn = Math.max(b.endColumn, a.endColumn);
        } else {
          endLineNumber = a.endLineNumber;
          endColumn = a.endColumn;
        }
        return new _Range(startLineNumber, startColumn, endLineNumber, endColumn);
      }
      /**
       * A intersection of the two ranges.
       */
      intersectRanges(range2) {
        return _Range.intersectRanges(this, range2);
      }
      /**
       * A intersection of the two ranges.
       */
      static intersectRanges(a, b) {
        let resultStartLineNumber = a.startLineNumber;
        let resultStartColumn = a.startColumn;
        let resultEndLineNumber = a.endLineNumber;
        let resultEndColumn = a.endColumn;
        const otherStartLineNumber = b.startLineNumber;
        const otherStartColumn = b.startColumn;
        const otherEndLineNumber = b.endLineNumber;
        const otherEndColumn = b.endColumn;
        if (resultStartLineNumber < otherStartLineNumber) {
          resultStartLineNumber = otherStartLineNumber;
          resultStartColumn = otherStartColumn;
        } else if (resultStartLineNumber === otherStartLineNumber) {
          resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
        }
        if (resultEndLineNumber > otherEndLineNumber) {
          resultEndLineNumber = otherEndLineNumber;
          resultEndColumn = otherEndColumn;
        } else if (resultEndLineNumber === otherEndLineNumber) {
          resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
        }
        if (resultStartLineNumber > resultEndLineNumber) {
          return null;
        }
        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
          return null;
        }
        return new _Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
      }
      /**
       * Test if this range equals other.
       */
      equalsRange(other) {
        return _Range.equalsRange(this, other);
      }
      /**
       * Test if range `a` equals `b`.
       */
      static equalsRange(a, b) {
        if (!a && !b) {
          return true;
        }
        return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;
      }
      /**
       * Return the end position (which will be after or equal to the start position)
       */
      getEndPosition() {
        return _Range.getEndPosition(this);
      }
      /**
       * Return the end position (which will be after or equal to the start position)
       */
      static getEndPosition(range2) {
        return new Position(range2.endLineNumber, range2.endColumn);
      }
      /**
       * Return the start position (which will be before or equal to the end position)
       */
      getStartPosition() {
        return _Range.getStartPosition(this);
      }
      /**
       * Return the start position (which will be before or equal to the end position)
       */
      static getStartPosition(range2) {
        return new Position(range2.startLineNumber, range2.startColumn);
      }
      /**
       * Transform to a user presentable string representation.
       */
      toString() {
        return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
      }
      /**
       * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
       */
      setEndPosition(endLineNumber, endColumn) {
        return new _Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
      }
      /**
       * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
       */
      setStartPosition(startLineNumber, startColumn) {
        return new _Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
      }
      /**
       * Create a new empty range using this range's start position.
       */
      collapseToStart() {
        return _Range.collapseToStart(this);
      }
      /**
       * Create a new empty range using this range's start position.
       */
      static collapseToStart(range2) {
        return new _Range(range2.startLineNumber, range2.startColumn, range2.startLineNumber, range2.startColumn);
      }
      /**
       * Create a new empty range using this range's end position.
       */
      collapseToEnd() {
        return _Range.collapseToEnd(this);
      }
      /**
       * Create a new empty range using this range's end position.
       */
      static collapseToEnd(range2) {
        return new _Range(range2.endLineNumber, range2.endColumn, range2.endLineNumber, range2.endColumn);
      }
      /**
       * Moves the range by the given amount of lines.
       */
      delta(lineCount) {
        return new _Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);
      }
      // ---
      static fromPositions(start, end = start) {
        return new _Range(start.lineNumber, start.column, end.lineNumber, end.column);
      }
      static lift(range2) {
        if (!range2) {
          return null;
        }
        return new _Range(range2.startLineNumber, range2.startColumn, range2.endLineNumber, range2.endColumn);
      }
      /**
       * Test if `obj` is an `IRange`.
       */
      static isIRange(obj) {
        return obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
      }
      /**
       * Test if the two ranges are touching in any way.
       */
      static areIntersectingOrTouching(a, b) {
        if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn) {
          return false;
        }
        if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn) {
          return false;
        }
        return true;
      }
      /**
       * Test if the two ranges are intersecting. If the ranges are touching it returns true.
       */
      static areIntersecting(a, b) {
        if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) {
          return false;
        }
        if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) {
          return false;
        }
        return true;
      }
      /**
       * A function that compares ranges, useful for sorting ranges
       * It will first compare ranges on the startPosition and then on the endPosition
       */
      static compareRangesUsingStarts(a, b) {
        if (a && b) {
          const aStartLineNumber = a.startLineNumber | 0;
          const bStartLineNumber = b.startLineNumber | 0;
          if (aStartLineNumber === bStartLineNumber) {
            const aStartColumn = a.startColumn | 0;
            const bStartColumn = b.startColumn | 0;
            if (aStartColumn === bStartColumn) {
              const aEndLineNumber = a.endLineNumber | 0;
              const bEndLineNumber = b.endLineNumber | 0;
              if (aEndLineNumber === bEndLineNumber) {
                const aEndColumn = a.endColumn | 0;
                const bEndColumn = b.endColumn | 0;
                return aEndColumn - bEndColumn;
              }
              return aEndLineNumber - bEndLineNumber;
            }
            return aStartColumn - bStartColumn;
          }
          return aStartLineNumber - bStartLineNumber;
        }
        const aExists = a ? 1 : 0;
        const bExists = b ? 1 : 0;
        return aExists - bExists;
      }
      /**
       * A function that compares ranges, useful for sorting ranges
       * It will first compare ranges on the endPosition and then on the startPosition
       */
      static compareRangesUsingEnds(a, b) {
        if (a.endLineNumber === b.endLineNumber) {
          if (a.endColumn === b.endColumn) {
            if (a.startLineNumber === b.startLineNumber) {
              return a.startColumn - b.startColumn;
            }
            return a.startLineNumber - b.startLineNumber;
          }
          return a.endColumn - b.endColumn;
        }
        return a.endLineNumber - b.endLineNumber;
      }
      /**
       * Test if the range spans multiple lines.
       */
      static spansMultipleLines(range2) {
        return range2.endLineNumber > range2.startLineNumber;
      }
      toJSON() {
        return this;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js
function groupFuzzyBrackets(brackets) {
  const N = brackets.length;
  brackets = brackets.map((b) => [b[0].toLowerCase(), b[1].toLowerCase()]);
  const group = [];
  for (let i = 0; i < N; i++) {
    group[i] = i;
  }
  const areOverlapping = (a, b) => {
    const [aOpen, aClose] = a;
    const [bOpen, bClose] = b;
    return aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose;
  };
  const mergeGroups = (g1, g2) => {
    const newG = Math.min(g1, g2);
    const oldG = Math.max(g1, g2);
    for (let i = 0; i < N; i++) {
      if (group[i] === oldG) {
        group[i] = newG;
      }
    }
  };
  for (let i = 0; i < N; i++) {
    const a = brackets[i];
    for (let j = i + 1; j < N; j++) {
      const b = brackets[j];
      if (areOverlapping(a, b)) {
        mergeGroups(group[i], group[j]);
      }
    }
  }
  const result = [];
  for (let g = 0; g < N; g++) {
    const currentOpen = [];
    const currentClose = [];
    for (let i = 0; i < N; i++) {
      if (group[i] === g) {
        const [open, close] = brackets[i];
        currentOpen.push(open);
        currentClose.push(close);
      }
    }
    if (currentOpen.length > 0) {
      result.push({
        open: currentOpen,
        close: currentClose
      });
    }
  }
  return result;
}
function collectSuperstrings(str, brackets, currentIndex, dest) {
  for (let i = 0, len = brackets.length; i < len; i++) {
    if (i === currentIndex) {
      continue;
    }
    const bracket = brackets[i];
    for (const open of bracket.open) {
      if (open.indexOf(str) >= 0) {
        dest.push(open);
      }
    }
    for (const close of bracket.close) {
      if (close.indexOf(str) >= 0) {
        dest.push(close);
      }
    }
  }
}
function lengthcmp(a, b) {
  return a.length - b.length;
}
function unique(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const result = [];
  const seen = /* @__PURE__ */ new Set();
  for (const element of arr) {
    if (seen.has(element)) {
      continue;
    }
    result.push(element);
    seen.add(element);
  }
  return result;
}
function getRegexForBracketPair(open, close, brackets, currentIndex) {
  let pieces = [];
  pieces = pieces.concat(open);
  pieces = pieces.concat(close);
  for (let i = 0, len = pieces.length; i < len; i++) {
    collectSuperstrings(pieces[i], brackets, currentIndex, pieces);
  }
  pieces = unique(pieces);
  pieces.sort(lengthcmp);
  pieces.reverse();
  return createBracketOrRegExp(pieces);
}
function getReversedRegexForBracketPair(open, close, brackets, currentIndex) {
  let pieces = [];
  pieces = pieces.concat(open);
  pieces = pieces.concat(close);
  for (let i = 0, len = pieces.length; i < len; i++) {
    collectSuperstrings(pieces[i], brackets, currentIndex, pieces);
  }
  pieces = unique(pieces);
  pieces.sort(lengthcmp);
  pieces.reverse();
  return createBracketOrRegExp(pieces.map(toReversedString));
}
function getRegexForBrackets(brackets) {
  let pieces = [];
  for (const bracket of brackets) {
    for (const open of bracket.open) {
      pieces.push(open);
    }
    for (const close of bracket.close) {
      pieces.push(close);
    }
  }
  pieces = unique(pieces);
  return createBracketOrRegExp(pieces);
}
function getReversedRegexForBrackets(brackets) {
  let pieces = [];
  for (const bracket of brackets) {
    for (const open of bracket.open) {
      pieces.push(open);
    }
    for (const close of bracket.close) {
      pieces.push(close);
    }
  }
  pieces = unique(pieces);
  return createBracketOrRegExp(pieces.map(toReversedString));
}
function prepareBracketForRegExp(str) {
  const insertWordBoundaries = /^[\w ]+$/.test(str);
  str = escapeRegExpCharacters(str);
  return insertWordBoundaries ? `\\b${str}\\b` : str;
}
function createBracketOrRegExp(pieces) {
  const regexStr = `(${pieces.map(prepareBracketForRegExp).join(")|(")})`;
  return createRegExp(regexStr, true);
}
var RichEditBracket, RichEditBrackets, toReversedString, BracketsUtils;
var init_richEditBrackets = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js"() {
    init_strings();
    init_stringBuilder();
    init_range();
    RichEditBracket = class _RichEditBracket {
      constructor(languageId, index, open, close, forwardRegex, reversedRegex) {
        this._richEditBracketBrand = void 0;
        this.languageId = languageId;
        this.index = index;
        this.open = open;
        this.close = close;
        this.forwardRegex = forwardRegex;
        this.reversedRegex = reversedRegex;
        this._openSet = _RichEditBracket._toSet(this.open);
        this._closeSet = _RichEditBracket._toSet(this.close);
      }
      /**
       * Check if the provided `text` is an open bracket in this group.
       */
      isOpen(text) {
        return this._openSet.has(text);
      }
      /**
       * Check if the provided `text` is a close bracket in this group.
       */
      isClose(text) {
        return this._closeSet.has(text);
      }
      static _toSet(arr) {
        const result = /* @__PURE__ */ new Set();
        for (const element of arr) {
          result.add(element);
        }
        return result;
      }
    };
    RichEditBrackets = class {
      constructor(languageId, _brackets) {
        this._richEditBracketsBrand = void 0;
        const brackets = groupFuzzyBrackets(_brackets);
        this.brackets = brackets.map((b, index) => {
          return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));
        });
        this.forwardRegex = getRegexForBrackets(this.brackets);
        this.reversedRegex = getReversedRegexForBrackets(this.brackets);
        this.textIsBracket = {};
        this.textIsOpenBracket = {};
        this.maxBracketLength = 0;
        for (const bracket of this.brackets) {
          for (const open of bracket.open) {
            this.textIsBracket[open] = bracket;
            this.textIsOpenBracket[open] = true;
            this.maxBracketLength = Math.max(this.maxBracketLength, open.length);
          }
          for (const close of bracket.close) {
            this.textIsBracket[close] = bracket;
            this.textIsOpenBracket[close] = false;
            this.maxBracketLength = Math.max(this.maxBracketLength, close.length);
          }
        }
      }
    };
    toReversedString = /* @__PURE__ */ function() {
      function reverse(str) {
        const arr = new Uint16Array(str.length);
        let offset = 0;
        for (let i = str.length - 1; i >= 0; i--) {
          arr[offset++] = str.charCodeAt(i);
        }
        return getPlatformTextDecoder().decode(arr);
      }
      let lastInput = null;
      let lastOutput = null;
      return function toReversedString2(str) {
        if (lastInput !== str) {
          lastInput = str;
          lastOutput = reverse(lastInput);
        }
        return lastOutput;
      };
    }();
    BracketsUtils = class {
      static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {
        const m = reversedText.match(reversedBracketRegex);
        if (!m) {
          return null;
        }
        const matchOffset = reversedText.length - (m.index || 0);
        const matchLength = m[0].length;
        const absoluteMatchOffset = offset + matchOffset;
        return new Range2(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);
      }
      static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {
        const reversedLineText = toReversedString(lineText);
        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);
        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);
      }
      static findNextBracketInText(bracketRegex, lineNumber, text, offset) {
        const m = text.match(bracketRegex);
        if (!m) {
          return null;
        }
        const matchOffset = m.index || 0;
        const matchLength = m[0].length;
        if (matchLength === 0) {
          return null;
        }
        const absoluteMatchOffset = offset + matchOffset;
        return new Range2(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);
      }
      static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {
        const substr = lineText.substring(startOffset, endOffset);
        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js
var BracketElectricCharacterSupport;
var init_electricCharacter = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js"() {
    init_arrays();
    init_supports();
    init_richEditBrackets();
    BracketElectricCharacterSupport = class {
      constructor(richEditBrackets) {
        this._richEditBrackets = richEditBrackets;
      }
      getElectricCharacters() {
        const result = [];
        if (this._richEditBrackets) {
          for (const bracket of this._richEditBrackets.brackets) {
            for (const close of bracket.close) {
              const lastChar = close.charAt(close.length - 1);
              result.push(lastChar);
            }
          }
        }
        return distinct(result);
      }
      onElectricCharacter(character, context, column) {
        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {
          return null;
        }
        const tokenIndex = context.findTokenIndexAtOffset(column - 1);
        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {
          return null;
        }
        const reversedBracketRegex = this._richEditBrackets.reversedRegex;
        const text = context.getLineContent().substring(0, column - 1) + character;
        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);
        if (!r) {
          return null;
        }
        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];
        if (isOpen) {
          return null;
        }
        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);
        if (!/^\s*$/.test(textBeforeBracket)) {
          return null;
        }
        return {
          matchOpenBracket: bracketText
        };
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js
function resetGlobalRegex(reg) {
  if (reg.global) {
    reg.lastIndex = 0;
  }
  return true;
}
var IndentRulesSupport;
var init_indentRules = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js"() {
    IndentRulesSupport = class {
      constructor(indentationRules) {
        this._indentationRules = indentationRules;
      }
      shouldIncrease(text) {
        if (this._indentationRules) {
          if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {
            return true;
          }
        }
        return false;
      }
      shouldDecrease(text) {
        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {
          return true;
        }
        return false;
      }
      shouldIndentNextLine(text) {
        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {
          return true;
        }
        return false;
      }
      shouldIgnore(text) {
        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {
          return true;
        }
        return false;
      }
      getIndentMetadata(text) {
        let ret = 0;
        if (this.shouldIncrease(text)) {
          ret += 1;
        }
        if (this.shouldDecrease(text)) {
          ret += 2;
        }
        if (this.shouldIndentNextLine(text)) {
          ret += 4;
        }
        if (this.shouldIgnore(text)) {
          ret += 8;
        }
        return ret;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js
var OnEnterSupport;
var init_onEnter = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js"() {
    init_errors();
    init_strings();
    init_languageConfiguration();
    OnEnterSupport = class _OnEnterSupport {
      constructor(opts) {
        opts = opts || {};
        opts.brackets = opts.brackets || [
          ["(", ")"],
          ["{", "}"],
          ["[", "]"]
        ];
        this._brackets = [];
        opts.brackets.forEach((bracket) => {
          const openRegExp = _OnEnterSupport._createOpenBracketRegExp(bracket[0]);
          const closeRegExp = _OnEnterSupport._createCloseBracketRegExp(bracket[1]);
          if (openRegExp && closeRegExp) {
            this._brackets.push({
              open: bracket[0],
              openRegExp,
              close: bracket[1],
              closeRegExp
            });
          }
        });
        this._regExpRules = opts.onEnterRules || [];
      }
      onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {
        if (autoIndent >= 3) {
          for (let i = 0, len = this._regExpRules.length; i < len; i++) {
            const rule = this._regExpRules[i];
            const regResult = [{
              reg: rule.beforeText,
              text: beforeEnterText
            }, {
              reg: rule.afterText,
              text: afterEnterText
            }, {
              reg: rule.previousLineText,
              text: previousLineText
            }].every((obj) => {
              if (!obj.reg) {
                return true;
              }
              obj.reg.lastIndex = 0;
              return obj.reg.test(obj.text);
            });
            if (regResult) {
              return rule.action;
            }
          }
        }
        if (autoIndent >= 2) {
          if (beforeEnterText.length > 0 && afterEnterText.length > 0) {
            for (let i = 0, len = this._brackets.length; i < len; i++) {
              const bracket = this._brackets[i];
              if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {
                return { indentAction: IndentAction.IndentOutdent };
              }
            }
          }
        }
        if (autoIndent >= 2) {
          if (beforeEnterText.length > 0) {
            for (let i = 0, len = this._brackets.length; i < len; i++) {
              const bracket = this._brackets[i];
              if (bracket.openRegExp.test(beforeEnterText)) {
                return { indentAction: IndentAction.Indent };
              }
            }
          }
        }
        return null;
      }
      static _createOpenBracketRegExp(bracket) {
        let str = escapeRegExpCharacters(bracket);
        if (!/\B/.test(str.charAt(0))) {
          str = "\\b" + str;
        }
        str += "\\s*$";
        return _OnEnterSupport._safeRegExp(str);
      }
      static _createCloseBracketRegExp(bracket) {
        let str = escapeRegExpCharacters(bracket);
        if (!/\B/.test(str.charAt(str.length - 1))) {
          str = str + "\\b";
        }
        str = "^\\s*" + str;
        return _OnEnterSupport._safeRegExp(str);
      }
      static _safeRegExp(def) {
        try {
          return new RegExp(def);
        } catch (err) {
          onUnexpectedError(err);
          return null;
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/platform/configuration/common/configuration.js
function toValuesTree(properties, conflictReporter) {
  const root = /* @__PURE__ */ Object.create(null);
  for (const key in properties) {
    addToValueTree(root, key, properties[key], conflictReporter);
  }
  return root;
}
function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {
  const segments = key.split(".");
  const last = segments.pop();
  let curr = settingsTreeRoot;
  for (let i = 0; i < segments.length; i++) {
    const s = segments[i];
    let obj = curr[s];
    switch (typeof obj) {
      case "undefined":
        obj = curr[s] = /* @__PURE__ */ Object.create(null);
        break;
      case "object":
        break;
      default:
        conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join(".")} is ${JSON.stringify(obj)}`);
        return;
    }
    curr = obj;
  }
  if (typeof curr === "object" && curr !== null) {
    try {
      curr[last] = value;
    } catch (e) {
      conflictReporter(`Ignoring ${key} as ${segments.join(".")} is ${JSON.stringify(curr)}`);
    }
  } else {
    conflictReporter(`Ignoring ${key} as ${segments.join(".")} is ${JSON.stringify(curr)}`);
  }
}
function removeFromValueTree(valueTree, key) {
  const segments = key.split(".");
  doRemoveFromValueTree(valueTree, segments);
}
function doRemoveFromValueTree(valueTree, segments) {
  const first = segments.shift();
  if (segments.length === 0) {
    delete valueTree[first];
    return;
  }
  if (Object.keys(valueTree).indexOf(first) !== -1) {
    const value = valueTree[first];
    if (typeof value === "object" && !Array.isArray(value)) {
      doRemoveFromValueTree(value, segments);
      if (Object.keys(value).length === 0) {
        delete valueTree[first];
      }
    }
  }
}
function getConfigurationValue(config, settingPath, defaultValue) {
  function accessSetting(config2, path2) {
    let current = config2;
    for (const component of path2) {
      if (typeof current !== "object" || current === null) {
        return void 0;
      }
      current = current[component];
    }
    return current;
  }
  const path = settingPath.split(".");
  const result = accessSetting(config, path);
  return typeof result === "undefined" ? defaultValue : result;
}
function getLanguageTagSettingPlainKey(settingKey) {
  return settingKey.replace(/[\[\]]/g, "");
}
var IConfigurationService;
var init_configuration = __esm({
  "node_modules/monaco-editor/esm/vs/platform/configuration/common/configuration.js"() {
    init_instantiation();
    IConfigurationService = createDecorator("configurationService");
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/languages/language.js
var ILanguageService;
var init_language = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/languages/language.js"() {
    init_instantiation();
    ILanguageService = createDecorator("languageService");
  }
});

// node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js
function registerSingleton(id, ctorOrDescriptor, supportsDelayedInstantiation) {
  if (!(ctorOrDescriptor instanceof SyncDescriptor)) {
    ctorOrDescriptor = new SyncDescriptor(ctorOrDescriptor, [], Boolean(supportsDelayedInstantiation));
  }
  _registry.push([id, ctorOrDescriptor]);
}
function getSingletonServiceDescriptors() {
  return _registry;
}
var _registry;
var init_extensions = __esm({
  "node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js"() {
    init_descriptors();
    _registry = [];
  }
});

// node_modules/monaco-editor/esm/vs/base/common/assert.js
function ok(value, message) {
  if (!value) {
    throw new Error(message ? `Assertion failed (${message})` : "Assertion Failed");
  }
}
function assertNever(value, message = "Unreachable") {
  throw new Error(message);
}
function softAssert(condition) {
  if (!condition) {
    onUnexpectedError(new BugIndicatingError("Soft Assertion Failed"));
  }
}
function assertFn(condition) {
  if (!condition()) {
    debugger;
    condition();
    onUnexpectedError(new BugIndicatingError("Assertion Failed"));
  }
}
function checkAdjacentItems(items, predicate) {
  let i = 0;
  while (i < items.length - 1) {
    const a = items[i];
    const b = items[i + 1];
    if (!predicate(a, b)) {
      return false;
    }
    i++;
  }
  return true;
}
var init_assert = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/assert.js"() {
    init_errors();
  }
});

// node_modules/monaco-editor/esm/vs/base/common/types.js
function isString(str) {
  return typeof str === "string";
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj) && !(obj instanceof RegExp) && !(obj instanceof Date);
}
function isTypedArray(obj) {
  const TypedArray = Object.getPrototypeOf(Uint8Array);
  return typeof obj === "object" && obj instanceof TypedArray;
}
function isNumber(obj) {
  return typeof obj === "number" && !isNaN(obj);
}
function isIterable(obj) {
  return !!obj && typeof obj[Symbol.iterator] === "function";
}
function isBoolean(obj) {
  return obj === true || obj === false;
}
function isUndefined(obj) {
  return typeof obj === "undefined";
}
function isDefined(arg) {
  return !isUndefinedOrNull(arg);
}
function isUndefinedOrNull(obj) {
  return isUndefined(obj) || obj === null;
}
function assertType(condition, type) {
  if (!condition) {
    throw new Error(type ? `Unexpected type, expected '${type}'` : "Unexpected type");
  }
}
function assertIsDefined(arg) {
  if (isUndefinedOrNull(arg)) {
    throw new Error("Assertion Failed: argument is undefined or null");
  }
  return arg;
}
function isFunction(obj) {
  return typeof obj === "function";
}
function validateConstraints(args, constraints) {
  const len = Math.min(args.length, constraints.length);
  for (let i = 0; i < len; i++) {
    validateConstraint(args[i], constraints[i]);
  }
}
function validateConstraint(arg, constraint) {
  if (isString(constraint)) {
    if (typeof arg !== constraint) {
      throw new Error(`argument does not match constraint: typeof ${constraint}`);
    }
  } else if (isFunction(constraint)) {
    try {
      if (arg instanceof constraint) {
        return;
      }
    } catch (_a2) {
    }
    if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {
      return;
    }
    if (constraint.length === 1 && constraint.call(void 0, arg) === true) {
      return;
    }
    throw new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);
  }
}
var init_types = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/types.js"() {
  }
});

// node_modules/monaco-editor/esm/vs/platform/registry/common/platform.js
var RegistryImpl, Registry;
var init_platform2 = __esm({
  "node_modules/monaco-editor/esm/vs/platform/registry/common/platform.js"() {
    init_assert();
    init_types();
    RegistryImpl = class {
      constructor() {
        this.data = /* @__PURE__ */ new Map();
      }
      add(id, data) {
        ok(isString(id));
        ok(isObject(data));
        ok(!this.data.has(id), "There is already an extension with this id");
        this.data.set(id, data);
      }
      as(id) {
        return this.data.get(id) || null;
      }
    };
    Registry = new RegistryImpl();
  }
});

// node_modules/monaco-editor/esm/vs/base/common/mime.js
var Mimes;
var init_mime = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/mime.js"() {
    Mimes = Object.freeze({
      text: "text/plain",
      binary: "application/octet-stream",
      unknown: "application/unknown",
      markdown: "text/markdown",
      latex: "text/latex",
      uriList: "text/uri-list"
    });
  }
});

// node_modules/monaco-editor/esm/vs/platform/jsonschemas/common/jsonContributionRegistry.js
function normalizeId(id) {
  if (id.length > 0 && id.charAt(id.length - 1) === "#") {
    return id.substring(0, id.length - 1);
  }
  return id;
}
var Extensions, JSONContributionRegistry, jsonContributionRegistry;
var init_jsonContributionRegistry = __esm({
  "node_modules/monaco-editor/esm/vs/platform/jsonschemas/common/jsonContributionRegistry.js"() {
    init_event();
    init_platform2();
    Extensions = {
      JSONContribution: "base.contributions.json"
    };
    JSONContributionRegistry = class {
      constructor() {
        this._onDidChangeSchema = new Emitter();
        this.schemasById = {};
      }
      registerSchema(uri, unresolvedSchemaContent) {
        this.schemasById[normalizeId(uri)] = unresolvedSchemaContent;
        this._onDidChangeSchema.fire(uri);
      }
      notifySchemaChanged(uri) {
        this._onDidChangeSchema.fire(uri);
      }
    };
    jsonContributionRegistry = new JSONContributionRegistry();
    Registry.add(Extensions.JSONContribution, jsonContributionRegistry);
  }
});

// node_modules/monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js
function overrideIdentifiersFromKey(key) {
  const identifiers = [];
  if (OVERRIDE_PROPERTY_REGEX.test(key)) {
    let matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);
    while (matches === null || matches === void 0 ? void 0 : matches.length) {
      const identifier = matches[1].trim();
      if (identifier) {
        identifiers.push(identifier);
      }
      matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);
    }
  }
  return distinct(identifiers);
}
function getDefaultValue(type) {
  const t = Array.isArray(type) ? type[0] : type;
  switch (t) {
    case "boolean":
      return false;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "array":
      return [];
    case "object":
      return {};
    default:
      return null;
  }
}
function validateProperty(property, schema) {
  var _a2, _b2, _c, _d;
  if (!property.trim()) {
    return localize("config.property.empty", "Cannot register an empty property");
  }
  if (OVERRIDE_PROPERTY_REGEX.test(property)) {
    return localize("config.property.languageDefault", "Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.", property);
  }
  if (configurationRegistry.getConfigurationProperties()[property] !== void 0) {
    return localize("config.property.duplicate", "Cannot register '{0}'. This property is already registered.", property);
  }
  if (((_a2 = schema.policy) === null || _a2 === void 0 ? void 0 : _a2.name) && configurationRegistry.getPolicyConfigurations().get((_b2 = schema.policy) === null || _b2 === void 0 ? void 0 : _b2.name) !== void 0) {
    return localize("config.policy.duplicate", "Cannot register '{0}'. The associated policy {1} is already registered with {2}.", property, (_c = schema.policy) === null || _c === void 0 ? void 0 : _c.name, configurationRegistry.getPolicyConfigurations().get((_d = schema.policy) === null || _d === void 0 ? void 0 : _d.name));
  }
  return null;
}
var Extensions2, allSettings, applicationSettings, machineSettings, machineOverridableSettings, windowSettings, resourceSettings, resourceLanguageSettingsSchemaId, contributionRegistry, ConfigurationRegistry, OVERRIDE_IDENTIFIER_PATTERN, OVERRIDE_IDENTIFIER_REGEX, OVERRIDE_PROPERTY_PATTERN, OVERRIDE_PROPERTY_REGEX, configurationRegistry;
var init_configurationRegistry = __esm({
  "node_modules/monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js"() {
    init_arrays();
    init_event();
    init_types();
    init_nls();
    init_configuration();
    init_jsonContributionRegistry();
    init_platform2();
    Extensions2 = {
      Configuration: "base.contributions.configuration"
    };
    allSettings = { properties: {}, patternProperties: {} };
    applicationSettings = { properties: {}, patternProperties: {} };
    machineSettings = { properties: {}, patternProperties: {} };
    machineOverridableSettings = { properties: {}, patternProperties: {} };
    windowSettings = { properties: {}, patternProperties: {} };
    resourceSettings = { properties: {}, patternProperties: {} };
    resourceLanguageSettingsSchemaId = "vscode://schemas/settings/resourceLanguage";
    contributionRegistry = Registry.as(Extensions.JSONContribution);
    ConfigurationRegistry = class {
      constructor() {
        this.overrideIdentifiers = /* @__PURE__ */ new Set();
        this._onDidSchemaChange = new Emitter();
        this._onDidUpdateConfiguration = new Emitter();
        this.configurationDefaultsOverrides = /* @__PURE__ */ new Map();
        this.defaultLanguageConfigurationOverridesNode = {
          id: "defaultOverrides",
          title: localize("defaultLanguageConfigurationOverrides.title", "Default Language Configuration Overrides"),
          properties: {}
        };
        this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode];
        this.resourceLanguageSettingsSchema = {
          properties: {},
          patternProperties: {},
          additionalProperties: true,
          allowTrailingCommas: true,
          allowComments: true
        };
        this.configurationProperties = {};
        this.policyConfigurations = /* @__PURE__ */ new Map();
        this.excludedConfigurationProperties = {};
        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);
        this.registerOverridePropertyPatternKey();
      }
      registerConfiguration(configuration, validate = true) {
        this.registerConfigurations([configuration], validate);
      }
      registerConfigurations(configurations, validate = true) {
        const properties = /* @__PURE__ */ new Set();
        this.doRegisterConfigurations(configurations, validate, properties);
        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);
        this._onDidSchemaChange.fire();
        this._onDidUpdateConfiguration.fire({ properties });
      }
      registerDefaultConfigurations(configurationDefaults) {
        const properties = /* @__PURE__ */ new Set();
        this.doRegisterDefaultConfigurations(configurationDefaults, properties);
        this._onDidSchemaChange.fire();
        this._onDidUpdateConfiguration.fire({ properties, defaultsOverrides: true });
      }
      doRegisterDefaultConfigurations(configurationDefaults, bucket) {
        var _a2;
        const overrideIdentifiers = [];
        for (const { overrides, source } of configurationDefaults) {
          for (const key in overrides) {
            bucket.add(key);
            if (OVERRIDE_PROPERTY_REGEX.test(key)) {
              const configurationDefaultOverride = this.configurationDefaultsOverrides.get(key);
              const valuesSources = (_a2 = configurationDefaultOverride === null || configurationDefaultOverride === void 0 ? void 0 : configurationDefaultOverride.valuesSources) !== null && _a2 !== void 0 ? _a2 : /* @__PURE__ */ new Map();
              if (source) {
                for (const configuration of Object.keys(overrides[key])) {
                  valuesSources.set(configuration, source);
                }
              }
              const defaultValue = { ...(configurationDefaultOverride === null || configurationDefaultOverride === void 0 ? void 0 : configurationDefaultOverride.value) || {}, ...overrides[key] };
              this.configurationDefaultsOverrides.set(key, { source, value: defaultValue, valuesSources });
              const plainKey = getLanguageTagSettingPlainKey(key);
              const property = {
                type: "object",
                default: defaultValue,
                description: localize("defaultLanguageConfiguration.description", "Configure settings to be overridden for the {0} language.", plainKey),
                $ref: resourceLanguageSettingsSchemaId,
                defaultDefaultValue: defaultValue,
                source: isString(source) ? void 0 : source,
                defaultValueSource: source
              };
              overrideIdentifiers.push(...overrideIdentifiersFromKey(key));
              this.configurationProperties[key] = property;
              this.defaultLanguageConfigurationOverridesNode.properties[key] = property;
            } else {
              this.configurationDefaultsOverrides.set(key, { value: overrides[key], source });
              const property = this.configurationProperties[key];
              if (property) {
                this.updatePropertyDefaultValue(key, property);
                this.updateSchema(key, property);
              }
            }
          }
        }
        this.doRegisterOverrideIdentifiers(overrideIdentifiers);
      }
      registerOverrideIdentifiers(overrideIdentifiers) {
        this.doRegisterOverrideIdentifiers(overrideIdentifiers);
        this._onDidSchemaChange.fire();
      }
      doRegisterOverrideIdentifiers(overrideIdentifiers) {
        for (const overrideIdentifier of overrideIdentifiers) {
          this.overrideIdentifiers.add(overrideIdentifier);
        }
        this.updateOverridePropertyPatternKey();
      }
      doRegisterConfigurations(configurations, validate, bucket) {
        configurations.forEach((configuration) => {
          this.validateAndRegisterProperties(configuration, validate, configuration.extensionInfo, configuration.restrictedProperties, void 0, bucket);
          this.configurationContributors.push(configuration);
          this.registerJSONConfiguration(configuration);
        });
      }
      validateAndRegisterProperties(configuration, validate = true, extensionInfo, restrictedProperties, scope = 3, bucket) {
        var _a2;
        scope = isUndefinedOrNull(configuration.scope) ? scope : configuration.scope;
        const properties = configuration.properties;
        if (properties) {
          for (const key in properties) {
            const property = properties[key];
            if (validate && validateProperty(key, property)) {
              delete properties[key];
              continue;
            }
            property.source = extensionInfo;
            property.defaultDefaultValue = properties[key].default;
            this.updatePropertyDefaultValue(key, property);
            if (OVERRIDE_PROPERTY_REGEX.test(key)) {
              property.scope = void 0;
            } else {
              property.scope = isUndefinedOrNull(property.scope) ? scope : property.scope;
              property.restricted = isUndefinedOrNull(property.restricted) ? !!(restrictedProperties === null || restrictedProperties === void 0 ? void 0 : restrictedProperties.includes(key)) : property.restricted;
            }
            if (properties[key].hasOwnProperty("included") && !properties[key].included) {
              this.excludedConfigurationProperties[key] = properties[key];
              delete properties[key];
              continue;
            } else {
              this.configurationProperties[key] = properties[key];
              if ((_a2 = properties[key].policy) === null || _a2 === void 0 ? void 0 : _a2.name) {
                this.policyConfigurations.set(properties[key].policy.name, key);
              }
            }
            if (!properties[key].deprecationMessage && properties[key].markdownDeprecationMessage) {
              properties[key].deprecationMessage = properties[key].markdownDeprecationMessage;
            }
            bucket.add(key);
          }
        }
        const subNodes = configuration.allOf;
        if (subNodes) {
          for (const node of subNodes) {
            this.validateAndRegisterProperties(node, validate, extensionInfo, restrictedProperties, scope, bucket);
          }
        }
      }
      getConfigurationProperties() {
        return this.configurationProperties;
      }
      getPolicyConfigurations() {
        return this.policyConfigurations;
      }
      registerJSONConfiguration(configuration) {
        const register3 = (configuration2) => {
          const properties = configuration2.properties;
          if (properties) {
            for (const key in properties) {
              this.updateSchema(key, properties[key]);
            }
          }
          const subNodes = configuration2.allOf;
          subNodes === null || subNodes === void 0 ? void 0 : subNodes.forEach(register3);
        };
        register3(configuration);
      }
      updateSchema(key, property) {
        allSettings.properties[key] = property;
        switch (property.scope) {
          case 1:
            applicationSettings.properties[key] = property;
            break;
          case 2:
            machineSettings.properties[key] = property;
            break;
          case 6:
            machineOverridableSettings.properties[key] = property;
            break;
          case 3:
            windowSettings.properties[key] = property;
            break;
          case 4:
            resourceSettings.properties[key] = property;
            break;
          case 5:
            resourceSettings.properties[key] = property;
            this.resourceLanguageSettingsSchema.properties[key] = property;
            break;
        }
      }
      updateOverridePropertyPatternKey() {
        for (const overrideIdentifier of this.overrideIdentifiers.values()) {
          const overrideIdentifierProperty = `[${overrideIdentifier}]`;
          const resourceLanguagePropertiesSchema = {
            type: "object",
            description: localize("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."),
            errorMessage: localize("overrideSettings.errorMessage", "This setting does not support per-language configuration."),
            $ref: resourceLanguageSettingsSchemaId
          };
          this.updatePropertyDefaultValue(overrideIdentifierProperty, resourceLanguagePropertiesSchema);
          allSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
          applicationSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
          machineSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
          machineOverridableSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
          windowSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
          resourceSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
        }
      }
      registerOverridePropertyPatternKey() {
        const resourceLanguagePropertiesSchema = {
          type: "object",
          description: localize("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."),
          errorMessage: localize("overrideSettings.errorMessage", "This setting does not support per-language configuration."),
          $ref: resourceLanguageSettingsSchemaId
        };
        allSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
        applicationSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
        machineSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
        machineOverridableSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
        windowSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
        resourceSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
        this._onDidSchemaChange.fire();
      }
      updatePropertyDefaultValue(key, property) {
        const configurationdefaultOverride = this.configurationDefaultsOverrides.get(key);
        let defaultValue = configurationdefaultOverride === null || configurationdefaultOverride === void 0 ? void 0 : configurationdefaultOverride.value;
        let defaultSource = configurationdefaultOverride === null || configurationdefaultOverride === void 0 ? void 0 : configurationdefaultOverride.source;
        if (isUndefined(defaultValue)) {
          defaultValue = property.defaultDefaultValue;
          defaultSource = void 0;
        }
        if (isUndefined(defaultValue)) {
          defaultValue = getDefaultValue(property.type);
        }
        property.default = defaultValue;
        property.defaultValueSource = defaultSource;
      }
    };
    OVERRIDE_IDENTIFIER_PATTERN = `\\[([^\\]]+)\\]`;
    OVERRIDE_IDENTIFIER_REGEX = new RegExp(OVERRIDE_IDENTIFIER_PATTERN, "g");
    OVERRIDE_PROPERTY_PATTERN = `^(${OVERRIDE_IDENTIFIER_PATTERN})+$`;
    OVERRIDE_PROPERTY_REGEX = new RegExp(OVERRIDE_PROPERTY_PATTERN);
    configurationRegistry = new ConfigurationRegistry();
    Registry.add(Extensions2.Configuration, configurationRegistry);
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/languages/modesRegistry.js
var Extensions3, EditorModesRegistry, ModesRegistry, PLAINTEXT_LANGUAGE_ID, PLAINTEXT_EXTENSION;
var init_modesRegistry = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/languages/modesRegistry.js"() {
    init_nls();
    init_event();
    init_platform2();
    init_mime();
    init_configurationRegistry();
    Extensions3 = {
      ModesRegistry: "editor.modesRegistry"
    };
    EditorModesRegistry = class {
      constructor() {
        this._onDidChangeLanguages = new Emitter();
        this.onDidChangeLanguages = this._onDidChangeLanguages.event;
        this._languages = [];
      }
      registerLanguage(def) {
        this._languages.push(def);
        this._onDidChangeLanguages.fire(void 0);
        return {
          dispose: () => {
            for (let i = 0, len = this._languages.length; i < len; i++) {
              if (this._languages[i] === def) {
                this._languages.splice(i, 1);
                return;
              }
            }
          }
        };
      }
      getLanguages() {
        return this._languages;
      }
    };
    ModesRegistry = new EditorModesRegistry();
    Registry.add(Extensions3.ModesRegistry, ModesRegistry);
    PLAINTEXT_LANGUAGE_ID = "plaintext";
    PLAINTEXT_EXTENSION = ".txt";
    ModesRegistry.registerLanguage({
      id: PLAINTEXT_LANGUAGE_ID,
      extensions: [PLAINTEXT_EXTENSION],
      aliases: [localize("plainText.alias", "Plain Text"), "text"],
      mimetypes: [Mimes.text]
    });
    Registry.as(Extensions2.Configuration).registerDefaultConfigurations([{
      overrides: {
        "[plaintext]": {
          "editor.unicodeHighlight.ambiguousCharacters": false,
          "editor.unicodeHighlight.invisibleCharacters": false
        }
      }
    }]);
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js
function filterValidBrackets(bracketPairs) {
  return bracketPairs.filter(([open, close]) => open !== "" && close !== "");
}
var LanguageBracketsConfiguration, BracketKindBase, OpeningBracketKind, ClosingBracketKind;
var init_languageBracketsConfiguration = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js"() {
    init_cache();
    LanguageBracketsConfiguration = class {
      constructor(languageId, config) {
        this.languageId = languageId;
        const bracketPairs = config.brackets ? filterValidBrackets(config.brackets) : [];
        const openingBracketInfos = new CachedFunction((bracket) => {
          const closing = /* @__PURE__ */ new Set();
          return {
            info: new OpeningBracketKind(this, bracket, closing),
            closing
          };
        });
        const closingBracketInfos = new CachedFunction((bracket) => {
          const opening = /* @__PURE__ */ new Set();
          const openingColorized = /* @__PURE__ */ new Set();
          return {
            info: new ClosingBracketKind(this, bracket, opening, openingColorized),
            opening,
            openingColorized
          };
        });
        for (const [open, close] of bracketPairs) {
          const opening = openingBracketInfos.get(open);
          const closing = closingBracketInfos.get(close);
          opening.closing.add(closing.info);
          closing.opening.add(opening.info);
        }
        const colorizedBracketPairs = config.colorizedBracketPairs ? filterValidBrackets(config.colorizedBracketPairs) : bracketPairs.filter((p) => !(p[0] === "<" && p[1] === ">"));
        for (const [open, close] of colorizedBracketPairs) {
          const opening = openingBracketInfos.get(open);
          const closing = closingBracketInfos.get(close);
          opening.closing.add(closing.info);
          closing.openingColorized.add(opening.info);
          closing.opening.add(opening.info);
        }
        this._openingBrackets = new Map([...openingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));
        this._closingBrackets = new Map([...closingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));
      }
      /**
       * No two brackets have the same bracket text.
      */
      get openingBrackets() {
        return [...this._openingBrackets.values()];
      }
      /**
       * No two brackets have the same bracket text.
      */
      get closingBrackets() {
        return [...this._closingBrackets.values()];
      }
      getOpeningBracketInfo(bracketText) {
        return this._openingBrackets.get(bracketText);
      }
      getClosingBracketInfo(bracketText) {
        return this._closingBrackets.get(bracketText);
      }
      getBracketInfo(bracketText) {
        return this.getOpeningBracketInfo(bracketText) || this.getClosingBracketInfo(bracketText);
      }
    };
    BracketKindBase = class {
      constructor(config, bracketText) {
        this.config = config;
        this.bracketText = bracketText;
      }
      get languageId() {
        return this.config.languageId;
      }
    };
    OpeningBracketKind = class extends BracketKindBase {
      constructor(config, bracketText, openedBrackets) {
        super(config, bracketText);
        this.openedBrackets = openedBrackets;
        this.isOpeningBracket = true;
      }
    };
    ClosingBracketKind = class extends BracketKindBase {
      constructor(config, bracketText, openingBrackets, openingColorizedBrackets) {
        super(config, bracketText);
        this.openingBrackets = openingBrackets;
        this.openingColorizedBrackets = openingColorizedBrackets;
        this.isOpeningBracket = false;
      }
      /**
       * Checks if this bracket closes the given other bracket.
       * If the bracket infos come from different configurations, this method will return false.
      */
      closes(other) {
        if (other["config"] !== this.config) {
          return false;
        }
        return this.openingBrackets.has(other);
      }
      closesColorized(other) {
        if (other["config"] !== this.config) {
          return false;
        }
        return this.openingColorizedBrackets.has(other);
      }
      getOpeningBrackets() {
        return [...this.openingBrackets];
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js
function computeConfig(languageId, registry, configurationService, languageService) {
  let languageConfig = registry.getLanguageConfiguration(languageId);
  if (!languageConfig) {
    if (!languageService.isRegisteredLanguageId(languageId)) {
      return new ResolvedLanguageConfiguration(languageId, {});
    }
    languageConfig = new ResolvedLanguageConfiguration(languageId, {});
  }
  const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);
  const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);
  const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);
  return config;
}
function getCustomizedLanguageConfig(languageId, configurationService) {
  const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {
    overrideIdentifier: languageId
  });
  const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {
    overrideIdentifier: languageId
  });
  return {
    brackets: validateBracketPairs(brackets),
    colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs)
  };
}
function validateBracketPairs(data) {
  if (!Array.isArray(data)) {
    return void 0;
  }
  return data.map((pair) => {
    if (!Array.isArray(pair) || pair.length !== 2) {
      return void 0;
    }
    return [pair[0], pair[1]];
  }).filter((p) => !!p);
}
function getIndentationAtPosition(model, lineNumber, column) {
  const lineText = model.getLineContent(lineNumber);
  let indentation = getLeadingWhitespace(lineText);
  if (indentation.length > column - 1) {
    indentation = indentation.substring(0, column - 1);
  }
  return indentation;
}
function getScopedLineTokens(model, lineNumber, columnNumber) {
  model.tokenization.forceTokenization(lineNumber);
  const lineTokens = model.tokenization.getLineTokens(lineNumber);
  const column = typeof columnNumber === "undefined" ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1;
  return createScopedLineTokens(lineTokens, column);
}
function combineLanguageConfigurations(configs) {
  let result = {
    comments: void 0,
    brackets: void 0,
    wordPattern: void 0,
    indentationRules: void 0,
    onEnterRules: void 0,
    autoClosingPairs: void 0,
    surroundingPairs: void 0,
    autoCloseBefore: void 0,
    folding: void 0,
    colorizedBracketPairs: void 0,
    __electricCharacterSupport: void 0
  };
  for (const entry of configs) {
    result = {
      comments: entry.comments || result.comments,
      brackets: entry.brackets || result.brackets,
      wordPattern: entry.wordPattern || result.wordPattern,
      indentationRules: entry.indentationRules || result.indentationRules,
      onEnterRules: entry.onEnterRules || result.onEnterRules,
      autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,
      surroundingPairs: entry.surroundingPairs || result.surroundingPairs,
      autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,
      folding: entry.folding || result.folding,
      colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,
      __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport
    };
  }
  return result;
}
var __decorate, __param, LanguageConfigurationServiceChangeEvent, ILanguageConfigurationService, LanguageConfigurationService, customizedLanguageConfigKeys, ComposedLanguageConfiguration, LanguageConfigurationContribution, LanguageConfigurationChangeEvent, LanguageConfigurationRegistry, ResolvedLanguageConfiguration;
var init_languageConfigurationRegistry = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js"() {
    init_event();
    init_lifecycle();
    init_strings();
    init_wordHelper();
    init_languageConfiguration();
    init_supports();
    init_characterPair();
    init_electricCharacter();
    init_indentRules();
    init_onEnter();
    init_richEditBrackets();
    init_instantiation();
    init_configuration();
    init_language();
    init_extensions();
    init_modesRegistry();
    init_languageBracketsConfiguration();
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    LanguageConfigurationServiceChangeEvent = class {
      constructor(languageId) {
        this.languageId = languageId;
      }
      affects(languageId) {
        return !this.languageId ? true : this.languageId === languageId;
      }
    };
    ILanguageConfigurationService = createDecorator("languageConfigurationService");
    LanguageConfigurationService = class LanguageConfigurationService2 extends Disposable {
      constructor(configurationService, languageService) {
        super();
        this.configurationService = configurationService;
        this.languageService = languageService;
        this._registry = this._register(new LanguageConfigurationRegistry());
        this.onDidChangeEmitter = this._register(new Emitter());
        this.onDidChange = this.onDidChangeEmitter.event;
        this.configurations = /* @__PURE__ */ new Map();
        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));
        this._register(this.configurationService.onDidChangeConfiguration((e) => {
          const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));
          const localConfigChanged = e.change.overrides.filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k))).map(([overrideLangName]) => overrideLangName);
          if (globalConfigChanged) {
            this.configurations.clear();
            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(void 0));
          } else {
            for (const languageId of localConfigChanged) {
              if (this.languageService.isRegisteredLanguageId(languageId)) {
                this.configurations.delete(languageId);
                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));
              }
            }
          }
        }));
        this._register(this._registry.onDidChange((e) => {
          this.configurations.delete(e.languageId);
          this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));
        }));
      }
      register(languageId, configuration, priority) {
        return this._registry.register(languageId, configuration, priority);
      }
      getLanguageConfiguration(languageId) {
        let result = this.configurations.get(languageId);
        if (!result) {
          result = computeConfig(languageId, this._registry, this.configurationService, this.languageService);
          this.configurations.set(languageId, result);
        }
        return result;
      }
    };
    LanguageConfigurationService = __decorate([
      __param(0, IConfigurationService),
      __param(1, ILanguageService)
    ], LanguageConfigurationService);
    customizedLanguageConfigKeys = {
      brackets: "editor.language.brackets",
      colorizedBracketPairs: "editor.language.colorizedBracketPairs"
    };
    ComposedLanguageConfiguration = class {
      constructor(languageId) {
        this.languageId = languageId;
        this._resolved = null;
        this._entries = [];
        this._order = 0;
        this._resolved = null;
      }
      register(configuration, priority) {
        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);
        this._entries.push(entry);
        this._resolved = null;
        return toDisposable(() => {
          for (let i = 0; i < this._entries.length; i++) {
            if (this._entries[i] === entry) {
              this._entries.splice(i, 1);
              this._resolved = null;
              break;
            }
          }
        });
      }
      getResolvedConfiguration() {
        if (!this._resolved) {
          const config = this._resolve();
          if (config) {
            this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);
          }
        }
        return this._resolved;
      }
      _resolve() {
        if (this._entries.length === 0) {
          return null;
        }
        this._entries.sort(LanguageConfigurationContribution.cmp);
        return combineLanguageConfigurations(this._entries.map((e) => e.configuration));
      }
    };
    LanguageConfigurationContribution = class {
      constructor(configuration, priority, order) {
        this.configuration = configuration;
        this.priority = priority;
        this.order = order;
      }
      static cmp(a, b) {
        if (a.priority === b.priority) {
          return a.order - b.order;
        }
        return a.priority - b.priority;
      }
    };
    LanguageConfigurationChangeEvent = class {
      constructor(languageId) {
        this.languageId = languageId;
      }
    };
    LanguageConfigurationRegistry = class extends Disposable {
      constructor() {
        super();
        this._entries = /* @__PURE__ */ new Map();
        this._onDidChange = this._register(new Emitter());
        this.onDidChange = this._onDidChange.event;
        this._register(this.register(PLAINTEXT_LANGUAGE_ID, {
          brackets: [
            ["(", ")"],
            ["[", "]"],
            ["{", "}"]
          ],
          surroundingPairs: [
            { open: "{", close: "}" },
            { open: "[", close: "]" },
            { open: "(", close: ")" },
            { open: "<", close: ">" },
            { open: '"', close: '"' },
            { open: "'", close: "'" },
            { open: "`", close: "`" }
          ],
          colorizedBracketPairs: [],
          folding: {
            offSide: true
          }
        }, 0));
      }
      /**
       * @param priority Use a higher number for higher priority
       */
      register(languageId, configuration, priority = 0) {
        let entries = this._entries.get(languageId);
        if (!entries) {
          entries = new ComposedLanguageConfiguration(languageId);
          this._entries.set(languageId, entries);
        }
        const disposable = entries.register(configuration, priority);
        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));
        return toDisposable(() => {
          disposable.dispose();
          this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));
        });
      }
      getLanguageConfiguration(languageId) {
        const entries = this._entries.get(languageId);
        return (entries === null || entries === void 0 ? void 0 : entries.getResolvedConfiguration()) || null;
      }
    };
    ResolvedLanguageConfiguration = class _ResolvedLanguageConfiguration {
      constructor(languageId, underlyingConfig) {
        this.languageId = languageId;
        this.underlyingConfig = underlyingConfig;
        this._brackets = null;
        this._electricCharacter = null;
        this._onEnterSupport = this.underlyingConfig.brackets || this.underlyingConfig.indentationRules || this.underlyingConfig.onEnterRules ? new OnEnterSupport(this.underlyingConfig) : null;
        this.comments = _ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);
        this.characterPair = new CharacterPairSupport(this.underlyingConfig);
        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;
        this.indentationRules = this.underlyingConfig.indentationRules;
        if (this.underlyingConfig.indentationRules) {
          this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);
        } else {
          this.indentRulesSupport = null;
        }
        this.foldingRules = this.underlyingConfig.folding || {};
        this.bracketsNew = new LanguageBracketsConfiguration(languageId, this.underlyingConfig);
      }
      getWordDefinition() {
        return ensureValidWordDefinition(this.wordDefinition);
      }
      get brackets() {
        if (!this._brackets && this.underlyingConfig.brackets) {
          this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);
        }
        return this._brackets;
      }
      get electricCharacter() {
        if (!this._electricCharacter) {
          this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);
        }
        return this._electricCharacter;
      }
      onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {
        if (!this._onEnterSupport) {
          return null;
        }
        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);
      }
      getAutoClosingPairs() {
        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());
      }
      getAutoCloseBeforeSet(forQuotes) {
        return this.characterPair.getAutoCloseBeforeSet(forQuotes);
      }
      getSurroundingPairs() {
        return this.characterPair.getSurroundingPairs();
      }
      static _handleComments(conf) {
        const commentRule = conf.comments;
        if (!commentRule) {
          return null;
        }
        const comments = {};
        if (commentRule.lineComment) {
          comments.lineCommentToken = commentRule.lineComment;
        }
        if (commentRule.blockComment) {
          const [blockStart, blockEnd] = commentRule.blockComment;
          comments.blockCommentStartToken = blockStart;
          comments.blockCommentEndToken = blockEnd;
        }
        return comments;
      }
    };
    registerSingleton(
      ILanguageConfigurationService,
      LanguageConfigurationService,
      1
      /* InstantiationType.Delayed */
    );
  }
});

// node_modules/monaco-editor/esm/vs/platform/theme/common/theme.js
function isHighContrast(scheme) {
  return scheme === ColorScheme.HIGH_CONTRAST_DARK || scheme === ColorScheme.HIGH_CONTRAST_LIGHT;
}
function isDark(scheme) {
  return scheme === ColorScheme.DARK || scheme === ColorScheme.HIGH_CONTRAST_DARK;
}
var ColorScheme;
var init_theme = __esm({
  "node_modules/monaco-editor/esm/vs/platform/theme/common/theme.js"() {
    (function(ColorScheme2) {
      ColorScheme2["DARK"] = "dark";
      ColorScheme2["LIGHT"] = "light";
      ColorScheme2["HIGH_CONTRAST_DARK"] = "hcDark";
      ColorScheme2["HIGH_CONTRAST_LIGHT"] = "hcLight";
    })(ColorScheme || (ColorScheme = {}));
  }
});

// node_modules/monaco-editor/esm/vs/platform/theme/common/themeService.js
function themeColorFromId(id) {
  return { id };
}
function getThemeTypeSelector(type) {
  switch (type) {
    case ColorScheme.DARK:
      return "vs-dark";
    case ColorScheme.HIGH_CONTRAST_DARK:
      return "hc-black";
    case ColorScheme.HIGH_CONTRAST_LIGHT:
      return "hc-light";
    default:
      return "vs";
  }
}
function registerThemingParticipant(participant) {
  return themingRegistry.onColorThemeChange(participant);
}
var IThemeService, Extensions4, ThemingRegistry, themingRegistry, Themable;
var init_themeService = __esm({
  "node_modules/monaco-editor/esm/vs/platform/theme/common/themeService.js"() {
    init_event();
    init_lifecycle();
    init_instantiation();
    init_platform2();
    init_theme();
    IThemeService = createDecorator("themeService");
    Extensions4 = {
      ThemingContribution: "base.contributions.theming"
    };
    ThemingRegistry = class {
      constructor() {
        this.themingParticipants = [];
        this.themingParticipants = [];
        this.onThemingParticipantAddedEmitter = new Emitter();
      }
      onColorThemeChange(participant) {
        this.themingParticipants.push(participant);
        this.onThemingParticipantAddedEmitter.fire(participant);
        return toDisposable(() => {
          const idx = this.themingParticipants.indexOf(participant);
          this.themingParticipants.splice(idx, 1);
        });
      }
      getThemingParticipants() {
        return this.themingParticipants;
      }
    };
    themingRegistry = new ThemingRegistry();
    Registry.add(Extensions4.ThemingContribution, themingRegistry);
    Themable = class extends Disposable {
      constructor(themeService) {
        super();
        this.themeService = themeService;
        this.theme = themeService.getColorTheme();
        this._register(this.themeService.onDidColorThemeChange((theme) => this.onThemeChange(theme)));
      }
      onThemeChange(theme) {
        this.theme = theme;
        this.updateStyles();
      }
      updateStyles() {
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/browser/services/codeEditorService.js
var ICodeEditorService;
var init_codeEditorService = __esm({
  "node_modules/monaco-editor/esm/vs/editor/browser/services/codeEditorService.js"() {
    init_instantiation();
    ICodeEditorService = createDecorator("codeEditorService");
  }
});

// node_modules/monaco-editor/esm/vs/platform/contextkey/common/scanner.js
function hintDidYouMean(...meant) {
  switch (meant.length) {
    case 1:
      return localize("contextkey.scanner.hint.didYouMean1", "Did you mean {0}?", meant[0]);
    case 2:
      return localize("contextkey.scanner.hint.didYouMean2", "Did you mean {0} or {1}?", meant[0], meant[1]);
    case 3:
      return localize("contextkey.scanner.hint.didYouMean3", "Did you mean {0}, {1} or {2}?", meant[0], meant[1], meant[2]);
    default:
      return void 0;
  }
}
var hintDidYouForgetToOpenOrCloseQuote, hintDidYouForgetToEscapeSlash, Scanner;
var init_scanner = __esm({
  "node_modules/monaco-editor/esm/vs/platform/contextkey/common/scanner.js"() {
    init_errors();
    init_nls();
    hintDidYouForgetToOpenOrCloseQuote = localize("contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote", "Did you forget to open or close the quote?");
    hintDidYouForgetToEscapeSlash = localize("contextkey.scanner.hint.didYouForgetToEscapeSlash", "Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\/'.");
    Scanner = class _Scanner {
      constructor() {
        this._input = "";
        this._start = 0;
        this._current = 0;
        this._tokens = [];
        this._errors = [];
        this.stringRe = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy;
      }
      static getLexeme(token) {
        switch (token.type) {
          case 0:
            return "(";
          case 1:
            return ")";
          case 2:
            return "!";
          case 3:
            return token.isTripleEq ? "===" : "==";
          case 4:
            return token.isTripleEq ? "!==" : "!=";
          case 5:
            return "<";
          case 6:
            return "<=";
          case 7:
            return ">=";
          case 8:
            return ">=";
          case 9:
            return "=~";
          case 10:
            return token.lexeme;
          case 11:
            return "true";
          case 12:
            return "false";
          case 13:
            return "in";
          case 14:
            return "not";
          case 15:
            return "&&";
          case 16:
            return "||";
          case 17:
            return token.lexeme;
          case 18:
            return token.lexeme;
          case 19:
            return token.lexeme;
          case 20:
            return "EOF";
          default:
            throw illegalState(`unhandled token type: ${JSON.stringify(token)}; have you forgotten to add a case?`);
        }
      }
      reset(value) {
        this._input = value;
        this._start = 0;
        this._current = 0;
        this._tokens = [];
        this._errors = [];
        return this;
      }
      scan() {
        while (!this._isAtEnd()) {
          this._start = this._current;
          const ch = this._advance();
          switch (ch) {
            case 40:
              this._addToken(
                0
                /* TokenType.LParen */
              );
              break;
            case 41:
              this._addToken(
                1
                /* TokenType.RParen */
              );
              break;
            case 33:
              if (this._match(
                61
                /* CharCode.Equals */
              )) {
                const isTripleEq = this._match(
                  61
                  /* CharCode.Equals */
                );
                this._tokens.push({ type: 4, offset: this._start, isTripleEq });
              } else {
                this._addToken(
                  2
                  /* TokenType.Neg */
                );
              }
              break;
            case 39:
              this._quotedString();
              break;
            case 47:
              this._regex();
              break;
            case 61:
              if (this._match(
                61
                /* CharCode.Equals */
              )) {
                const isTripleEq = this._match(
                  61
                  /* CharCode.Equals */
                );
                this._tokens.push({ type: 3, offset: this._start, isTripleEq });
              } else if (this._match(
                126
                /* CharCode.Tilde */
              )) {
                this._addToken(
                  9
                  /* TokenType.RegexOp */
                );
              } else {
                this._error(hintDidYouMean("==", "=~"));
              }
              break;
            case 60:
              this._addToken(
                this._match(
                  61
                  /* CharCode.Equals */
                ) ? 6 : 5
                /* TokenType.Lt */
              );
              break;
            case 62:
              this._addToken(
                this._match(
                  61
                  /* CharCode.Equals */
                ) ? 8 : 7
                /* TokenType.Gt */
              );
              break;
            case 38:
              if (this._match(
                38
                /* CharCode.Ampersand */
              )) {
                this._addToken(
                  15
                  /* TokenType.And */
                );
              } else {
                this._error(hintDidYouMean("&&"));
              }
              break;
            case 124:
              if (this._match(
                124
                /* CharCode.Pipe */
              )) {
                this._addToken(
                  16
                  /* TokenType.Or */
                );
              } else {
                this._error(hintDidYouMean("||"));
              }
              break;
            case 32:
            case 13:
            case 9:
            case 10:
            case 160:
              break;
            default:
              this._string();
          }
        }
        this._start = this._current;
        this._addToken(
          20
          /* TokenType.EOF */
        );
        return Array.from(this._tokens);
      }
      _match(expected) {
        if (this._isAtEnd()) {
          return false;
        }
        if (this._input.charCodeAt(this._current) !== expected) {
          return false;
        }
        this._current++;
        return true;
      }
      _advance() {
        return this._input.charCodeAt(this._current++);
      }
      _peek() {
        return this._isAtEnd() ? 0 : this._input.charCodeAt(this._current);
      }
      _addToken(type) {
        this._tokens.push({ type, offset: this._start });
      }
      _error(additional) {
        const offset = this._start;
        const lexeme = this._input.substring(this._start, this._current);
        const errToken = { type: 19, offset: this._start, lexeme };
        this._errors.push({ offset, lexeme, additionalInfo: additional });
        this._tokens.push(errToken);
      }
      _string() {
        this.stringRe.lastIndex = this._start;
        const match2 = this.stringRe.exec(this._input);
        if (match2) {
          this._current = this._start + match2[0].length;
          const lexeme = this._input.substring(this._start, this._current);
          const keyword = _Scanner._keywords.get(lexeme);
          if (keyword) {
            this._addToken(keyword);
          } else {
            this._tokens.push({ type: 17, lexeme, offset: this._start });
          }
        }
      }
      // captures the lexeme without the leading and trailing '
      _quotedString() {
        while (this._peek() !== 39 && !this._isAtEnd()) {
          this._advance();
        }
        if (this._isAtEnd()) {
          this._error(hintDidYouForgetToOpenOrCloseQuote);
          return;
        }
        this._advance();
        this._tokens.push({ type: 18, lexeme: this._input.substring(this._start + 1, this._current - 1), offset: this._start + 1 });
      }
      /*
       * Lexing a regex expression: /.../[igsmyu]*
       * Based on https://github.com/microsoft/TypeScript/blob/9247ef115e617805983740ba795d7a8164babf89/src/compiler/scanner.ts#L2129-L2181
       *
       * Note that we want slashes within a regex to be escaped, e.g., /file:\\/\\/\\// should match `file:///`
       */
      _regex() {
        let p = this._current;
        let inEscape = false;
        let inCharacterClass = false;
        while (true) {
          if (p >= this._input.length) {
            this._current = p;
            this._error(hintDidYouForgetToEscapeSlash);
            return;
          }
          const ch = this._input.charCodeAt(p);
          if (inEscape) {
            inEscape = false;
          } else if (ch === 47 && !inCharacterClass) {
            p++;
            break;
          } else if (ch === 91) {
            inCharacterClass = true;
          } else if (ch === 92) {
            inEscape = true;
          } else if (ch === 93) {
            inCharacterClass = false;
          }
          p++;
        }
        while (p < this._input.length && _Scanner._regexFlags.has(this._input.charCodeAt(p))) {
          p++;
        }
        this._current = p;
        const lexeme = this._input.substring(this._start, this._current);
        this._tokens.push({ type: 10, lexeme, offset: this._start });
      }
      _isAtEnd() {
        return this._current >= this._input.length;
      }
    };
    Scanner._regexFlags = new Set(["i", "g", "s", "m", "y", "u"].map((ch) => ch.charCodeAt(0)));
    Scanner._keywords = /* @__PURE__ */ new Map([
      [
        "not",
        14
        /* TokenType.Not */
      ],
      [
        "in",
        13
        /* TokenType.In */
      ],
      [
        "false",
        12
        /* TokenType.False */
      ],
      [
        "true",
        11
        /* TokenType.True */
      ]
    ]);
  }
});

// node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js
function expressionsAreEqualWithConstantSubstitution(a, b) {
  const aExpr = a ? a.substituteConstants() : void 0;
  const bExpr = b ? b.substituteConstants() : void 0;
  if (!aExpr && !bExpr) {
    return true;
  }
  if (!aExpr || !bExpr) {
    return false;
  }
  return aExpr.equals(bExpr);
}
function cmp(a, b) {
  return a.cmp(b);
}
function withFloatOrStr(value, callback) {
  if (typeof value === "string") {
    const n = parseFloat(value);
    if (!isNaN(n)) {
      value = n;
    }
  }
  if (typeof value === "string" || typeof value === "number") {
    return callback(value);
  }
  return ContextKeyFalseExpr.INSTANCE;
}
function eliminateConstantsInArray(arr) {
  let newArr = null;
  for (let i = 0, len = arr.length; i < len; i++) {
    const newExpr = arr[i].substituteConstants();
    if (arr[i] !== newExpr) {
      if (newArr === null) {
        newArr = [];
        for (let j = 0; j < i; j++) {
          newArr[j] = arr[j];
        }
      }
    }
    if (newArr !== null) {
      newArr[i] = newExpr;
    }
  }
  if (newArr === null) {
    return arr;
  }
  return newArr;
}
function cmp1(key1, key2) {
  if (key1 < key2) {
    return -1;
  }
  if (key1 > key2) {
    return 1;
  }
  return 0;
}
function cmp2(key1, value1, key2, value2) {
  if (key1 < key2) {
    return -1;
  }
  if (key1 > key2) {
    return 1;
  }
  if (value1 < value2) {
    return -1;
  }
  if (value1 > value2) {
    return 1;
  }
  return 0;
}
function implies(p, q) {
  if (p.type === 0 || q.type === 1) {
    return true;
  }
  if (p.type === 9) {
    if (q.type === 9) {
      return allElementsIncluded(p.expr, q.expr);
    }
    return false;
  }
  if (q.type === 9) {
    for (const element of q.expr) {
      if (implies(p, element)) {
        return true;
      }
    }
    return false;
  }
  if (p.type === 6) {
    if (q.type === 6) {
      return allElementsIncluded(q.expr, p.expr);
    }
    for (const element of p.expr) {
      if (implies(element, q)) {
        return true;
      }
    }
    return false;
  }
  return p.equals(q);
}
function allElementsIncluded(p, q) {
  let pIndex = 0;
  let qIndex = 0;
  while (pIndex < p.length && qIndex < q.length) {
    const cmp3 = p[pIndex].cmp(q[qIndex]);
    if (cmp3 < 0) {
      return false;
    } else if (cmp3 === 0) {
      pIndex++;
      qIndex++;
    } else {
      qIndex++;
    }
  }
  return pIndex === p.length;
}
function getTerminals(node) {
  if (node.type === 9) {
    return node.expr;
  }
  return [node];
}
var CONSTANT_VALUES, hasOwnProperty, defaultConfig, errorEmptyString, hintEmptyString, errorNoInAfterNot, errorClosingParenthesis, errorUnexpectedToken, hintUnexpectedToken, errorUnexpectedEOF, hintUnexpectedEOF, Parser, ContextKeyExpr, ContextKeyFalseExpr, ContextKeyTrueExpr, ContextKeyDefinedExpr, ContextKeyEqualsExpr, ContextKeyInExpr, ContextKeyNotInExpr, ContextKeyNotEqualsExpr, ContextKeyNotExpr, ContextKeyGreaterExpr, ContextKeyGreaterEqualsExpr, ContextKeySmallerExpr, ContextKeySmallerEqualsExpr, ContextKeyRegexExpr, ContextKeyNotRegexExpr, ContextKeyAndExpr, ContextKeyOrExpr, RawContextKey, IContextKeyService;
var init_contextkey = __esm({
  "node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js"() {
    init_platform();
    init_strings();
    init_scanner();
    init_instantiation();
    init_nls();
    CONSTANT_VALUES = /* @__PURE__ */ new Map();
    CONSTANT_VALUES.set("false", false);
    CONSTANT_VALUES.set("true", true);
    CONSTANT_VALUES.set("isMac", isMacintosh);
    CONSTANT_VALUES.set("isLinux", isLinux);
    CONSTANT_VALUES.set("isWindows", isWindows);
    CONSTANT_VALUES.set("isWeb", isWeb);
    CONSTANT_VALUES.set("isMacNative", isMacintosh && !isWeb);
    CONSTANT_VALUES.set("isEdge", isEdge);
    CONSTANT_VALUES.set("isFirefox", isFirefox);
    CONSTANT_VALUES.set("isChrome", isChrome);
    CONSTANT_VALUES.set("isSafari", isSafari);
    hasOwnProperty = Object.prototype.hasOwnProperty;
    defaultConfig = {
      regexParsingWithErrorRecovery: true
    };
    errorEmptyString = localize("contextkey.parser.error.emptyString", "Empty context key expression");
    hintEmptyString = localize("contextkey.parser.error.emptyString.hint", "Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.");
    errorNoInAfterNot = localize("contextkey.parser.error.noInAfterNot", "'in' after 'not'.");
    errorClosingParenthesis = localize("contextkey.parser.error.closingParenthesis", "closing parenthesis ')'");
    errorUnexpectedToken = localize("contextkey.parser.error.unexpectedToken", "Unexpected token");
    hintUnexpectedToken = localize("contextkey.parser.error.unexpectedToken.hint", "Did you forget to put && or || before the token?");
    errorUnexpectedEOF = localize("contextkey.parser.error.unexpectedEOF", "Unexpected end of expression");
    hintUnexpectedEOF = localize("contextkey.parser.error.unexpectedEOF.hint", "Did you forget to put a context key?");
    Parser = class _Parser {
      constructor(_config = defaultConfig) {
        this._config = _config;
        this._scanner = new Scanner();
        this._tokens = [];
        this._current = 0;
        this._parsingErrors = [];
        this._flagsGYRe = /g|y/g;
      }
      /**
       * Parse a context key expression.
       *
       * @param input the expression to parse
       * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors
       */
      parse(input) {
        if (input === "") {
          this._parsingErrors.push({ message: errorEmptyString, offset: 0, lexeme: "", additionalInfo: hintEmptyString });
          return void 0;
        }
        this._tokens = this._scanner.reset(input).scan();
        this._current = 0;
        this._parsingErrors = [];
        try {
          const expr = this._expr();
          if (!this._isAtEnd()) {
            const peek = this._peek();
            const additionalInfo = peek.type === 17 ? hintUnexpectedToken : void 0;
            this._parsingErrors.push({ message: errorUnexpectedToken, offset: peek.offset, lexeme: Scanner.getLexeme(peek), additionalInfo });
            throw _Parser._parseError;
          }
          return expr;
        } catch (e) {
          if (!(e === _Parser._parseError)) {
            throw e;
          }
          return void 0;
        }
      }
      _expr() {
        return this._or();
      }
      _or() {
        const expr = [this._and()];
        while (this._matchOne(
          16
          /* TokenType.Or */
        )) {
          const right = this._and();
          expr.push(right);
        }
        return expr.length === 1 ? expr[0] : ContextKeyExpr.or(...expr);
      }
      _and() {
        const expr = [this._term()];
        while (this._matchOne(
          15
          /* TokenType.And */
        )) {
          const right = this._term();
          expr.push(right);
        }
        return expr.length === 1 ? expr[0] : ContextKeyExpr.and(...expr);
      }
      _term() {
        if (this._matchOne(
          2
          /* TokenType.Neg */
        )) {
          const peek = this._peek();
          switch (peek.type) {
            case 11:
              this._advance();
              return ContextKeyFalseExpr.INSTANCE;
            case 12:
              this._advance();
              return ContextKeyTrueExpr.INSTANCE;
            case 0: {
              this._advance();
              const expr = this._expr();
              this._consume(1, errorClosingParenthesis);
              return expr === null || expr === void 0 ? void 0 : expr.negate();
            }
            case 17:
              this._advance();
              return ContextKeyNotExpr.create(peek.lexeme);
            default:
              throw this._errExpectedButGot(`KEY | true | false | '(' expression ')'`, peek);
          }
        }
        return this._primary();
      }
      _primary() {
        const peek = this._peek();
        switch (peek.type) {
          case 11:
            this._advance();
            return ContextKeyExpr.true();
          case 12:
            this._advance();
            return ContextKeyExpr.false();
          case 0: {
            this._advance();
            const expr = this._expr();
            this._consume(1, errorClosingParenthesis);
            return expr;
          }
          case 17: {
            const key = peek.lexeme;
            this._advance();
            if (this._matchOne(
              9
              /* TokenType.RegexOp */
            )) {
              const expr = this._peek();
              if (!this._config.regexParsingWithErrorRecovery) {
                this._advance();
                if (expr.type !== 10) {
                  throw this._errExpectedButGot(`REGEX`, expr);
                }
                const regexLexeme = expr.lexeme;
                const closingSlashIndex = regexLexeme.lastIndexOf("/");
                const flags = closingSlashIndex === regexLexeme.length - 1 ? void 0 : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));
                let regexp;
                try {
                  regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);
                } catch (e) {
                  throw this._errExpectedButGot(`REGEX`, expr);
                }
                return ContextKeyRegexExpr.create(key, regexp);
              }
              switch (expr.type) {
                case 10:
                case 19: {
                  const lexemeReconstruction = [expr.lexeme];
                  this._advance();
                  let followingToken = this._peek();
                  let parenBalance = 0;
                  for (let i = 0; i < expr.lexeme.length; i++) {
                    if (expr.lexeme.charCodeAt(i) === 40) {
                      parenBalance++;
                    } else if (expr.lexeme.charCodeAt(i) === 41) {
                      parenBalance--;
                    }
                  }
                  while (!this._isAtEnd() && followingToken.type !== 15 && followingToken.type !== 16) {
                    switch (followingToken.type) {
                      case 0:
                        parenBalance++;
                        break;
                      case 1:
                        parenBalance--;
                        break;
                      case 10:
                      case 18:
                        for (let i = 0; i < followingToken.lexeme.length; i++) {
                          if (followingToken.lexeme.charCodeAt(i) === 40) {
                            parenBalance++;
                          } else if (expr.lexeme.charCodeAt(i) === 41) {
                            parenBalance--;
                          }
                        }
                    }
                    if (parenBalance < 0) {
                      break;
                    }
                    lexemeReconstruction.push(Scanner.getLexeme(followingToken));
                    this._advance();
                    followingToken = this._peek();
                  }
                  const regexLexeme = lexemeReconstruction.join("");
                  const closingSlashIndex = regexLexeme.lastIndexOf("/");
                  const flags = closingSlashIndex === regexLexeme.length - 1 ? void 0 : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));
                  let regexp;
                  try {
                    regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);
                  } catch (e) {
                    throw this._errExpectedButGot(`REGEX`, expr);
                  }
                  return ContextKeyExpr.regex(key, regexp);
                }
                case 18: {
                  const serializedValue = expr.lexeme;
                  this._advance();
                  let regex = null;
                  if (!isFalsyOrWhitespace(serializedValue)) {
                    const start = serializedValue.indexOf("/");
                    const end = serializedValue.lastIndexOf("/");
                    if (start !== end && start >= 0) {
                      const value = serializedValue.slice(start + 1, end);
                      const caseIgnoreFlag = serializedValue[end + 1] === "i" ? "i" : "";
                      try {
                        regex = new RegExp(value, caseIgnoreFlag);
                      } catch (_e) {
                        throw this._errExpectedButGot(`REGEX`, expr);
                      }
                    }
                  }
                  if (regex === null) {
                    throw this._errExpectedButGot("REGEX", expr);
                  }
                  return ContextKeyRegexExpr.create(key, regex);
                }
                default:
                  throw this._errExpectedButGot("REGEX", this._peek());
              }
            }
            if (this._matchOne(
              14
              /* TokenType.Not */
            )) {
              this._consume(13, errorNoInAfterNot);
              const right = this._value();
              return ContextKeyExpr.notIn(key, right);
            }
            const maybeOp = this._peek().type;
            switch (maybeOp) {
              case 3: {
                this._advance();
                const right = this._value();
                if (this._previous().type === 18) {
                  return ContextKeyExpr.equals(key, right);
                }
                switch (right) {
                  case "true":
                    return ContextKeyExpr.has(key);
                  case "false":
                    return ContextKeyExpr.not(key);
                  default:
                    return ContextKeyExpr.equals(key, right);
                }
              }
              case 4: {
                this._advance();
                const right = this._value();
                if (this._previous().type === 18) {
                  return ContextKeyExpr.notEquals(key, right);
                }
                switch (right) {
                  case "true":
                    return ContextKeyExpr.not(key);
                  case "false":
                    return ContextKeyExpr.has(key);
                  default:
                    return ContextKeyExpr.notEquals(key, right);
                }
              }
              case 5:
                this._advance();
                return ContextKeySmallerExpr.create(key, this._value());
              case 6:
                this._advance();
                return ContextKeySmallerEqualsExpr.create(key, this._value());
              case 7:
                this._advance();
                return ContextKeyGreaterExpr.create(key, this._value());
              case 8:
                this._advance();
                return ContextKeyGreaterEqualsExpr.create(key, this._value());
              case 13:
                this._advance();
                return ContextKeyExpr.in(key, this._value());
              default:
                return ContextKeyExpr.has(key);
            }
          }
          case 20:
            this._parsingErrors.push({ message: errorUnexpectedEOF, offset: peek.offset, lexeme: "", additionalInfo: hintUnexpectedEOF });
            throw _Parser._parseError;
          default:
            throw this._errExpectedButGot(`true | false | KEY 
	| KEY '=~' REGEX 
	| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());
        }
      }
      _value() {
        const token = this._peek();
        switch (token.type) {
          case 17:
          case 18:
            this._advance();
            return token.lexeme;
          case 11:
            this._advance();
            return "true";
          case 12:
            this._advance();
            return "false";
          case 13:
            this._advance();
            return "in";
          default:
            return "";
        }
      }
      _removeFlagsGY(flags) {
        return flags.replaceAll(this._flagsGYRe, "");
      }
      // careful: this can throw if current token is the initial one (ie index = 0)
      _previous() {
        return this._tokens[this._current - 1];
      }
      _matchOne(token) {
        if (this._check(token)) {
          this._advance();
          return true;
        }
        return false;
      }
      _advance() {
        if (!this._isAtEnd()) {
          this._current++;
        }
        return this._previous();
      }
      _consume(type, message) {
        if (this._check(type)) {
          return this._advance();
        }
        throw this._errExpectedButGot(message, this._peek());
      }
      _errExpectedButGot(expected, got, additionalInfo) {
        const message = localize("contextkey.parser.error.expectedButGot", "Expected: {0}\nReceived: '{1}'.", expected, Scanner.getLexeme(got));
        const offset = got.offset;
        const lexeme = Scanner.getLexeme(got);
        this._parsingErrors.push({ message, offset, lexeme, additionalInfo });
        return _Parser._parseError;
      }
      _check(type) {
        return this._peek().type === type;
      }
      _peek() {
        return this._tokens[this._current];
      }
      _isAtEnd() {
        return this._peek().type === 20;
      }
    };
    Parser._parseError = new Error();
    ContextKeyExpr = class {
      static false() {
        return ContextKeyFalseExpr.INSTANCE;
      }
      static true() {
        return ContextKeyTrueExpr.INSTANCE;
      }
      static has(key) {
        return ContextKeyDefinedExpr.create(key);
      }
      static equals(key, value) {
        return ContextKeyEqualsExpr.create(key, value);
      }
      static notEquals(key, value) {
        return ContextKeyNotEqualsExpr.create(key, value);
      }
      static regex(key, value) {
        return ContextKeyRegexExpr.create(key, value);
      }
      static in(key, value) {
        return ContextKeyInExpr.create(key, value);
      }
      static notIn(key, value) {
        return ContextKeyNotInExpr.create(key, value);
      }
      static not(key) {
        return ContextKeyNotExpr.create(key);
      }
      static and(...expr) {
        return ContextKeyAndExpr.create(expr, null, true);
      }
      static or(...expr) {
        return ContextKeyOrExpr.create(expr, null, true);
      }
      static deserialize(serialized) {
        if (serialized === void 0 || serialized === null) {
          return void 0;
        }
        const expr = this._parser.parse(serialized);
        return expr;
      }
    };
    ContextKeyExpr._parser = new Parser({ regexParsingWithErrorRecovery: false });
    ContextKeyFalseExpr = class {
      constructor() {
        this.type = 0;
      }
      cmp(other) {
        return this.type - other.type;
      }
      equals(other) {
        return other.type === this.type;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        return false;
      }
      serialize() {
        return "false";
      }
      keys() {
        return [];
      }
      negate() {
        return ContextKeyTrueExpr.INSTANCE;
      }
    };
    ContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();
    ContextKeyTrueExpr = class {
      constructor() {
        this.type = 1;
      }
      cmp(other) {
        return this.type - other.type;
      }
      equals(other) {
        return other.type === this.type;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        return true;
      }
      serialize() {
        return "true";
      }
      keys() {
        return [];
      }
      negate() {
        return ContextKeyFalseExpr.INSTANCE;
      }
    };
    ContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();
    ContextKeyDefinedExpr = class _ContextKeyDefinedExpr {
      static create(key, negated = null) {
        const constantValue = CONSTANT_VALUES.get(key);
        if (typeof constantValue === "boolean") {
          return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
        }
        return new _ContextKeyDefinedExpr(key, negated);
      }
      constructor(key, negated) {
        this.key = key;
        this.negated = negated;
        this.type = 2;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp1(this.key, other.key);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key;
        }
        return false;
      }
      substituteConstants() {
        const constantValue = CONSTANT_VALUES.get(this.key);
        if (typeof constantValue === "boolean") {
          return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
        }
        return this;
      }
      evaluate(context) {
        return !!context.getValue(this.key);
      }
      serialize() {
        return this.key;
      }
      keys() {
        return [this.key];
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeyNotExpr.create(this.key, this);
        }
        return this.negated;
      }
    };
    ContextKeyEqualsExpr = class _ContextKeyEqualsExpr {
      static create(key, value, negated = null) {
        if (typeof value === "boolean") {
          return value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated);
        }
        const constantValue = CONSTANT_VALUES.get(key);
        if (typeof constantValue === "boolean") {
          const trueValue = constantValue ? "true" : "false";
          return value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
        }
        return new _ContextKeyEqualsExpr(key, value, negated);
      }
      constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 4;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key && this.value === other.value;
        }
        return false;
      }
      substituteConstants() {
        const constantValue = CONSTANT_VALUES.get(this.key);
        if (typeof constantValue === "boolean") {
          const trueValue = constantValue ? "true" : "false";
          return this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
        }
        return this;
      }
      evaluate(context) {
        return context.getValue(this.key) == this.value;
      }
      serialize() {
        return `${this.key} == '${this.value}'`;
      }
      keys() {
        return [this.key];
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);
        }
        return this.negated;
      }
    };
    ContextKeyInExpr = class _ContextKeyInExpr {
      static create(key, valueKey) {
        return new _ContextKeyInExpr(key, valueKey);
      }
      constructor(key, valueKey) {
        this.key = key;
        this.valueKey = valueKey;
        this.type = 10;
        this.negated = null;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp2(this.key, this.valueKey, other.key, other.valueKey);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key && this.valueKey === other.valueKey;
        }
        return false;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        const source = context.getValue(this.valueKey);
        const item = context.getValue(this.key);
        if (Array.isArray(source)) {
          return source.includes(item);
        }
        if (typeof item === "string" && typeof source === "object" && source !== null) {
          return hasOwnProperty.call(source, item);
        }
        return false;
      }
      serialize() {
        return `${this.key} in '${this.valueKey}'`;
      }
      keys() {
        return [this.key, this.valueKey];
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);
        }
        return this.negated;
      }
    };
    ContextKeyNotInExpr = class _ContextKeyNotInExpr {
      static create(key, valueKey) {
        return new _ContextKeyNotInExpr(key, valueKey);
      }
      constructor(key, valueKey) {
        this.key = key;
        this.valueKey = valueKey;
        this.type = 11;
        this._negated = ContextKeyInExpr.create(key, valueKey);
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return this._negated.cmp(other._negated);
      }
      equals(other) {
        if (other.type === this.type) {
          return this._negated.equals(other._negated);
        }
        return false;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        return !this._negated.evaluate(context);
      }
      serialize() {
        return `${this.key} not in '${this.valueKey}'`;
      }
      keys() {
        return this._negated.keys();
      }
      negate() {
        return this._negated;
      }
    };
    ContextKeyNotEqualsExpr = class _ContextKeyNotEqualsExpr {
      static create(key, value, negated = null) {
        if (typeof value === "boolean") {
          if (value) {
            return ContextKeyNotExpr.create(key, negated);
          }
          return ContextKeyDefinedExpr.create(key, negated);
        }
        const constantValue = CONSTANT_VALUES.get(key);
        if (typeof constantValue === "boolean") {
          const falseValue = constantValue ? "true" : "false";
          return value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
        }
        return new _ContextKeyNotEqualsExpr(key, value, negated);
      }
      constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 5;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key && this.value === other.value;
        }
        return false;
      }
      substituteConstants() {
        const constantValue = CONSTANT_VALUES.get(this.key);
        if (typeof constantValue === "boolean") {
          const falseValue = constantValue ? "true" : "false";
          return this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
        }
        return this;
      }
      evaluate(context) {
        return context.getValue(this.key) != this.value;
      }
      serialize() {
        return `${this.key} != '${this.value}'`;
      }
      keys() {
        return [this.key];
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);
        }
        return this.negated;
      }
    };
    ContextKeyNotExpr = class _ContextKeyNotExpr {
      static create(key, negated = null) {
        const constantValue = CONSTANT_VALUES.get(key);
        if (typeof constantValue === "boolean") {
          return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
        }
        return new _ContextKeyNotExpr(key, negated);
      }
      constructor(key, negated) {
        this.key = key;
        this.negated = negated;
        this.type = 3;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp1(this.key, other.key);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key;
        }
        return false;
      }
      substituteConstants() {
        const constantValue = CONSTANT_VALUES.get(this.key);
        if (typeof constantValue === "boolean") {
          return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
        }
        return this;
      }
      evaluate(context) {
        return !context.getValue(this.key);
      }
      serialize() {
        return `!${this.key}`;
      }
      keys() {
        return [this.key];
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeyDefinedExpr.create(this.key, this);
        }
        return this.negated;
      }
    };
    ContextKeyGreaterExpr = class _ContextKeyGreaterExpr {
      static create(key, _value, negated = null) {
        return withFloatOrStr(_value, (value) => new _ContextKeyGreaterExpr(key, value, negated));
      }
      constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 12;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key && this.value === other.value;
        }
        return false;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        if (typeof this.value === "string") {
          return false;
        }
        return parseFloat(context.getValue(this.key)) > this.value;
      }
      serialize() {
        return `${this.key} > ${this.value}`;
      }
      keys() {
        return [this.key];
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);
        }
        return this.negated;
      }
    };
    ContextKeyGreaterEqualsExpr = class _ContextKeyGreaterEqualsExpr {
      static create(key, _value, negated = null) {
        return withFloatOrStr(_value, (value) => new _ContextKeyGreaterEqualsExpr(key, value, negated));
      }
      constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 13;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key && this.value === other.value;
        }
        return false;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        if (typeof this.value === "string") {
          return false;
        }
        return parseFloat(context.getValue(this.key)) >= this.value;
      }
      serialize() {
        return `${this.key} >= ${this.value}`;
      }
      keys() {
        return [this.key];
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);
        }
        return this.negated;
      }
    };
    ContextKeySmallerExpr = class _ContextKeySmallerExpr {
      static create(key, _value, negated = null) {
        return withFloatOrStr(_value, (value) => new _ContextKeySmallerExpr(key, value, negated));
      }
      constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 14;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key && this.value === other.value;
        }
        return false;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        if (typeof this.value === "string") {
          return false;
        }
        return parseFloat(context.getValue(this.key)) < this.value;
      }
      serialize() {
        return `${this.key} < ${this.value}`;
      }
      keys() {
        return [this.key];
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);
        }
        return this.negated;
      }
    };
    ContextKeySmallerEqualsExpr = class _ContextKeySmallerEqualsExpr {
      static create(key, _value, negated = null) {
        return withFloatOrStr(_value, (value) => new _ContextKeySmallerEqualsExpr(key, value, negated));
      }
      constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 15;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
      }
      equals(other) {
        if (other.type === this.type) {
          return this.key === other.key && this.value === other.value;
        }
        return false;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        if (typeof this.value === "string") {
          return false;
        }
        return parseFloat(context.getValue(this.key)) <= this.value;
      }
      serialize() {
        return `${this.key} <= ${this.value}`;
      }
      keys() {
        return [this.key];
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);
        }
        return this.negated;
      }
    };
    ContextKeyRegexExpr = class _ContextKeyRegexExpr {
      static create(key, regexp) {
        return new _ContextKeyRegexExpr(key, regexp);
      }
      constructor(key, regexp) {
        this.key = key;
        this.regexp = regexp;
        this.type = 7;
        this.negated = null;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        if (this.key < other.key) {
          return -1;
        }
        if (this.key > other.key) {
          return 1;
        }
        const thisSource = this.regexp ? this.regexp.source : "";
        const otherSource = other.regexp ? other.regexp.source : "";
        if (thisSource < otherSource) {
          return -1;
        }
        if (thisSource > otherSource) {
          return 1;
        }
        return 0;
      }
      equals(other) {
        if (other.type === this.type) {
          const thisSource = this.regexp ? this.regexp.source : "";
          const otherSource = other.regexp ? other.regexp.source : "";
          return this.key === other.key && thisSource === otherSource;
        }
        return false;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        const value = context.getValue(this.key);
        return this.regexp ? this.regexp.test(value) : false;
      }
      serialize() {
        const value = this.regexp ? `/${this.regexp.source}/${this.regexp.flags}` : "/invalid/";
        return `${this.key} =~ ${value}`;
      }
      keys() {
        return [this.key];
      }
      negate() {
        if (!this.negated) {
          this.negated = ContextKeyNotRegexExpr.create(this);
        }
        return this.negated;
      }
    };
    ContextKeyNotRegexExpr = class _ContextKeyNotRegexExpr {
      static create(actual) {
        return new _ContextKeyNotRegexExpr(actual);
      }
      constructor(_actual) {
        this._actual = _actual;
        this.type = 8;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        return this._actual.cmp(other._actual);
      }
      equals(other) {
        if (other.type === this.type) {
          return this._actual.equals(other._actual);
        }
        return false;
      }
      substituteConstants() {
        return this;
      }
      evaluate(context) {
        return !this._actual.evaluate(context);
      }
      serialize() {
        return `!(${this._actual.serialize()})`;
      }
      keys() {
        return this._actual.keys();
      }
      negate() {
        return this._actual;
      }
    };
    ContextKeyAndExpr = class _ContextKeyAndExpr {
      static create(_expr, negated, extraRedundantCheck) {
        return _ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);
      }
      constructor(expr, negated) {
        this.expr = expr;
        this.negated = negated;
        this.type = 6;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        if (this.expr.length < other.expr.length) {
          return -1;
        }
        if (this.expr.length > other.expr.length) {
          return 1;
        }
        for (let i = 0, len = this.expr.length; i < len; i++) {
          const r = cmp(this.expr[i], other.expr[i]);
          if (r !== 0) {
            return r;
          }
        }
        return 0;
      }
      equals(other) {
        if (other.type === this.type) {
          if (this.expr.length !== other.expr.length) {
            return false;
          }
          for (let i = 0, len = this.expr.length; i < len; i++) {
            if (!this.expr[i].equals(other.expr[i])) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      substituteConstants() {
        const exprArr = eliminateConstantsInArray(this.expr);
        if (exprArr === this.expr) {
          return this;
        }
        return _ContextKeyAndExpr.create(exprArr, this.negated, false);
      }
      evaluate(context) {
        for (let i = 0, len = this.expr.length; i < len; i++) {
          if (!this.expr[i].evaluate(context)) {
            return false;
          }
        }
        return true;
      }
      static _normalizeArr(arr, negated, extraRedundantCheck) {
        const expr = [];
        let hasTrue = false;
        for (const e of arr) {
          if (!e) {
            continue;
          }
          if (e.type === 1) {
            hasTrue = true;
            continue;
          }
          if (e.type === 0) {
            return ContextKeyFalseExpr.INSTANCE;
          }
          if (e.type === 6) {
            expr.push(...e.expr);
            continue;
          }
          expr.push(e);
        }
        if (expr.length === 0 && hasTrue) {
          return ContextKeyTrueExpr.INSTANCE;
        }
        if (expr.length === 0) {
          return void 0;
        }
        if (expr.length === 1) {
          return expr[0];
        }
        expr.sort(cmp);
        for (let i = 1; i < expr.length; i++) {
          if (expr[i - 1].equals(expr[i])) {
            expr.splice(i, 1);
            i--;
          }
        }
        if (expr.length === 1) {
          return expr[0];
        }
        while (expr.length > 1) {
          const lastElement = expr[expr.length - 1];
          if (lastElement.type !== 9) {
            break;
          }
          expr.pop();
          const secondToLastElement = expr.pop();
          const isFinished = expr.length === 0;
          const resultElement = ContextKeyOrExpr.create(lastElement.expr.map((el) => _ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)), null, isFinished);
          if (resultElement) {
            expr.push(resultElement);
            expr.sort(cmp);
          }
        }
        if (expr.length === 1) {
          return expr[0];
        }
        if (extraRedundantCheck) {
          for (let i = 0; i < expr.length; i++) {
            for (let j = i + 1; j < expr.length; j++) {
              if (expr[i].negate().equals(expr[j])) {
                return ContextKeyFalseExpr.INSTANCE;
              }
            }
          }
          if (expr.length === 1) {
            return expr[0];
          }
        }
        return new _ContextKeyAndExpr(expr, negated);
      }
      serialize() {
        return this.expr.map((e) => e.serialize()).join(" && ");
      }
      keys() {
        const result = [];
        for (const expr of this.expr) {
          result.push(...expr.keys());
        }
        return result;
      }
      negate() {
        if (!this.negated) {
          const result = [];
          for (const expr of this.expr) {
            result.push(expr.negate());
          }
          this.negated = ContextKeyOrExpr.create(result, this, true);
        }
        return this.negated;
      }
    };
    ContextKeyOrExpr = class _ContextKeyOrExpr {
      static create(_expr, negated, extraRedundantCheck) {
        return _ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);
      }
      constructor(expr, negated) {
        this.expr = expr;
        this.negated = negated;
        this.type = 9;
      }
      cmp(other) {
        if (other.type !== this.type) {
          return this.type - other.type;
        }
        if (this.expr.length < other.expr.length) {
          return -1;
        }
        if (this.expr.length > other.expr.length) {
          return 1;
        }
        for (let i = 0, len = this.expr.length; i < len; i++) {
          const r = cmp(this.expr[i], other.expr[i]);
          if (r !== 0) {
            return r;
          }
        }
        return 0;
      }
      equals(other) {
        if (other.type === this.type) {
          if (this.expr.length !== other.expr.length) {
            return false;
          }
          for (let i = 0, len = this.expr.length; i < len; i++) {
            if (!this.expr[i].equals(other.expr[i])) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      substituteConstants() {
        const exprArr = eliminateConstantsInArray(this.expr);
        if (exprArr === this.expr) {
          return this;
        }
        return _ContextKeyOrExpr.create(exprArr, this.negated, false);
      }
      evaluate(context) {
        for (let i = 0, len = this.expr.length; i < len; i++) {
          if (this.expr[i].evaluate(context)) {
            return true;
          }
        }
        return false;
      }
      static _normalizeArr(arr, negated, extraRedundantCheck) {
        let expr = [];
        let hasFalse = false;
        if (arr) {
          for (let i = 0, len = arr.length; i < len; i++) {
            const e = arr[i];
            if (!e) {
              continue;
            }
            if (e.type === 0) {
              hasFalse = true;
              continue;
            }
            if (e.type === 1) {
              return ContextKeyTrueExpr.INSTANCE;
            }
            if (e.type === 9) {
              expr = expr.concat(e.expr);
              continue;
            }
            expr.push(e);
          }
          if (expr.length === 0 && hasFalse) {
            return ContextKeyFalseExpr.INSTANCE;
          }
          expr.sort(cmp);
        }
        if (expr.length === 0) {
          return void 0;
        }
        if (expr.length === 1) {
          return expr[0];
        }
        for (let i = 1; i < expr.length; i++) {
          if (expr[i - 1].equals(expr[i])) {
            expr.splice(i, 1);
            i--;
          }
        }
        if (expr.length === 1) {
          return expr[0];
        }
        if (extraRedundantCheck) {
          for (let i = 0; i < expr.length; i++) {
            for (let j = i + 1; j < expr.length; j++) {
              if (expr[i].negate().equals(expr[j])) {
                return ContextKeyTrueExpr.INSTANCE;
              }
            }
          }
          if (expr.length === 1) {
            return expr[0];
          }
        }
        return new _ContextKeyOrExpr(expr, negated);
      }
      serialize() {
        return this.expr.map((e) => e.serialize()).join(" || ");
      }
      keys() {
        const result = [];
        for (const expr of this.expr) {
          result.push(...expr.keys());
        }
        return result;
      }
      negate() {
        if (!this.negated) {
          const result = [];
          for (const expr of this.expr) {
            result.push(expr.negate());
          }
          while (result.length > 1) {
            const LEFT = result.shift();
            const RIGHT = result.shift();
            const all = [];
            for (const left of getTerminals(LEFT)) {
              for (const right of getTerminals(RIGHT)) {
                all.push(ContextKeyAndExpr.create([left, right], null, false));
              }
            }
            result.unshift(_ContextKeyOrExpr.create(all, null, false));
          }
          this.negated = _ContextKeyOrExpr.create(result, this, true);
        }
        return this.negated;
      }
    };
    RawContextKey = class _RawContextKey extends ContextKeyDefinedExpr {
      static all() {
        return _RawContextKey._info.values();
      }
      constructor(key, defaultValue, metaOrHide) {
        super(key, null);
        this._defaultValue = defaultValue;
        if (typeof metaOrHide === "object") {
          _RawContextKey._info.push({ ...metaOrHide, key });
        } else if (metaOrHide !== true) {
          _RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== void 0 ? typeof defaultValue : void 0 });
        }
      }
      bindTo(target) {
        return target.createKey(this.key, this._defaultValue);
      }
      getValue(target) {
        return target.getContextKeyValue(this.key);
      }
      toNegated() {
        return this.negate();
      }
      isEqualTo(value) {
        return ContextKeyEqualsExpr.create(this.key, value);
      }
    };
    RawContextKey._info = [];
    IContextKeyService = createDecorator("contextKeyService");
  }
});

// node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js
var IUndoRedoService, ResourceEditStackSnapshot, UndoRedoGroup, UndoRedoSource;
var init_undoRedo = __esm({
  "node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js"() {
    init_instantiation();
    IUndoRedoService = createDecorator("undoRedoService");
    ResourceEditStackSnapshot = class {
      constructor(resource, elements) {
        this.resource = resource;
        this.elements = elements;
      }
    };
    UndoRedoGroup = class _UndoRedoGroup {
      constructor() {
        this.id = _UndoRedoGroup._ID++;
        this.order = 1;
      }
      nextOrder() {
        if (this.id === 0) {
          return 0;
        }
        return this.order++;
      }
    };
    UndoRedoGroup._ID = 0;
    UndoRedoGroup.None = new UndoRedoGroup();
    UndoRedoSource = class _UndoRedoSource {
      constructor() {
        this.id = _UndoRedoSource._ID++;
        this.order = 1;
      }
      nextOrder() {
        if (this.id === 0) {
          return 0;
        }
        return this.order++;
      }
    };
    UndoRedoSource._ID = 0;
    UndoRedoSource.None = new UndoRedoSource();
  }
});

// node_modules/monaco-editor/esm/vs/base/common/map.js
function isEntries(arg) {
  return Array.isArray(arg);
}
var _a, _b, ResourceMapEntry, ResourceMap, LinkedMap, LRUCache, BidirectionalMap, SetMap;
var init_map = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/map.js"() {
    ResourceMapEntry = class {
      constructor(uri, value) {
        this.uri = uri;
        this.value = value;
      }
    };
    ResourceMap = class _ResourceMap {
      constructor(arg, toKey) {
        this[_a] = "ResourceMap";
        if (arg instanceof _ResourceMap) {
          this.map = new Map(arg.map);
          this.toKey = toKey !== null && toKey !== void 0 ? toKey : _ResourceMap.defaultToKey;
        } else if (isEntries(arg)) {
          this.map = /* @__PURE__ */ new Map();
          this.toKey = toKey !== null && toKey !== void 0 ? toKey : _ResourceMap.defaultToKey;
          for (const [resource, value] of arg) {
            this.set(resource, value);
          }
        } else {
          this.map = /* @__PURE__ */ new Map();
          this.toKey = arg !== null && arg !== void 0 ? arg : _ResourceMap.defaultToKey;
        }
      }
      set(resource, value) {
        this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));
        return this;
      }
      get(resource) {
        var _c;
        return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;
      }
      has(resource) {
        return this.map.has(this.toKey(resource));
      }
      get size() {
        return this.map.size;
      }
      clear() {
        this.map.clear();
      }
      delete(resource) {
        return this.map.delete(this.toKey(resource));
      }
      forEach(clb, thisArg) {
        if (typeof thisArg !== "undefined") {
          clb = clb.bind(thisArg);
        }
        for (const [_, entry] of this.map) {
          clb(entry.value, entry.uri, this);
        }
      }
      *values() {
        for (const entry of this.map.values()) {
          yield entry.value;
        }
      }
      *keys() {
        for (const entry of this.map.values()) {
          yield entry.uri;
        }
      }
      *entries() {
        for (const entry of this.map.values()) {
          yield [entry.uri, entry.value];
        }
      }
      *[(_a = Symbol.toStringTag, Symbol.iterator)]() {
        for (const [, entry] of this.map) {
          yield [entry.uri, entry.value];
        }
      }
    };
    ResourceMap.defaultToKey = (resource) => resource.toString();
    LinkedMap = class {
      constructor() {
        this[_b] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        var _c;
        return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;
      }
      get last() {
        var _c;
        return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = 0) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== 0) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = 0) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== 0) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case 0:
              this.addItemLast(item);
              break;
            case 1:
              this.addItemFirst(item);
              break;
            case 2:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_b = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== 1 && touch !== 2) {
          return;
        }
        if (touch === 1) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === 2) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get(key, touch = 2) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(
          key,
          0
          /* Touch.None */
        );
      }
      set(key, value) {
        super.set(
          key,
          value,
          2
          /* Touch.AsNew */
        );
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    BidirectionalMap = class {
      constructor(entries) {
        this._m1 = /* @__PURE__ */ new Map();
        this._m2 = /* @__PURE__ */ new Map();
        if (entries) {
          for (const [key, value] of entries) {
            this.set(key, value);
          }
        }
      }
      clear() {
        this._m1.clear();
        this._m2.clear();
      }
      set(key, value) {
        this._m1.set(key, value);
        this._m2.set(value, key);
      }
      get(key) {
        return this._m1.get(key);
      }
      getKey(value) {
        return this._m2.get(value);
      }
      delete(key) {
        const value = this._m1.get(key);
        if (value === void 0) {
          return false;
        }
        this._m1.delete(key);
        this._m2.delete(value);
        return true;
      }
      keys() {
        return this._m1.keys();
      }
      values() {
        return this._m1.values();
      }
    };
    SetMap = class {
      constructor() {
        this.map = /* @__PURE__ */ new Map();
      }
      add(key, value) {
        let values = this.map.get(key);
        if (!values) {
          values = /* @__PURE__ */ new Set();
          this.map.set(key, values);
        }
        values.add(value);
      }
      delete(key, value) {
        const values = this.map.get(key);
        if (!values) {
          return;
        }
        values.delete(value);
        if (values.size === 0) {
          this.map.delete(key);
        }
      }
      forEach(key, fn) {
        const values = this.map.get(key);
        if (!values) {
          return;
        }
        values.forEach(fn);
      }
      get(key) {
        const values = this.map.get(key);
        if (!values) {
          return /* @__PURE__ */ new Set();
        }
        return values;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/numbers.js
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
var MovingAverage, SlidingWindowAverage;
var init_numbers = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/numbers.js"() {
    MovingAverage = class {
      constructor() {
        this._n = 1;
        this._val = 0;
      }
      update(value) {
        this._val = this._val + (value - this._val) / this._n;
        this._n += 1;
        return this._val;
      }
      get value() {
        return this._val;
      }
    };
    SlidingWindowAverage = class {
      constructor(size) {
        this._n = 0;
        this._val = 0;
        this._values = [];
        this._index = 0;
        this._sum = 0;
        this._values = new Array(size);
        this._values.fill(0, 0, size);
      }
      update(value) {
        const oldValue = this._values[this._index];
        this._values[this._index] = value;
        this._index = (this._index + 1) % this._values.length;
        this._sum -= oldValue;
        this._sum += value;
        if (this._n < this._values.length) {
          this._n += 1;
        }
        this._val = this._sum / this._n;
        return this._val;
      }
      get value() {
        return this._val;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/platform/environment/common/environment.js
var IEnvironmentService;
var init_environment = __esm({
  "node_modules/monaco-editor/esm/vs/platform/environment/common/environment.js"() {
    init_instantiation();
    IEnvironmentService = createDecorator("environmentService");
  }
});

// node_modules/monaco-editor/esm/vs/platform/log/common/log.js
function LogLevelToString(logLevel) {
  switch (logLevel) {
    case LogLevel.Trace:
      return "trace";
    case LogLevel.Debug:
      return "debug";
    case LogLevel.Info:
      return "info";
    case LogLevel.Warning:
      return "warn";
    case LogLevel.Error:
      return "error";
    case LogLevel.Off:
      return "off";
  }
}
var ILogService, LogLevel, DEFAULT_LOG_LEVEL, AbstractLogger, ConsoleLogger, MultiplexLogger, CONTEXT_LOG_LEVEL;
var init_log = __esm({
  "node_modules/monaco-editor/esm/vs/platform/log/common/log.js"() {
    init_event();
    init_lifecycle();
    init_contextkey();
    init_instantiation();
    ILogService = createDecorator("logService");
    (function(LogLevel2) {
      LogLevel2[LogLevel2["Off"] = 0] = "Off";
      LogLevel2[LogLevel2["Trace"] = 1] = "Trace";
      LogLevel2[LogLevel2["Debug"] = 2] = "Debug";
      LogLevel2[LogLevel2["Info"] = 3] = "Info";
      LogLevel2[LogLevel2["Warning"] = 4] = "Warning";
      LogLevel2[LogLevel2["Error"] = 5] = "Error";
    })(LogLevel || (LogLevel = {}));
    DEFAULT_LOG_LEVEL = LogLevel.Info;
    AbstractLogger = class extends Disposable {
      constructor() {
        super(...arguments);
        this.level = DEFAULT_LOG_LEVEL;
        this._onDidChangeLogLevel = this._register(new Emitter());
        this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;
      }
      setLevel(level) {
        if (this.level !== level) {
          this.level = level;
          this._onDidChangeLogLevel.fire(this.level);
        }
      }
      getLevel() {
        return this.level;
      }
      checkLogLevel(level) {
        return this.level !== LogLevel.Off && this.level <= level;
      }
    };
    ConsoleLogger = class extends AbstractLogger {
      constructor(logLevel = DEFAULT_LOG_LEVEL, useColors = true) {
        super();
        this.useColors = useColors;
        this.setLevel(logLevel);
      }
      trace(message, ...args) {
        if (this.checkLogLevel(LogLevel.Trace)) {
          if (this.useColors) {
            console.log("%cTRACE", "color: #888", message, ...args);
          } else {
            console.log(message, ...args);
          }
        }
      }
      debug(message, ...args) {
        if (this.checkLogLevel(LogLevel.Debug)) {
          if (this.useColors) {
            console.log("%cDEBUG", "background: #eee; color: #888", message, ...args);
          } else {
            console.log(message, ...args);
          }
        }
      }
      info(message, ...args) {
        if (this.checkLogLevel(LogLevel.Info)) {
          if (this.useColors) {
            console.log("%c INFO", "color: #33f", message, ...args);
          } else {
            console.log(message, ...args);
          }
        }
      }
      warn(message, ...args) {
        if (this.checkLogLevel(LogLevel.Warning)) {
          if (this.useColors) {
            console.log("%c WARN", "color: #993", message, ...args);
          } else {
            console.log(message, ...args);
          }
        }
      }
      error(message, ...args) {
        if (this.checkLogLevel(LogLevel.Error)) {
          if (this.useColors) {
            console.log("%c  ERR", "color: #f33", message, ...args);
          } else {
            console.error(message, ...args);
          }
        }
      }
    };
    MultiplexLogger = class extends AbstractLogger {
      constructor(loggers) {
        super();
        this.loggers = loggers;
        if (loggers.length) {
          this.setLevel(loggers[0].getLevel());
        }
      }
      setLevel(level) {
        for (const logger of this.loggers) {
          logger.setLevel(level);
        }
        super.setLevel(level);
      }
      trace(message, ...args) {
        for (const logger of this.loggers) {
          logger.trace(message, ...args);
        }
      }
      debug(message, ...args) {
        for (const logger of this.loggers) {
          logger.debug(message, ...args);
        }
      }
      info(message, ...args) {
        for (const logger of this.loggers) {
          logger.info(message, ...args);
        }
      }
      warn(message, ...args) {
        for (const logger of this.loggers) {
          logger.warn(message, ...args);
        }
      }
      error(message, ...args) {
        for (const logger of this.loggers) {
          logger.error(message, ...args);
        }
      }
      dispose() {
        for (const logger of this.loggers) {
          logger.dispose();
        }
        super.dispose();
      }
    };
    CONTEXT_LOG_LEVEL = new RawContextKey("logLevel", LogLevelToString(LogLevel.Info));
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/services/languageFeatureDebounce.js
var __decorate6, __param6, ILanguageFeatureDebounceService, IdentityHash, NullDebounceInformation, FeatureDebounceInformation, LanguageFeatureDebounceService;
var init_languageFeatureDebounce = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/services/languageFeatureDebounce.js"() {
    init_hash();
    init_map();
    init_numbers();
    init_environment();
    init_extensions();
    init_instantiation();
    init_log();
    init_network();
    __decorate6 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param6 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    ILanguageFeatureDebounceService = createDecorator("ILanguageFeatureDebounceService");
    (function(IdentityHash2) {
      const _hashes = /* @__PURE__ */ new WeakMap();
      let pool = 0;
      function of(obj) {
        let value = _hashes.get(obj);
        if (value === void 0) {
          value = ++pool;
          _hashes.set(obj, value);
        }
        return value;
      }
      IdentityHash2.of = of;
    })(IdentityHash || (IdentityHash = {}));
    NullDebounceInformation = class {
      constructor(_default) {
        this._default = _default;
      }
      get(_model) {
        return this._default;
      }
      update(_model, _value) {
        return this._default;
      }
      default() {
        return this._default;
      }
    };
    FeatureDebounceInformation = class {
      constructor(_logService, _name, _registry2, _default, _min, _max) {
        this._logService = _logService;
        this._name = _name;
        this._registry = _registry2;
        this._default = _default;
        this._min = _min;
        this._max = _max;
        this._cache = new LRUCache(50, 0.7);
      }
      _key(model) {
        return model.id + this._registry.all(model).reduce((hashVal, obj) => doHash(IdentityHash.of(obj), hashVal), 0);
      }
      get(model) {
        const key = this._key(model);
        const avg = this._cache.get(key);
        return avg ? clamp(avg.value, this._min, this._max) : this.default();
      }
      update(model, value) {
        const key = this._key(model);
        let avg = this._cache.get(key);
        if (!avg) {
          avg = new SlidingWindowAverage(6);
          this._cache.set(key, avg);
        }
        const newValue = clamp(avg.update(value), this._min, this._max);
        if (!matchesScheme(model.uri, "output")) {
          this._logService.trace(`[DEBOUNCE: ${this._name}] for ${model.uri.toString()} is ${newValue}ms`);
        }
        return newValue;
      }
      _overall() {
        const result = new MovingAverage();
        for (const [, avg] of this._cache) {
          result.update(avg.value);
        }
        return result.value;
      }
      default() {
        const value = this._overall() | 0 || this._default;
        return clamp(value, this._min, this._max);
      }
    };
    LanguageFeatureDebounceService = class LanguageFeatureDebounceService2 {
      constructor(_logService, envService) {
        this._logService = _logService;
        this._data = /* @__PURE__ */ new Map();
        this._isDev = envService.isExtensionDevelopment || !envService.isBuilt;
      }
      for(feature, name, config) {
        var _a2, _b2, _c;
        const min = (_a2 = config === null || config === void 0 ? void 0 : config.min) !== null && _a2 !== void 0 ? _a2 : 50;
        const max = (_b2 = config === null || config === void 0 ? void 0 : config.max) !== null && _b2 !== void 0 ? _b2 : min ** 2;
        const extra = (_c = config === null || config === void 0 ? void 0 : config.key) !== null && _c !== void 0 ? _c : void 0;
        const key = `${IdentityHash.of(feature)},${min}${extra ? "," + extra : ""}`;
        let info = this._data.get(key);
        if (!info) {
          if (!this._isDev) {
            this._logService.debug(`[DEBOUNCE: ${name}] is disabled in developed mode`);
            info = new NullDebounceInformation(min * 1.5);
          } else {
            info = new FeatureDebounceInformation(
              this._logService,
              name,
              feature,
              this._overallAverage() | 0 || min * 1.5,
              // default is overall default or derived from min-value
              min,
              max
            );
          }
          this._data.set(key, info);
        }
        return info;
      }
      _overallAverage() {
        const result = new MovingAverage();
        for (const info of this._data.values()) {
          result.update(info.default());
        }
        return result.value;
      }
    };
    LanguageFeatureDebounceService = __decorate6([
      __param6(0, ILogService),
      __param6(1, IEnvironmentService)
    ], LanguageFeatureDebounceService);
    registerSingleton(
      ILanguageFeatureDebounceService,
      LanguageFeatureDebounceService,
      1
      /* InstantiationType.Delayed */
    );
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js
var TokenMetadata;
var init_encodedTokenAttributes = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js"() {
    TokenMetadata = class {
      static getLanguageId(metadata) {
        return (metadata & 255) >>> 0;
      }
      static getTokenType(metadata) {
        return (metadata & 768) >>> 8;
      }
      static containsBalancedBrackets(metadata) {
        return (metadata & 1024) !== 0;
      }
      static getFontStyle(metadata) {
        return (metadata & 30720) >>> 11;
      }
      static getForeground(metadata) {
        return (metadata & 16744448) >>> 15;
      }
      static getBackground(metadata) {
        return (metadata & 4278190080) >>> 24;
      }
      static getClassNameFromMetadata(metadata) {
        const foreground2 = this.getForeground(metadata);
        let className = "mtk" + foreground2;
        const fontStyle = this.getFontStyle(metadata);
        if (fontStyle & 1) {
          className += " mtki";
        }
        if (fontStyle & 2) {
          className += " mtkb";
        }
        if (fontStyle & 4) {
          className += " mtku";
        }
        if (fontStyle & 8) {
          className += " mtks";
        }
        return className;
      }
      static getInlineStyleFromMetadata(metadata, colorMap) {
        const foreground2 = this.getForeground(metadata);
        const fontStyle = this.getFontStyle(metadata);
        let result = `color: ${colorMap[foreground2]};`;
        if (fontStyle & 1) {
          result += "font-style: italic;";
        }
        if (fontStyle & 2) {
          result += "font-weight: bold;";
        }
        let textDecoration = "";
        if (fontStyle & 4) {
          textDecoration += " underline";
        }
        if (fontStyle & 8) {
          textDecoration += " line-through";
        }
        if (textDecoration) {
          result += `text-decoration:${textDecoration};`;
        }
        return result;
      }
      static getPresentationFromMetadata(metadata) {
        const foreground2 = this.getForeground(metadata);
        const fontStyle = this.getFontStyle(metadata);
        return {
          foreground: foreground2,
          italic: Boolean(
            fontStyle & 1
            /* FontStyle.Italic */
          ),
          bold: Boolean(
            fontStyle & 2
            /* FontStyle.Bold */
          ),
          underline: Boolean(
            fontStyle & 4
            /* FontStyle.Underline */
          ),
          strikethrough: Boolean(
            fontStyle & 8
            /* FontStyle.Strikethrough */
          )
        };
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js
function countEOL(text) {
  let eolCount = 0;
  let firstLineLength = 0;
  let lastLineStart = 0;
  let eol = 0;
  for (let i = 0, len = text.length; i < len; i++) {
    const chr = text.charCodeAt(i);
    if (chr === 13) {
      if (eolCount === 0) {
        firstLineLength = i;
      }
      eolCount++;
      if (i + 1 < len && text.charCodeAt(i + 1) === 10) {
        eol |= 2;
        i++;
      } else {
        eol |= 3;
      }
      lastLineStart = i + 1;
    } else if (chr === 10) {
      eol |= 1;
      if (eolCount === 0) {
        firstLineLength = i;
      }
      eolCount++;
      lastLineStart = i + 1;
    }
  }
  if (eolCount === 0) {
    firstLineLength = text.length;
  }
  return [eolCount, firstLineLength, text.length - lastLineStart, eol];
}
var init_eolCounter = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js"() {
  }
});

// node_modules/monaco-editor/esm/vs/base/common/objects.js
function deepClone(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  if (obj instanceof RegExp) {
    return obj;
  }
  const result = Array.isArray(obj) ? [] : {};
  Object.entries(obj).forEach(([key, value]) => {
    result[key] = value && typeof value === "object" ? deepClone(value) : value;
  });
  return result;
}
function deepFreeze(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  const stack = [obj];
  while (stack.length > 0) {
    const obj2 = stack.shift();
    Object.freeze(obj2);
    for (const key in obj2) {
      if (_hasOwnProperty.call(obj2, key)) {
        const prop = obj2[key];
        if (typeof prop === "object" && !Object.isFrozen(prop) && !isTypedArray(prop)) {
          stack.push(prop);
        }
      }
    }
  }
  return obj;
}
function cloneAndChange(obj, changer) {
  return _cloneAndChange(obj, changer, /* @__PURE__ */ new Set());
}
function _cloneAndChange(obj, changer, seen) {
  if (isUndefinedOrNull(obj)) {
    return obj;
  }
  const changed = changer(obj);
  if (typeof changed !== "undefined") {
    return changed;
  }
  if (Array.isArray(obj)) {
    const r1 = [];
    for (const e of obj) {
      r1.push(_cloneAndChange(e, changer, seen));
    }
    return r1;
  }
  if (isObject(obj)) {
    if (seen.has(obj)) {
      throw new Error("Cannot clone recursive data-structure");
    }
    seen.add(obj);
    const r2 = {};
    for (const i2 in obj) {
      if (_hasOwnProperty.call(obj, i2)) {
        r2[i2] = _cloneAndChange(obj[i2], changer, seen);
      }
    }
    seen.delete(obj);
    return r2;
  }
  return obj;
}
function mixin(destination, source, overwrite = true) {
  if (!isObject(destination)) {
    return source;
  }
  if (isObject(source)) {
    Object.keys(source).forEach((key) => {
      if (key in destination) {
        if (overwrite) {
          if (isObject(destination[key]) && isObject(source[key])) {
            mixin(destination[key], source[key], overwrite);
          } else {
            destination[key] = source[key];
          }
        }
      } else {
        destination[key] = source[key];
      }
    });
  }
  return destination;
}
function equals2(one, other) {
  if (one === other) {
    return true;
  }
  if (one === null || one === void 0 || other === null || other === void 0) {
    return false;
  }
  if (typeof one !== typeof other) {
    return false;
  }
  if (typeof one !== "object") {
    return false;
  }
  if (Array.isArray(one) !== Array.isArray(other)) {
    return false;
  }
  let i;
  let key;
  if (Array.isArray(one)) {
    if (one.length !== other.length) {
      return false;
    }
    for (i = 0; i < one.length; i++) {
      if (!equals2(one[i], other[i])) {
        return false;
      }
    }
  } else {
    const oneKeys = [];
    for (key in one) {
      oneKeys.push(key);
    }
    oneKeys.sort();
    const otherKeys = [];
    for (key in other) {
      otherKeys.push(key);
    }
    otherKeys.sort();
    if (!equals2(oneKeys, otherKeys)) {
      return false;
    }
    for (i = 0; i < oneKeys.length; i++) {
      if (!equals2(one[oneKeys[i]], other[oneKeys[i]])) {
        return false;
      }
    }
  }
  return true;
}
function getAllPropertyNames(obj) {
  let res = [];
  while (Object.prototype !== obj) {
    res = res.concat(Object.getOwnPropertyNames(obj));
    obj = Object.getPrototypeOf(obj);
  }
  return res;
}
function getAllMethodNames(obj) {
  const methods = [];
  for (const prop of getAllPropertyNames(obj)) {
    if (typeof obj[prop] === "function") {
      methods.push(prop);
    }
  }
  return methods;
}
function createProxyObject(methodNames, invoke) {
  const createProxyMethod = (method) => {
    return function() {
      const args = Array.prototype.slice.call(arguments, 0);
      return invoke(method, args);
    };
  };
  const result = {};
  for (const methodName of methodNames) {
    result[methodName] = createProxyMethod(methodName);
  }
  return result;
}
var _hasOwnProperty;
var init_objects = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/objects.js"() {
    init_types();
    _hasOwnProperty = Object.prototype.hasOwnProperty;
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model.js
function isITextSnapshot(obj) {
  return obj && typeof obj.read === "function";
}
function shouldSynchronizeModel(model) {
  return !model.isTooLargeForSyncing() && !model.isForSimpleWidget;
}
var OverviewRulerLane, GlyphMarginLane, MinimapPosition, InjectedTextCursorStops, TextModelResolvedOptions, FindMatch, ValidAnnotatedEditOperation, SearchData, ApplyEditsResult;
var init_model = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model.js"() {
    init_objects();
    (function(OverviewRulerLane3) {
      OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
      OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
      OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
      OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
    })(OverviewRulerLane || (OverviewRulerLane = {}));
    (function(GlyphMarginLane3) {
      GlyphMarginLane3[GlyphMarginLane3["Left"] = 1] = "Left";
      GlyphMarginLane3[GlyphMarginLane3["Center"] = 2] = "Center";
      GlyphMarginLane3[GlyphMarginLane3["Right"] = 3] = "Right";
    })(GlyphMarginLane || (GlyphMarginLane = {}));
    (function(MinimapPosition3) {
      MinimapPosition3[MinimapPosition3["Inline"] = 1] = "Inline";
      MinimapPosition3[MinimapPosition3["Gutter"] = 2] = "Gutter";
    })(MinimapPosition || (MinimapPosition = {}));
    (function(InjectedTextCursorStops3) {
      InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
      InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
      InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
      InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
    })(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
    TextModelResolvedOptions = class {
      get originalIndentSize() {
        return this._indentSizeIsTabSize ? "tabSize" : this.indentSize;
      }
      /**
       * @internal
       */
      constructor(src) {
        this._textModelResolvedOptionsBrand = void 0;
        this.tabSize = Math.max(1, src.tabSize | 0);
        if (src.indentSize === "tabSize") {
          this.indentSize = this.tabSize;
          this._indentSizeIsTabSize = true;
        } else {
          this.indentSize = Math.max(1, src.indentSize | 0);
          this._indentSizeIsTabSize = false;
        }
        this.insertSpaces = Boolean(src.insertSpaces);
        this.defaultEOL = src.defaultEOL | 0;
        this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);
        this.bracketPairColorizationOptions = src.bracketPairColorizationOptions;
      }
      /**
       * @internal
       */
      equals(other) {
        return this.tabSize === other.tabSize && this._indentSizeIsTabSize === other._indentSizeIsTabSize && this.indentSize === other.indentSize && this.insertSpaces === other.insertSpaces && this.defaultEOL === other.defaultEOL && this.trimAutoWhitespace === other.trimAutoWhitespace && equals2(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions);
      }
      /**
       * @internal
       */
      createChangeEvent(newOpts) {
        return {
          tabSize: this.tabSize !== newOpts.tabSize,
          indentSize: this.indentSize !== newOpts.indentSize,
          insertSpaces: this.insertSpaces !== newOpts.insertSpaces,
          trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace
        };
      }
    };
    FindMatch = class {
      /**
       * @internal
       */
      constructor(range2, matches) {
        this._findMatchBrand = void 0;
        this.range = range2;
        this.matches = matches;
      }
    };
    ValidAnnotatedEditOperation = class {
      constructor(identifier, range2, text, forceMoveMarkers, isAutoWhitespaceEdit, _isTracked) {
        this.identifier = identifier;
        this.range = range2;
        this.text = text;
        this.forceMoveMarkers = forceMoveMarkers;
        this.isAutoWhitespaceEdit = isAutoWhitespaceEdit;
        this._isTracked = _isTracked;
      }
    };
    SearchData = class {
      constructor(regex, wordSeparators2, simpleSearch) {
        this.regex = regex;
        this.wordSeparators = wordSeparators2;
        this.simpleSearch = simpleSearch;
      }
    };
    ApplyEditsResult = class {
      constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {
        this.reverseEdits = reverseEdits;
        this.changes = changes;
        this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/extpath.js
function isPathSeparator(code) {
  return code === 47 || code === 92;
}
function toSlashes(osPath) {
  return osPath.replace(/[\\/]/g, posix.sep);
}
function toPosixPath(osPath) {
  if (osPath.indexOf("/") === -1) {
    osPath = toSlashes(osPath);
  }
  if (/^[a-zA-Z]:(\/|$)/.test(osPath)) {
    osPath = "/" + osPath;
  }
  return osPath;
}
function getRoot(path, sep2 = posix.sep) {
  if (!path) {
    return "";
  }
  const len = path.length;
  const firstLetter = path.charCodeAt(0);
  if (isPathSeparator(firstLetter)) {
    if (isPathSeparator(path.charCodeAt(1))) {
      if (!isPathSeparator(path.charCodeAt(2))) {
        let pos2 = 3;
        const start = pos2;
        for (; pos2 < len; pos2++) {
          if (isPathSeparator(path.charCodeAt(pos2))) {
            break;
          }
        }
        if (start !== pos2 && !isPathSeparator(path.charCodeAt(pos2 + 1))) {
          pos2 += 1;
          for (; pos2 < len; pos2++) {
            if (isPathSeparator(path.charCodeAt(pos2))) {
              return path.slice(0, pos2 + 1).replace(/[\\/]/g, sep2);
            }
          }
        }
      }
    }
    return sep2;
  } else if (isWindowsDriveLetter(firstLetter)) {
    if (path.charCodeAt(1) === 58) {
      if (isPathSeparator(path.charCodeAt(2))) {
        return path.slice(0, 2) + sep2;
      } else {
        return path.slice(0, 2);
      }
    }
  }
  let pos = path.indexOf("://");
  if (pos !== -1) {
    pos += 3;
    for (; pos < len; pos++) {
      if (isPathSeparator(path.charCodeAt(pos))) {
        return path.slice(0, pos + 1);
      }
    }
  }
  return "";
}
function isEqualOrParent(base, parentCandidate, ignoreCase, separator = sep) {
  if (base === parentCandidate) {
    return true;
  }
  if (!base || !parentCandidate) {
    return false;
  }
  if (parentCandidate.length > base.length) {
    return false;
  }
  if (ignoreCase) {
    const beginsWith = startsWithIgnoreCase(base, parentCandidate);
    if (!beginsWith) {
      return false;
    }
    if (parentCandidate.length === base.length) {
      return true;
    }
    let sepOffset = parentCandidate.length;
    if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {
      sepOffset--;
    }
    return base.charAt(sepOffset) === separator;
  }
  if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {
    parentCandidate += separator;
  }
  return base.indexOf(parentCandidate) === 0;
}
function isWindowsDriveLetter(char0) {
  return char0 >= 65 && char0 <= 90 || char0 >= 97 && char0 <= 122;
}
function hasDriveLetter(path, isWindowsOS = isWindows) {
  if (isWindowsOS) {
    return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58;
  }
  return false;
}
var init_extpath = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/extpath.js"() {
    init_path();
    init_platform();
    init_strings();
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/services/languageFeatures.js
var ILanguageFeaturesService;
var init_languageFeatures = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/services/languageFeatures.js"() {
    init_instantiation();
    ILanguageFeaturesService = createDecorator("ILanguageFeaturesService");
  }
});

// node_modules/monaco-editor/esm/vs/base/common/color.js
function roundFloat(number, decimalPoints) {
  const decimal = Math.pow(10, decimalPoints);
  return Math.round(number * decimal) / decimal;
}
var RGBA, HSLA, HSVA, Color;
var init_color = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/color.js"() {
    RGBA = class {
      constructor(r, g, b, a = 1) {
        this._rgbaBrand = void 0;
        this.r = Math.min(255, Math.max(0, r)) | 0;
        this.g = Math.min(255, Math.max(0, g)) | 0;
        this.b = Math.min(255, Math.max(0, b)) | 0;
        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
      }
      static equals(a, b) {
        return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
      }
    };
    HSLA = class _HSLA {
      constructor(h2, s, l, a) {
        this._hslaBrand = void 0;
        this.h = Math.max(Math.min(360, h2), 0) | 0;
        this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
        this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);
        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
      }
      static equals(a, b) {
        return a.h === b.h && a.s === b.s && a.l === b.l && a.a === b.a;
      }
      /**
       * Converts an RGB color value to HSL. Conversion formula
       * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
       * Assumes r, g, and b are contained in the set [0, 255] and
       * returns h in the set [0, 360], s, and l in the set [0, 1].
       */
      static fromRGBA(rgba) {
        const r = rgba.r / 255;
        const g = rgba.g / 255;
        const b = rgba.b / 255;
        const a = rgba.a;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h2 = 0;
        let s = 0;
        const l = (min + max) / 2;
        const chroma = max - min;
        if (chroma > 0) {
          s = Math.min(l <= 0.5 ? chroma / (2 * l) : chroma / (2 - 2 * l), 1);
          switch (max) {
            case r:
              h2 = (g - b) / chroma + (g < b ? 6 : 0);
              break;
            case g:
              h2 = (b - r) / chroma + 2;
              break;
            case b:
              h2 = (r - g) / chroma + 4;
              break;
          }
          h2 *= 60;
          h2 = Math.round(h2);
        }
        return new _HSLA(h2, s, l, a);
      }
      static _hue2rgb(p, q, t) {
        if (t < 0) {
          t += 1;
        }
        if (t > 1) {
          t -= 1;
        }
        if (t < 1 / 6) {
          return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
          return q;
        }
        if (t < 2 / 3) {
          return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
      }
      /**
       * Converts an HSL color value to RGB. Conversion formula
       * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
       * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
       * returns r, g, and b in the set [0, 255].
       */
      static toRGBA(hsla) {
        const h2 = hsla.h / 360;
        const { s, l, a } = hsla;
        let r, g, b;
        if (s === 0) {
          r = g = b = l;
        } else {
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = _HSLA._hue2rgb(p, q, h2 + 1 / 3);
          g = _HSLA._hue2rgb(p, q, h2);
          b = _HSLA._hue2rgb(p, q, h2 - 1 / 3);
        }
        return new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a);
      }
    };
    HSVA = class _HSVA {
      constructor(h2, s, v, a) {
        this._hsvaBrand = void 0;
        this.h = Math.max(Math.min(360, h2), 0) | 0;
        this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
        this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);
        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
      }
      static equals(a, b) {
        return a.h === b.h && a.s === b.s && a.v === b.v && a.a === b.a;
      }
      // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
      static fromRGBA(rgba) {
        const r = rgba.r / 255;
        const g = rgba.g / 255;
        const b = rgba.b / 255;
        const cmax = Math.max(r, g, b);
        const cmin = Math.min(r, g, b);
        const delta = cmax - cmin;
        const s = cmax === 0 ? 0 : delta / cmax;
        let m;
        if (delta === 0) {
          m = 0;
        } else if (cmax === r) {
          m = ((g - b) / delta % 6 + 6) % 6;
        } else if (cmax === g) {
          m = (b - r) / delta + 2;
        } else {
          m = (r - g) / delta + 4;
        }
        return new _HSVA(Math.round(m * 60), s, cmax, rgba.a);
      }
      // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
      static toRGBA(hsva) {
        const { h: h2, s, v, a } = hsva;
        const c = v * s;
        const x = c * (1 - Math.abs(h2 / 60 % 2 - 1));
        const m = v - c;
        let [r, g, b] = [0, 0, 0];
        if (h2 < 60) {
          r = c;
          g = x;
        } else if (h2 < 120) {
          r = x;
          g = c;
        } else if (h2 < 180) {
          g = c;
          b = x;
        } else if (h2 < 240) {
          g = x;
          b = c;
        } else if (h2 < 300) {
          r = x;
          b = c;
        } else if (h2 <= 360) {
          r = c;
          b = x;
        }
        r = Math.round((r + m) * 255);
        g = Math.round((g + m) * 255);
        b = Math.round((b + m) * 255);
        return new RGBA(r, g, b, a);
      }
    };
    Color = class _Color {
      static fromHex(hex) {
        return _Color.Format.CSS.parseHex(hex) || _Color.red;
      }
      static equals(a, b) {
        if (!a && !b) {
          return true;
        }
        if (!a || !b) {
          return false;
        }
        return a.equals(b);
      }
      get hsla() {
        if (this._hsla) {
          return this._hsla;
        } else {
          return HSLA.fromRGBA(this.rgba);
        }
      }
      get hsva() {
        if (this._hsva) {
          return this._hsva;
        }
        return HSVA.fromRGBA(this.rgba);
      }
      constructor(arg) {
        if (!arg) {
          throw new Error("Color needs a value");
        } else if (arg instanceof RGBA) {
          this.rgba = arg;
        } else if (arg instanceof HSLA) {
          this._hsla = arg;
          this.rgba = HSLA.toRGBA(arg);
        } else if (arg instanceof HSVA) {
          this._hsva = arg;
          this.rgba = HSVA.toRGBA(arg);
        } else {
          throw new Error("Invalid color ctor argument");
        }
      }
      equals(other) {
        return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);
      }
      /**
       * http://www.w3.org/TR/WCAG20/#relativeluminancedef
       * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
       */
      getRelativeLuminance() {
        const R = _Color._relativeLuminanceForComponent(this.rgba.r);
        const G = _Color._relativeLuminanceForComponent(this.rgba.g);
        const B = _Color._relativeLuminanceForComponent(this.rgba.b);
        const luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;
        return roundFloat(luminance, 4);
      }
      static _relativeLuminanceForComponent(color) {
        const c = color / 255;
        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      }
      /**
       *	http://24ways.org/2010/calculating-color-contrast
       *  Return 'true' if lighter color otherwise 'false'
       */
      isLighter() {
        const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3;
        return yiq >= 128;
      }
      isLighterThan(another) {
        const lum1 = this.getRelativeLuminance();
        const lum2 = another.getRelativeLuminance();
        return lum1 > lum2;
      }
      isDarkerThan(another) {
        const lum1 = this.getRelativeLuminance();
        const lum2 = another.getRelativeLuminance();
        return lum1 < lum2;
      }
      lighten(factor2) {
        return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor2, this.hsla.a));
      }
      darken(factor2) {
        return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor2, this.hsla.a));
      }
      transparent(factor2) {
        const { r, g, b, a } = this.rgba;
        return new _Color(new RGBA(r, g, b, a * factor2));
      }
      isTransparent() {
        return this.rgba.a === 0;
      }
      isOpaque() {
        return this.rgba.a === 1;
      }
      opposite() {
        return new _Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
      }
      makeOpaque(opaqueBackground) {
        if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {
          return this;
        }
        const { r, g, b, a } = this.rgba;
        return new _Color(new RGBA(opaqueBackground.rgba.r - a * (opaqueBackground.rgba.r - r), opaqueBackground.rgba.g - a * (opaqueBackground.rgba.g - g), opaqueBackground.rgba.b - a * (opaqueBackground.rgba.b - b), 1));
      }
      toString() {
        if (!this._toString) {
          this._toString = _Color.Format.CSS.format(this);
        }
        return this._toString;
      }
      static getLighterColor(of, relative2, factor2) {
        if (of.isLighterThan(relative2)) {
          return of;
        }
        factor2 = factor2 ? factor2 : 0.5;
        const lum1 = of.getRelativeLuminance();
        const lum2 = relative2.getRelativeLuminance();
        factor2 = factor2 * (lum2 - lum1) / lum2;
        return of.lighten(factor2);
      }
      static getDarkerColor(of, relative2, factor2) {
        if (of.isDarkerThan(relative2)) {
          return of;
        }
        factor2 = factor2 ? factor2 : 0.5;
        const lum1 = of.getRelativeLuminance();
        const lum2 = relative2.getRelativeLuminance();
        factor2 = factor2 * (lum1 - lum2) / lum1;
        return of.darken(factor2);
      }
    };
    Color.white = new Color(new RGBA(255, 255, 255, 1));
    Color.black = new Color(new RGBA(0, 0, 0, 1));
    Color.red = new Color(new RGBA(255, 0, 0, 1));
    Color.blue = new Color(new RGBA(0, 0, 255, 1));
    Color.green = new Color(new RGBA(0, 255, 0, 1));
    Color.cyan = new Color(new RGBA(0, 255, 255, 1));
    Color.lightgrey = new Color(new RGBA(211, 211, 211, 1));
    Color.transparent = new Color(new RGBA(0, 0, 0, 0));
    (function(Color2) {
      let Format;
      (function(Format2) {
        let CSS;
        (function(CSS2) {
          function formatRGB(color) {
            if (color.rgba.a === 1) {
              return `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;
            }
            return Color2.Format.CSS.formatRGBA(color);
          }
          CSS2.formatRGB = formatRGB;
          function formatRGBA(color) {
            return `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+color.rgba.a.toFixed(2)})`;
          }
          CSS2.formatRGBA = formatRGBA;
          function formatHSL(color) {
            if (color.hsla.a === 1) {
              return `hsl(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%)`;
            }
            return Color2.Format.CSS.formatHSLA(color);
          }
          CSS2.formatHSL = formatHSL;
          function formatHSLA(color) {
            return `hsla(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%, ${color.hsla.a.toFixed(2)})`;
          }
          CSS2.formatHSLA = formatHSLA;
          function _toTwoDigitHex(n) {
            const r = n.toString(16);
            return r.length !== 2 ? "0" + r : r;
          }
          function formatHex(color) {
            return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;
          }
          CSS2.formatHex = formatHex;
          function formatHexA(color, compact = false) {
            if (compact && color.rgba.a === 1) {
              return Color2.Format.CSS.formatHex(color);
            }
            return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;
          }
          CSS2.formatHexA = formatHexA;
          function format2(color) {
            if (color.isOpaque()) {
              return Color2.Format.CSS.formatHex(color);
            }
            return Color2.Format.CSS.formatRGBA(color);
          }
          CSS2.format = format2;
          function parseHex(hex) {
            const length = hex.length;
            if (length === 0) {
              return null;
            }
            if (hex.charCodeAt(0) !== 35) {
              return null;
            }
            if (length === 7) {
              const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
              const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
              const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
              return new Color2(new RGBA(r, g, b, 1));
            }
            if (length === 9) {
              const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
              const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
              const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
              const a = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));
              return new Color2(new RGBA(r, g, b, a / 255));
            }
            if (length === 4) {
              const r = _parseHexDigit(hex.charCodeAt(1));
              const g = _parseHexDigit(hex.charCodeAt(2));
              const b = _parseHexDigit(hex.charCodeAt(3));
              return new Color2(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));
            }
            if (length === 5) {
              const r = _parseHexDigit(hex.charCodeAt(1));
              const g = _parseHexDigit(hex.charCodeAt(2));
              const b = _parseHexDigit(hex.charCodeAt(3));
              const a = _parseHexDigit(hex.charCodeAt(4));
              return new Color2(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a + a) / 255));
            }
            return null;
          }
          CSS2.parseHex = parseHex;
          function _parseHexDigit(charCode) {
            switch (charCode) {
              case 48:
                return 0;
              case 49:
                return 1;
              case 50:
                return 2;
              case 51:
                return 3;
              case 52:
                return 4;
              case 53:
                return 5;
              case 54:
                return 6;
              case 55:
                return 7;
              case 56:
                return 8;
              case 57:
                return 9;
              case 97:
                return 10;
              case 65:
                return 10;
              case 98:
                return 11;
              case 66:
                return 11;
              case 99:
                return 12;
              case 67:
                return 12;
              case 100:
                return 13;
              case 68:
                return 13;
              case 101:
                return 14;
              case 69:
                return 14;
              case 102:
                return 15;
              case 70:
                return 15;
            }
            return 0;
          }
        })(CSS = Format2.CSS || (Format2.CSS = {}));
      })(Format = Color2.Format || (Color2.Format = {}));
    })(Color || (Color = {}));
  }
});

// node_modules/monaco-editor/esm/vs/platform/theme/common/colorRegistry.js
function asCssVariableName(colorIdent) {
  return `--vscode-${colorIdent.replace(/\./g, "-")}`;
}
function asCssVariable(color) {
  return `var(${asCssVariableName(color)})`;
}
function asCssVariableWithDefault(color, defaultCssValue) {
  return `var(${asCssVariableName(color)}, ${defaultCssValue})`;
}
function registerColor(id, defaults, description, needsTransparency, deprecationMessage) {
  return colorRegistry.registerColor(id, defaults, description, needsTransparency, deprecationMessage);
}
function executeTransform(transform, theme) {
  var _a2, _b2, _c, _d;
  switch (transform.op) {
    case 0:
      return (_a2 = resolveColorValue(transform.value, theme)) === null || _a2 === void 0 ? void 0 : _a2.darken(transform.factor);
    case 1:
      return (_b2 = resolveColorValue(transform.value, theme)) === null || _b2 === void 0 ? void 0 : _b2.lighten(transform.factor);
    case 2:
      return (_c = resolveColorValue(transform.value, theme)) === null || _c === void 0 ? void 0 : _c.transparent(transform.factor);
    case 3: {
      const backgroundColor = resolveColorValue(transform.background, theme);
      if (!backgroundColor) {
        return resolveColorValue(transform.value, theme);
      }
      return (_d = resolveColorValue(transform.value, theme)) === null || _d === void 0 ? void 0 : _d.makeOpaque(backgroundColor);
    }
    case 4:
      for (const candidate of transform.values) {
        const color = resolveColorValue(candidate, theme);
        if (color) {
          return color;
        }
      }
      return void 0;
    case 6:
      return resolveColorValue(theme.defines(transform.if) ? transform.then : transform.else, theme);
    case 5: {
      const from = resolveColorValue(transform.value, theme);
      if (!from) {
        return void 0;
      }
      const backgroundColor = resolveColorValue(transform.background, theme);
      if (!backgroundColor) {
        return from.transparent(transform.factor * transform.transparency);
      }
      return from.isDarkerThan(backgroundColor) ? Color.getLighterColor(from, backgroundColor, transform.factor).transparent(transform.transparency) : Color.getDarkerColor(from, backgroundColor, transform.factor).transparent(transform.transparency);
    }
    default:
      throw assertNever(transform);
  }
}
function darken(colorValue, factor2) {
  return { op: 0, value: colorValue, factor: factor2 };
}
function lighten(colorValue, factor2) {
  return { op: 1, value: colorValue, factor: factor2 };
}
function transparent(colorValue, factor2) {
  return { op: 2, value: colorValue, factor: factor2 };
}
function oneOf(...colorValues) {
  return { op: 4, values: colorValues };
}
function ifDefinedThenElse(ifArg, thenArg, elseArg) {
  return { op: 6, if: ifArg, then: thenArg, else: elseArg };
}
function lessProminent(colorValue, backgroundColorValue, factor2, transparency) {
  return { op: 5, value: colorValue, background: backgroundColorValue, factor: factor2, transparency };
}
function resolveColorValue(colorValue, theme) {
  if (colorValue === null) {
    return void 0;
  } else if (typeof colorValue === "string") {
    if (colorValue[0] === "#") {
      return Color.fromHex(colorValue);
    }
    return theme.getColor(colorValue);
  } else if (colorValue instanceof Color) {
    return colorValue;
  } else if (typeof colorValue === "object") {
    return executeTransform(colorValue, theme);
  }
  return void 0;
}
var Extensions5, ColorRegistry, colorRegistry, foreground, disabledForeground, errorForeground, descriptionForeground, iconForeground, focusBorder, contrastBorder, activeContrastBorder, selectionBackground, textSeparatorForeground, textLinkForeground, textLinkActiveForeground, textPreformatForeground, textPreformatBackground, textBlockQuoteBackground, textBlockQuoteBorder, textCodeBlockBackground, widgetShadow, widgetBorder, inputBackground, inputForeground, inputBorder, inputActiveOptionBorder, inputActiveOptionHoverBackground, inputActiveOptionBackground, inputActiveOptionForeground, inputPlaceholderForeground, inputValidationInfoBackground, inputValidationInfoForeground, inputValidationInfoBorder, inputValidationWarningBackground, inputValidationWarningForeground, inputValidationWarningBorder, inputValidationErrorBackground, inputValidationErrorForeground, inputValidationErrorBorder, selectBackground, selectListBackground, selectForeground, selectBorder, buttonForeground, buttonSeparator, buttonBackground, buttonHoverBackground, buttonBorder, buttonSecondaryForeground, buttonSecondaryBackground, buttonSecondaryHoverBackground, badgeBackground, badgeForeground, scrollbarShadow, scrollbarSliderBackground, scrollbarSliderHoverBackground, scrollbarSliderActiveBackground, progressBarBackground, editorErrorBackground, editorErrorForeground, editorErrorBorder, editorWarningBackground, editorWarningForeground, editorWarningBorder, editorInfoBackground, editorInfoForeground, editorInfoBorder, editorHintForeground, editorHintBorder, sashHoverBorder, editorBackground, editorForeground, editorStickyScrollBackground, editorStickyScrollHoverBackground, editorStickyScrollBorder, editorStickyScrollShadow, editorWidgetBackground, editorWidgetForeground, editorWidgetBorder, editorWidgetResizeBorder, quickInputBackground, quickInputForeground, quickInputTitleBackground, pickerGroupForeground, pickerGroupBorder, keybindingLabelBackground, keybindingLabelForeground, keybindingLabelBorder, keybindingLabelBottomBorder, editorSelectionBackground, editorSelectionForeground, editorInactiveSelection, editorSelectionHighlight, editorSelectionHighlightBorder, editorFindMatch, editorFindMatchHighlight, editorFindRangeHighlight, editorFindMatchBorder, editorFindMatchHighlightBorder, editorFindRangeHighlightBorder, searchEditorFindMatch, searchEditorFindMatchBorder, searchResultsInfoForeground, editorHoverHighlight, editorHoverBackground, editorHoverForeground, editorHoverBorder, editorHoverStatusBarBackground, editorActiveLinkForeground, editorInlayHintForeground, editorInlayHintBackground, editorInlayHintTypeForeground, editorInlayHintTypeBackground, editorInlayHintParameterForeground, editorInlayHintParameterBackground, editorLightBulbForeground, editorLightBulbAutoFixForeground, editorLightBulbAiForeground, defaultInsertColor, defaultRemoveColor, diffInserted, diffRemoved, diffInsertedLine, diffRemovedLine, diffInsertedLineGutter, diffRemovedLineGutter, diffOverviewRulerInserted, diffOverviewRulerRemoved, diffInsertedOutline, diffRemovedOutline, diffBorder, diffDiagonalFill, diffUnchangedRegionBackground, diffUnchangedRegionForeground, diffUnchangedTextBackground, listFocusBackground, listFocusForeground, listFocusOutline, listFocusAndSelectionOutline, listActiveSelectionBackground, listActiveSelectionForeground, listActiveSelectionIconForeground, listInactiveSelectionBackground, listInactiveSelectionForeground, listInactiveSelectionIconForeground, listInactiveFocusBackground, listInactiveFocusOutline, listHoverBackground, listHoverForeground, listDropOverBackground, listDropBetweenBackground, listHighlightForeground, listFocusHighlightForeground, listInvalidItemForeground, listErrorForeground, listWarningForeground, listFilterWidgetBackground, listFilterWidgetOutline, listFilterWidgetNoMatchesOutline, listFilterWidgetShadow, listFilterMatchHighlight, listFilterMatchHighlightBorder, treeIndentGuidesStroke, treeInactiveIndentGuidesStroke, tableColumnsBorder, tableOddRowsBackgroundColor, listDeemphasizedForeground, checkboxBackground, checkboxSelectBackground, checkboxForeground, checkboxBorder, checkboxSelectBorder, _deprecatedQuickInputListFocusBackground, quickInputListFocusForeground, quickInputListFocusIconForeground, quickInputListFocusBackground, menuBorder, menuForeground, menuBackground, menuSelectionForeground, menuSelectionBackground, menuSelectionBorder, menuSeparatorBackground, toolbarHoverBackground, toolbarHoverOutline, toolbarActiveBackground, snippetTabstopHighlightBackground, snippetTabstopHighlightBorder, snippetFinalTabstopHighlightBackground, snippetFinalTabstopHighlightBorder, breadcrumbsForeground, breadcrumbsBackground, breadcrumbsFocusForeground, breadcrumbsActiveSelectionForeground, breadcrumbsPickerBackground, headerTransparency, currentBaseColor, incomingBaseColor, commonBaseColor, contentTransparency, rulerTransparency, mergeCurrentHeaderBackground, mergeCurrentContentBackground, mergeIncomingHeaderBackground, mergeIncomingContentBackground, mergeCommonHeaderBackground, mergeCommonContentBackground, mergeBorder, overviewRulerCurrentContentForeground, overviewRulerIncomingContentForeground, overviewRulerCommonContentForeground, overviewRulerFindMatchForeground, overviewRulerSelectionHighlightForeground, minimapFindMatch, minimapSelectionOccurrenceHighlight, minimapSelection, minimapInfo, minimapWarning, minimapError, minimapBackground, minimapForegroundOpacity, minimapSliderBackground, minimapSliderHoverBackground, minimapSliderActiveBackground, problemsErrorIconForeground, problemsWarningIconForeground, problemsInfoIconForeground, chartsForeground, chartsLines, chartsRed, chartsBlue, chartsYellow, chartsOrange, chartsGreen, chartsPurple, workbenchColorsSchemaId, schemaRegistry, delayer;
var init_colorRegistry = __esm({
  "node_modules/monaco-editor/esm/vs/platform/theme/common/colorRegistry.js"() {
    init_assert();
    init_async();
    init_color();
    init_event();
    init_nls();
    init_jsonContributionRegistry();
    init_platform2();
    Extensions5 = {
      ColorContribution: "base.contributions.colors"
    };
    ColorRegistry = class {
      constructor() {
        this._onDidChangeSchema = new Emitter();
        this.onDidChangeSchema = this._onDidChangeSchema.event;
        this.colorSchema = { type: "object", properties: {} };
        this.colorReferenceSchema = { type: "string", enum: [], enumDescriptions: [] };
        this.colorsById = {};
      }
      registerColor(id, defaults, description, needsTransparency = false, deprecationMessage) {
        const colorContribution = { id, description, defaults, needsTransparency, deprecationMessage };
        this.colorsById[id] = colorContribution;
        const propertySchema = { type: "string", description, format: "color-hex", defaultSnippets: [{ body: "${1:#ff0000}" }] };
        if (deprecationMessage) {
          propertySchema.deprecationMessage = deprecationMessage;
        }
        if (needsTransparency) {
          propertySchema.pattern = "^#(?:(?<rgba>[0-9a-fA-f]{3}[0-9a-eA-E])|(?:[0-9a-fA-F]{6}(?:(?![fF]{2})(?:[0-9a-fA-F]{2}))))?$";
          propertySchema.patternErrorMessage = "This color must be transparent or it will obscure content";
        }
        this.colorSchema.properties[id] = propertySchema;
        this.colorReferenceSchema.enum.push(id);
        this.colorReferenceSchema.enumDescriptions.push(description);
        this._onDidChangeSchema.fire();
        return id;
      }
      getColors() {
        return Object.keys(this.colorsById).map((id) => this.colorsById[id]);
      }
      resolveDefaultColor(id, theme) {
        const colorDesc = this.colorsById[id];
        if (colorDesc && colorDesc.defaults) {
          const colorValue = colorDesc.defaults[theme.type];
          return resolveColorValue(colorValue, theme);
        }
        return void 0;
      }
      getColorSchema() {
        return this.colorSchema;
      }
      toString() {
        const sorter2 = (a, b) => {
          const cat1 = a.indexOf(".") === -1 ? 0 : 1;
          const cat2 = b.indexOf(".") === -1 ? 0 : 1;
          if (cat1 !== cat2) {
            return cat1 - cat2;
          }
          return a.localeCompare(b);
        };
        return Object.keys(this.colorsById).sort(sorter2).map((k) => `- \`${k}\`: ${this.colorsById[k].description}`).join("\n");
      }
    };
    colorRegistry = new ColorRegistry();
    Registry.add(Extensions5.ColorContribution, colorRegistry);
    foreground = registerColor("foreground", { dark: "#CCCCCC", light: "#616161", hcDark: "#FFFFFF", hcLight: "#292929" }, localize("foreground", "Overall foreground color. This color is only used if not overridden by a component."));
    disabledForeground = registerColor("disabledForeground", { dark: "#CCCCCC80", light: "#61616180", hcDark: "#A5A5A5", hcLight: "#7F7F7F" }, localize("disabledForeground", "Overall foreground for disabled elements. This color is only used if not overridden by a component."));
    errorForeground = registerColor("errorForeground", { dark: "#F48771", light: "#A1260D", hcDark: "#F48771", hcLight: "#B5200D" }, localize("errorForeground", "Overall foreground color for error messages. This color is only used if not overridden by a component."));
    descriptionForeground = registerColor("descriptionForeground", { light: "#717171", dark: transparent(foreground, 0.7), hcDark: transparent(foreground, 0.7), hcLight: transparent(foreground, 0.7) }, localize("descriptionForeground", "Foreground color for description text providing additional information, for example for a label."));
    iconForeground = registerColor("icon.foreground", { dark: "#C5C5C5", light: "#424242", hcDark: "#FFFFFF", hcLight: "#292929" }, localize("iconForeground", "The default color for icons in the workbench."));
    focusBorder = registerColor("focusBorder", { dark: "#007FD4", light: "#0090F1", hcDark: "#F38518", hcLight: "#006BBD" }, localize("focusBorder", "Overall border color for focused elements. This color is only used if not overridden by a component."));
    contrastBorder = registerColor("contrastBorder", { light: null, dark: null, hcDark: "#6FC3DF", hcLight: "#0F4A85" }, localize("contrastBorder", "An extra border around elements to separate them from others for greater contrast."));
    activeContrastBorder = registerColor("contrastActiveBorder", { light: null, dark: null, hcDark: focusBorder, hcLight: focusBorder }, localize("activeContrastBorder", "An extra border around active elements to separate them from others for greater contrast."));
    selectionBackground = registerColor("selection.background", { light: null, dark: null, hcDark: null, hcLight: null }, localize("selectionBackground", "The background color of text selections in the workbench (e.g. for input fields or text areas). Note that this does not apply to selections within the editor."));
    textSeparatorForeground = registerColor("textSeparator.foreground", { light: "#0000002e", dark: "#ffffff2e", hcDark: Color.black, hcLight: "#292929" }, localize("textSeparatorForeground", "Color for text separators."));
    textLinkForeground = registerColor("textLink.foreground", { light: "#006AB1", dark: "#3794FF", hcDark: "#21A6FF", hcLight: "#0F4A85" }, localize("textLinkForeground", "Foreground color for links in text."));
    textLinkActiveForeground = registerColor("textLink.activeForeground", { light: "#006AB1", dark: "#3794FF", hcDark: "#21A6FF", hcLight: "#0F4A85" }, localize("textLinkActiveForeground", "Foreground color for links in text when clicked on and on mouse hover."));
    textPreformatForeground = registerColor("textPreformat.foreground", { light: "#A31515", dark: "#D7BA7D", hcDark: "#000000", hcLight: "#FFFFFF" }, localize("textPreformatForeground", "Foreground color for preformatted text segments."));
    textPreformatBackground = registerColor("textPreformat.background", { light: "#0000001A", dark: "#FFFFFF1A", hcDark: "#FFFFFF", hcLight: "#09345f" }, localize("textPreformatBackground", "Background color for preformatted text segments."));
    textBlockQuoteBackground = registerColor("textBlockQuote.background", { light: "#f2f2f2", dark: "#222222", hcDark: null, hcLight: "#F2F2F2" }, localize("textBlockQuoteBackground", "Background color for block quotes in text."));
    textBlockQuoteBorder = registerColor("textBlockQuote.border", { light: "#007acc80", dark: "#007acc80", hcDark: Color.white, hcLight: "#292929" }, localize("textBlockQuoteBorder", "Border color for block quotes in text."));
    textCodeBlockBackground = registerColor("textCodeBlock.background", { light: "#dcdcdc66", dark: "#0a0a0a66", hcDark: Color.black, hcLight: "#F2F2F2" }, localize("textCodeBlockBackground", "Background color for code blocks in text."));
    widgetShadow = registerColor("widget.shadow", { dark: transparent(Color.black, 0.36), light: transparent(Color.black, 0.16), hcDark: null, hcLight: null }, localize("widgetShadow", "Shadow color of widgets such as find/replace inside the editor."));
    widgetBorder = registerColor("widget.border", { dark: null, light: null, hcDark: contrastBorder, hcLight: contrastBorder }, localize("widgetBorder", "Border color of widgets such as find/replace inside the editor."));
    inputBackground = registerColor("input.background", { dark: "#3C3C3C", light: Color.white, hcDark: Color.black, hcLight: Color.white }, localize("inputBoxBackground", "Input box background."));
    inputForeground = registerColor("input.foreground", { dark: foreground, light: foreground, hcDark: foreground, hcLight: foreground }, localize("inputBoxForeground", "Input box foreground."));
    inputBorder = registerColor("input.border", { dark: null, light: null, hcDark: contrastBorder, hcLight: contrastBorder }, localize("inputBoxBorder", "Input box border."));
    inputActiveOptionBorder = registerColor("inputOption.activeBorder", { dark: "#007ACC", light: "#007ACC", hcDark: contrastBorder, hcLight: contrastBorder }, localize("inputBoxActiveOptionBorder", "Border color of activated options in input fields."));
    inputActiveOptionHoverBackground = registerColor("inputOption.hoverBackground", { dark: "#5a5d5e80", light: "#b8b8b850", hcDark: null, hcLight: null }, localize("inputOption.hoverBackground", "Background color of activated options in input fields."));
    inputActiveOptionBackground = registerColor("inputOption.activeBackground", { dark: transparent(focusBorder, 0.4), light: transparent(focusBorder, 0.2), hcDark: Color.transparent, hcLight: Color.transparent }, localize("inputOption.activeBackground", "Background hover color of options in input fields."));
    inputActiveOptionForeground = registerColor("inputOption.activeForeground", { dark: Color.white, light: Color.black, hcDark: foreground, hcLight: foreground }, localize("inputOption.activeForeground", "Foreground color of activated options in input fields."));
    inputPlaceholderForeground = registerColor("input.placeholderForeground", { light: transparent(foreground, 0.5), dark: transparent(foreground, 0.5), hcDark: transparent(foreground, 0.7), hcLight: transparent(foreground, 0.7) }, localize("inputPlaceholderForeground", "Input box foreground color for placeholder text."));
    inputValidationInfoBackground = registerColor("inputValidation.infoBackground", { dark: "#063B49", light: "#D6ECF2", hcDark: Color.black, hcLight: Color.white }, localize("inputValidationInfoBackground", "Input validation background color for information severity."));
    inputValidationInfoForeground = registerColor("inputValidation.infoForeground", { dark: null, light: null, hcDark: null, hcLight: foreground }, localize("inputValidationInfoForeground", "Input validation foreground color for information severity."));
    inputValidationInfoBorder = registerColor("inputValidation.infoBorder", { dark: "#007acc", light: "#007acc", hcDark: contrastBorder, hcLight: contrastBorder }, localize("inputValidationInfoBorder", "Input validation border color for information severity."));
    inputValidationWarningBackground = registerColor("inputValidation.warningBackground", { dark: "#352A05", light: "#F6F5D2", hcDark: Color.black, hcLight: Color.white }, localize("inputValidationWarningBackground", "Input validation background color for warning severity."));
    inputValidationWarningForeground = registerColor("inputValidation.warningForeground", { dark: null, light: null, hcDark: null, hcLight: foreground }, localize("inputValidationWarningForeground", "Input validation foreground color for warning severity."));
    inputValidationWarningBorder = registerColor("inputValidation.warningBorder", { dark: "#B89500", light: "#B89500", hcDark: contrastBorder, hcLight: contrastBorder }, localize("inputValidationWarningBorder", "Input validation border color for warning severity."));
    inputValidationErrorBackground = registerColor("inputValidation.errorBackground", { dark: "#5A1D1D", light: "#F2DEDE", hcDark: Color.black, hcLight: Color.white }, localize("inputValidationErrorBackground", "Input validation background color for error severity."));
    inputValidationErrorForeground = registerColor("inputValidation.errorForeground", { dark: null, light: null, hcDark: null, hcLight: foreground }, localize("inputValidationErrorForeground", "Input validation foreground color for error severity."));
    inputValidationErrorBorder = registerColor("inputValidation.errorBorder", { dark: "#BE1100", light: "#BE1100", hcDark: contrastBorder, hcLight: contrastBorder }, localize("inputValidationErrorBorder", "Input validation border color for error severity."));
    selectBackground = registerColor("dropdown.background", { dark: "#3C3C3C", light: Color.white, hcDark: Color.black, hcLight: Color.white }, localize("dropdownBackground", "Dropdown background."));
    selectListBackground = registerColor("dropdown.listBackground", { dark: null, light: null, hcDark: Color.black, hcLight: Color.white }, localize("dropdownListBackground", "Dropdown list background."));
    selectForeground = registerColor("dropdown.foreground", { dark: "#F0F0F0", light: foreground, hcDark: Color.white, hcLight: foreground }, localize("dropdownForeground", "Dropdown foreground."));
    selectBorder = registerColor("dropdown.border", { dark: selectBackground, light: "#CECECE", hcDark: contrastBorder, hcLight: contrastBorder }, localize("dropdownBorder", "Dropdown border."));
    buttonForeground = registerColor("button.foreground", { dark: Color.white, light: Color.white, hcDark: Color.white, hcLight: Color.white }, localize("buttonForeground", "Button foreground color."));
    buttonSeparator = registerColor("button.separator", { dark: transparent(buttonForeground, 0.4), light: transparent(buttonForeground, 0.4), hcDark: transparent(buttonForeground, 0.4), hcLight: transparent(buttonForeground, 0.4) }, localize("buttonSeparator", "Button separator color."));
    buttonBackground = registerColor("button.background", { dark: "#0E639C", light: "#007ACC", hcDark: null, hcLight: "#0F4A85" }, localize("buttonBackground", "Button background color."));
    buttonHoverBackground = registerColor("button.hoverBackground", { dark: lighten(buttonBackground, 0.2), light: darken(buttonBackground, 0.2), hcDark: buttonBackground, hcLight: buttonBackground }, localize("buttonHoverBackground", "Button background color when hovering."));
    buttonBorder = registerColor("button.border", { dark: contrastBorder, light: contrastBorder, hcDark: contrastBorder, hcLight: contrastBorder }, localize("buttonBorder", "Button border color."));
    buttonSecondaryForeground = registerColor("button.secondaryForeground", { dark: Color.white, light: Color.white, hcDark: Color.white, hcLight: foreground }, localize("buttonSecondaryForeground", "Secondary button foreground color."));
    buttonSecondaryBackground = registerColor("button.secondaryBackground", { dark: "#3A3D41", light: "#5F6A79", hcDark: null, hcLight: Color.white }, localize("buttonSecondaryBackground", "Secondary button background color."));
    buttonSecondaryHoverBackground = registerColor("button.secondaryHoverBackground", { dark: lighten(buttonSecondaryBackground, 0.2), light: darken(buttonSecondaryBackground, 0.2), hcDark: null, hcLight: null }, localize("buttonSecondaryHoverBackground", "Secondary button background color when hovering."));
    badgeBackground = registerColor("badge.background", { dark: "#4D4D4D", light: "#C4C4C4", hcDark: Color.black, hcLight: "#0F4A85" }, localize("badgeBackground", "Badge background color. Badges are small information labels, e.g. for search results count."));
    badgeForeground = registerColor("badge.foreground", { dark: Color.white, light: "#333", hcDark: Color.white, hcLight: Color.white }, localize("badgeForeground", "Badge foreground color. Badges are small information labels, e.g. for search results count."));
    scrollbarShadow = registerColor("scrollbar.shadow", { dark: "#000000", light: "#DDDDDD", hcDark: null, hcLight: null }, localize("scrollbarShadow", "Scrollbar shadow to indicate that the view is scrolled."));
    scrollbarSliderBackground = registerColor("scrollbarSlider.background", { dark: Color.fromHex("#797979").transparent(0.4), light: Color.fromHex("#646464").transparent(0.4), hcDark: transparent(contrastBorder, 0.6), hcLight: transparent(contrastBorder, 0.4) }, localize("scrollbarSliderBackground", "Scrollbar slider background color."));
    scrollbarSliderHoverBackground = registerColor("scrollbarSlider.hoverBackground", { dark: Color.fromHex("#646464").transparent(0.7), light: Color.fromHex("#646464").transparent(0.7), hcDark: transparent(contrastBorder, 0.8), hcLight: transparent(contrastBorder, 0.8) }, localize("scrollbarSliderHoverBackground", "Scrollbar slider background color when hovering."));
    scrollbarSliderActiveBackground = registerColor("scrollbarSlider.activeBackground", { dark: Color.fromHex("#BFBFBF").transparent(0.4), light: Color.fromHex("#000000").transparent(0.6), hcDark: contrastBorder, hcLight: contrastBorder }, localize("scrollbarSliderActiveBackground", "Scrollbar slider background color when clicked on."));
    progressBarBackground = registerColor("progressBar.background", { dark: Color.fromHex("#0E70C0"), light: Color.fromHex("#0E70C0"), hcDark: contrastBorder, hcLight: contrastBorder }, localize("progressBarBackground", "Background color of the progress bar that can show for long running operations."));
    editorErrorBackground = registerColor("editorError.background", { dark: null, light: null, hcDark: null, hcLight: null }, localize("editorError.background", "Background color of error text in the editor. The color must not be opaque so as not to hide underlying decorations."), true);
    editorErrorForeground = registerColor("editorError.foreground", { dark: "#F14C4C", light: "#E51400", hcDark: "#F48771", hcLight: "#B5200D" }, localize("editorError.foreground", "Foreground color of error squigglies in the editor."));
    editorErrorBorder = registerColor("editorError.border", { dark: null, light: null, hcDark: Color.fromHex("#E47777").transparent(0.8), hcLight: "#B5200D" }, localize("errorBorder", "If set, color of double underlines for errors in the editor."));
    editorWarningBackground = registerColor("editorWarning.background", { dark: null, light: null, hcDark: null, hcLight: null }, localize("editorWarning.background", "Background color of warning text in the editor. The color must not be opaque so as not to hide underlying decorations."), true);
    editorWarningForeground = registerColor("editorWarning.foreground", { dark: "#CCA700", light: "#BF8803", hcDark: "#FFD370", hcLight: "#895503" }, localize("editorWarning.foreground", "Foreground color of warning squigglies in the editor."));
    editorWarningBorder = registerColor("editorWarning.border", { dark: null, light: null, hcDark: Color.fromHex("#FFCC00").transparent(0.8), hcLight: Color.fromHex("#FFCC00").transparent(0.8) }, localize("warningBorder", "If set, color of double underlines for warnings in the editor."));
    editorInfoBackground = registerColor("editorInfo.background", { dark: null, light: null, hcDark: null, hcLight: null }, localize("editorInfo.background", "Background color of info text in the editor. The color must not be opaque so as not to hide underlying decorations."), true);
    editorInfoForeground = registerColor("editorInfo.foreground", { dark: "#3794FF", light: "#1a85ff", hcDark: "#3794FF", hcLight: "#1a85ff" }, localize("editorInfo.foreground", "Foreground color of info squigglies in the editor."));
    editorInfoBorder = registerColor("editorInfo.border", { dark: null, light: null, hcDark: Color.fromHex("#3794FF").transparent(0.8), hcLight: "#292929" }, localize("infoBorder", "If set, color of double underlines for infos in the editor."));
    editorHintForeground = registerColor("editorHint.foreground", { dark: Color.fromHex("#eeeeee").transparent(0.7), light: "#6c6c6c", hcDark: null, hcLight: null }, localize("editorHint.foreground", "Foreground color of hint squigglies in the editor."));
    editorHintBorder = registerColor("editorHint.border", { dark: null, light: null, hcDark: Color.fromHex("#eeeeee").transparent(0.8), hcLight: "#292929" }, localize("hintBorder", "If set, color of double underlines for hints in the editor."));
    sashHoverBorder = registerColor("sash.hoverBorder", { dark: focusBorder, light: focusBorder, hcDark: focusBorder, hcLight: focusBorder }, localize("sashActiveBorder", "Border color of active sashes."));
    editorBackground = registerColor("editor.background", { light: "#ffffff", dark: "#1E1E1E", hcDark: Color.black, hcLight: Color.white }, localize("editorBackground", "Editor background color."));
    editorForeground = registerColor("editor.foreground", { light: "#333333", dark: "#BBBBBB", hcDark: Color.white, hcLight: foreground }, localize("editorForeground", "Editor default foreground color."));
    editorStickyScrollBackground = registerColor("editorStickyScroll.background", { light: editorBackground, dark: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, localize("editorStickyScrollBackground", "Background color of sticky scroll in the editor"));
    editorStickyScrollHoverBackground = registerColor("editorStickyScrollHover.background", { dark: "#2A2D2E", light: "#F0F0F0", hcDark: null, hcLight: Color.fromHex("#0F4A85").transparent(0.1) }, localize("editorStickyScrollHoverBackground", "Background color of sticky scroll on hover in the editor"));
    editorStickyScrollBorder = registerColor("editorStickyScroll.border", { dark: null, light: null, hcDark: contrastBorder, hcLight: contrastBorder }, localize("editorStickyScrollBorder", "Border color of sticky scroll in the editor"));
    editorStickyScrollShadow = registerColor("editorStickyScroll.shadow", { dark: scrollbarShadow, light: scrollbarShadow, hcDark: scrollbarShadow, hcLight: scrollbarShadow }, localize("editorStickyScrollShadow", " Shadow color of sticky scroll in the editor"));
    editorWidgetBackground = registerColor("editorWidget.background", { dark: "#252526", light: "#F3F3F3", hcDark: "#0C141F", hcLight: Color.white }, localize("editorWidgetBackground", "Background color of editor widgets, such as find/replace."));
    editorWidgetForeground = registerColor("editorWidget.foreground", { dark: foreground, light: foreground, hcDark: foreground, hcLight: foreground }, localize("editorWidgetForeground", "Foreground color of editor widgets, such as find/replace."));
    editorWidgetBorder = registerColor("editorWidget.border", { dark: "#454545", light: "#C8C8C8", hcDark: contrastBorder, hcLight: contrastBorder }, localize("editorWidgetBorder", "Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget."));
    editorWidgetResizeBorder = registerColor("editorWidget.resizeBorder", { light: null, dark: null, hcDark: null, hcLight: null }, localize("editorWidgetResizeBorder", "Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget."));
    quickInputBackground = registerColor("quickInput.background", { dark: editorWidgetBackground, light: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, localize("pickerBackground", "Quick picker background color. The quick picker widget is the container for pickers like the command palette."));
    quickInputForeground = registerColor("quickInput.foreground", { dark: editorWidgetForeground, light: editorWidgetForeground, hcDark: editorWidgetForeground, hcLight: editorWidgetForeground }, localize("pickerForeground", "Quick picker foreground color. The quick picker widget is the container for pickers like the command palette."));
    quickInputTitleBackground = registerColor("quickInputTitle.background", { dark: new Color(new RGBA(255, 255, 255, 0.105)), light: new Color(new RGBA(0, 0, 0, 0.06)), hcDark: "#000000", hcLight: Color.white }, localize("pickerTitleBackground", "Quick picker title background color. The quick picker widget is the container for pickers like the command palette."));
    pickerGroupForeground = registerColor("pickerGroup.foreground", { dark: "#3794FF", light: "#0066BF", hcDark: Color.white, hcLight: "#0F4A85" }, localize("pickerGroupForeground", "Quick picker color for grouping labels."));
    pickerGroupBorder = registerColor("pickerGroup.border", { dark: "#3F3F46", light: "#CCCEDB", hcDark: Color.white, hcLight: "#0F4A85" }, localize("pickerGroupBorder", "Quick picker color for grouping borders."));
    keybindingLabelBackground = registerColor("keybindingLabel.background", { dark: new Color(new RGBA(128, 128, 128, 0.17)), light: new Color(new RGBA(221, 221, 221, 0.4)), hcDark: Color.transparent, hcLight: Color.transparent }, localize("keybindingLabelBackground", "Keybinding label background color. The keybinding label is used to represent a keyboard shortcut."));
    keybindingLabelForeground = registerColor("keybindingLabel.foreground", { dark: Color.fromHex("#CCCCCC"), light: Color.fromHex("#555555"), hcDark: Color.white, hcLight: foreground }, localize("keybindingLabelForeground", "Keybinding label foreground color. The keybinding label is used to represent a keyboard shortcut."));
    keybindingLabelBorder = registerColor("keybindingLabel.border", { dark: new Color(new RGBA(51, 51, 51, 0.6)), light: new Color(new RGBA(204, 204, 204, 0.4)), hcDark: new Color(new RGBA(111, 195, 223)), hcLight: contrastBorder }, localize("keybindingLabelBorder", "Keybinding label border color. The keybinding label is used to represent a keyboard shortcut."));
    keybindingLabelBottomBorder = registerColor("keybindingLabel.bottomBorder", { dark: new Color(new RGBA(68, 68, 68, 0.6)), light: new Color(new RGBA(187, 187, 187, 0.4)), hcDark: new Color(new RGBA(111, 195, 223)), hcLight: foreground }, localize("keybindingLabelBottomBorder", "Keybinding label border bottom color. The keybinding label is used to represent a keyboard shortcut."));
    editorSelectionBackground = registerColor("editor.selectionBackground", { light: "#ADD6FF", dark: "#264F78", hcDark: "#f3f518", hcLight: "#0F4A85" }, localize("editorSelectionBackground", "Color of the editor selection."));
    editorSelectionForeground = registerColor("editor.selectionForeground", { light: null, dark: null, hcDark: "#000000", hcLight: Color.white }, localize("editorSelectionForeground", "Color of the selected text for high contrast."));
    editorInactiveSelection = registerColor("editor.inactiveSelectionBackground", { light: transparent(editorSelectionBackground, 0.5), dark: transparent(editorSelectionBackground, 0.5), hcDark: transparent(editorSelectionBackground, 0.7), hcLight: transparent(editorSelectionBackground, 0.5) }, localize("editorInactiveSelection", "Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations."), true);
    editorSelectionHighlight = registerColor("editor.selectionHighlightBackground", { light: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), dark: lessProminent(editorSelectionBackground, editorBackground, 0.3, 0.6), hcDark: null, hcLight: null }, localize("editorSelectionHighlight", "Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations."), true);
    editorSelectionHighlightBorder = registerColor("editor.selectionHighlightBorder", { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize("editorSelectionHighlightBorder", "Border color for regions with the same content as the selection."));
    editorFindMatch = registerColor("editor.findMatchBackground", { light: "#A8AC94", dark: "#515C6A", hcDark: null, hcLight: null }, localize("editorFindMatch", "Color of the current search match."));
    editorFindMatchHighlight = registerColor("editor.findMatchHighlightBackground", { light: "#EA5C0055", dark: "#EA5C0055", hcDark: null, hcLight: null }, localize("findMatchHighlight", "Color of the other search matches. The color must not be opaque so as not to hide underlying decorations."), true);
    editorFindRangeHighlight = registerColor("editor.findRangeHighlightBackground", { dark: "#3a3d4166", light: "#b4b4b44d", hcDark: null, hcLight: null }, localize("findRangeHighlight", "Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), true);
    editorFindMatchBorder = registerColor("editor.findMatchBorder", { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize("editorFindMatchBorder", "Border color of the current search match."));
    editorFindMatchHighlightBorder = registerColor("editor.findMatchHighlightBorder", { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize("findMatchHighlightBorder", "Border color of the other search matches."));
    editorFindRangeHighlightBorder = registerColor("editor.findRangeHighlightBorder", { dark: null, light: null, hcDark: transparent(activeContrastBorder, 0.4), hcLight: transparent(activeContrastBorder, 0.4) }, localize("findRangeHighlightBorder", "Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), true);
    searchEditorFindMatch = registerColor("searchEditor.findMatchBackground", { light: transparent(editorFindMatchHighlight, 0.66), dark: transparent(editorFindMatchHighlight, 0.66), hcDark: editorFindMatchHighlight, hcLight: editorFindMatchHighlight }, localize("searchEditor.queryMatch", "Color of the Search Editor query matches."));
    searchEditorFindMatchBorder = registerColor("searchEditor.findMatchBorder", { light: transparent(editorFindMatchHighlightBorder, 0.66), dark: transparent(editorFindMatchHighlightBorder, 0.66), hcDark: editorFindMatchHighlightBorder, hcLight: editorFindMatchHighlightBorder }, localize("searchEditor.editorFindMatchBorder", "Border color of the Search Editor query matches."));
    searchResultsInfoForeground = registerColor("search.resultsInfoForeground", { light: foreground, dark: transparent(foreground, 0.65), hcDark: foreground, hcLight: foreground }, localize("search.resultsInfoForeground", "Color of the text in the search viewlet's completion message."));
    editorHoverHighlight = registerColor("editor.hoverHighlightBackground", { light: "#ADD6FF26", dark: "#264f7840", hcDark: "#ADD6FF26", hcLight: null }, localize("hoverHighlight", "Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations."), true);
    editorHoverBackground = registerColor("editorHoverWidget.background", { light: editorWidgetBackground, dark: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, localize("hoverBackground", "Background color of the editor hover."));
    editorHoverForeground = registerColor("editorHoverWidget.foreground", { light: editorWidgetForeground, dark: editorWidgetForeground, hcDark: editorWidgetForeground, hcLight: editorWidgetForeground }, localize("hoverForeground", "Foreground color of the editor hover."));
    editorHoverBorder = registerColor("editorHoverWidget.border", { light: editorWidgetBorder, dark: editorWidgetBorder, hcDark: editorWidgetBorder, hcLight: editorWidgetBorder }, localize("hoverBorder", "Border color of the editor hover."));
    editorHoverStatusBarBackground = registerColor("editorHoverWidget.statusBarBackground", { dark: lighten(editorHoverBackground, 0.2), light: darken(editorHoverBackground, 0.05), hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, localize("statusBarBackground", "Background color of the editor hover status bar."));
    editorActiveLinkForeground = registerColor("editorLink.activeForeground", { dark: "#4E94CE", light: Color.blue, hcDark: Color.cyan, hcLight: "#292929" }, localize("activeLinkForeground", "Color of active links."));
    editorInlayHintForeground = registerColor("editorInlayHint.foreground", { dark: "#969696", light: "#969696", hcDark: Color.white, hcLight: Color.black }, localize("editorInlayHintForeground", "Foreground color of inline hints"));
    editorInlayHintBackground = registerColor("editorInlayHint.background", { dark: transparent(badgeBackground, 0.1), light: transparent(badgeBackground, 0.1), hcDark: transparent(Color.white, 0.1), hcLight: transparent(badgeBackground, 0.1) }, localize("editorInlayHintBackground", "Background color of inline hints"));
    editorInlayHintTypeForeground = registerColor("editorInlayHint.typeForeground", { dark: editorInlayHintForeground, light: editorInlayHintForeground, hcDark: editorInlayHintForeground, hcLight: editorInlayHintForeground }, localize("editorInlayHintForegroundTypes", "Foreground color of inline hints for types"));
    editorInlayHintTypeBackground = registerColor("editorInlayHint.typeBackground", { dark: editorInlayHintBackground, light: editorInlayHintBackground, hcDark: editorInlayHintBackground, hcLight: editorInlayHintBackground }, localize("editorInlayHintBackgroundTypes", "Background color of inline hints for types"));
    editorInlayHintParameterForeground = registerColor("editorInlayHint.parameterForeground", { dark: editorInlayHintForeground, light: editorInlayHintForeground, hcDark: editorInlayHintForeground, hcLight: editorInlayHintForeground }, localize("editorInlayHintForegroundParameter", "Foreground color of inline hints for parameters"));
    editorInlayHintParameterBackground = registerColor("editorInlayHint.parameterBackground", { dark: editorInlayHintBackground, light: editorInlayHintBackground, hcDark: editorInlayHintBackground, hcLight: editorInlayHintBackground }, localize("editorInlayHintBackgroundParameter", "Background color of inline hints for parameters"));
    editorLightBulbForeground = registerColor("editorLightBulb.foreground", { dark: "#FFCC00", light: "#DDB100", hcDark: "#FFCC00", hcLight: "#007ACC" }, localize("editorLightBulbForeground", "The color used for the lightbulb actions icon."));
    editorLightBulbAutoFixForeground = registerColor("editorLightBulbAutoFix.foreground", { dark: "#75BEFF", light: "#007ACC", hcDark: "#75BEFF", hcLight: "#007ACC" }, localize("editorLightBulbAutoFixForeground", "The color used for the lightbulb auto fix actions icon."));
    editorLightBulbAiForeground = registerColor("editorLightBulbAi.foreground", { dark: editorLightBulbForeground, light: editorLightBulbForeground, hcDark: editorLightBulbForeground, hcLight: editorLightBulbForeground }, localize("editorLightBulbAiForeground", "The color used for the lightbulb AI icon."));
    defaultInsertColor = new Color(new RGBA(155, 185, 85, 0.2));
    defaultRemoveColor = new Color(new RGBA(255, 0, 0, 0.2));
    diffInserted = registerColor("diffEditor.insertedTextBackground", { dark: "#9ccc2c33", light: "#9ccc2c40", hcDark: null, hcLight: null }, localize("diffEditorInserted", "Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations."), true);
    diffRemoved = registerColor("diffEditor.removedTextBackground", { dark: "#ff000033", light: "#ff000033", hcDark: null, hcLight: null }, localize("diffEditorRemoved", "Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations."), true);
    diffInsertedLine = registerColor("diffEditor.insertedLineBackground", { dark: defaultInsertColor, light: defaultInsertColor, hcDark: null, hcLight: null }, localize("diffEditorInsertedLines", "Background color for lines that got inserted. The color must not be opaque so as not to hide underlying decorations."), true);
    diffRemovedLine = registerColor("diffEditor.removedLineBackground", { dark: defaultRemoveColor, light: defaultRemoveColor, hcDark: null, hcLight: null }, localize("diffEditorRemovedLines", "Background color for lines that got removed. The color must not be opaque so as not to hide underlying decorations."), true);
    diffInsertedLineGutter = registerColor("diffEditorGutter.insertedLineBackground", { dark: null, light: null, hcDark: null, hcLight: null }, localize("diffEditorInsertedLineGutter", "Background color for the margin where lines got inserted."));
    diffRemovedLineGutter = registerColor("diffEditorGutter.removedLineBackground", { dark: null, light: null, hcDark: null, hcLight: null }, localize("diffEditorRemovedLineGutter", "Background color for the margin where lines got removed."));
    diffOverviewRulerInserted = registerColor("diffEditorOverview.insertedForeground", { dark: null, light: null, hcDark: null, hcLight: null }, localize("diffEditorOverviewInserted", "Diff overview ruler foreground for inserted content."));
    diffOverviewRulerRemoved = registerColor("diffEditorOverview.removedForeground", { dark: null, light: null, hcDark: null, hcLight: null }, localize("diffEditorOverviewRemoved", "Diff overview ruler foreground for removed content."));
    diffInsertedOutline = registerColor("diffEditor.insertedTextBorder", { dark: null, light: null, hcDark: "#33ff2eff", hcLight: "#374E06" }, localize("diffEditorInsertedOutline", "Outline color for the text that got inserted."));
    diffRemovedOutline = registerColor("diffEditor.removedTextBorder", { dark: null, light: null, hcDark: "#FF008F", hcLight: "#AD0707" }, localize("diffEditorRemovedOutline", "Outline color for text that got removed."));
    diffBorder = registerColor("diffEditor.border", { dark: null, light: null, hcDark: contrastBorder, hcLight: contrastBorder }, localize("diffEditorBorder", "Border color between the two text editors."));
    diffDiagonalFill = registerColor("diffEditor.diagonalFill", { dark: "#cccccc33", light: "#22222233", hcDark: null, hcLight: null }, localize("diffDiagonalFill", "Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views."));
    diffUnchangedRegionBackground = registerColor("diffEditor.unchangedRegionBackground", { dark: "sideBar.background", light: "sideBar.background", hcDark: "sideBar.background", hcLight: "sideBar.background" }, localize("diffEditor.unchangedRegionBackground", "The background color of unchanged blocks in the diff editor."));
    diffUnchangedRegionForeground = registerColor("diffEditor.unchangedRegionForeground", { dark: "foreground", light: "foreground", hcDark: "foreground", hcLight: "foreground" }, localize("diffEditor.unchangedRegionForeground", "The foreground color of unchanged blocks in the diff editor."));
    diffUnchangedTextBackground = registerColor("diffEditor.unchangedCodeBackground", { dark: "#74747429", light: "#b8b8b829", hcDark: null, hcLight: null }, localize("diffEditor.unchangedCodeBackground", "The background color of unchanged code in the diff editor."));
    listFocusBackground = registerColor("list.focusBackground", { dark: null, light: null, hcDark: null, hcLight: null }, localize("listFocusBackground", "List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
    listFocusForeground = registerColor("list.focusForeground", { dark: null, light: null, hcDark: null, hcLight: null }, localize("listFocusForeground", "List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
    listFocusOutline = registerColor("list.focusOutline", { dark: focusBorder, light: focusBorder, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize("listFocusOutline", "List/Tree outline color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
    listFocusAndSelectionOutline = registerColor("list.focusAndSelectionOutline", { dark: null, light: null, hcDark: null, hcLight: null }, localize("listFocusAndSelectionOutline", "List/Tree outline color for the focused item when the list/tree is active and selected. An active list/tree has keyboard focus, an inactive does not."));
    listActiveSelectionBackground = registerColor("list.activeSelectionBackground", { dark: "#04395E", light: "#0060C0", hcDark: null, hcLight: Color.fromHex("#0F4A85").transparent(0.1) }, localize("listActiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
    listActiveSelectionForeground = registerColor("list.activeSelectionForeground", { dark: Color.white, light: Color.white, hcDark: null, hcLight: null }, localize("listActiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
    listActiveSelectionIconForeground = registerColor("list.activeSelectionIconForeground", { dark: null, light: null, hcDark: null, hcLight: null }, localize("listActiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not."));
    listInactiveSelectionBackground = registerColor("list.inactiveSelectionBackground", { dark: "#37373D", light: "#E4E6F1", hcDark: null, hcLight: Color.fromHex("#0F4A85").transparent(0.1) }, localize("listInactiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
    listInactiveSelectionForeground = registerColor("list.inactiveSelectionForeground", { dark: null, light: null, hcDark: null, hcLight: null }, localize("listInactiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
    listInactiveSelectionIconForeground = registerColor("list.inactiveSelectionIconForeground", { dark: null, light: null, hcDark: null, hcLight: null }, localize("listInactiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
    listInactiveFocusBackground = registerColor("list.inactiveFocusBackground", { dark: null, light: null, hcDark: null, hcLight: null }, localize("listInactiveFocusBackground", "List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
    listInactiveFocusOutline = registerColor("list.inactiveFocusOutline", { dark: null, light: null, hcDark: null, hcLight: null }, localize("listInactiveFocusOutline", "List/Tree outline color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not."));
    listHoverBackground = registerColor("list.hoverBackground", { dark: "#2A2D2E", light: "#F0F0F0", hcDark: Color.white.transparent(0.1), hcLight: Color.fromHex("#0F4A85").transparent(0.1) }, localize("listHoverBackground", "List/Tree background when hovering over items using the mouse."));
    listHoverForeground = registerColor("list.hoverForeground", { dark: null, light: null, hcDark: null, hcLight: null }, localize("listHoverForeground", "List/Tree foreground when hovering over items using the mouse."));
    listDropOverBackground = registerColor("list.dropBackground", { dark: "#062F4A", light: "#D6EBFF", hcDark: null, hcLight: null }, localize("listDropBackground", "List/Tree drag and drop background when moving items over other items when using the mouse."));
    listDropBetweenBackground = registerColor("list.dropBetweenBackground", { dark: iconForeground, light: iconForeground, hcDark: null, hcLight: null }, localize("listDropBetweenBackground", "List/Tree drag and drop border color when moving items between items when using the mouse."));
    listHighlightForeground = registerColor("list.highlightForeground", { dark: "#2AAAFF", light: "#0066BF", hcDark: focusBorder, hcLight: focusBorder }, localize("highlight", "List/Tree foreground color of the match highlights when searching inside the list/tree."));
    listFocusHighlightForeground = registerColor("list.focusHighlightForeground", { dark: listHighlightForeground, light: ifDefinedThenElse(listActiveSelectionBackground, listHighlightForeground, "#BBE7FF"), hcDark: listHighlightForeground, hcLight: listHighlightForeground }, localize("listFocusHighlightForeground", "List/Tree foreground color of the match highlights on actively focused items when searching inside the list/tree."));
    listInvalidItemForeground = registerColor("list.invalidItemForeground", { dark: "#B89500", light: "#B89500", hcDark: "#B89500", hcLight: "#B5200D" }, localize("invalidItemForeground", "List/Tree foreground color for invalid items, for example an unresolved root in explorer."));
    listErrorForeground = registerColor("list.errorForeground", { dark: "#F88070", light: "#B01011", hcDark: null, hcLight: null }, localize("listErrorForeground", "Foreground color of list items containing errors."));
    listWarningForeground = registerColor("list.warningForeground", { dark: "#CCA700", light: "#855F00", hcDark: null, hcLight: null }, localize("listWarningForeground", "Foreground color of list items containing warnings."));
    listFilterWidgetBackground = registerColor("listFilterWidget.background", { light: darken(editorWidgetBackground, 0), dark: lighten(editorWidgetBackground, 0), hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, localize("listFilterWidgetBackground", "Background color of the type filter widget in lists and trees."));
    listFilterWidgetOutline = registerColor("listFilterWidget.outline", { dark: Color.transparent, light: Color.transparent, hcDark: "#f38518", hcLight: "#007ACC" }, localize("listFilterWidgetOutline", "Outline color of the type filter widget in lists and trees."));
    listFilterWidgetNoMatchesOutline = registerColor("listFilterWidget.noMatchesOutline", { dark: "#BE1100", light: "#BE1100", hcDark: contrastBorder, hcLight: contrastBorder }, localize("listFilterWidgetNoMatchesOutline", "Outline color of the type filter widget in lists and trees, when there are no matches."));
    listFilterWidgetShadow = registerColor("listFilterWidget.shadow", { dark: widgetShadow, light: widgetShadow, hcDark: widgetShadow, hcLight: widgetShadow }, localize("listFilterWidgetShadow", "Shadow color of the type filter widget in lists and trees."));
    listFilterMatchHighlight = registerColor("list.filterMatchBackground", { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, localize("listFilterMatchHighlight", "Background color of the filtered match."));
    listFilterMatchHighlightBorder = registerColor("list.filterMatchBorder", { dark: editorFindMatchHighlightBorder, light: editorFindMatchHighlightBorder, hcDark: contrastBorder, hcLight: activeContrastBorder }, localize("listFilterMatchHighlightBorder", "Border color of the filtered match."));
    treeIndentGuidesStroke = registerColor("tree.indentGuidesStroke", { dark: "#585858", light: "#a9a9a9", hcDark: "#a9a9a9", hcLight: "#a5a5a5" }, localize("treeIndentGuidesStroke", "Tree stroke color for the indentation guides."));
    treeInactiveIndentGuidesStroke = registerColor("tree.inactiveIndentGuidesStroke", { dark: transparent(treeIndentGuidesStroke, 0.4), light: transparent(treeIndentGuidesStroke, 0.4), hcDark: transparent(treeIndentGuidesStroke, 0.4), hcLight: transparent(treeIndentGuidesStroke, 0.4) }, localize("treeInactiveIndentGuidesStroke", "Tree stroke color for the indentation guides that are not active."));
    tableColumnsBorder = registerColor("tree.tableColumnsBorder", { dark: "#CCCCCC20", light: "#61616120", hcDark: null, hcLight: null }, localize("tableColumnsBorder", "Table border color between columns."));
    tableOddRowsBackgroundColor = registerColor("tree.tableOddRowsBackground", { dark: transparent(foreground, 0.04), light: transparent(foreground, 0.04), hcDark: null, hcLight: null }, localize("tableOddRowsBackgroundColor", "Background color for odd table rows."));
    listDeemphasizedForeground = registerColor("list.deemphasizedForeground", { dark: "#8C8C8C", light: "#8E8E90", hcDark: "#A7A8A9", hcLight: "#666666" }, localize("listDeemphasizedForeground", "List/Tree foreground color for items that are deemphasized. "));
    checkboxBackground = registerColor("checkbox.background", { dark: selectBackground, light: selectBackground, hcDark: selectBackground, hcLight: selectBackground }, localize("checkbox.background", "Background color of checkbox widget."));
    checkboxSelectBackground = registerColor("checkbox.selectBackground", { dark: editorWidgetBackground, light: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, localize("checkbox.select.background", "Background color of checkbox widget when the element it's in is selected."));
    checkboxForeground = registerColor("checkbox.foreground", { dark: selectForeground, light: selectForeground, hcDark: selectForeground, hcLight: selectForeground }, localize("checkbox.foreground", "Foreground color of checkbox widget."));
    checkboxBorder = registerColor("checkbox.border", { dark: selectBorder, light: selectBorder, hcDark: selectBorder, hcLight: selectBorder }, localize("checkbox.border", "Border color of checkbox widget."));
    checkboxSelectBorder = registerColor("checkbox.selectBorder", { dark: iconForeground, light: iconForeground, hcDark: iconForeground, hcLight: iconForeground }, localize("checkbox.select.border", "Border color of checkbox widget when the element it's in is selected."));
    _deprecatedQuickInputListFocusBackground = registerColor("quickInput.list.focusBackground", { dark: null, light: null, hcDark: null, hcLight: null }, "", void 0, localize("quickInput.list.focusBackground deprecation", "Please use quickInputList.focusBackground instead"));
    quickInputListFocusForeground = registerColor("quickInputList.focusForeground", { dark: listActiveSelectionForeground, light: listActiveSelectionForeground, hcDark: listActiveSelectionForeground, hcLight: listActiveSelectionForeground }, localize("quickInput.listFocusForeground", "Quick picker foreground color for the focused item."));
    quickInputListFocusIconForeground = registerColor("quickInputList.focusIconForeground", { dark: listActiveSelectionIconForeground, light: listActiveSelectionIconForeground, hcDark: listActiveSelectionIconForeground, hcLight: listActiveSelectionIconForeground }, localize("quickInput.listFocusIconForeground", "Quick picker icon foreground color for the focused item."));
    quickInputListFocusBackground = registerColor("quickInputList.focusBackground", { dark: oneOf(_deprecatedQuickInputListFocusBackground, listActiveSelectionBackground), light: oneOf(_deprecatedQuickInputListFocusBackground, listActiveSelectionBackground), hcDark: null, hcLight: null }, localize("quickInput.listFocusBackground", "Quick picker background color for the focused item."));
    menuBorder = registerColor("menu.border", { dark: null, light: null, hcDark: contrastBorder, hcLight: contrastBorder }, localize("menuBorder", "Border color of menus."));
    menuForeground = registerColor("menu.foreground", { dark: selectForeground, light: selectForeground, hcDark: selectForeground, hcLight: selectForeground }, localize("menuForeground", "Foreground color of menu items."));
    menuBackground = registerColor("menu.background", { dark: selectBackground, light: selectBackground, hcDark: selectBackground, hcLight: selectBackground }, localize("menuBackground", "Background color of menu items."));
    menuSelectionForeground = registerColor("menu.selectionForeground", { dark: listActiveSelectionForeground, light: listActiveSelectionForeground, hcDark: listActiveSelectionForeground, hcLight: listActiveSelectionForeground }, localize("menuSelectionForeground", "Foreground color of the selected menu item in menus."));
    menuSelectionBackground = registerColor("menu.selectionBackground", { dark: listActiveSelectionBackground, light: listActiveSelectionBackground, hcDark: listActiveSelectionBackground, hcLight: listActiveSelectionBackground }, localize("menuSelectionBackground", "Background color of the selected menu item in menus."));
    menuSelectionBorder = registerColor("menu.selectionBorder", { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize("menuSelectionBorder", "Border color of the selected menu item in menus."));
    menuSeparatorBackground = registerColor("menu.separatorBackground", { dark: "#606060", light: "#D4D4D4", hcDark: contrastBorder, hcLight: contrastBorder }, localize("menuSeparatorBackground", "Color of a separator menu item in menus."));
    toolbarHoverBackground = registerColor("toolbar.hoverBackground", { dark: "#5a5d5e50", light: "#b8b8b850", hcDark: null, hcLight: null }, localize("toolbarHoverBackground", "Toolbar background when hovering over actions using the mouse"));
    toolbarHoverOutline = registerColor("toolbar.hoverOutline", { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize("toolbarHoverOutline", "Toolbar outline when hovering over actions using the mouse"));
    toolbarActiveBackground = registerColor("toolbar.activeBackground", { dark: lighten(toolbarHoverBackground, 0.1), light: darken(toolbarHoverBackground, 0.1), hcDark: null, hcLight: null }, localize("toolbarActiveBackground", "Toolbar background when holding the mouse over actions"));
    snippetTabstopHighlightBackground = registerColor("editor.snippetTabstopHighlightBackground", { dark: new Color(new RGBA(124, 124, 124, 0.3)), light: new Color(new RGBA(10, 50, 100, 0.2)), hcDark: new Color(new RGBA(124, 124, 124, 0.3)), hcLight: new Color(new RGBA(10, 50, 100, 0.2)) }, localize("snippetTabstopHighlightBackground", "Highlight background color of a snippet tabstop."));
    snippetTabstopHighlightBorder = registerColor("editor.snippetTabstopHighlightBorder", { dark: null, light: null, hcDark: null, hcLight: null }, localize("snippetTabstopHighlightBorder", "Highlight border color of a snippet tabstop."));
    snippetFinalTabstopHighlightBackground = registerColor("editor.snippetFinalTabstopHighlightBackground", { dark: null, light: null, hcDark: null, hcLight: null }, localize("snippetFinalTabstopHighlightBackground", "Highlight background color of the final tabstop of a snippet."));
    snippetFinalTabstopHighlightBorder = registerColor("editor.snippetFinalTabstopHighlightBorder", { dark: "#525252", light: new Color(new RGBA(10, 50, 100, 0.5)), hcDark: "#525252", hcLight: "#292929" }, localize("snippetFinalTabstopHighlightBorder", "Highlight border color of the final tabstop of a snippet."));
    breadcrumbsForeground = registerColor("breadcrumb.foreground", { light: transparent(foreground, 0.8), dark: transparent(foreground, 0.8), hcDark: transparent(foreground, 0.8), hcLight: transparent(foreground, 0.8) }, localize("breadcrumbsFocusForeground", "Color of focused breadcrumb items."));
    breadcrumbsBackground = registerColor("breadcrumb.background", { light: editorBackground, dark: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, localize("breadcrumbsBackground", "Background color of breadcrumb items."));
    breadcrumbsFocusForeground = registerColor("breadcrumb.focusForeground", { light: darken(foreground, 0.2), dark: lighten(foreground, 0.1), hcDark: lighten(foreground, 0.1), hcLight: lighten(foreground, 0.1) }, localize("breadcrumbsFocusForeground", "Color of focused breadcrumb items."));
    breadcrumbsActiveSelectionForeground = registerColor("breadcrumb.activeSelectionForeground", { light: darken(foreground, 0.2), dark: lighten(foreground, 0.1), hcDark: lighten(foreground, 0.1), hcLight: lighten(foreground, 0.1) }, localize("breadcrumbsSelectedForeground", "Color of selected breadcrumb items."));
    breadcrumbsPickerBackground = registerColor("breadcrumbPicker.background", { light: editorWidgetBackground, dark: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, localize("breadcrumbsSelectedBackground", "Background color of breadcrumb item picker."));
    headerTransparency = 0.5;
    currentBaseColor = Color.fromHex("#40C8AE").transparent(headerTransparency);
    incomingBaseColor = Color.fromHex("#40A6FF").transparent(headerTransparency);
    commonBaseColor = Color.fromHex("#606060").transparent(0.4);
    contentTransparency = 0.4;
    rulerTransparency = 1;
    mergeCurrentHeaderBackground = registerColor("merge.currentHeaderBackground", { dark: currentBaseColor, light: currentBaseColor, hcDark: null, hcLight: null }, localize("mergeCurrentHeaderBackground", "Current header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
    mergeCurrentContentBackground = registerColor("merge.currentContentBackground", { dark: transparent(mergeCurrentHeaderBackground, contentTransparency), light: transparent(mergeCurrentHeaderBackground, contentTransparency), hcDark: transparent(mergeCurrentHeaderBackground, contentTransparency), hcLight: transparent(mergeCurrentHeaderBackground, contentTransparency) }, localize("mergeCurrentContentBackground", "Current content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
    mergeIncomingHeaderBackground = registerColor("merge.incomingHeaderBackground", { dark: incomingBaseColor, light: incomingBaseColor, hcDark: null, hcLight: null }, localize("mergeIncomingHeaderBackground", "Incoming header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
    mergeIncomingContentBackground = registerColor("merge.incomingContentBackground", { dark: transparent(mergeIncomingHeaderBackground, contentTransparency), light: transparent(mergeIncomingHeaderBackground, contentTransparency), hcDark: transparent(mergeIncomingHeaderBackground, contentTransparency), hcLight: transparent(mergeIncomingHeaderBackground, contentTransparency) }, localize("mergeIncomingContentBackground", "Incoming content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
    mergeCommonHeaderBackground = registerColor("merge.commonHeaderBackground", { dark: commonBaseColor, light: commonBaseColor, hcDark: null, hcLight: null }, localize("mergeCommonHeaderBackground", "Common ancestor header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
    mergeCommonContentBackground = registerColor("merge.commonContentBackground", { dark: transparent(mergeCommonHeaderBackground, contentTransparency), light: transparent(mergeCommonHeaderBackground, contentTransparency), hcDark: transparent(mergeCommonHeaderBackground, contentTransparency), hcLight: transparent(mergeCommonHeaderBackground, contentTransparency) }, localize("mergeCommonContentBackground", "Common ancestor content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), true);
    mergeBorder = registerColor("merge.border", { dark: null, light: null, hcDark: "#C3DF6F", hcLight: "#007ACC" }, localize("mergeBorder", "Border color on headers and the splitter in inline merge-conflicts."));
    overviewRulerCurrentContentForeground = registerColor("editorOverviewRuler.currentContentForeground", { dark: transparent(mergeCurrentHeaderBackground, rulerTransparency), light: transparent(mergeCurrentHeaderBackground, rulerTransparency), hcDark: mergeBorder, hcLight: mergeBorder }, localize("overviewRulerCurrentContentForeground", "Current overview ruler foreground for inline merge-conflicts."));
    overviewRulerIncomingContentForeground = registerColor("editorOverviewRuler.incomingContentForeground", { dark: transparent(mergeIncomingHeaderBackground, rulerTransparency), light: transparent(mergeIncomingHeaderBackground, rulerTransparency), hcDark: mergeBorder, hcLight: mergeBorder }, localize("overviewRulerIncomingContentForeground", "Incoming overview ruler foreground for inline merge-conflicts."));
    overviewRulerCommonContentForeground = registerColor("editorOverviewRuler.commonContentForeground", { dark: transparent(mergeCommonHeaderBackground, rulerTransparency), light: transparent(mergeCommonHeaderBackground, rulerTransparency), hcDark: mergeBorder, hcLight: mergeBorder }, localize("overviewRulerCommonContentForeground", "Common ancestor overview ruler foreground for inline merge-conflicts."));
    overviewRulerFindMatchForeground = registerColor("editorOverviewRuler.findMatchForeground", { dark: "#d186167e", light: "#d186167e", hcDark: "#AB5A00", hcLight: "" }, localize("overviewRulerFindMatchForeground", "Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations."), true);
    overviewRulerSelectionHighlightForeground = registerColor("editorOverviewRuler.selectionHighlightForeground", { dark: "#A0A0A0CC", light: "#A0A0A0CC", hcDark: "#A0A0A0CC", hcLight: "#A0A0A0CC" }, localize("overviewRulerSelectionHighlightForeground", "Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations."), true);
    minimapFindMatch = registerColor("minimap.findMatchHighlight", { light: "#d18616", dark: "#d18616", hcDark: "#AB5A00", hcLight: "#0F4A85" }, localize("minimapFindMatchHighlight", "Minimap marker color for find matches."), true);
    minimapSelectionOccurrenceHighlight = registerColor("minimap.selectionOccurrenceHighlight", { light: "#c9c9c9", dark: "#676767", hcDark: "#ffffff", hcLight: "#0F4A85" }, localize("minimapSelectionOccurrenceHighlight", "Minimap marker color for repeating editor selections."), true);
    minimapSelection = registerColor("minimap.selectionHighlight", { light: "#ADD6FF", dark: "#264F78", hcDark: "#ffffff", hcLight: "#0F4A85" }, localize("minimapSelectionHighlight", "Minimap marker color for the editor selection."), true);
    minimapInfo = registerColor("minimap.infoHighlight", { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, localize("minimapInfo", "Minimap marker color for infos."));
    minimapWarning = registerColor("minimap.warningHighlight", { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, localize("overviewRuleWarning", "Minimap marker color for warnings."));
    minimapError = registerColor("minimap.errorHighlight", { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: "#B5200D" }, localize("minimapError", "Minimap marker color for errors."));
    minimapBackground = registerColor("minimap.background", { dark: null, light: null, hcDark: null, hcLight: null }, localize("minimapBackground", "Minimap background color."));
    minimapForegroundOpacity = registerColor("minimap.foregroundOpacity", { dark: Color.fromHex("#000f"), light: Color.fromHex("#000f"), hcDark: Color.fromHex("#000f"), hcLight: Color.fromHex("#000f") }, localize("minimapForegroundOpacity", 'Opacity of foreground elements rendered in the minimap. For example, "#000000c0" will render the elements with 75% opacity.'));
    minimapSliderBackground = registerColor("minimapSlider.background", { light: transparent(scrollbarSliderBackground, 0.5), dark: transparent(scrollbarSliderBackground, 0.5), hcDark: transparent(scrollbarSliderBackground, 0.5), hcLight: transparent(scrollbarSliderBackground, 0.5) }, localize("minimapSliderBackground", "Minimap slider background color."));
    minimapSliderHoverBackground = registerColor("minimapSlider.hoverBackground", { light: transparent(scrollbarSliderHoverBackground, 0.5), dark: transparent(scrollbarSliderHoverBackground, 0.5), hcDark: transparent(scrollbarSliderHoverBackground, 0.5), hcLight: transparent(scrollbarSliderHoverBackground, 0.5) }, localize("minimapSliderHoverBackground", "Minimap slider background color when hovering."));
    minimapSliderActiveBackground = registerColor("minimapSlider.activeBackground", { light: transparent(scrollbarSliderActiveBackground, 0.5), dark: transparent(scrollbarSliderActiveBackground, 0.5), hcDark: transparent(scrollbarSliderActiveBackground, 0.5), hcLight: transparent(scrollbarSliderActiveBackground, 0.5) }, localize("minimapSliderActiveBackground", "Minimap slider background color when clicked on."));
    problemsErrorIconForeground = registerColor("problemsErrorIcon.foreground", { dark: editorErrorForeground, light: editorErrorForeground, hcDark: editorErrorForeground, hcLight: editorErrorForeground }, localize("problemsErrorIconForeground", "The color used for the problems error icon."));
    problemsWarningIconForeground = registerColor("problemsWarningIcon.foreground", { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningForeground, hcLight: editorWarningForeground }, localize("problemsWarningIconForeground", "The color used for the problems warning icon."));
    problemsInfoIconForeground = registerColor("problemsInfoIcon.foreground", { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoForeground, hcLight: editorInfoForeground }, localize("problemsInfoIconForeground", "The color used for the problems info icon."));
    chartsForeground = registerColor("charts.foreground", { dark: foreground, light: foreground, hcDark: foreground, hcLight: foreground }, localize("chartsForeground", "The foreground color used in charts."));
    chartsLines = registerColor("charts.lines", { dark: transparent(foreground, 0.5), light: transparent(foreground, 0.5), hcDark: transparent(foreground, 0.5), hcLight: transparent(foreground, 0.5) }, localize("chartsLines", "The color used for horizontal lines in charts."));
    chartsRed = registerColor("charts.red", { dark: editorErrorForeground, light: editorErrorForeground, hcDark: editorErrorForeground, hcLight: editorErrorForeground }, localize("chartsRed", "The red color used in chart visualizations."));
    chartsBlue = registerColor("charts.blue", { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoForeground, hcLight: editorInfoForeground }, localize("chartsBlue", "The blue color used in chart visualizations."));
    chartsYellow = registerColor("charts.yellow", { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningForeground, hcLight: editorWarningForeground }, localize("chartsYellow", "The yellow color used in chart visualizations."));
    chartsOrange = registerColor("charts.orange", { dark: minimapFindMatch, light: minimapFindMatch, hcDark: minimapFindMatch, hcLight: minimapFindMatch }, localize("chartsOrange", "The orange color used in chart visualizations."));
    chartsGreen = registerColor("charts.green", { dark: "#89D185", light: "#388A34", hcDark: "#89D185", hcLight: "#374e06" }, localize("chartsGreen", "The green color used in chart visualizations."));
    chartsPurple = registerColor("charts.purple", { dark: "#B180D7", light: "#652D90", hcDark: "#B180D7", hcLight: "#652D90" }, localize("chartsPurple", "The purple color used in chart visualizations."));
    workbenchColorsSchemaId = "vscode://schemas/workbench-colors";
    schemaRegistry = Registry.as(Extensions.JSONContribution);
    schemaRegistry.registerSchema(workbenchColorsSchemaId, colorRegistry.getColorSchema());
    delayer = new RunOnceScheduler(() => schemaRegistry.notifySchemaChanged(workbenchColorsSchemaId), 200);
    colorRegistry.onDidChangeSchema(() => {
      if (!delayer.isScheduled()) {
        delayer.schedule();
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js
var EDITOR_MODEL_DEFAULTS;
var init_textModelDefaults = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js"() {
    EDITOR_MODEL_DEFAULTS = {
      tabSize: 4,
      indentSize: 4,
      insertSpaces: true,
      detectIndentation: true,
      trimAutoWhitespace: true,
      largeFileOptimizations: true,
      bracketPairColorizationOptions: {
        enabled: true,
        independentColorPoolPerBracketType: false
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/codicons.js
function register2(id, fontCharacter) {
  if (isString(fontCharacter)) {
    const val = _codiconFontCharacters[fontCharacter];
    if (val === void 0) {
      throw new Error(`${id} references an unknown codicon: ${fontCharacter}`);
    }
    fontCharacter = val;
  }
  _codiconFontCharacters[id] = fontCharacter;
  return { id };
}
function getCodiconFontCharacters() {
  return _codiconFontCharacters;
}
var _codiconFontCharacters, Codicon;
var init_codicons = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/codicons.js"() {
    init_types();
    _codiconFontCharacters = /* @__PURE__ */ Object.create(null);
    Codicon = {
      // built-in icons, with image name
      add: register2("add", 6e4),
      plus: register2("plus", 6e4),
      gistNew: register2("gist-new", 6e4),
      repoCreate: register2("repo-create", 6e4),
      lightbulb: register2("lightbulb", 60001),
      lightBulb: register2("light-bulb", 60001),
      repo: register2("repo", 60002),
      repoDelete: register2("repo-delete", 60002),
      gistFork: register2("gist-fork", 60003),
      repoForked: register2("repo-forked", 60003),
      gitPullRequest: register2("git-pull-request", 60004),
      gitPullRequestAbandoned: register2("git-pull-request-abandoned", 60004),
      recordKeys: register2("record-keys", 60005),
      keyboard: register2("keyboard", 60005),
      tag: register2("tag", 60006),
      tagAdd: register2("tag-add", 60006),
      tagRemove: register2("tag-remove", 60006),
      gitPullRequestLabel: register2("git-pull-request-label", 60006),
      person: register2("person", 60007),
      personFollow: register2("person-follow", 60007),
      personOutline: register2("person-outline", 60007),
      personFilled: register2("person-filled", 60007),
      gitBranch: register2("git-branch", 60008),
      gitBranchCreate: register2("git-branch-create", 60008),
      gitBranchDelete: register2("git-branch-delete", 60008),
      sourceControl: register2("source-control", 60008),
      mirror: register2("mirror", 60009),
      mirrorPublic: register2("mirror-public", 60009),
      star: register2("star", 60010),
      starAdd: register2("star-add", 60010),
      starDelete: register2("star-delete", 60010),
      starEmpty: register2("star-empty", 60010),
      comment: register2("comment", 60011),
      commentAdd: register2("comment-add", 60011),
      alert: register2("alert", 60012),
      warning: register2("warning", 60012),
      search: register2("search", 60013),
      searchSave: register2("search-save", 60013),
      logOut: register2("log-out", 60014),
      signOut: register2("sign-out", 60014),
      logIn: register2("log-in", 60015),
      signIn: register2("sign-in", 60015),
      eye: register2("eye", 60016),
      eyeUnwatch: register2("eye-unwatch", 60016),
      eyeWatch: register2("eye-watch", 60016),
      circleFilled: register2("circle-filled", 60017),
      primitiveDot: register2("primitive-dot", 60017),
      closeDirty: register2("close-dirty", 60017),
      debugBreakpoint: register2("debug-breakpoint", 60017),
      debugBreakpointDisabled: register2("debug-breakpoint-disabled", 60017),
      debugBreakpointPending: register2("debug-breakpoint-pending", 60377),
      debugHint: register2("debug-hint", 60017),
      primitiveSquare: register2("primitive-square", 60018),
      edit: register2("edit", 60019),
      pencil: register2("pencil", 60019),
      info: register2("info", 60020),
      issueOpened: register2("issue-opened", 60020),
      gistPrivate: register2("gist-private", 60021),
      gitForkPrivate: register2("git-fork-private", 60021),
      lock: register2("lock", 60021),
      mirrorPrivate: register2("mirror-private", 60021),
      close: register2("close", 60022),
      removeClose: register2("remove-close", 60022),
      x: register2("x", 60022),
      repoSync: register2("repo-sync", 60023),
      sync: register2("sync", 60023),
      clone: register2("clone", 60024),
      desktopDownload: register2("desktop-download", 60024),
      beaker: register2("beaker", 60025),
      microscope: register2("microscope", 60025),
      vm: register2("vm", 60026),
      deviceDesktop: register2("device-desktop", 60026),
      file: register2("file", 60027),
      fileText: register2("file-text", 60027),
      more: register2("more", 60028),
      ellipsis: register2("ellipsis", 60028),
      kebabHorizontal: register2("kebab-horizontal", 60028),
      mailReply: register2("mail-reply", 60029),
      reply: register2("reply", 60029),
      organization: register2("organization", 60030),
      organizationFilled: register2("organization-filled", 60030),
      organizationOutline: register2("organization-outline", 60030),
      newFile: register2("new-file", 60031),
      fileAdd: register2("file-add", 60031),
      newFolder: register2("new-folder", 60032),
      fileDirectoryCreate: register2("file-directory-create", 60032),
      trash: register2("trash", 60033),
      trashcan: register2("trashcan", 60033),
      history: register2("history", 60034),
      clock: register2("clock", 60034),
      folder: register2("folder", 60035),
      fileDirectory: register2("file-directory", 60035),
      symbolFolder: register2("symbol-folder", 60035),
      logoGithub: register2("logo-github", 60036),
      markGithub: register2("mark-github", 60036),
      github: register2("github", 60036),
      terminal: register2("terminal", 60037),
      console: register2("console", 60037),
      repl: register2("repl", 60037),
      zap: register2("zap", 60038),
      symbolEvent: register2("symbol-event", 60038),
      error: register2("error", 60039),
      stop: register2("stop", 60039),
      variable: register2("variable", 60040),
      symbolVariable: register2("symbol-variable", 60040),
      array: register2("array", 60042),
      symbolArray: register2("symbol-array", 60042),
      symbolModule: register2("symbol-module", 60043),
      symbolPackage: register2("symbol-package", 60043),
      symbolNamespace: register2("symbol-namespace", 60043),
      symbolObject: register2("symbol-object", 60043),
      symbolMethod: register2("symbol-method", 60044),
      symbolFunction: register2("symbol-function", 60044),
      symbolConstructor: register2("symbol-constructor", 60044),
      symbolBoolean: register2("symbol-boolean", 60047),
      symbolNull: register2("symbol-null", 60047),
      symbolNumeric: register2("symbol-numeric", 60048),
      symbolNumber: register2("symbol-number", 60048),
      symbolStructure: register2("symbol-structure", 60049),
      symbolStruct: register2("symbol-struct", 60049),
      symbolParameter: register2("symbol-parameter", 60050),
      symbolTypeParameter: register2("symbol-type-parameter", 60050),
      symbolKey: register2("symbol-key", 60051),
      symbolText: register2("symbol-text", 60051),
      symbolReference: register2("symbol-reference", 60052),
      goToFile: register2("go-to-file", 60052),
      symbolEnum: register2("symbol-enum", 60053),
      symbolValue: register2("symbol-value", 60053),
      symbolRuler: register2("symbol-ruler", 60054),
      symbolUnit: register2("symbol-unit", 60054),
      activateBreakpoints: register2("activate-breakpoints", 60055),
      archive: register2("archive", 60056),
      arrowBoth: register2("arrow-both", 60057),
      arrowDown: register2("arrow-down", 60058),
      arrowLeft: register2("arrow-left", 60059),
      arrowRight: register2("arrow-right", 60060),
      arrowSmallDown: register2("arrow-small-down", 60061),
      arrowSmallLeft: register2("arrow-small-left", 60062),
      arrowSmallRight: register2("arrow-small-right", 60063),
      arrowSmallUp: register2("arrow-small-up", 60064),
      arrowUp: register2("arrow-up", 60065),
      bell: register2("bell", 60066),
      bold: register2("bold", 60067),
      book: register2("book", 60068),
      bookmark: register2("bookmark", 60069),
      debugBreakpointConditionalUnverified: register2("debug-breakpoint-conditional-unverified", 60070),
      debugBreakpointConditional: register2("debug-breakpoint-conditional", 60071),
      debugBreakpointConditionalDisabled: register2("debug-breakpoint-conditional-disabled", 60071),
      debugBreakpointDataUnverified: register2("debug-breakpoint-data-unverified", 60072),
      debugBreakpointData: register2("debug-breakpoint-data", 60073),
      debugBreakpointDataDisabled: register2("debug-breakpoint-data-disabled", 60073),
      debugBreakpointLogUnverified: register2("debug-breakpoint-log-unverified", 60074),
      debugBreakpointLog: register2("debug-breakpoint-log", 60075),
      debugBreakpointLogDisabled: register2("debug-breakpoint-log-disabled", 60075),
      briefcase: register2("briefcase", 60076),
      broadcast: register2("broadcast", 60077),
      browser: register2("browser", 60078),
      bug: register2("bug", 60079),
      calendar: register2("calendar", 60080),
      caseSensitive: register2("case-sensitive", 60081),
      check: register2("check", 60082),
      checklist: register2("checklist", 60083),
      chevronDown: register2("chevron-down", 60084),
      dropDownButton: register2("drop-down-button", 60084),
      chevronLeft: register2("chevron-left", 60085),
      chevronRight: register2("chevron-right", 60086),
      chevronUp: register2("chevron-up", 60087),
      chromeClose: register2("chrome-close", 60088),
      chromeMaximize: register2("chrome-maximize", 60089),
      chromeMinimize: register2("chrome-minimize", 60090),
      chromeRestore: register2("chrome-restore", 60091),
      circle: register2("circle", 60092),
      circleOutline: register2("circle-outline", 60092),
      debugBreakpointUnverified: register2("debug-breakpoint-unverified", 60092),
      circleSlash: register2("circle-slash", 60093),
      circuitBoard: register2("circuit-board", 60094),
      clearAll: register2("clear-all", 60095),
      clippy: register2("clippy", 60096),
      closeAll: register2("close-all", 60097),
      cloudDownload: register2("cloud-download", 60098),
      cloudUpload: register2("cloud-upload", 60099),
      code: register2("code", 60100),
      collapseAll: register2("collapse-all", 60101),
      colorMode: register2("color-mode", 60102),
      commentDiscussion: register2("comment-discussion", 60103),
      compareChanges: register2("compare-changes", 60157),
      creditCard: register2("credit-card", 60105),
      dash: register2("dash", 60108),
      dashboard: register2("dashboard", 60109),
      database: register2("database", 60110),
      debugContinue: register2("debug-continue", 60111),
      debugDisconnect: register2("debug-disconnect", 60112),
      debugPause: register2("debug-pause", 60113),
      debugRestart: register2("debug-restart", 60114),
      debugStart: register2("debug-start", 60115),
      debugStepInto: register2("debug-step-into", 60116),
      debugStepOut: register2("debug-step-out", 60117),
      debugStepOver: register2("debug-step-over", 60118),
      debugStop: register2("debug-stop", 60119),
      debug: register2("debug", 60120),
      deviceCameraVideo: register2("device-camera-video", 60121),
      deviceCamera: register2("device-camera", 60122),
      deviceMobile: register2("device-mobile", 60123),
      diffAdded: register2("diff-added", 60124),
      diffIgnored: register2("diff-ignored", 60125),
      diffModified: register2("diff-modified", 60126),
      diffRemoved: register2("diff-removed", 60127),
      diffRenamed: register2("diff-renamed", 60128),
      diff: register2("diff", 60129),
      discard: register2("discard", 60130),
      editorLayout: register2("editor-layout", 60131),
      emptyWindow: register2("empty-window", 60132),
      exclude: register2("exclude", 60133),
      extensions: register2("extensions", 60134),
      eyeClosed: register2("eye-closed", 60135),
      fileBinary: register2("file-binary", 60136),
      fileCode: register2("file-code", 60137),
      fileMedia: register2("file-media", 60138),
      filePdf: register2("file-pdf", 60139),
      fileSubmodule: register2("file-submodule", 60140),
      fileSymlinkDirectory: register2("file-symlink-directory", 60141),
      fileSymlinkFile: register2("file-symlink-file", 60142),
      fileZip: register2("file-zip", 60143),
      files: register2("files", 60144),
      filter: register2("filter", 60145),
      flame: register2("flame", 60146),
      foldDown: register2("fold-down", 60147),
      foldUp: register2("fold-up", 60148),
      fold: register2("fold", 60149),
      folderActive: register2("folder-active", 60150),
      folderOpened: register2("folder-opened", 60151),
      gear: register2("gear", 60152),
      gift: register2("gift", 60153),
      gistSecret: register2("gist-secret", 60154),
      gist: register2("gist", 60155),
      gitCommit: register2("git-commit", 60156),
      gitCompare: register2("git-compare", 60157),
      gitMerge: register2("git-merge", 60158),
      githubAction: register2("github-action", 60159),
      githubAlt: register2("github-alt", 60160),
      globe: register2("globe", 60161),
      grabber: register2("grabber", 60162),
      graph: register2("graph", 60163),
      gripper: register2("gripper", 60164),
      heart: register2("heart", 60165),
      home: register2("home", 60166),
      horizontalRule: register2("horizontal-rule", 60167),
      hubot: register2("hubot", 60168),
      inbox: register2("inbox", 60169),
      issueClosed: register2("issue-closed", 60324),
      issueReopened: register2("issue-reopened", 60171),
      issues: register2("issues", 60172),
      italic: register2("italic", 60173),
      jersey: register2("jersey", 60174),
      json: register2("json", 60175),
      bracket: register2("bracket", 60175),
      kebabVertical: register2("kebab-vertical", 60176),
      key: register2("key", 60177),
      law: register2("law", 60178),
      lightbulbAutofix: register2("lightbulb-autofix", 60179),
      linkExternal: register2("link-external", 60180),
      link: register2("link", 60181),
      listOrdered: register2("list-ordered", 60182),
      listUnordered: register2("list-unordered", 60183),
      liveShare: register2("live-share", 60184),
      loading: register2("loading", 60185),
      location: register2("location", 60186),
      mailRead: register2("mail-read", 60187),
      mail: register2("mail", 60188),
      markdown: register2("markdown", 60189),
      megaphone: register2("megaphone", 60190),
      mention: register2("mention", 60191),
      milestone: register2("milestone", 60192),
      gitPullRequestMilestone: register2("git-pull-request-milestone", 60192),
      mortarBoard: register2("mortar-board", 60193),
      move: register2("move", 60194),
      multipleWindows: register2("multiple-windows", 60195),
      mute: register2("mute", 60196),
      noNewline: register2("no-newline", 60197),
      note: register2("note", 60198),
      octoface: register2("octoface", 60199),
      openPreview: register2("open-preview", 60200),
      package: register2("package", 60201),
      paintcan: register2("paintcan", 60202),
      pin: register2("pin", 60203),
      play: register2("play", 60204),
      run: register2("run", 60204),
      plug: register2("plug", 60205),
      preserveCase: register2("preserve-case", 60206),
      preview: register2("preview", 60207),
      project: register2("project", 60208),
      pulse: register2("pulse", 60209),
      question: register2("question", 60210),
      quote: register2("quote", 60211),
      radioTower: register2("radio-tower", 60212),
      reactions: register2("reactions", 60213),
      references: register2("references", 60214),
      refresh: register2("refresh", 60215),
      regex: register2("regex", 60216),
      remoteExplorer: register2("remote-explorer", 60217),
      remote: register2("remote", 60218),
      remove: register2("remove", 60219),
      replaceAll: register2("replace-all", 60220),
      replace: register2("replace", 60221),
      repoClone: register2("repo-clone", 60222),
      repoForcePush: register2("repo-force-push", 60223),
      repoPull: register2("repo-pull", 60224),
      repoPush: register2("repo-push", 60225),
      report: register2("report", 60226),
      requestChanges: register2("request-changes", 60227),
      rocket: register2("rocket", 60228),
      rootFolderOpened: register2("root-folder-opened", 60229),
      rootFolder: register2("root-folder", 60230),
      rss: register2("rss", 60231),
      ruby: register2("ruby", 60232),
      saveAll: register2("save-all", 60233),
      saveAs: register2("save-as", 60234),
      save: register2("save", 60235),
      screenFull: register2("screen-full", 60236),
      screenNormal: register2("screen-normal", 60237),
      searchStop: register2("search-stop", 60238),
      server: register2("server", 60240),
      settingsGear: register2("settings-gear", 60241),
      settings: register2("settings", 60242),
      shield: register2("shield", 60243),
      smiley: register2("smiley", 60244),
      sortPrecedence: register2("sort-precedence", 60245),
      splitHorizontal: register2("split-horizontal", 60246),
      splitVertical: register2("split-vertical", 60247),
      squirrel: register2("squirrel", 60248),
      starFull: register2("star-full", 60249),
      starHalf: register2("star-half", 60250),
      symbolClass: register2("symbol-class", 60251),
      symbolColor: register2("symbol-color", 60252),
      symbolCustomColor: register2("symbol-customcolor", 60252),
      symbolConstant: register2("symbol-constant", 60253),
      symbolEnumMember: register2("symbol-enum-member", 60254),
      symbolField: register2("symbol-field", 60255),
      symbolFile: register2("symbol-file", 60256),
      symbolInterface: register2("symbol-interface", 60257),
      symbolKeyword: register2("symbol-keyword", 60258),
      symbolMisc: register2("symbol-misc", 60259),
      symbolOperator: register2("symbol-operator", 60260),
      symbolProperty: register2("symbol-property", 60261),
      wrench: register2("wrench", 60261),
      wrenchSubaction: register2("wrench-subaction", 60261),
      symbolSnippet: register2("symbol-snippet", 60262),
      tasklist: register2("tasklist", 60263),
      telescope: register2("telescope", 60264),
      textSize: register2("text-size", 60265),
      threeBars: register2("three-bars", 60266),
      thumbsdown: register2("thumbsdown", 60267),
      thumbsup: register2("thumbsup", 60268),
      tools: register2("tools", 60269),
      triangleDown: register2("triangle-down", 60270),
      triangleLeft: register2("triangle-left", 60271),
      triangleRight: register2("triangle-right", 60272),
      triangleUp: register2("triangle-up", 60273),
      twitter: register2("twitter", 60274),
      unfold: register2("unfold", 60275),
      unlock: register2("unlock", 60276),
      unmute: register2("unmute", 60277),
      unverified: register2("unverified", 60278),
      verified: register2("verified", 60279),
      versions: register2("versions", 60280),
      vmActive: register2("vm-active", 60281),
      vmOutline: register2("vm-outline", 60282),
      vmRunning: register2("vm-running", 60283),
      watch: register2("watch", 60284),
      whitespace: register2("whitespace", 60285),
      wholeWord: register2("whole-word", 60286),
      window: register2("window", 60287),
      wordWrap: register2("word-wrap", 60288),
      zoomIn: register2("zoom-in", 60289),
      zoomOut: register2("zoom-out", 60290),
      listFilter: register2("list-filter", 60291),
      listFlat: register2("list-flat", 60292),
      listSelection: register2("list-selection", 60293),
      selection: register2("selection", 60293),
      listTree: register2("list-tree", 60294),
      debugBreakpointFunctionUnverified: register2("debug-breakpoint-function-unverified", 60295),
      debugBreakpointFunction: register2("debug-breakpoint-function", 60296),
      debugBreakpointFunctionDisabled: register2("debug-breakpoint-function-disabled", 60296),
      debugStackframeActive: register2("debug-stackframe-active", 60297),
      circleSmallFilled: register2("circle-small-filled", 60298),
      debugStackframeDot: register2("debug-stackframe-dot", 60298),
      debugStackframe: register2("debug-stackframe", 60299),
      debugStackframeFocused: register2("debug-stackframe-focused", 60299),
      debugBreakpointUnsupported: register2("debug-breakpoint-unsupported", 60300),
      symbolString: register2("symbol-string", 60301),
      debugReverseContinue: register2("debug-reverse-continue", 60302),
      debugStepBack: register2("debug-step-back", 60303),
      debugRestartFrame: register2("debug-restart-frame", 60304),
      callIncoming: register2("call-incoming", 60306),
      callOutgoing: register2("call-outgoing", 60307),
      menu: register2("menu", 60308),
      expandAll: register2("expand-all", 60309),
      feedback: register2("feedback", 60310),
      gitPullRequestReviewer: register2("git-pull-request-reviewer", 60310),
      groupByRefType: register2("group-by-ref-type", 60311),
      ungroupByRefType: register2("ungroup-by-ref-type", 60312),
      account: register2("account", 60313),
      gitPullRequestAssignee: register2("git-pull-request-assignee", 60313),
      bellDot: register2("bell-dot", 60314),
      debugConsole: register2("debug-console", 60315),
      library: register2("library", 60316),
      output: register2("output", 60317),
      runAll: register2("run-all", 60318),
      syncIgnored: register2("sync-ignored", 60319),
      pinned: register2("pinned", 60320),
      githubInverted: register2("github-inverted", 60321),
      debugAlt: register2("debug-alt", 60305),
      serverProcess: register2("server-process", 60322),
      serverEnvironment: register2("server-environment", 60323),
      pass: register2("pass", 60324),
      stopCircle: register2("stop-circle", 60325),
      playCircle: register2("play-circle", 60326),
      record: register2("record", 60327),
      debugAltSmall: register2("debug-alt-small", 60328),
      vmConnect: register2("vm-connect", 60329),
      cloud: register2("cloud", 60330),
      merge: register2("merge", 60331),
      exportIcon: register2("export", 60332),
      graphLeft: register2("graph-left", 60333),
      magnet: register2("magnet", 60334),
      notebook: register2("notebook", 60335),
      redo: register2("redo", 60336),
      checkAll: register2("check-all", 60337),
      pinnedDirty: register2("pinned-dirty", 60338),
      passFilled: register2("pass-filled", 60339),
      circleLargeFilled: register2("circle-large-filled", 60340),
      circleLarge: register2("circle-large", 60341),
      circleLargeOutline: register2("circle-large-outline", 60341),
      combine: register2("combine", 60342),
      gather: register2("gather", 60342),
      table: register2("table", 60343),
      variableGroup: register2("variable-group", 60344),
      typeHierarchy: register2("type-hierarchy", 60345),
      typeHierarchySub: register2("type-hierarchy-sub", 60346),
      typeHierarchySuper: register2("type-hierarchy-super", 60347),
      gitPullRequestCreate: register2("git-pull-request-create", 60348),
      runAbove: register2("run-above", 60349),
      runBelow: register2("run-below", 60350),
      notebookTemplate: register2("notebook-template", 60351),
      debugRerun: register2("debug-rerun", 60352),
      workspaceTrusted: register2("workspace-trusted", 60353),
      workspaceUntrusted: register2("workspace-untrusted", 60354),
      workspaceUnspecified: register2("workspace-unspecified", 60355),
      terminalCmd: register2("terminal-cmd", 60356),
      terminalDebian: register2("terminal-debian", 60357),
      terminalLinux: register2("terminal-linux", 60358),
      terminalPowershell: register2("terminal-powershell", 60359),
      terminalTmux: register2("terminal-tmux", 60360),
      terminalUbuntu: register2("terminal-ubuntu", 60361),
      terminalBash: register2("terminal-bash", 60362),
      arrowSwap: register2("arrow-swap", 60363),
      copy: register2("copy", 60364),
      personAdd: register2("person-add", 60365),
      filterFilled: register2("filter-filled", 60366),
      wand: register2("wand", 60367),
      debugLineByLine: register2("debug-line-by-line", 60368),
      inspect: register2("inspect", 60369),
      layers: register2("layers", 60370),
      layersDot: register2("layers-dot", 60371),
      layersActive: register2("layers-active", 60372),
      compass: register2("compass", 60373),
      compassDot: register2("compass-dot", 60374),
      compassActive: register2("compass-active", 60375),
      azure: register2("azure", 60376),
      issueDraft: register2("issue-draft", 60377),
      gitPullRequestClosed: register2("git-pull-request-closed", 60378),
      gitPullRequestDraft: register2("git-pull-request-draft", 60379),
      debugAll: register2("debug-all", 60380),
      debugCoverage: register2("debug-coverage", 60381),
      runErrors: register2("run-errors", 60382),
      folderLibrary: register2("folder-library", 60383),
      debugContinueSmall: register2("debug-continue-small", 60384),
      beakerStop: register2("beaker-stop", 60385),
      graphLine: register2("graph-line", 60386),
      graphScatter: register2("graph-scatter", 60387),
      pieChart: register2("pie-chart", 60388),
      bracketDot: register2("bracket-dot", 60389),
      bracketError: register2("bracket-error", 60390),
      lockSmall: register2("lock-small", 60391),
      azureDevops: register2("azure-devops", 60392),
      verifiedFilled: register2("verified-filled", 60393),
      newLine: register2("newline", 60394),
      layout: register2("layout", 60395),
      layoutActivitybarLeft: register2("layout-activitybar-left", 60396),
      layoutActivitybarRight: register2("layout-activitybar-right", 60397),
      layoutPanelLeft: register2("layout-panel-left", 60398),
      layoutPanelCenter: register2("layout-panel-center", 60399),
      layoutPanelJustify: register2("layout-panel-justify", 60400),
      layoutPanelRight: register2("layout-panel-right", 60401),
      layoutPanel: register2("layout-panel", 60402),
      layoutSidebarLeft: register2("layout-sidebar-left", 60403),
      layoutSidebarRight: register2("layout-sidebar-right", 60404),
      layoutStatusbar: register2("layout-statusbar", 60405),
      layoutMenubar: register2("layout-menubar", 60406),
      layoutCentered: register2("layout-centered", 60407),
      layoutSidebarRightOff: register2("layout-sidebar-right-off", 60416),
      layoutPanelOff: register2("layout-panel-off", 60417),
      layoutSidebarLeftOff: register2("layout-sidebar-left-off", 60418),
      target: register2("target", 60408),
      indent: register2("indent", 60409),
      recordSmall: register2("record-small", 60410),
      errorSmall: register2("error-small", 60411),
      arrowCircleDown: register2("arrow-circle-down", 60412),
      arrowCircleLeft: register2("arrow-circle-left", 60413),
      arrowCircleRight: register2("arrow-circle-right", 60414),
      arrowCircleUp: register2("arrow-circle-up", 60415),
      heartFilled: register2("heart-filled", 60420),
      map: register2("map", 60421),
      mapFilled: register2("map-filled", 60422),
      circleSmall: register2("circle-small", 60423),
      bellSlash: register2("bell-slash", 60424),
      bellSlashDot: register2("bell-slash-dot", 60425),
      commentUnresolved: register2("comment-unresolved", 60426),
      gitPullRequestGoToChanges: register2("git-pull-request-go-to-changes", 60427),
      gitPullRequestNewChanges: register2("git-pull-request-new-changes", 60428),
      searchFuzzy: register2("search-fuzzy", 60429),
      commentDraft: register2("comment-draft", 60430),
      send: register2("send", 60431),
      sparkle: register2("sparkle", 60432),
      insert: register2("insert", 60433),
      mic: register2("mic", 60434),
      thumbsDownFilled: register2("thumbsdown-filled", 60435),
      thumbsUpFilled: register2("thumbsup-filled", 60436),
      coffee: register2("coffee", 60437),
      snake: register2("snake", 60438),
      game: register2("game", 60439),
      vr: register2("vr", 60440),
      chip: register2("chip", 60441),
      piano: register2("piano", 60442),
      music: register2("music", 60443),
      micFilled: register2("mic-filled", 60444),
      gitFetch: register2("git-fetch", 60445),
      copilot: register2("copilot", 60446),
      lightbulbSparkle: register2("lightbulb-sparkle", 60447),
      lightbulbSparkleAutofix: register2("lightbulb-sparkle-autofix", 60447),
      robot: register2("robot", 60448),
      sparkleFilled: register2("sparkle-filled", 60449),
      diffSingle: register2("diff-single", 60450),
      diffMultiple: register2("diff-multiple", 60451),
      surroundWith: register2("surround-with", 60452),
      gitStash: register2("git-stash", 60454),
      gitStashApply: register2("git-stash-apply", 60455),
      gitStashPop: register2("git-stash-pop", 60456),
      runAllCoverage: register2("run-all-coverage", 60461),
      runCoverage: register2("run-all-coverage", 60460),
      coverage: register2("coverage", 60462),
      githubProject: register2("github-project", 60463),
      // derived icons, that could become separate icons
      // TODO: These mappings should go in the vscode-codicons mapping file
      dialogError: register2("dialog-error", "error"),
      dialogWarning: register2("dialog-warning", "warning"),
      dialogInfo: register2("dialog-info", "info"),
      dialogClose: register2("dialog-close", "close"),
      treeItemExpanded: register2("tree-item-expanded", "chevron-down"),
      // collapsed is done with rotation
      treeFilterOnTypeOn: register2("tree-filter-on-type-on", "list-filter"),
      treeFilterOnTypeOff: register2("tree-filter-on-type-off", "list-selection"),
      treeFilterClear: register2("tree-filter-clear", "close"),
      treeItemLoading: register2("tree-item-loading", "loading"),
      menuSelection: register2("menu-selection", "check"),
      menuSubmenu: register2("menu-submenu", "chevron-right"),
      menuBarMore: register2("menubar-more", "more"),
      scrollbarButtonLeft: register2("scrollbar-button-left", "triangle-left"),
      scrollbarButtonRight: register2("scrollbar-button-right", "triangle-right"),
      scrollbarButtonUp: register2("scrollbar-button-up", "triangle-up"),
      scrollbarButtonDown: register2("scrollbar-button-down", "triangle-down"),
      toolBarMore: register2("toolbar-more", "more"),
      quickInputBack: register2("quick-input-back", "arrow-left")
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/themables.js
var ThemeColor, ThemeIcon;
var init_themables = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/themables.js"() {
    init_codicons();
    (function(ThemeColor2) {
      function isThemeColor(obj) {
        return obj && typeof obj === "object" && typeof obj.id === "string";
      }
      ThemeColor2.isThemeColor = isThemeColor;
    })(ThemeColor || (ThemeColor = {}));
    (function(ThemeIcon2) {
      ThemeIcon2.iconNameSegment = "[A-Za-z0-9]+";
      ThemeIcon2.iconNameExpression = "[A-Za-z0-9-]+";
      ThemeIcon2.iconModifierExpression = "~[A-Za-z]+";
      ThemeIcon2.iconNameCharacter = "[A-Za-z0-9~-]";
      const ThemeIconIdRegex = new RegExp(`^(${ThemeIcon2.iconNameExpression})(${ThemeIcon2.iconModifierExpression})?$`);
      function asClassNameArray(icon) {
        const match2 = ThemeIconIdRegex.exec(icon.id);
        if (!match2) {
          return asClassNameArray(Codicon.error);
        }
        const [, id, modifier] = match2;
        const classNames = ["codicon", "codicon-" + id];
        if (modifier) {
          classNames.push("codicon-modifier-" + modifier.substring(1));
        }
        return classNames;
      }
      ThemeIcon2.asClassNameArray = asClassNameArray;
      function asClassName(icon) {
        return asClassNameArray(icon).join(" ");
      }
      ThemeIcon2.asClassName = asClassName;
      function asCSSSelector(icon) {
        return "." + asClassNameArray(icon).join(".");
      }
      ThemeIcon2.asCSSSelector = asCSSSelector;
      function isThemeIcon(obj) {
        return obj && typeof obj === "object" && typeof obj.id === "string" && (typeof obj.color === "undefined" || ThemeColor.isThemeColor(obj.color));
      }
      ThemeIcon2.isThemeIcon = isThemeIcon;
      const _regexFromString = new RegExp(`^\\$\\((${ThemeIcon2.iconNameExpression}(?:${ThemeIcon2.iconModifierExpression})?)\\)$`);
      function fromString(str) {
        const match2 = _regexFromString.exec(str);
        if (!match2) {
          return void 0;
        }
        const [, name] = match2;
        return { id: name };
      }
      ThemeIcon2.fromString = fromString;
      function fromId(id) {
        return { id };
      }
      ThemeIcon2.fromId = fromId;
      function modify(icon, modifier) {
        let id = icon.id;
        const tildeIndex = id.lastIndexOf("~");
        if (tildeIndex !== -1) {
          id = id.substring(0, tildeIndex);
        }
        if (modifier) {
          id = `${id}~${modifier}`;
        }
        return { id };
      }
      ThemeIcon2.modify = modify;
      function getModifier(icon) {
        const tildeIndex = icon.id.lastIndexOf("~");
        if (tildeIndex !== -1) {
          return icon.id.substring(tildeIndex + 1);
        }
        return void 0;
      }
      ThemeIcon2.getModifier = getModifier;
      function isEqual2(ti1, ti2) {
        var _a2, _b2;
        return ti1.id === ti2.id && ((_a2 = ti1.color) === null || _a2 === void 0 ? void 0 : _a2.id) === ((_b2 = ti2.color) === null || _b2 === void 0 ? void 0 : _b2.id);
      }
      ThemeIcon2.isEqual = isEqual2;
    })(ThemeIcon || (ThemeIcon = {}));
  }
});

// node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabels.js
function renderLabelWithIcons(text) {
  const elements = new Array();
  let match2;
  let textStart = 0, textStop = 0;
  while ((match2 = labelWithIconsRegex.exec(text)) !== null) {
    textStop = match2.index || 0;
    if (textStart < textStop) {
      elements.push(text.substring(textStart, textStop));
    }
    textStart = (match2.index || 0) + match2[0].length;
    const [, escaped, codicon] = match2;
    elements.push(escaped ? `$(${codicon})` : renderIcon({ id: codicon }));
  }
  if (textStart < text.length) {
    elements.push(text.substring(textStart));
  }
  return elements;
}
function renderIcon(icon) {
  const node = $(`span`);
  node.classList.add(...ThemeIcon.asClassNameArray(icon));
  return node;
}
var labelWithIconsRegex;
var init_iconLabels = __esm({
  "node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabels.js"() {
    init_dom();
    init_themables();
    labelWithIconsRegex = new RegExp(`(\\\\)?\\$\\((${ThemeIcon.iconNameExpression}(?:${ThemeIcon.iconModifierExpression})?)\\)`, "g");
  }
});

// node_modules/monaco-editor/esm/vs/base/common/naturalLanguage/korean.js
function getKoreanAltChars(code) {
  const result = disassembleKorean(code);
  if (result && result.length > 0) {
    return new Uint32Array(result);
  }
  return void 0;
}
function disassembleKorean(code) {
  codeBufferLength = 0;
  getCodesFromArray(
    code,
    modernConsonants,
    4352
    /* HangulRangeStartCode.InitialConsonant */
  );
  if (codeBufferLength > 0) {
    return codeBuffer.subarray(0, codeBufferLength);
  }
  getCodesFromArray(
    code,
    modernVowels,
    4449
    /* HangulRangeStartCode.Vowel */
  );
  if (codeBufferLength > 0) {
    return codeBuffer.subarray(0, codeBufferLength);
  }
  getCodesFromArray(
    code,
    modernFinalConsonants,
    4520
    /* HangulRangeStartCode.FinalConsonant */
  );
  if (codeBufferLength > 0) {
    return codeBuffer.subarray(0, codeBufferLength);
  }
  getCodesFromArray(
    code,
    compatibilityJamo,
    12593
    /* HangulRangeStartCode.CompatibilityJamo */
  );
  if (codeBufferLength) {
    return codeBuffer.subarray(0, codeBufferLength);
  }
  if (code >= 44032 && code <= 55203) {
    const hangulIndex = code - 44032;
    const vowelAndFinalConsonantProduct = hangulIndex % 588;
    const initialConsonantIndex = Math.floor(hangulIndex / 588);
    const vowelIndex = Math.floor(vowelAndFinalConsonantProduct / 28);
    const finalConsonantIndex = vowelAndFinalConsonantProduct % 28 - 1;
    if (initialConsonantIndex < modernConsonants.length) {
      getCodesFromArray(initialConsonantIndex, modernConsonants, 0);
    } else if (4352 + initialConsonantIndex - 12593 < compatibilityJamo.length) {
      getCodesFromArray(
        4352 + initialConsonantIndex,
        compatibilityJamo,
        12593
        /* HangulRangeStartCode.CompatibilityJamo */
      );
    }
    if (vowelIndex < modernVowels.length) {
      getCodesFromArray(vowelIndex, modernVowels, 0);
    } else if (4449 + vowelIndex - 12593 < compatibilityJamo.length) {
      getCodesFromArray(
        4449 + vowelIndex - 12593,
        compatibilityJamo,
        12593
        /* HangulRangeStartCode.CompatibilityJamo */
      );
    }
    if (finalConsonantIndex >= 0) {
      if (finalConsonantIndex < modernFinalConsonants.length) {
        getCodesFromArray(finalConsonantIndex, modernFinalConsonants, 0);
      } else if (4520 + finalConsonantIndex - 12593 < compatibilityJamo.length) {
        getCodesFromArray(
          4520 + finalConsonantIndex - 12593,
          compatibilityJamo,
          12593
          /* HangulRangeStartCode.CompatibilityJamo */
        );
      }
    }
    if (codeBufferLength > 0) {
      return codeBuffer.subarray(0, codeBufferLength);
    }
  }
  return void 0;
}
function getCodesFromArray(code, array, arrayStartIndex) {
  if (code >= arrayStartIndex && code < arrayStartIndex + array.length) {
    addCodesToBuffer(array[code - arrayStartIndex]);
  }
}
function addCodesToBuffer(codes) {
  if (codes === 0) {
    return;
  }
  codeBuffer[codeBufferLength++] = codes & 255;
  if (codes >> 8) {
    codeBuffer[codeBufferLength++] = codes >> 8 & 255;
  }
  if (codes >> 16) {
    codeBuffer[codeBufferLength++] = codes >> 16 & 255;
  }
}
var codeBufferLength, codeBuffer, modernConsonants, modernVowels, modernFinalConsonants, compatibilityJamo;
var init_korean = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/naturalLanguage/korean.js"() {
    codeBufferLength = 0;
    codeBuffer = new Uint32Array(10);
    modernConsonants = new Uint8Array([
      114,
      // 
      82,
      // 
      115,
      // 
      101,
      // 
      69,
      // 
      102,
      // 
      97,
      // 
      113,
      // 
      81,
      // 
      116,
      // 
      84,
      // 
      100,
      // 
      119,
      // 
      87,
      // 
      99,
      // 
      122,
      // 
      120,
      // 
      118,
      // 
      103
      // 
    ]);
    modernVowels = new Uint16Array([
      107,
      //  -> 
      111,
      //  -> 
      105,
      //  -> 
      79,
      //  -> 
      106,
      //  -> 
      112,
      //  -> 
      117,
      //  -> 
      80,
      //  -> 
      104,
      //  -> 
      27496,
      //  -> 
      28520,
      //  -> 
      27752,
      //  -> 
      121,
      //  -> 
      110,
      //  -> 
      27246,
      //  -> 
      28782,
      //  -> 
      27758,
      //  -> 
      98,
      //  -> 
      109,
      //  -> 
      27757,
      //  -> 
      108
      //  -> 
    ]);
    modernFinalConsonants = new Uint16Array([
      114,
      // 
      82,
      // 
      29810,
      // 
      115,
      // 
      30579,
      // 
      26483,
      // 
      101,
      // 
      102,
      // 
      29286,
      // 
      24934,
      // 
      29030,
      // 
      29798,
      // 
      30822,
      // 
      30310,
      // 
      26470,
      // 
      97,
      // 
      113,
      // 
      29809,
      // 
      116,
      // 
      84,
      // 
      100,
      // 
      119,
      // 
      99,
      // 
      122,
      // 
      120,
      // 
      118,
      // 
      103
      // 
    ]);
    compatibilityJamo = new Uint16Array([
      114,
      // 
      82,
      // 
      29810,
      // 
      115,
      // 
      30579,
      // 
      26483,
      // 
      101,
      // 
      69,
      // 
      102,
      // 
      29286,
      // 
      24934,
      // 
      29030,
      // 
      29798,
      // 
      30822,
      // 
      30310,
      // 
      26470,
      // 
      97,
      // 
      113,
      // 
      81,
      // 
      29809,
      // 
      116,
      // 
      84,
      // 
      100,
      // 
      119,
      // 
      87,
      // 
      99,
      // 
      122,
      // 
      120,
      // 
      118,
      // 
      103,
      // 
      107,
      // 
      111,
      // 
      105,
      // 
      79,
      // 
      106,
      // 
      112,
      // 
      117,
      // 
      80,
      // 
      104,
      // 
      27496,
      // 
      28520,
      // 
      27752,
      // 
      121,
      // 
      110,
      // 
      27246,
      // 
      28782,
      // 
      27758,
      // 
      98,
      // 
      109,
      // 
      27757,
      // 
      108
      // 
      // HF: Hangul Filler (everything after this is archaic)
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
      // 
    ]);
  }
});

// node_modules/monaco-editor/esm/vs/base/common/filters.js
function or(...filter) {
  return function(word, wordToMatchAgainst) {
    for (let i = 0, len = filter.length; i < len; i++) {
      const match2 = filter[i](word, wordToMatchAgainst);
      if (match2) {
        return match2;
      }
    }
    return null;
  };
}
function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {
  if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {
    return null;
  }
  let matches;
  if (ignoreCase) {
    matches = startsWithIgnoreCase(wordToMatchAgainst, word);
  } else {
    matches = wordToMatchAgainst.indexOf(word) === 0;
  }
  if (!matches) {
    return null;
  }
  return word.length > 0 ? [{ start: 0, end: word.length }] : [];
}
function matchesContiguousSubString(word, wordToMatchAgainst) {
  const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());
  if (index === -1) {
    return null;
  }
  return [{ start: index, end: index + word.length }];
}
function matchesSubString(word, wordToMatchAgainst) {
  return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);
}
function _matchesSubString(word, wordToMatchAgainst, i, j) {
  if (i === word.length) {
    return [];
  } else if (j === wordToMatchAgainst.length) {
    return null;
  } else {
    if (word[i] === wordToMatchAgainst[j]) {
      let result = null;
      if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {
        return join({ start: j, end: j + 1 }, result);
      }
      return null;
    }
    return _matchesSubString(word, wordToMatchAgainst, i, j + 1);
  }
}
function isLower(code) {
  return 97 <= code && code <= 122;
}
function isUpper(code) {
  return 65 <= code && code <= 90;
}
function isNumber2(code) {
  return 48 <= code && code <= 57;
}
function isWhitespace(code) {
  return code === 32 || code === 9 || code === 10 || code === 13;
}
function isWordSeparator(code) {
  return isWhitespace(code) || wordSeparators.has(code);
}
function charactersMatch(codeA, codeB) {
  return codeA === codeB || isWordSeparator(codeA) && isWordSeparator(codeB);
}
function getAlternateCodes(code) {
  if (alternateCharsCache.has(code)) {
    return alternateCharsCache.get(code);
  }
  let result;
  const codes = getKoreanAltChars(code);
  if (codes) {
    result = codes;
  }
  alternateCharsCache.set(code, result);
  return result;
}
function isAlphanumeric(code) {
  return isLower(code) || isUpper(code) || isNumber2(code);
}
function join(head, tail3) {
  if (tail3.length === 0) {
    tail3 = [head];
  } else if (head.end === tail3[0].start) {
    tail3[0].start = head.start;
  } else {
    tail3.unshift(head);
  }
  return tail3;
}
function nextAnchor(camelCaseWord, start) {
  for (let i = start; i < camelCaseWord.length; i++) {
    const c = camelCaseWord.charCodeAt(i);
    if (isUpper(c) || isNumber2(c) || i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1))) {
      return i;
    }
  }
  return camelCaseWord.length;
}
function _matchesCamelCase(word, camelCaseWord, i, j) {
  if (i === word.length) {
    return [];
  } else if (j === camelCaseWord.length) {
    return null;
  } else if (word[i] !== camelCaseWord[j].toLowerCase()) {
    return null;
  } else {
    let result = null;
    let nextUpperIndex = j + 1;
    result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);
    while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {
      result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);
      nextUpperIndex++;
    }
    return result === null ? null : join({ start: j, end: j + 1 }, result);
  }
}
function analyzeCamelCaseWord(word) {
  let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;
  for (let i = 0; i < word.length; i++) {
    code = word.charCodeAt(i);
    if (isUpper(code)) {
      upper++;
    }
    if (isLower(code)) {
      lower++;
    }
    if (isAlphanumeric(code)) {
      alpha++;
    }
    if (isNumber2(code)) {
      numeric++;
    }
  }
  const upperPercent = upper / word.length;
  const lowerPercent = lower / word.length;
  const alphaPercent = alpha / word.length;
  const numericPercent = numeric / word.length;
  return { upperPercent, lowerPercent, alphaPercent, numericPercent };
}
function isUpperCaseWord(analysis) {
  const { upperPercent, lowerPercent } = analysis;
  return lowerPercent === 0 && upperPercent > 0.6;
}
function isCamelCaseWord(analysis) {
  const { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;
  return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;
}
function isCamelCasePattern(word) {
  let upper = 0, lower = 0, code = 0, whitespace = 0;
  for (let i = 0; i < word.length; i++) {
    code = word.charCodeAt(i);
    if (isUpper(code)) {
      upper++;
    }
    if (isLower(code)) {
      lower++;
    }
    if (isWhitespace(code)) {
      whitespace++;
    }
  }
  if ((upper === 0 || lower === 0) && whitespace === 0) {
    return word.length <= 30;
  } else {
    return upper <= 5;
  }
}
function matchesCamelCase(word, camelCaseWord) {
  if (!camelCaseWord) {
    return null;
  }
  camelCaseWord = camelCaseWord.trim();
  if (camelCaseWord.length === 0) {
    return null;
  }
  if (!isCamelCasePattern(word)) {
    return null;
  }
  if (camelCaseWord.length > 60) {
    camelCaseWord = camelCaseWord.substring(0, 60);
  }
  const analysis = analyzeCamelCaseWord(camelCaseWord);
  if (!isCamelCaseWord(analysis)) {
    if (!isUpperCaseWord(analysis)) {
      return null;
    }
    camelCaseWord = camelCaseWord.toLowerCase();
  }
  let result = null;
  let i = 0;
  word = word.toLowerCase();
  while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {
    i = nextAnchor(camelCaseWord, i + 1);
  }
  return result;
}
function matchesWords(word, target, contiguous = false) {
  if (!target || target.length === 0) {
    return null;
  }
  let result = null;
  let targetIndex = 0;
  word = word.toLowerCase();
  target = target.toLowerCase();
  while (targetIndex < target.length) {
    result = _matchesWords(word, target, 0, targetIndex, contiguous);
    if (result !== null) {
      break;
    }
    targetIndex = nextWord(target, targetIndex + 1);
  }
  return result;
}
function _matchesWords(word, target, wordIndex, targetIndex, contiguous) {
  let targetIndexOffset = 0;
  if (wordIndex === word.length) {
    return [];
  } else if (targetIndex === target.length) {
    return null;
  } else if (!charactersMatch(word.charCodeAt(wordIndex), target.charCodeAt(targetIndex))) {
    const altChars = getAlternateCodes(word.charCodeAt(wordIndex));
    if (!altChars) {
      return null;
    }
    for (let k = 0; k < altChars.length; k++) {
      if (!charactersMatch(altChars[k], target.charCodeAt(targetIndex + k))) {
        return null;
      }
    }
    targetIndexOffset += altChars.length - 1;
  }
  let result = null;
  let nextWordIndex = targetIndex + targetIndexOffset + 1;
  result = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);
  if (!contiguous) {
    while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {
      result = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);
      nextWordIndex++;
    }
  }
  if (!result) {
    return null;
  }
  if (word.charCodeAt(wordIndex) !== target.charCodeAt(targetIndex)) {
    const altChars = getAlternateCodes(word.charCodeAt(wordIndex));
    if (!altChars) {
      return result;
    }
    for (let k = 0; k < altChars.length; k++) {
      if (altChars[k] !== target.charCodeAt(targetIndex + k)) {
        return result;
      }
    }
  }
  return join({ start: targetIndex, end: targetIndex + targetIndexOffset + 1 }, result);
}
function nextWord(word, start) {
  for (let i = start; i < word.length; i++) {
    if (isWordSeparator(word.charCodeAt(i)) || i > 0 && isWordSeparator(word.charCodeAt(i - 1))) {
      return i;
    }
  }
  return word.length;
}
function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {
  if (typeof word !== "string" || typeof wordToMatchAgainst !== "string") {
    return null;
  }
  let regexp = fuzzyRegExpCache.get(word);
  if (!regexp) {
    regexp = new RegExp(convertSimple2RegExpPattern(word), "i");
    fuzzyRegExpCache.set(word, regexp);
  }
  const match2 = regexp.exec(wordToMatchAgainst);
  if (match2) {
    return [{ start: match2.index, end: match2.index + match2[0].length }];
  }
  return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);
}
function matchesFuzzy2(pattern, word) {
  const score3 = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });
  return score3 ? createMatches(score3) : null;
}
function anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos) {
  const max = Math.min(13, pattern.length);
  for (; patternPos < max; patternPos++) {
    const result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, { firstMatchCanBeWeak: true, boostFullMatch: true });
    if (result) {
      return result;
    }
  }
  return [0, wordPos];
}
function createMatches(score3) {
  if (typeof score3 === "undefined") {
    return [];
  }
  const res = [];
  const wordPos = score3[1];
  for (let i = score3.length - 1; i > 1; i--) {
    const pos = score3[i] + wordPos;
    const last = res[res.length - 1];
    if (last && last.end === pos) {
      last.end = pos + 1;
    } else {
      res.push({ start: pos, end: pos + 1 });
    }
  }
  return res;
}
function initTable() {
  const table = [];
  const row = [];
  for (let i = 0; i <= _maxLen; i++) {
    row[i] = 0;
  }
  for (let i = 0; i <= _maxLen; i++) {
    table.push(row.slice(0));
  }
  return table;
}
function initArr(maxLen) {
  const row = [];
  for (let i = 0; i <= maxLen; i++) {
    row[i] = 0;
  }
  return row;
}
function printTable(table, pattern, patternLen, word, wordLen) {
  function pad(s, n, pad2 = " ") {
    while (s.length < n) {
      s = pad2 + s;
    }
    return s;
  }
  let ret = ` |   |${word.split("").map((c) => pad(c, 3)).join("|")}
`;
  for (let i = 0; i <= patternLen; i++) {
    if (i === 0) {
      ret += " |";
    } else {
      ret += `${pattern[i - 1]}|`;
    }
    ret += table[i].slice(0, wordLen + 1).map((n) => pad(n.toString(), 3)).join("|") + "\n";
  }
  return ret;
}
function printTables(pattern, patternStart, word, wordStart) {
  pattern = pattern.substr(patternStart);
  word = word.substr(wordStart);
  console.log(printTable(_table, pattern, pattern.length, word, word.length));
  console.log(printTable(_arrows, pattern, pattern.length, word, word.length));
  console.log(printTable(_diag, pattern, pattern.length, word, word.length));
}
function isSeparatorAtPos(value, index) {
  if (index < 0 || index >= value.length) {
    return false;
  }
  const code = value.codePointAt(index);
  switch (code) {
    case 95:
    case 45:
    case 46:
    case 32:
    case 47:
    case 92:
    case 39:
    case 34:
    case 58:
    case 36:
    case 60:
    case 62:
    case 40:
    case 41:
    case 91:
    case 93:
    case 123:
    case 125:
      return true;
    case void 0:
      return false;
    default:
      if (isEmojiImprecise(code)) {
        return true;
      }
      return false;
  }
}
function isWhitespaceAtPos(value, index) {
  if (index < 0 || index >= value.length) {
    return false;
  }
  const code = value.charCodeAt(index);
  switch (code) {
    case 32:
    case 9:
      return true;
    default:
      return false;
  }
}
function isUpperCaseAtPos(pos, word, wordLow) {
  return word[pos] !== wordLow[pos];
}
function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {
  while (patternPos < patternLen && wordPos < wordLen) {
    if (patternLow[patternPos] === wordLow[wordPos]) {
      if (fillMinWordPosArr) {
        _minWordMatchPos[patternPos] = wordPos;
      }
      patternPos += 1;
    }
    wordPos += 1;
  }
  return patternPos === patternLen;
}
function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, options2 = FuzzyScoreOptions.default) {
  const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;
  const wordLen = word.length > _maxLen ? _maxLen : word.length;
  if (patternStart >= patternLen || wordStart >= wordLen || patternLen - patternStart > wordLen - wordStart) {
    return void 0;
  }
  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {
    return void 0;
  }
  _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);
  let row = 1;
  let column = 1;
  let patternPos = patternStart;
  let wordPos = wordStart;
  const hasStrongFirstMatch = [false];
  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {
    const minWordMatchPos = _minWordMatchPos[patternPos];
    const maxWordMatchPos = _maxWordMatchPos[patternPos];
    const nextMaxWordMatchPos = patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen;
    for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {
      let score3 = Number.MIN_SAFE_INTEGER;
      let canComeDiag = false;
      if (wordPos <= maxWordMatchPos) {
        score3 = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);
      }
      let diagScore = 0;
      if (score3 !== Number.MAX_SAFE_INTEGER) {
        canComeDiag = true;
        diagScore = score3 + _table[row - 1][column - 1];
      }
      const canComeLeft = wordPos > minWordMatchPos;
      const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0;
      const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;
      const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0;
      if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {
        _table[row][column] = leftLeftScore;
        _arrows[row][column] = 3;
        _diag[row][column] = 0;
      } else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {
        _table[row][column] = leftScore;
        _arrows[row][column] = 2;
        _diag[row][column] = 0;
      } else if (canComeDiag) {
        _table[row][column] = diagScore;
        _arrows[row][column] = 1;
        _diag[row][column] = _diag[row - 1][column - 1] + 1;
      } else {
        throw new Error(`not possible`);
      }
    }
  }
  if (_debug) {
    printTables(pattern, patternStart, word, wordStart);
  }
  if (!hasStrongFirstMatch[0] && !options2.firstMatchCanBeWeak) {
    return void 0;
  }
  row--;
  column--;
  const result = [_table[row][column], wordStart];
  let backwardsDiagLength = 0;
  let maxMatchColumn = 0;
  while (row >= 1) {
    let diagColumn = column;
    do {
      const arrow = _arrows[row][diagColumn];
      if (arrow === 3) {
        diagColumn = diagColumn - 2;
      } else if (arrow === 2) {
        diagColumn = diagColumn - 1;
      } else {
        break;
      }
    } while (diagColumn >= 1);
    if (backwardsDiagLength > 1 && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) && backwardsDiagLength + 1 > _diag[row][diagColumn]) {
      diagColumn = column;
    }
    if (diagColumn === column) {
      backwardsDiagLength++;
    } else {
      backwardsDiagLength = 1;
    }
    if (!maxMatchColumn) {
      maxMatchColumn = diagColumn;
    }
    row--;
    column = diagColumn - 1;
    result.push(column);
  }
  if (wordLen === patternLen && options2.boostFullMatch) {
    result[0] += 2;
  }
  const skippedCharsCount = maxMatchColumn - patternLen;
  result[0] -= skippedCharsCount;
  return result;
}
function _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {
  let patternPos = patternLen - 1;
  let wordPos = wordLen - 1;
  while (patternPos >= patternStart && wordPos >= wordStart) {
    if (patternLow[patternPos] === wordLow[wordPos]) {
      _maxWordMatchPos[patternPos] = wordPos;
      patternPos--;
    }
    wordPos--;
  }
}
function _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {
  if (patternLow[patternPos] !== wordLow[wordPos]) {
    return Number.MIN_SAFE_INTEGER;
  }
  let score3 = 1;
  let isGapLocation = false;
  if (wordPos === patternPos - patternStart) {
    score3 = pattern[patternPos] === word[wordPos] ? 7 : 5;
  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {
    score3 = pattern[patternPos] === word[wordPos] ? 7 : 5;
    isGapLocation = true;
  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {
    score3 = 5;
  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {
    score3 = 5;
    isGapLocation = true;
  }
  if (score3 > 1 && patternPos === patternStart) {
    outFirstMatchStrong[0] = true;
  }
  if (!isGapLocation) {
    isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);
  }
  if (patternPos === patternStart) {
    if (wordPos > wordStart) {
      score3 -= isGapLocation ? 3 : 5;
    }
  } else {
    if (newMatchStart) {
      score3 += isGapLocation ? 2 : 0;
    } else {
      score3 += isGapLocation ? 0 : 1;
    }
  }
  if (wordPos + 1 === wordLen) {
    score3 -= isGapLocation ? 3 : 5;
  }
  return score3;
}
function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, options2) {
  return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options2);
}
function fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, options2) {
  let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options2);
  if (top && !aggressive) {
    return top;
  }
  if (pattern.length >= 3) {
    const tries = Math.min(7, pattern.length - 1);
    for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {
      const newPattern = nextTypoPermutation(pattern, movingPatternPos);
      if (newPattern) {
        const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options2);
        if (candidate) {
          candidate[0] -= 3;
          if (!top || candidate[0] > top[0]) {
            top = candidate;
          }
        }
      }
    }
  }
  return top;
}
function nextTypoPermutation(pattern, patternPos) {
  if (patternPos + 1 >= pattern.length) {
    return void 0;
  }
  const swap1 = pattern[patternPos];
  const swap2 = pattern[patternPos + 1];
  if (swap1 === swap2) {
    return void 0;
  }
  return pattern.slice(0, patternPos) + swap2 + swap1 + pattern.slice(patternPos + 2);
}
var matchesStrictPrefix, matchesPrefix, wordSeparators, alternateCharsCache, fuzzyContiguousFilter, fuzzySeparateFilter, fuzzyRegExpCache, _maxLen, _minWordMatchPos, _maxWordMatchPos, _diag, _table, _arrows, _debug, FuzzyScore, FuzzyScoreOptions;
var init_filters = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/filters.js"() {
    init_map();
    init_korean();
    init_strings();
    matchesStrictPrefix = _matchesPrefix.bind(void 0, false);
    matchesPrefix = _matchesPrefix.bind(void 0, true);
    wordSeparators = /* @__PURE__ */ new Set();
    "()[]{}<>`'\"-/;:,.?!".split("").forEach((s) => wordSeparators.add(s.charCodeAt(0)));
    alternateCharsCache = /* @__PURE__ */ new Map();
    fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);
    fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);
    fuzzyRegExpCache = new LRUCache(1e4);
    _maxLen = 128;
    _minWordMatchPos = initArr(2 * _maxLen);
    _maxWordMatchPos = initArr(2 * _maxLen);
    _diag = initTable();
    _table = initTable();
    _arrows = initTable();
    _debug = false;
    (function(FuzzyScore2) {
      FuzzyScore2.Default = [-100, 0];
      function isDefault(score3) {
        return !score3 || score3.length === 2 && score3[0] === -100 && score3[1] === 0;
      }
      FuzzyScore2.isDefault = isDefault;
    })(FuzzyScore || (FuzzyScore = {}));
    FuzzyScoreOptions = class {
      constructor(firstMatchCanBeWeak, boostFullMatch) {
        this.firstMatchCanBeWeak = firstMatchCanBeWeak;
        this.boostFullMatch = boostFullMatch;
      }
    };
    FuzzyScoreOptions.default = { boostFullMatch: true, firstMatchCanBeWeak: false };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/iconLabels.js
function escapeIcons(text) {
  return text.replace(escapeIconsRegex, (match2, escaped) => escaped ? match2 : `\\${match2}`);
}
function markdownEscapeEscapedIcons(text) {
  return text.replace(markdownEscapedIconsRegex, (match2) => `\\${match2}`);
}
function stripIcons(text) {
  if (text.indexOf(iconStartMarker) === -1) {
    return text;
  }
  return text.replace(stripIconsRegex, (match2, preWhitespace, escaped, postWhitespace) => escaped ? match2 : preWhitespace || postWhitespace || "");
}
function getCodiconAriaLabel(text) {
  if (!text) {
    return "";
  }
  return text.replace(/\$\((.*?)\)/g, (_match, codiconName) => ` ${codiconName} `).trim();
}
function parseLabelWithIcons(input) {
  _parseIconsRegex.lastIndex = 0;
  let text = "";
  const iconOffsets = [];
  let iconsOffset = 0;
  while (true) {
    const pos = _parseIconsRegex.lastIndex;
    const match2 = _parseIconsRegex.exec(input);
    const chars = input.substring(pos, match2 === null || match2 === void 0 ? void 0 : match2.index);
    if (chars.length > 0) {
      text += chars;
      for (let i = 0; i < chars.length; i++) {
        iconOffsets.push(iconsOffset);
      }
    }
    if (!match2) {
      break;
    }
    iconsOffset += match2[0].length;
  }
  return { text, iconOffsets };
}
function matchesFuzzyIconAware(query, target, enableSeparateSubstringMatching = false) {
  const { text, iconOffsets } = target;
  if (!iconOffsets || iconOffsets.length === 0) {
    return matchesFuzzy(query, text, enableSeparateSubstringMatching);
  }
  const wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, " ");
  const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;
  const matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching);
  if (matches) {
    for (const match2 of matches) {
      const iconOffset = iconOffsets[match2.start + leadingWhitespaceOffset] + leadingWhitespaceOffset;
      match2.start += iconOffset;
      match2.end += iconOffset;
    }
  }
  return matches;
}
var iconStartMarker, iconsRegex, escapeIconsRegex, markdownEscapedIconsRegex, stripIconsRegex, _parseIconsRegex;
var init_iconLabels2 = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/iconLabels.js"() {
    init_filters();
    init_strings();
    init_themables();
    iconStartMarker = "$(";
    iconsRegex = new RegExp(`\\$\\(${ThemeIcon.iconNameExpression}(?:${ThemeIcon.iconModifierExpression})?\\)`, "g");
    escapeIconsRegex = new RegExp(`(\\\\)?${iconsRegex.source}`, "g");
    markdownEscapedIconsRegex = new RegExp(`\\\\${iconsRegex.source}`, "g");
    stripIconsRegex = new RegExp(`(\\s)?(\\\\)?${iconsRegex.source}(\\s)?`, "g");
    _parseIconsRegex = new RegExp(`\\$\\(${ThemeIcon.iconNameCharacter}+\\)`, "g");
  }
});

// node_modules/monaco-editor/esm/vs/base/common/resources.js
function originalFSPath(uri) {
  return uriToFsPath(uri, true);
}
var ExtUri, extUri, extUriBiasedIgnorePathCase, extUriIgnorePathCase, isEqual, isEqualOrParent2, getComparisonKey, basenameOrAuthority, basename2, extname2, dirname2, joinPath, normalizePath, relativePath, resolvePath, isAbsolutePath, isEqualAuthority, hasTrailingPathSeparator, removeTrailingPathSeparator, addTrailingPathSeparator, DataUri;
var init_resources = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/resources.js"() {
    init_extpath();
    init_network();
    init_path();
    init_platform();
    init_strings();
    init_uri();
    ExtUri = class {
      constructor(_ignorePathCasing) {
        this._ignorePathCasing = _ignorePathCasing;
      }
      compare(uri1, uri2, ignoreFragment = false) {
        if (uri1 === uri2) {
          return 0;
        }
        return compare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));
      }
      isEqual(uri1, uri2, ignoreFragment = false) {
        if (uri1 === uri2) {
          return true;
        }
        if (!uri1 || !uri2) {
          return false;
        }
        return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);
      }
      getComparisonKey(uri, ignoreFragment = false) {
        return uri.with({
          path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : void 0,
          fragment: ignoreFragment ? null : void 0
        }).toString();
      }
      isEqualOrParent(base, parentCandidate, ignoreFragment = false) {
        if (base.scheme === parentCandidate.scheme) {
          if (base.scheme === Schemas.file) {
            return isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);
          }
          if (isEqualAuthority(base.authority, parentCandidate.authority)) {
            return isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), "/") && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);
          }
        }
        return false;
      }
      // --- path math
      joinPath(resource, ...pathFragment) {
        return URI.joinPath(resource, ...pathFragment);
      }
      basenameOrAuthority(resource) {
        return basename2(resource) || resource.authority;
      }
      basename(resource) {
        return posix.basename(resource.path);
      }
      extname(resource) {
        return posix.extname(resource.path);
      }
      dirname(resource) {
        if (resource.path.length === 0) {
          return resource;
        }
        let dirname3;
        if (resource.scheme === Schemas.file) {
          dirname3 = URI.file(dirname(originalFSPath(resource))).path;
        } else {
          dirname3 = posix.dirname(resource.path);
          if (resource.authority && dirname3.length && dirname3.charCodeAt(0) !== 47) {
            console.error(`dirname("${resource.toString})) resulted in a relative path`);
            dirname3 = "/";
          }
        }
        return resource.with({
          path: dirname3
        });
      }
      normalizePath(resource) {
        if (!resource.path.length) {
          return resource;
        }
        let normalizedPath;
        if (resource.scheme === Schemas.file) {
          normalizedPath = URI.file(normalize(originalFSPath(resource))).path;
        } else {
          normalizedPath = posix.normalize(resource.path);
        }
        return resource.with({
          path: normalizedPath
        });
      }
      relativePath(from, to) {
        if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {
          return void 0;
        }
        if (from.scheme === Schemas.file) {
          const relativePath2 = relative(originalFSPath(from), originalFSPath(to));
          return isWindows ? toSlashes(relativePath2) : relativePath2;
        }
        let fromPath = from.path || "/";
        const toPath = to.path || "/";
        if (this._ignorePathCasing(from)) {
          let i = 0;
          for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {
            if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {
              if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {
                break;
              }
            }
          }
          fromPath = toPath.substr(0, i) + fromPath.substr(i);
        }
        return posix.relative(fromPath, toPath);
      }
      resolvePath(base, path) {
        if (base.scheme === Schemas.file) {
          const newURI = URI.file(resolve(originalFSPath(base), path));
          return base.with({
            authority: newURI.authority,
            path: newURI.path
          });
        }
        path = toPosixPath(path);
        return base.with({
          path: posix.resolve(base.path, path)
        });
      }
      // --- misc
      isAbsolutePath(resource) {
        return !!resource.path && resource.path[0] === "/";
      }
      isEqualAuthority(a1, a2) {
        return a1 === a2 || a1 !== void 0 && a2 !== void 0 && equalsIgnoreCase(a1, a2);
      }
      hasTrailingPathSeparator(resource, sep2 = sep) {
        if (resource.scheme === Schemas.file) {
          const fsp = originalFSPath(resource);
          return fsp.length > getRoot(fsp).length && fsp[fsp.length - 1] === sep2;
        } else {
          const p = resource.path;
          return p.length > 1 && p.charCodeAt(p.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(resource.fsPath);
        }
      }
      removeTrailingPathSeparator(resource, sep2 = sep) {
        if (hasTrailingPathSeparator(resource, sep2)) {
          return resource.with({ path: resource.path.substr(0, resource.path.length - 1) });
        }
        return resource;
      }
      addTrailingPathSeparator(resource, sep2 = sep) {
        let isRootSep = false;
        if (resource.scheme === Schemas.file) {
          const fsp = originalFSPath(resource);
          isRootSep = fsp !== void 0 && fsp.length === getRoot(fsp).length && fsp[fsp.length - 1] === sep2;
        } else {
          sep2 = "/";
          const p = resource.path;
          isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47;
        }
        if (!isRootSep && !hasTrailingPathSeparator(resource, sep2)) {
          return resource.with({ path: resource.path + "/" });
        }
        return resource;
      }
    };
    extUri = new ExtUri(() => false);
    extUriBiasedIgnorePathCase = new ExtUri((uri) => {
      return uri.scheme === Schemas.file ? !isLinux : true;
    });
    extUriIgnorePathCase = new ExtUri((_) => true);
    isEqual = extUri.isEqual.bind(extUri);
    isEqualOrParent2 = extUri.isEqualOrParent.bind(extUri);
    getComparisonKey = extUri.getComparisonKey.bind(extUri);
    basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);
    basename2 = extUri.basename.bind(extUri);
    extname2 = extUri.extname.bind(extUri);
    dirname2 = extUri.dirname.bind(extUri);
    joinPath = extUri.joinPath.bind(extUri);
    normalizePath = extUri.normalizePath.bind(extUri);
    relativePath = extUri.relativePath.bind(extUri);
    resolvePath = extUri.resolvePath.bind(extUri);
    isAbsolutePath = extUri.isAbsolutePath.bind(extUri);
    isEqualAuthority = extUri.isEqualAuthority.bind(extUri);
    hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);
    removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);
    addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);
    (function(DataUri2) {
      DataUri2.META_DATA_LABEL = "label";
      DataUri2.META_DATA_DESCRIPTION = "description";
      DataUri2.META_DATA_SIZE = "size";
      DataUri2.META_DATA_MIME = "mime";
      function parseMetaData(dataUri) {
        const metadata = /* @__PURE__ */ new Map();
        const meta = dataUri.path.substring(dataUri.path.indexOf(";") + 1, dataUri.path.lastIndexOf(";"));
        meta.split(";").forEach((property) => {
          const [key, value] = property.split(":");
          if (key && value) {
            metadata.set(key, value);
          }
        });
        const mime = dataUri.path.substring(0, dataUri.path.indexOf(";"));
        if (mime) {
          metadata.set(DataUri2.META_DATA_MIME, mime);
        }
        return metadata;
      }
      DataUri2.parseMetaData = parseMetaData;
    })(DataUri || (DataUri = {}));
  }
});

// node_modules/monaco-editor/esm/vs/base/common/htmlContent.js
function isEmptyMarkdownString(oneOrMany) {
  if (isMarkdownString(oneOrMany)) {
    return !oneOrMany.value;
  } else if (Array.isArray(oneOrMany)) {
    return oneOrMany.every(isEmptyMarkdownString);
  } else {
    return true;
  }
}
function isMarkdownString(thing) {
  if (thing instanceof MarkdownString) {
    return true;
  } else if (thing && typeof thing === "object") {
    return typeof thing.value === "string" && (typeof thing.isTrusted === "boolean" || typeof thing.isTrusted === "object" || thing.isTrusted === void 0) && (typeof thing.supportThemeIcons === "boolean" || thing.supportThemeIcons === void 0);
  }
  return false;
}
function markdownStringEqual(a, b) {
  if (a === b) {
    return true;
  } else if (!a || !b) {
    return false;
  } else {
    return a.value === b.value && a.isTrusted === b.isTrusted && a.supportThemeIcons === b.supportThemeIcons && a.supportHtml === b.supportHtml && (a.baseUri === b.baseUri || !!a.baseUri && !!b.baseUri && isEqual(URI.from(a.baseUri), URI.from(b.baseUri)));
  }
}
function escapeMarkdownSyntaxTokens(text) {
  return text.replace(/[\\`*_{}[\]()#+\-!~]/g, "\\$&");
}
function appendEscapedMarkdownCodeBlockFence(code, langId) {
  var _a2, _b2;
  const longestFenceLength = (_b2 = (_a2 = code.match(/^`+/gm)) === null || _a2 === void 0 ? void 0 : _a2.reduce((a, b) => a.length > b.length ? a : b).length) !== null && _b2 !== void 0 ? _b2 : 0;
  const desiredFenceLength = longestFenceLength >= 3 ? longestFenceLength + 1 : 3;
  return [
    `${"`".repeat(desiredFenceLength)}${langId}`,
    code,
    `${"`".repeat(desiredFenceLength)}`
  ].join("\n");
}
function escapeDoubleQuotes(input) {
  return input.replace(/"/g, "&quot;");
}
function removeMarkdownEscapes(text) {
  if (!text) {
    return text;
  }
  return text.replace(/\\([\\`*_{}[\]()#+\-.!~])/g, "$1");
}
function parseHrefAndDimensions(href) {
  const dimensions = [];
  const splitted = href.split("|").map((s) => s.trim());
  href = splitted[0];
  const parameters = splitted[1];
  if (parameters) {
    const heightFromParams = /height=(\d+)/.exec(parameters);
    const widthFromParams = /width=(\d+)/.exec(parameters);
    const height = heightFromParams ? heightFromParams[1] : "";
    const width = widthFromParams ? widthFromParams[1] : "";
    const widthIsFinite = isFinite(parseInt(width));
    const heightIsFinite = isFinite(parseInt(height));
    if (widthIsFinite) {
      dimensions.push(`width="${width}"`);
    }
    if (heightIsFinite) {
      dimensions.push(`height="${height}"`);
    }
  }
  return { href, dimensions };
}
var MarkdownString;
var init_htmlContent = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/htmlContent.js"() {
    init_errors();
    init_iconLabels2();
    init_resources();
    init_strings();
    init_uri();
    MarkdownString = class {
      constructor(value = "", isTrustedOrOptions = false) {
        var _a2, _b2, _c;
        this.value = value;
        if (typeof this.value !== "string") {
          throw illegalArgument("value");
        }
        if (typeof isTrustedOrOptions === "boolean") {
          this.isTrusted = isTrustedOrOptions;
          this.supportThemeIcons = false;
          this.supportHtml = false;
        } else {
          this.isTrusted = (_a2 = isTrustedOrOptions.isTrusted) !== null && _a2 !== void 0 ? _a2 : void 0;
          this.supportThemeIcons = (_b2 = isTrustedOrOptions.supportThemeIcons) !== null && _b2 !== void 0 ? _b2 : false;
          this.supportHtml = (_c = isTrustedOrOptions.supportHtml) !== null && _c !== void 0 ? _c : false;
        }
      }
      appendText(value, newlineStyle = 0) {
        this.value += escapeMarkdownSyntaxTokens(this.supportThemeIcons ? escapeIcons(value) : value).replace(/([ \t]+)/g, (_match, g1) => "&nbsp;".repeat(g1.length)).replace(/\>/gm, "\\>").replace(/\n/g, newlineStyle === 1 ? "\\\n" : "\n\n");
        return this;
      }
      appendMarkdown(value) {
        this.value += value;
        return this;
      }
      appendCodeblock(langId, code) {
        this.value += `
${appendEscapedMarkdownCodeBlockFence(code, langId)}
`;
        return this;
      }
      appendLink(target, label, title) {
        this.value += "[";
        this.value += this._escape(label, "]");
        this.value += "](";
        this.value += this._escape(String(target), ")");
        if (title) {
          this.value += ` "${this._escape(this._escape(title, '"'), ")")}"`;
        }
        this.value += ")";
        return this;
      }
      _escape(value, ch) {
        const r = new RegExp(escapeRegExpCharacters(ch), "g");
        return value.replace(r, (match2, offset) => {
          if (value.charAt(offset - 1) !== "\\") {
            return `\\${match2}`;
          } else {
            return match2;
          }
        });
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js
var LineTokens, SliceLineTokens;
var init_lineTokens = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js"() {
    init_encodedTokenAttributes();
    LineTokens = class _LineTokens {
      static createEmpty(lineContent, decoder) {
        const defaultMetadata = _LineTokens.defaultTokenMetadata;
        const tokens = new Uint32Array(2);
        tokens[0] = lineContent.length;
        tokens[1] = defaultMetadata;
        return new _LineTokens(tokens, lineContent, decoder);
      }
      constructor(tokens, text, decoder) {
        this._lineTokensBrand = void 0;
        this._tokens = tokens;
        this._tokensCount = this._tokens.length >>> 1;
        this._text = text;
        this._languageIdCodec = decoder;
      }
      equals(other) {
        if (other instanceof _LineTokens) {
          return this.slicedEquals(other, 0, this._tokensCount);
        }
        return false;
      }
      slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {
        if (this._text !== other._text) {
          return false;
        }
        if (this._tokensCount !== other._tokensCount) {
          return false;
        }
        const from = sliceFromTokenIndex << 1;
        const to = from + (sliceTokenCount << 1);
        for (let i = from; i < to; i++) {
          if (this._tokens[i] !== other._tokens[i]) {
            return false;
          }
        }
        return true;
      }
      getLineContent() {
        return this._text;
      }
      getCount() {
        return this._tokensCount;
      }
      getStartOffset(tokenIndex) {
        if (tokenIndex > 0) {
          return this._tokens[tokenIndex - 1 << 1];
        }
        return 0;
      }
      getMetadata(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return metadata;
      }
      getLanguageId(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        const languageId = TokenMetadata.getLanguageId(metadata);
        return this._languageIdCodec.decodeLanguageId(languageId);
      }
      getStandardTokenType(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return TokenMetadata.getTokenType(metadata);
      }
      getForeground(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return TokenMetadata.getForeground(metadata);
      }
      getClassName(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return TokenMetadata.getClassNameFromMetadata(metadata);
      }
      getInlineStyle(tokenIndex, colorMap) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);
      }
      getPresentation(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return TokenMetadata.getPresentationFromMetadata(metadata);
      }
      getEndOffset(tokenIndex) {
        return this._tokens[tokenIndex << 1];
      }
      /**
       * Find the token containing offset `offset`.
       * @param offset The search offset
       * @return The index of the token containing the offset.
       */
      findTokenIndexAtOffset(offset) {
        return _LineTokens.findIndexInTokensArray(this._tokens, offset);
      }
      inflate() {
        return this;
      }
      sliceAndInflate(startOffset, endOffset, deltaOffset) {
        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);
      }
      static convertToEndOffset(tokens, lineTextLength) {
        const tokenCount = tokens.length >>> 1;
        const lastTokenIndex = tokenCount - 1;
        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {
          tokens[tokenIndex << 1] = tokens[tokenIndex + 1 << 1];
        }
        tokens[lastTokenIndex << 1] = lineTextLength;
      }
      static findIndexInTokensArray(tokens, desiredIndex) {
        if (tokens.length <= 2) {
          return 0;
        }
        let low = 0;
        let high = (tokens.length >>> 1) - 1;
        while (low < high) {
          const mid = low + Math.floor((high - low) / 2);
          const endOffset = tokens[mid << 1];
          if (endOffset === desiredIndex) {
            return mid + 1;
          } else if (endOffset < desiredIndex) {
            low = mid + 1;
          } else if (endOffset > desiredIndex) {
            high = mid;
          }
        }
        return low;
      }
      /**
       * @pure
       * @param insertTokens Must be sorted by offset.
      */
      withInserted(insertTokens) {
        if (insertTokens.length === 0) {
          return this;
        }
        let nextOriginalTokenIdx = 0;
        let nextInsertTokenIdx = 0;
        let text = "";
        const newTokens = new Array();
        let originalEndOffset = 0;
        while (true) {
          const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;
          const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;
          if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {
            text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);
            const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];
            newTokens.push(text.length, metadata);
            nextOriginalTokenIdx++;
            originalEndOffset = nextOriginalTokenEndOffset;
          } else if (nextInsertToken) {
            if (nextInsertToken.offset > originalEndOffset) {
              text += this._text.substring(originalEndOffset, nextInsertToken.offset);
              const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];
              newTokens.push(text.length, metadata);
              originalEndOffset = nextInsertToken.offset;
            }
            text += nextInsertToken.text;
            newTokens.push(text.length, nextInsertToken.tokenMetadata);
            nextInsertTokenIdx++;
          } else {
            break;
          }
        }
        return new _LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);
      }
    };
    LineTokens.defaultTokenMetadata = (0 << 11 | 1 << 15 | 2 << 24) >>> 0;
    SliceLineTokens = class _SliceLineTokens {
      constructor(source, startOffset, endOffset, deltaOffset) {
        this._source = source;
        this._startOffset = startOffset;
        this._endOffset = endOffset;
        this._deltaOffset = deltaOffset;
        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);
        this._tokensCount = 0;
        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {
          const tokenStartOffset = source.getStartOffset(i);
          if (tokenStartOffset >= endOffset) {
            break;
          }
          this._tokensCount++;
        }
      }
      getMetadata(tokenIndex) {
        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);
      }
      getLanguageId(tokenIndex) {
        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);
      }
      getLineContent() {
        return this._source.getLineContent().substring(this._startOffset, this._endOffset);
      }
      equals(other) {
        if (other instanceof _SliceLineTokens) {
          return this._startOffset === other._startOffset && this._endOffset === other._endOffset && this._deltaOffset === other._deltaOffset && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount);
        }
        return false;
      }
      getCount() {
        return this._tokensCount;
      }
      getForeground(tokenIndex) {
        return this._source.getForeground(this._firstTokenIndex + tokenIndex);
      }
      getEndOffset(tokenIndex) {
        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);
        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;
      }
      getClassName(tokenIndex) {
        return this._source.getClassName(this._firstTokenIndex + tokenIndex);
      }
      getInlineStyle(tokenIndex, colorMap) {
        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);
      }
      getPresentation(tokenIndex) {
        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);
      }
      findTokenIndexAtOffset(offset) {
        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js
var TokenizationRegistry, TokenizationSupportFactoryData;
var init_tokenizationRegistry = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js"() {
    init_event();
    init_lifecycle();
    TokenizationRegistry = class {
      constructor() {
        this._tokenizationSupports = /* @__PURE__ */ new Map();
        this._factories = /* @__PURE__ */ new Map();
        this._onDidChange = new Emitter();
        this.onDidChange = this._onDidChange.event;
        this._colorMap = null;
      }
      handleChange(languageIds) {
        this._onDidChange.fire({
          changedLanguages: languageIds,
          changedColorMap: false
        });
      }
      register(languageId, support) {
        this._tokenizationSupports.set(languageId, support);
        this.handleChange([languageId]);
        return toDisposable(() => {
          if (this._tokenizationSupports.get(languageId) !== support) {
            return;
          }
          this._tokenizationSupports.delete(languageId);
          this.handleChange([languageId]);
        });
      }
      get(languageId) {
        return this._tokenizationSupports.get(languageId) || null;
      }
      registerFactory(languageId, factory) {
        var _a2;
        (_a2 = this._factories.get(languageId)) === null || _a2 === void 0 ? void 0 : _a2.dispose();
        const myData = new TokenizationSupportFactoryData(this, languageId, factory);
        this._factories.set(languageId, myData);
        return toDisposable(() => {
          const v = this._factories.get(languageId);
          if (!v || v !== myData) {
            return;
          }
          this._factories.delete(languageId);
          v.dispose();
        });
      }
      async getOrCreate(languageId) {
        const tokenizationSupport = this.get(languageId);
        if (tokenizationSupport) {
          return tokenizationSupport;
        }
        const factory = this._factories.get(languageId);
        if (!factory || factory.isResolved) {
          return null;
        }
        await factory.resolve();
        return this.get(languageId);
      }
      isResolved(languageId) {
        const tokenizationSupport = this.get(languageId);
        if (tokenizationSupport) {
          return true;
        }
        const factory = this._factories.get(languageId);
        if (!factory || factory.isResolved) {
          return true;
        }
        return false;
      }
      setColorMap(colorMap) {
        this._colorMap = colorMap;
        this._onDidChange.fire({
          changedLanguages: Array.from(this._tokenizationSupports.keys()),
          changedColorMap: true
        });
      }
      getColorMap() {
        return this._colorMap;
      }
      getDefaultBackground() {
        if (this._colorMap && this._colorMap.length > 2) {
          return this._colorMap[
            2
            /* ColorId.DefaultBackground */
          ];
        }
        return null;
      }
    };
    TokenizationSupportFactoryData = class extends Disposable {
      get isResolved() {
        return this._isResolved;
      }
      constructor(_registry2, _languageId, _factory) {
        super();
        this._registry = _registry2;
        this._languageId = _languageId;
        this._factory = _factory;
        this._isDisposed = false;
        this._resolvePromise = null;
        this._isResolved = false;
      }
      dispose() {
        this._isDisposed = true;
        super.dispose();
      }
      async resolve() {
        if (!this._resolvePromise) {
          this._resolvePromise = this._create();
        }
        return this._resolvePromise;
      }
      async _create() {
        const value = await this._factory.tokenizationSupport;
        this._isResolved = true;
        if (value && !this._isDisposed) {
          this._register(this._registry.register(this._languageId, value));
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/languages.js
function isLocationLink(thing) {
  return thing && URI.isUri(thing.uri) && Range2.isIRange(thing.range) && (Range2.isIRange(thing.originSelectionRange) || Range2.isIRange(thing.targetSelectionRange));
}
function getAriaLabelForSymbol(symbolName, kind) {
  return localize("symbolAriaLabel", "{0} ({1})", symbolName, symbolKindNames[kind]);
}
var Token, TokenizationResult, EncodedTokenizationResult, CompletionItemKinds, InlineCompletionTriggerKind, SelectedSuggestionInfo, SignatureHelpTriggerKind, DocumentHighlightKind, symbolKindNames, SymbolKinds, FoldingRangeKind, NewSymbolNameTag, Command, InlayHintKind, LazyTokenizationSupport, TokenizationRegistry2, InlineEditTriggerKind;
var init_languages = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/languages.js"() {
    init_codicons();
    init_uri();
    init_range();
    init_tokenizationRegistry();
    init_nls();
    Token = class {
      constructor(offset, type, language) {
        this.offset = offset;
        this.type = type;
        this.language = language;
        this._tokenBrand = void 0;
      }
      toString() {
        return "(" + this.offset + ", " + this.type + ")";
      }
    };
    TokenizationResult = class {
      constructor(tokens, endState) {
        this.tokens = tokens;
        this.endState = endState;
        this._tokenizationResultBrand = void 0;
      }
    };
    EncodedTokenizationResult = class {
      constructor(tokens, endState) {
        this.tokens = tokens;
        this.endState = endState;
        this._encodedTokenizationResultBrand = void 0;
      }
    };
    (function(CompletionItemKinds2) {
      const byKind = /* @__PURE__ */ new Map();
      byKind.set(0, Codicon.symbolMethod);
      byKind.set(1, Codicon.symbolFunction);
      byKind.set(2, Codicon.symbolConstructor);
      byKind.set(3, Codicon.symbolField);
      byKind.set(4, Codicon.symbolVariable);
      byKind.set(5, Codicon.symbolClass);
      byKind.set(6, Codicon.symbolStruct);
      byKind.set(7, Codicon.symbolInterface);
      byKind.set(8, Codicon.symbolModule);
      byKind.set(9, Codicon.symbolProperty);
      byKind.set(10, Codicon.symbolEvent);
      byKind.set(11, Codicon.symbolOperator);
      byKind.set(12, Codicon.symbolUnit);
      byKind.set(13, Codicon.symbolValue);
      byKind.set(15, Codicon.symbolEnum);
      byKind.set(14, Codicon.symbolConstant);
      byKind.set(15, Codicon.symbolEnum);
      byKind.set(16, Codicon.symbolEnumMember);
      byKind.set(17, Codicon.symbolKeyword);
      byKind.set(27, Codicon.symbolSnippet);
      byKind.set(18, Codicon.symbolText);
      byKind.set(19, Codicon.symbolColor);
      byKind.set(20, Codicon.symbolFile);
      byKind.set(21, Codicon.symbolReference);
      byKind.set(22, Codicon.symbolCustomColor);
      byKind.set(23, Codicon.symbolFolder);
      byKind.set(24, Codicon.symbolTypeParameter);
      byKind.set(25, Codicon.account);
      byKind.set(26, Codicon.issues);
      function toIcon(kind) {
        let codicon = byKind.get(kind);
        if (!codicon) {
          console.info("No codicon found for CompletionItemKind " + kind);
          codicon = Codicon.symbolProperty;
        }
        return codicon;
      }
      CompletionItemKinds2.toIcon = toIcon;
      const data = /* @__PURE__ */ new Map();
      data.set(
        "method",
        0
        /* CompletionItemKind.Method */
      );
      data.set(
        "function",
        1
        /* CompletionItemKind.Function */
      );
      data.set(
        "constructor",
        2
        /* CompletionItemKind.Constructor */
      );
      data.set(
        "field",
        3
        /* CompletionItemKind.Field */
      );
      data.set(
        "variable",
        4
        /* CompletionItemKind.Variable */
      );
      data.set(
        "class",
        5
        /* CompletionItemKind.Class */
      );
      data.set(
        "struct",
        6
        /* CompletionItemKind.Struct */
      );
      data.set(
        "interface",
        7
        /* CompletionItemKind.Interface */
      );
      data.set(
        "module",
        8
        /* CompletionItemKind.Module */
      );
      data.set(
        "property",
        9
        /* CompletionItemKind.Property */
      );
      data.set(
        "event",
        10
        /* CompletionItemKind.Event */
      );
      data.set(
        "operator",
        11
        /* CompletionItemKind.Operator */
      );
      data.set(
        "unit",
        12
        /* CompletionItemKind.Unit */
      );
      data.set(
        "value",
        13
        /* CompletionItemKind.Value */
      );
      data.set(
        "constant",
        14
        /* CompletionItemKind.Constant */
      );
      data.set(
        "enum",
        15
        /* CompletionItemKind.Enum */
      );
      data.set(
        "enum-member",
        16
        /* CompletionItemKind.EnumMember */
      );
      data.set(
        "enumMember",
        16
        /* CompletionItemKind.EnumMember */
      );
      data.set(
        "keyword",
        17
        /* CompletionItemKind.Keyword */
      );
      data.set(
        "snippet",
        27
        /* CompletionItemKind.Snippet */
      );
      data.set(
        "text",
        18
        /* CompletionItemKind.Text */
      );
      data.set(
        "color",
        19
        /* CompletionItemKind.Color */
      );
      data.set(
        "file",
        20
        /* CompletionItemKind.File */
      );
      data.set(
        "reference",
        21
        /* CompletionItemKind.Reference */
      );
      data.set(
        "customcolor",
        22
        /* CompletionItemKind.Customcolor */
      );
      data.set(
        "folder",
        23
        /* CompletionItemKind.Folder */
      );
      data.set(
        "type-parameter",
        24
        /* CompletionItemKind.TypeParameter */
      );
      data.set(
        "typeParameter",
        24
        /* CompletionItemKind.TypeParameter */
      );
      data.set(
        "account",
        25
        /* CompletionItemKind.User */
      );
      data.set(
        "issue",
        26
        /* CompletionItemKind.Issue */
      );
      function fromString(value, strict) {
        let res = data.get(value);
        if (typeof res === "undefined" && !strict) {
          res = 9;
        }
        return res;
      }
      CompletionItemKinds2.fromString = fromString;
    })(CompletionItemKinds || (CompletionItemKinds = {}));
    (function(InlineCompletionTriggerKind3) {
      InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 0] = "Automatic";
      InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Explicit"] = 1] = "Explicit";
    })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
    SelectedSuggestionInfo = class {
      constructor(range2, text, completionKind, isSnippetText) {
        this.range = range2;
        this.text = text;
        this.completionKind = completionKind;
        this.isSnippetText = isSnippetText;
      }
      equals(other) {
        return Range2.lift(this.range).equalsRange(other.range) && this.text === other.text && this.completionKind === other.completionKind && this.isSnippetText === other.isSnippetText;
      }
    };
    (function(SignatureHelpTriggerKind3) {
      SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
      SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
      SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
    })(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
    (function(DocumentHighlightKind3) {
      DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
      DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
      DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
    })(DocumentHighlightKind || (DocumentHighlightKind = {}));
    symbolKindNames = {
      [
        17
        /* SymbolKind.Array */
      ]: localize("Array", "array"),
      [
        16
        /* SymbolKind.Boolean */
      ]: localize("Boolean", "boolean"),
      [
        4
        /* SymbolKind.Class */
      ]: localize("Class", "class"),
      [
        13
        /* SymbolKind.Constant */
      ]: localize("Constant", "constant"),
      [
        8
        /* SymbolKind.Constructor */
      ]: localize("Constructor", "constructor"),
      [
        9
        /* SymbolKind.Enum */
      ]: localize("Enum", "enumeration"),
      [
        21
        /* SymbolKind.EnumMember */
      ]: localize("EnumMember", "enumeration member"),
      [
        23
        /* SymbolKind.Event */
      ]: localize("Event", "event"),
      [
        7
        /* SymbolKind.Field */
      ]: localize("Field", "field"),
      [
        0
        /* SymbolKind.File */
      ]: localize("File", "file"),
      [
        11
        /* SymbolKind.Function */
      ]: localize("Function", "function"),
      [
        10
        /* SymbolKind.Interface */
      ]: localize("Interface", "interface"),
      [
        19
        /* SymbolKind.Key */
      ]: localize("Key", "key"),
      [
        5
        /* SymbolKind.Method */
      ]: localize("Method", "method"),
      [
        1
        /* SymbolKind.Module */
      ]: localize("Module", "module"),
      [
        2
        /* SymbolKind.Namespace */
      ]: localize("Namespace", "namespace"),
      [
        20
        /* SymbolKind.Null */
      ]: localize("Null", "null"),
      [
        15
        /* SymbolKind.Number */
      ]: localize("Number", "number"),
      [
        18
        /* SymbolKind.Object */
      ]: localize("Object", "object"),
      [
        24
        /* SymbolKind.Operator */
      ]: localize("Operator", "operator"),
      [
        3
        /* SymbolKind.Package */
      ]: localize("Package", "package"),
      [
        6
        /* SymbolKind.Property */
      ]: localize("Property", "property"),
      [
        14
        /* SymbolKind.String */
      ]: localize("String", "string"),
      [
        22
        /* SymbolKind.Struct */
      ]: localize("Struct", "struct"),
      [
        25
        /* SymbolKind.TypeParameter */
      ]: localize("TypeParameter", "type parameter"),
      [
        12
        /* SymbolKind.Variable */
      ]: localize("Variable", "variable")
    };
    (function(SymbolKinds2) {
      const byKind = /* @__PURE__ */ new Map();
      byKind.set(0, Codicon.symbolFile);
      byKind.set(1, Codicon.symbolModule);
      byKind.set(2, Codicon.symbolNamespace);
      byKind.set(3, Codicon.symbolPackage);
      byKind.set(4, Codicon.symbolClass);
      byKind.set(5, Codicon.symbolMethod);
      byKind.set(6, Codicon.symbolProperty);
      byKind.set(7, Codicon.symbolField);
      byKind.set(8, Codicon.symbolConstructor);
      byKind.set(9, Codicon.symbolEnum);
      byKind.set(10, Codicon.symbolInterface);
      byKind.set(11, Codicon.symbolFunction);
      byKind.set(12, Codicon.symbolVariable);
      byKind.set(13, Codicon.symbolConstant);
      byKind.set(14, Codicon.symbolString);
      byKind.set(15, Codicon.symbolNumber);
      byKind.set(16, Codicon.symbolBoolean);
      byKind.set(17, Codicon.symbolArray);
      byKind.set(18, Codicon.symbolObject);
      byKind.set(19, Codicon.symbolKey);
      byKind.set(20, Codicon.symbolNull);
      byKind.set(21, Codicon.symbolEnumMember);
      byKind.set(22, Codicon.symbolStruct);
      byKind.set(23, Codicon.symbolEvent);
      byKind.set(24, Codicon.symbolOperator);
      byKind.set(25, Codicon.symbolTypeParameter);
      function toIcon(kind) {
        let icon = byKind.get(kind);
        if (!icon) {
          console.info("No codicon found for SymbolKind " + kind);
          icon = Codicon.symbolProperty;
        }
        return icon;
      }
      SymbolKinds2.toIcon = toIcon;
    })(SymbolKinds || (SymbolKinds = {}));
    FoldingRangeKind = class _FoldingRangeKind {
      /**
       * Returns a {@link FoldingRangeKind} for the given value.
       *
       * @param value of the kind.
       */
      static fromValue(value) {
        switch (value) {
          case "comment":
            return _FoldingRangeKind.Comment;
          case "imports":
            return _FoldingRangeKind.Imports;
          case "region":
            return _FoldingRangeKind.Region;
        }
        return new _FoldingRangeKind(value);
      }
      /**
       * Creates a new {@link FoldingRangeKind}.
       *
       * @param value of the kind.
       */
      constructor(value) {
        this.value = value;
      }
    };
    FoldingRangeKind.Comment = new FoldingRangeKind("comment");
    FoldingRangeKind.Imports = new FoldingRangeKind("imports");
    FoldingRangeKind.Region = new FoldingRangeKind("region");
    (function(NewSymbolNameTag3) {
      NewSymbolNameTag3[NewSymbolNameTag3["AIGenerated"] = 1] = "AIGenerated";
    })(NewSymbolNameTag || (NewSymbolNameTag = {}));
    (function(Command3) {
      function is(obj) {
        if (!obj || typeof obj !== "object") {
          return false;
        }
        return typeof obj.id === "string" && typeof obj.title === "string";
      }
      Command3.is = is;
    })(Command || (Command = {}));
    (function(InlayHintKind3) {
      InlayHintKind3[InlayHintKind3["Type"] = 1] = "Type";
      InlayHintKind3[InlayHintKind3["Parameter"] = 2] = "Parameter";
    })(InlayHintKind || (InlayHintKind = {}));
    LazyTokenizationSupport = class {
      constructor(createSupport) {
        this.createSupport = createSupport;
        this._tokenizationSupport = null;
      }
      dispose() {
        if (this._tokenizationSupport) {
          this._tokenizationSupport.then((support) => {
            if (support) {
              support.dispose();
            }
          });
        }
      }
      get tokenizationSupport() {
        if (!this._tokenizationSupport) {
          this._tokenizationSupport = this.createSupport();
        }
        return this._tokenizationSupport;
      }
    };
    TokenizationRegistry2 = new TokenizationRegistry();
    (function(InlineEditTriggerKind3) {
      InlineEditTriggerKind3[InlineEditTriggerKind3["Invoke"] = 0] = "Invoke";
      InlineEditTriggerKind3[InlineEditTriggerKind3["Automatic"] = 1] = "Automatic";
    })(InlineEditTriggerKind || (InlineEditTriggerKind = {}));
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js
function nullTokenize(languageId, state) {
  return new TokenizationResult([new Token(0, "", languageId)], state);
}
function nullTokenizeEncoded(languageId, state) {
  const tokens = new Uint32Array(2);
  tokens[0] = 0;
  tokens[1] = (languageId << 0 | 0 << 8 | 0 << 11 | 1 << 15 | 2 << 24) >>> 0;
  return new EncodedTokenizationResult(tokens, state === null ? NullState : state);
}
var NullState;
var init_nullTokenize = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js"() {
    init_languages();
    NullState = new class {
      clone() {
        return this;
      }
      equals(other) {
        return this === other;
      }
    }();
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/services/model.js
var IModelService;
var init_model2 = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/services/model.js"() {
    init_instantiation();
    IModelService = createDecorator("modelService");
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/services/resolverService.js
var ITextModelService;
var init_resolverService = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/services/resolverService.js"() {
    init_instantiation();
    ITextModelService = createDecorator("textModelService");
  }
});

// node_modules/monaco-editor/esm/vs/platform/commands/common/commands.js
var ICommandService, CommandsRegistry;
var init_commands = __esm({
  "node_modules/monaco-editor/esm/vs/platform/commands/common/commands.js"() {
    init_event();
    init_iterator();
    init_lifecycle();
    init_linkedList();
    init_types();
    init_instantiation();
    ICommandService = createDecorator("commandService");
    CommandsRegistry = new class {
      constructor() {
        this._commands = /* @__PURE__ */ new Map();
        this._onDidRegisterCommand = new Emitter();
        this.onDidRegisterCommand = this._onDidRegisterCommand.event;
      }
      registerCommand(idOrCommand, handler) {
        if (!idOrCommand) {
          throw new Error(`invalid command`);
        }
        if (typeof idOrCommand === "string") {
          if (!handler) {
            throw new Error(`invalid command`);
          }
          return this.registerCommand({ id: idOrCommand, handler });
        }
        if (idOrCommand.metadata && Array.isArray(idOrCommand.metadata.args)) {
          const constraints = [];
          for (const arg of idOrCommand.metadata.args) {
            constraints.push(arg.constraint);
          }
          const actualHandler = idOrCommand.handler;
          idOrCommand.handler = function(accessor, ...args) {
            validateConstraints(args, constraints);
            return actualHandler(accessor, ...args);
          };
        }
        const { id } = idOrCommand;
        let commands = this._commands.get(id);
        if (!commands) {
          commands = new LinkedList();
          this._commands.set(id, commands);
        }
        const removeFn = commands.unshift(idOrCommand);
        const ret = toDisposable(() => {
          removeFn();
          const command = this._commands.get(id);
          if (command === null || command === void 0 ? void 0 : command.isEmpty()) {
            this._commands.delete(id);
          }
        });
        this._onDidRegisterCommand.fire(id);
        return ret;
      }
      registerCommandAlias(oldId, newId) {
        return CommandsRegistry.registerCommand(oldId, (accessor, ...args) => accessor.get(ICommandService).executeCommand(newId, ...args));
      }
      getCommand(id) {
        const list = this._commands.get(id);
        if (!list || list.isEmpty()) {
          return void 0;
        }
        return Iterable.first(list);
      }
      getCommands() {
        const result = /* @__PURE__ */ new Map();
        for (const key of this._commands.keys()) {
          const command = this.getCommand(key);
          if (command) {
            result.set(key, command);
          }
        }
        return result;
      }
    }();
    CommandsRegistry.registerCommand("noop", () => {
    });
  }
});

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js
function sorter(a, b) {
  if (a.weight1 !== b.weight1) {
    return a.weight1 - b.weight1;
  }
  if (a.command && b.command) {
    if (a.command < b.command) {
      return -1;
    }
    if (a.command > b.command) {
      return 1;
    }
  }
  return a.weight2 - b.weight2;
}
var KeybindingsRegistryImpl, KeybindingsRegistry, Extensions6;
var init_keybindingsRegistry = __esm({
  "node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js"() {
    init_keybindings();
    init_platform();
    init_commands();
    init_platform2();
    init_lifecycle();
    init_linkedList();
    KeybindingsRegistryImpl = class _KeybindingsRegistryImpl {
      constructor() {
        this._coreKeybindings = new LinkedList();
        this._extensionKeybindings = [];
        this._cachedMergedKeybindings = null;
      }
      /**
       * Take current platform into account and reduce to primary & secondary.
       */
      static bindToCurrentPlatform(kb) {
        if (OS === 1) {
          if (kb && kb.win) {
            return kb.win;
          }
        } else if (OS === 2) {
          if (kb && kb.mac) {
            return kb.mac;
          }
        } else {
          if (kb && kb.linux) {
            return kb.linux;
          }
        }
        return kb;
      }
      registerKeybindingRule(rule) {
        const actualKb = _KeybindingsRegistryImpl.bindToCurrentPlatform(rule);
        const result = new DisposableStore();
        if (actualKb && actualKb.primary) {
          const kk = decodeKeybinding(actualKb.primary, OS);
          if (kk) {
            result.add(this._registerDefaultKeybinding(kk, rule.id, rule.args, rule.weight, 0, rule.when));
          }
        }
        if (actualKb && Array.isArray(actualKb.secondary)) {
          for (let i = 0, len = actualKb.secondary.length; i < len; i++) {
            const k = actualKb.secondary[i];
            const kk = decodeKeybinding(k, OS);
            if (kk) {
              result.add(this._registerDefaultKeybinding(kk, rule.id, rule.args, rule.weight, -i - 1, rule.when));
            }
          }
        }
        return result;
      }
      registerCommandAndKeybindingRule(desc) {
        return combinedDisposable(this.registerKeybindingRule(desc), CommandsRegistry.registerCommand(desc));
      }
      _registerDefaultKeybinding(keybinding, commandId, commandArgs, weight1, weight2, when) {
        const remove = this._coreKeybindings.push({
          keybinding,
          command: commandId,
          commandArgs,
          when,
          weight1,
          weight2,
          extensionId: null,
          isBuiltinExtension: false
        });
        this._cachedMergedKeybindings = null;
        return toDisposable(() => {
          remove();
          this._cachedMergedKeybindings = null;
        });
      }
      getDefaultKeybindings() {
        if (!this._cachedMergedKeybindings) {
          this._cachedMergedKeybindings = Array.from(this._coreKeybindings).concat(this._extensionKeybindings);
          this._cachedMergedKeybindings.sort(sorter);
        }
        return this._cachedMergedKeybindings.slice(0);
      }
    };
    KeybindingsRegistry = new KeybindingsRegistryImpl();
    Extensions6 = {
      EditorModes: "platform.keybindingsRegistry"
    };
    Registry.add(Extensions6.EditorModes, KeybindingsRegistry);
  }
});

// node_modules/monaco-editor/esm/vs/platform/telemetry/common/telemetry.js
var ITelemetryService;
var init_telemetry = __esm({
  "node_modules/monaco-editor/esm/vs/platform/telemetry/common/telemetry.js"() {
    init_instantiation();
    ITelemetryService = createDecorator("telemetryService");
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/standaloneStrings.js
var InspectTokensNLS, GoToLineNLS, QuickHelpNLS, QuickCommandNLS, QuickOutlineNLS, StandaloneCodeEditorNLS, ToggleHighContrastNLS, StandaloneServicesNLS;
var init_standaloneStrings = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/standaloneStrings.js"() {
    init_nls();
    (function(InspectTokensNLS2) {
      InspectTokensNLS2.inspectTokensAction = localize("inspectTokens", "Developer: Inspect Tokens");
    })(InspectTokensNLS || (InspectTokensNLS = {}));
    (function(GoToLineNLS2) {
      GoToLineNLS2.gotoLineActionLabel = localize("gotoLineActionLabel", "Go to Line/Column...");
    })(GoToLineNLS || (GoToLineNLS = {}));
    (function(QuickHelpNLS2) {
      QuickHelpNLS2.helpQuickAccessActionLabel = localize("helpQuickAccess", "Show all Quick Access Providers");
    })(QuickHelpNLS || (QuickHelpNLS = {}));
    (function(QuickCommandNLS2) {
      QuickCommandNLS2.quickCommandActionLabel = localize("quickCommandActionLabel", "Command Palette");
      QuickCommandNLS2.quickCommandHelp = localize("quickCommandActionHelp", "Show And Run Commands");
    })(QuickCommandNLS || (QuickCommandNLS = {}));
    (function(QuickOutlineNLS2) {
      QuickOutlineNLS2.quickOutlineActionLabel = localize("quickOutlineActionLabel", "Go to Symbol...");
      QuickOutlineNLS2.quickOutlineByCategoryActionLabel = localize("quickOutlineByCategoryActionLabel", "Go to Symbol by Category...");
    })(QuickOutlineNLS || (QuickOutlineNLS = {}));
    (function(StandaloneCodeEditorNLS2) {
      StandaloneCodeEditorNLS2.editorViewAccessibleLabel = localize("editorViewAccessibleLabel", "Editor content");
      StandaloneCodeEditorNLS2.accessibilityHelpMessage = localize("accessibilityHelpMessage", "Press Alt+F1 for Accessibility Options.");
    })(StandaloneCodeEditorNLS || (StandaloneCodeEditorNLS = {}));
    (function(ToggleHighContrastNLS2) {
      ToggleHighContrastNLS2.toggleHighContrast = localize("toggleHighContrast", "Toggle High Contrast Theme");
    })(ToggleHighContrastNLS || (ToggleHighContrastNLS = {}));
    (function(StandaloneServicesNLS2) {
      StandaloneServicesNLS2.bulkEditServiceSummary = localize("bulkEditServiceSummary", "Made {0} edits in {1} files");
    })(StandaloneServicesNLS || (StandaloneServicesNLS = {}));
  }
});

// node_modules/monaco-editor/esm/vs/base/common/actions.js
function toAction(props) {
  var _a2;
  return {
    id: props.id,
    label: props.label,
    class: props.class,
    enabled: (_a2 = props.enabled) !== null && _a2 !== void 0 ? _a2 : true,
    checked: props.checked,
    run: async (...args) => props.run(...args),
    tooltip: props.label
  };
}
var Action, ActionRunner, Separator, SubmenuAction, EmptySubmenuAction;
var init_actions = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/actions.js"() {
    init_event();
    init_lifecycle();
    init_nls();
    Action = class extends Disposable {
      constructor(id, label = "", cssClass = "", enabled = true, actionCallback) {
        super();
        this._onDidChange = this._register(new Emitter());
        this.onDidChange = this._onDidChange.event;
        this._enabled = true;
        this._id = id;
        this._label = label;
        this._cssClass = cssClass;
        this._enabled = enabled;
        this._actionCallback = actionCallback;
      }
      get id() {
        return this._id;
      }
      get label() {
        return this._label;
      }
      set label(value) {
        this._setLabel(value);
      }
      _setLabel(value) {
        if (this._label !== value) {
          this._label = value;
          this._onDidChange.fire({ label: value });
        }
      }
      get tooltip() {
        return this._tooltip || "";
      }
      set tooltip(value) {
        this._setTooltip(value);
      }
      _setTooltip(value) {
        if (this._tooltip !== value) {
          this._tooltip = value;
          this._onDidChange.fire({ tooltip: value });
        }
      }
      get class() {
        return this._cssClass;
      }
      set class(value) {
        this._setClass(value);
      }
      _setClass(value) {
        if (this._cssClass !== value) {
          this._cssClass = value;
          this._onDidChange.fire({ class: value });
        }
      }
      get enabled() {
        return this._enabled;
      }
      set enabled(value) {
        this._setEnabled(value);
      }
      _setEnabled(value) {
        if (this._enabled !== value) {
          this._enabled = value;
          this._onDidChange.fire({ enabled: value });
        }
      }
      get checked() {
        return this._checked;
      }
      set checked(value) {
        this._setChecked(value);
      }
      _setChecked(value) {
        if (this._checked !== value) {
          this._checked = value;
          this._onDidChange.fire({ checked: value });
        }
      }
      async run(event, data) {
        if (this._actionCallback) {
          await this._actionCallback(event);
        }
      }
    };
    ActionRunner = class extends Disposable {
      constructor() {
        super(...arguments);
        this._onWillRun = this._register(new Emitter());
        this.onWillRun = this._onWillRun.event;
        this._onDidRun = this._register(new Emitter());
        this.onDidRun = this._onDidRun.event;
      }
      async run(action, context) {
        if (!action.enabled) {
          return;
        }
        this._onWillRun.fire({ action });
        let error = void 0;
        try {
          await this.runAction(action, context);
        } catch (e) {
          error = e;
        }
        this._onDidRun.fire({ action, error });
      }
      async runAction(action, context) {
        await action.run(context);
      }
    };
    Separator = class _Separator {
      constructor() {
        this.id = _Separator.ID;
        this.label = "";
        this.tooltip = "";
        this.class = "separator";
        this.enabled = false;
        this.checked = false;
      }
      /**
       * Joins all non-empty lists of actions with separators.
       */
      static join(...actionLists) {
        let out = [];
        for (const list of actionLists) {
          if (!list.length) {
          } else if (out.length) {
            out = [...out, new _Separator(), ...list];
          } else {
            out = list;
          }
        }
        return out;
      }
      async run() {
      }
    };
    Separator.ID = "vs.actions.separator";
    SubmenuAction = class {
      get actions() {
        return this._actions;
      }
      constructor(id, label, actions, cssClass) {
        this.tooltip = "";
        this.enabled = true;
        this.checked = void 0;
        this.id = id;
        this.label = label;
        this.class = cssClass;
        this._actions = actions;
      }
      async run() {
      }
    };
    EmptySubmenuAction = class _EmptySubmenuAction extends Action {
      constructor() {
        super(_EmptySubmenuAction.ID, localize("submenu.empty", "(empty)"), void 0, false);
      }
    };
    EmptySubmenuAction.ID = "vs.actions.empty";
  }
});

// node_modules/monaco-editor/esm/vs/platform/actions/common/actions.js
function isIMenuItem(item) {
  return item.command !== void 0;
}
function isISubmenuItem(item) {
  return item.submenu !== void 0;
}
function registerAction2(ctor) {
  const disposables = new DisposableStore();
  const action = new ctor();
  const { f1, menu, keybinding, ...command } = action.desc;
  if (CommandsRegistry.getCommand(command.id)) {
    throw new Error(`Cannot register two commands with the same id: ${command.id}`);
  }
  disposables.add(CommandsRegistry.registerCommand({
    id: command.id,
    handler: (accessor, ...args) => action.run(accessor, ...args),
    metadata: command.metadata
  }));
  if (Array.isArray(menu)) {
    for (const item of menu) {
      disposables.add(MenuRegistry.appendMenuItem(item.id, { command: { ...command, precondition: item.precondition === null ? void 0 : command.precondition }, ...item }));
    }
  } else if (menu) {
    disposables.add(MenuRegistry.appendMenuItem(menu.id, { command: { ...command, precondition: menu.precondition === null ? void 0 : command.precondition }, ...menu }));
  }
  if (f1) {
    disposables.add(MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command, when: command.precondition }));
    disposables.add(MenuRegistry.addCommand(command));
  }
  if (Array.isArray(keybinding)) {
    for (const item of keybinding) {
      disposables.add(KeybindingsRegistry.registerKeybindingRule({
        ...item,
        id: command.id,
        when: command.precondition ? ContextKeyExpr.and(command.precondition, item.when) : item.when
      }));
    }
  } else if (keybinding) {
    disposables.add(KeybindingsRegistry.registerKeybindingRule({
      ...keybinding,
      id: command.id,
      when: command.precondition ? ContextKeyExpr.and(command.precondition, keybinding.when) : keybinding.when
    }));
  }
  return disposables;
}
var __decorate16, __param13, MenuItemAction_1, MenuId, IMenuService, MenuRegistryChangeEvent, MenuRegistry, SubmenuItemAction, MenuItemAction, Action2;
var init_actions2 = __esm({
  "node_modules/monaco-editor/esm/vs/platform/actions/common/actions.js"() {
    init_actions();
    init_themables();
    init_event();
    init_lifecycle();
    init_linkedList();
    init_commands();
    init_contextkey();
    init_instantiation();
    init_keybindingsRegistry();
    __decorate16 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param13 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    MenuId = class _MenuId {
      /**
       * Create a new `MenuId` with the unique identifier. Will throw if a menu
       * with the identifier already exists, use `MenuId.for(ident)` or a unique
       * identifier
       */
      constructor(identifier) {
        if (_MenuId._instances.has(identifier)) {
          throw new TypeError(`MenuId with identifier '${identifier}' already exists. Use MenuId.for(ident) or a unique identifier`);
        }
        _MenuId._instances.set(identifier, this);
        this.id = identifier;
      }
    };
    MenuId._instances = /* @__PURE__ */ new Map();
    MenuId.CommandPalette = new MenuId("CommandPalette");
    MenuId.DebugBreakpointsContext = new MenuId("DebugBreakpointsContext");
    MenuId.DebugCallStackContext = new MenuId("DebugCallStackContext");
    MenuId.DebugConsoleContext = new MenuId("DebugConsoleContext");
    MenuId.DebugVariablesContext = new MenuId("DebugVariablesContext");
    MenuId.NotebookVariablesContext = new MenuId("NotebookVariablesContext");
    MenuId.DebugHoverContext = new MenuId("DebugHoverContext");
    MenuId.DebugWatchContext = new MenuId("DebugWatchContext");
    MenuId.DebugToolBar = new MenuId("DebugToolBar");
    MenuId.DebugToolBarStop = new MenuId("DebugToolBarStop");
    MenuId.EditorContext = new MenuId("EditorContext");
    MenuId.SimpleEditorContext = new MenuId("SimpleEditorContext");
    MenuId.EditorContent = new MenuId("EditorContent");
    MenuId.EditorLineNumberContext = new MenuId("EditorLineNumberContext");
    MenuId.EditorContextCopy = new MenuId("EditorContextCopy");
    MenuId.EditorContextPeek = new MenuId("EditorContextPeek");
    MenuId.EditorContextShare = new MenuId("EditorContextShare");
    MenuId.EditorTitle = new MenuId("EditorTitle");
    MenuId.EditorTitleRun = new MenuId("EditorTitleRun");
    MenuId.EditorTitleContext = new MenuId("EditorTitleContext");
    MenuId.EditorTitleContextShare = new MenuId("EditorTitleContextShare");
    MenuId.EmptyEditorGroup = new MenuId("EmptyEditorGroup");
    MenuId.EmptyEditorGroupContext = new MenuId("EmptyEditorGroupContext");
    MenuId.EditorTabsBarContext = new MenuId("EditorTabsBarContext");
    MenuId.EditorTabsBarShowTabsSubmenu = new MenuId("EditorTabsBarShowTabsSubmenu");
    MenuId.EditorTabsBarShowTabsZenModeSubmenu = new MenuId("EditorTabsBarShowTabsZenModeSubmenu");
    MenuId.EditorActionsPositionSubmenu = new MenuId("EditorActionsPositionSubmenu");
    MenuId.ExplorerContext = new MenuId("ExplorerContext");
    MenuId.ExplorerContextShare = new MenuId("ExplorerContextShare");
    MenuId.ExtensionContext = new MenuId("ExtensionContext");
    MenuId.GlobalActivity = new MenuId("GlobalActivity");
    MenuId.CommandCenter = new MenuId("CommandCenter");
    MenuId.CommandCenterCenter = new MenuId("CommandCenterCenter");
    MenuId.LayoutControlMenuSubmenu = new MenuId("LayoutControlMenuSubmenu");
    MenuId.LayoutControlMenu = new MenuId("LayoutControlMenu");
    MenuId.MenubarMainMenu = new MenuId("MenubarMainMenu");
    MenuId.MenubarAppearanceMenu = new MenuId("MenubarAppearanceMenu");
    MenuId.MenubarDebugMenu = new MenuId("MenubarDebugMenu");
    MenuId.MenubarEditMenu = new MenuId("MenubarEditMenu");
    MenuId.MenubarCopy = new MenuId("MenubarCopy");
    MenuId.MenubarFileMenu = new MenuId("MenubarFileMenu");
    MenuId.MenubarGoMenu = new MenuId("MenubarGoMenu");
    MenuId.MenubarHelpMenu = new MenuId("MenubarHelpMenu");
    MenuId.MenubarLayoutMenu = new MenuId("MenubarLayoutMenu");
    MenuId.MenubarNewBreakpointMenu = new MenuId("MenubarNewBreakpointMenu");
    MenuId.PanelAlignmentMenu = new MenuId("PanelAlignmentMenu");
    MenuId.PanelPositionMenu = new MenuId("PanelPositionMenu");
    MenuId.ActivityBarPositionMenu = new MenuId("ActivityBarPositionMenu");
    MenuId.MenubarPreferencesMenu = new MenuId("MenubarPreferencesMenu");
    MenuId.MenubarRecentMenu = new MenuId("MenubarRecentMenu");
    MenuId.MenubarSelectionMenu = new MenuId("MenubarSelectionMenu");
    MenuId.MenubarShare = new MenuId("MenubarShare");
    MenuId.MenubarSwitchEditorMenu = new MenuId("MenubarSwitchEditorMenu");
    MenuId.MenubarSwitchGroupMenu = new MenuId("MenubarSwitchGroupMenu");
    MenuId.MenubarTerminalMenu = new MenuId("MenubarTerminalMenu");
    MenuId.MenubarViewMenu = new MenuId("MenubarViewMenu");
    MenuId.MenubarHomeMenu = new MenuId("MenubarHomeMenu");
    MenuId.OpenEditorsContext = new MenuId("OpenEditorsContext");
    MenuId.OpenEditorsContextShare = new MenuId("OpenEditorsContextShare");
    MenuId.ProblemsPanelContext = new MenuId("ProblemsPanelContext");
    MenuId.SCMInputBox = new MenuId("SCMInputBox");
    MenuId.SCMChangesSeparator = new MenuId("SCMChangesSeparator");
    MenuId.SCMIncomingChanges = new MenuId("SCMIncomingChanges");
    MenuId.SCMIncomingChangesContext = new MenuId("SCMIncomingChangesContext");
    MenuId.SCMIncomingChangesSetting = new MenuId("SCMIncomingChangesSetting");
    MenuId.SCMOutgoingChanges = new MenuId("SCMOutgoingChanges");
    MenuId.SCMOutgoingChangesContext = new MenuId("SCMOutgoingChangesContext");
    MenuId.SCMOutgoingChangesSetting = new MenuId("SCMOutgoingChangesSetting");
    MenuId.SCMIncomingChangesAllChangesContext = new MenuId("SCMIncomingChangesAllChangesContext");
    MenuId.SCMIncomingChangesHistoryItemContext = new MenuId("SCMIncomingChangesHistoryItemContext");
    MenuId.SCMOutgoingChangesAllChangesContext = new MenuId("SCMOutgoingChangesAllChangesContext");
    MenuId.SCMOutgoingChangesHistoryItemContext = new MenuId("SCMOutgoingChangesHistoryItemContext");
    MenuId.SCMChangeContext = new MenuId("SCMChangeContext");
    MenuId.SCMResourceContext = new MenuId("SCMResourceContext");
    MenuId.SCMResourceContextShare = new MenuId("SCMResourceContextShare");
    MenuId.SCMResourceFolderContext = new MenuId("SCMResourceFolderContext");
    MenuId.SCMResourceGroupContext = new MenuId("SCMResourceGroupContext");
    MenuId.SCMSourceControl = new MenuId("SCMSourceControl");
    MenuId.SCMSourceControlInline = new MenuId("SCMSourceControlInline");
    MenuId.SCMSourceControlTitle = new MenuId("SCMSourceControlTitle");
    MenuId.SCMTitle = new MenuId("SCMTitle");
    MenuId.SearchContext = new MenuId("SearchContext");
    MenuId.SearchActionMenu = new MenuId("SearchActionContext");
    MenuId.StatusBarWindowIndicatorMenu = new MenuId("StatusBarWindowIndicatorMenu");
    MenuId.StatusBarRemoteIndicatorMenu = new MenuId("StatusBarRemoteIndicatorMenu");
    MenuId.StickyScrollContext = new MenuId("StickyScrollContext");
    MenuId.TestItem = new MenuId("TestItem");
    MenuId.TestItemGutter = new MenuId("TestItemGutter");
    MenuId.TestMessageContext = new MenuId("TestMessageContext");
    MenuId.TestMessageContent = new MenuId("TestMessageContent");
    MenuId.TestPeekElement = new MenuId("TestPeekElement");
    MenuId.TestPeekTitle = new MenuId("TestPeekTitle");
    MenuId.TouchBarContext = new MenuId("TouchBarContext");
    MenuId.TitleBarContext = new MenuId("TitleBarContext");
    MenuId.TitleBarTitleContext = new MenuId("TitleBarTitleContext");
    MenuId.TunnelContext = new MenuId("TunnelContext");
    MenuId.TunnelPrivacy = new MenuId("TunnelPrivacy");
    MenuId.TunnelProtocol = new MenuId("TunnelProtocol");
    MenuId.TunnelPortInline = new MenuId("TunnelInline");
    MenuId.TunnelTitle = new MenuId("TunnelTitle");
    MenuId.TunnelLocalAddressInline = new MenuId("TunnelLocalAddressInline");
    MenuId.TunnelOriginInline = new MenuId("TunnelOriginInline");
    MenuId.ViewItemContext = new MenuId("ViewItemContext");
    MenuId.ViewContainerTitle = new MenuId("ViewContainerTitle");
    MenuId.ViewContainerTitleContext = new MenuId("ViewContainerTitleContext");
    MenuId.ViewTitle = new MenuId("ViewTitle");
    MenuId.ViewTitleContext = new MenuId("ViewTitleContext");
    MenuId.CommentEditorActions = new MenuId("CommentEditorActions");
    MenuId.CommentThreadTitle = new MenuId("CommentThreadTitle");
    MenuId.CommentThreadActions = new MenuId("CommentThreadActions");
    MenuId.CommentThreadAdditionalActions = new MenuId("CommentThreadAdditionalActions");
    MenuId.CommentThreadTitleContext = new MenuId("CommentThreadTitleContext");
    MenuId.CommentThreadCommentContext = new MenuId("CommentThreadCommentContext");
    MenuId.CommentTitle = new MenuId("CommentTitle");
    MenuId.CommentActions = new MenuId("CommentActions");
    MenuId.InteractiveToolbar = new MenuId("InteractiveToolbar");
    MenuId.InteractiveCellTitle = new MenuId("InteractiveCellTitle");
    MenuId.InteractiveCellDelete = new MenuId("InteractiveCellDelete");
    MenuId.InteractiveCellExecute = new MenuId("InteractiveCellExecute");
    MenuId.InteractiveInputExecute = new MenuId("InteractiveInputExecute");
    MenuId.IssueReporter = new MenuId("IssueReporter");
    MenuId.NotebookToolbar = new MenuId("NotebookToolbar");
    MenuId.NotebookStickyScrollContext = new MenuId("NotebookStickyScrollContext");
    MenuId.NotebookCellTitle = new MenuId("NotebookCellTitle");
    MenuId.NotebookCellDelete = new MenuId("NotebookCellDelete");
    MenuId.NotebookCellInsert = new MenuId("NotebookCellInsert");
    MenuId.NotebookCellBetween = new MenuId("NotebookCellBetween");
    MenuId.NotebookCellListTop = new MenuId("NotebookCellTop");
    MenuId.NotebookCellExecute = new MenuId("NotebookCellExecute");
    MenuId.NotebookCellExecuteGoTo = new MenuId("NotebookCellExecuteGoTo");
    MenuId.NotebookCellExecutePrimary = new MenuId("NotebookCellExecutePrimary");
    MenuId.NotebookDiffCellInputTitle = new MenuId("NotebookDiffCellInputTitle");
    MenuId.NotebookDiffCellMetadataTitle = new MenuId("NotebookDiffCellMetadataTitle");
    MenuId.NotebookDiffCellOutputsTitle = new MenuId("NotebookDiffCellOutputsTitle");
    MenuId.NotebookOutputToolbar = new MenuId("NotebookOutputToolbar");
    MenuId.NotebookEditorLayoutConfigure = new MenuId("NotebookEditorLayoutConfigure");
    MenuId.NotebookKernelSource = new MenuId("NotebookKernelSource");
    MenuId.BulkEditTitle = new MenuId("BulkEditTitle");
    MenuId.BulkEditContext = new MenuId("BulkEditContext");
    MenuId.TimelineItemContext = new MenuId("TimelineItemContext");
    MenuId.TimelineTitle = new MenuId("TimelineTitle");
    MenuId.TimelineTitleContext = new MenuId("TimelineTitleContext");
    MenuId.TimelineFilterSubMenu = new MenuId("TimelineFilterSubMenu");
    MenuId.AccountsContext = new MenuId("AccountsContext");
    MenuId.SidebarTitle = new MenuId("SidebarTitle");
    MenuId.PanelTitle = new MenuId("PanelTitle");
    MenuId.AuxiliaryBarTitle = new MenuId("AuxiliaryBarTitle");
    MenuId.TerminalInstanceContext = new MenuId("TerminalInstanceContext");
    MenuId.TerminalEditorInstanceContext = new MenuId("TerminalEditorInstanceContext");
    MenuId.TerminalNewDropdownContext = new MenuId("TerminalNewDropdownContext");
    MenuId.TerminalTabContext = new MenuId("TerminalTabContext");
    MenuId.TerminalTabEmptyAreaContext = new MenuId("TerminalTabEmptyAreaContext");
    MenuId.TerminalStickyScrollContext = new MenuId("TerminalStickyScrollContext");
    MenuId.WebviewContext = new MenuId("WebviewContext");
    MenuId.InlineCompletionsActions = new MenuId("InlineCompletionsActions");
    MenuId.InlineEditActions = new MenuId("InlineEditActions");
    MenuId.NewFile = new MenuId("NewFile");
    MenuId.MergeInput1Toolbar = new MenuId("MergeToolbar1Toolbar");
    MenuId.MergeInput2Toolbar = new MenuId("MergeToolbar2Toolbar");
    MenuId.MergeBaseToolbar = new MenuId("MergeBaseToolbar");
    MenuId.MergeInputResultToolbar = new MenuId("MergeToolbarResultToolbar");
    MenuId.InlineSuggestionToolbar = new MenuId("InlineSuggestionToolbar");
    MenuId.InlineEditToolbar = new MenuId("InlineEditToolbar");
    MenuId.ChatContext = new MenuId("ChatContext");
    MenuId.ChatCodeBlock = new MenuId("ChatCodeblock");
    MenuId.ChatMessageTitle = new MenuId("ChatMessageTitle");
    MenuId.ChatExecute = new MenuId("ChatExecute");
    MenuId.ChatInputSide = new MenuId("ChatInputSide");
    MenuId.AccessibleView = new MenuId("AccessibleView");
    MenuId.MultiDiffEditorFileToolbar = new MenuId("MultiDiffEditorFileToolbar");
    IMenuService = createDecorator("menuService");
    MenuRegistryChangeEvent = class _MenuRegistryChangeEvent {
      static for(id) {
        let value = this._all.get(id);
        if (!value) {
          value = new _MenuRegistryChangeEvent(id);
          this._all.set(id, value);
        }
        return value;
      }
      static merge(events) {
        const ids = /* @__PURE__ */ new Set();
        for (const item of events) {
          if (item instanceof _MenuRegistryChangeEvent) {
            ids.add(item.id);
          }
        }
        return ids;
      }
      constructor(id) {
        this.id = id;
        this.has = (candidate) => candidate === id;
      }
    };
    MenuRegistryChangeEvent._all = /* @__PURE__ */ new Map();
    MenuRegistry = new class {
      constructor() {
        this._commands = /* @__PURE__ */ new Map();
        this._menuItems = /* @__PURE__ */ new Map();
        this._onDidChangeMenu = new MicrotaskEmitter({
          merge: MenuRegistryChangeEvent.merge
        });
        this.onDidChangeMenu = this._onDidChangeMenu.event;
      }
      addCommand(command) {
        this._commands.set(command.id, command);
        this._onDidChangeMenu.fire(MenuRegistryChangeEvent.for(MenuId.CommandPalette));
        return toDisposable(() => {
          if (this._commands.delete(command.id)) {
            this._onDidChangeMenu.fire(MenuRegistryChangeEvent.for(MenuId.CommandPalette));
          }
        });
      }
      getCommand(id) {
        return this._commands.get(id);
      }
      getCommands() {
        const map = /* @__PURE__ */ new Map();
        this._commands.forEach((value, key) => map.set(key, value));
        return map;
      }
      appendMenuItem(id, item) {
        let list = this._menuItems.get(id);
        if (!list) {
          list = new LinkedList();
          this._menuItems.set(id, list);
        }
        const rm = list.push(item);
        this._onDidChangeMenu.fire(MenuRegistryChangeEvent.for(id));
        return toDisposable(() => {
          rm();
          this._onDidChangeMenu.fire(MenuRegistryChangeEvent.for(id));
        });
      }
      appendMenuItems(items) {
        const result = new DisposableStore();
        for (const { id, item } of items) {
          result.add(this.appendMenuItem(id, item));
        }
        return result;
      }
      getMenuItems(id) {
        let result;
        if (this._menuItems.has(id)) {
          result = [...this._menuItems.get(id)];
        } else {
          result = [];
        }
        if (id === MenuId.CommandPalette) {
          this._appendImplicitItems(result);
        }
        return result;
      }
      _appendImplicitItems(result) {
        const set = /* @__PURE__ */ new Set();
        for (const item of result) {
          if (isIMenuItem(item)) {
            set.add(item.command.id);
            if (item.alt) {
              set.add(item.alt.id);
            }
          }
        }
        this._commands.forEach((command, id) => {
          if (!set.has(id)) {
            result.push({ command });
          }
        });
      }
    }();
    SubmenuItemAction = class extends SubmenuAction {
      constructor(item, hideActions, actions) {
        super(`submenuitem.${item.submenu.id}`, typeof item.title === "string" ? item.title : item.title.value, actions, "submenu");
        this.item = item;
        this.hideActions = hideActions;
      }
    };
    MenuItemAction = MenuItemAction_1 = class MenuItemAction2 {
      static label(action, options2) {
        return (options2 === null || options2 === void 0 ? void 0 : options2.renderShortTitle) && action.shortTitle ? typeof action.shortTitle === "string" ? action.shortTitle : action.shortTitle.value : typeof action.title === "string" ? action.title : action.title.value;
      }
      constructor(item, alt, options2, hideActions, contextKeyService, _commandService) {
        var _a2, _b2;
        this.hideActions = hideActions;
        this._commandService = _commandService;
        this.id = item.id;
        this.label = MenuItemAction_1.label(item, options2);
        this.tooltip = (_b2 = typeof item.tooltip === "string" ? item.tooltip : (_a2 = item.tooltip) === null || _a2 === void 0 ? void 0 : _a2.value) !== null && _b2 !== void 0 ? _b2 : "";
        this.enabled = !item.precondition || contextKeyService.contextMatchesRules(item.precondition);
        this.checked = void 0;
        let icon;
        if (item.toggled) {
          const toggled = item.toggled.condition ? item.toggled : { condition: item.toggled };
          this.checked = contextKeyService.contextMatchesRules(toggled.condition);
          if (this.checked && toggled.tooltip) {
            this.tooltip = typeof toggled.tooltip === "string" ? toggled.tooltip : toggled.tooltip.value;
          }
          if (this.checked && ThemeIcon.isThemeIcon(toggled.icon)) {
            icon = toggled.icon;
          }
          if (this.checked && toggled.title) {
            this.label = typeof toggled.title === "string" ? toggled.title : toggled.title.value;
          }
        }
        if (!icon) {
          icon = ThemeIcon.isThemeIcon(item.icon) ? item.icon : void 0;
        }
        this.item = item;
        this.alt = alt ? new MenuItemAction_1(alt, void 0, options2, hideActions, contextKeyService, _commandService) : void 0;
        this._options = options2;
        this.class = icon && ThemeIcon.asClassName(icon);
      }
      run(...args) {
        var _a2, _b2;
        let runArgs = [];
        if ((_a2 = this._options) === null || _a2 === void 0 ? void 0 : _a2.arg) {
          runArgs = [...runArgs, this._options.arg];
        }
        if ((_b2 = this._options) === null || _b2 === void 0 ? void 0 : _b2.shouldForwardArgs) {
          runArgs = [...runArgs, ...args];
        }
        return this._commandService.executeCommand(this.id, ...runArgs);
      }
    };
    MenuItemAction = MenuItemAction_1 = __decorate16([
      __param13(4, IContextKeyService),
      __param13(5, ICommandService)
    ], MenuItemAction);
    Action2 = class {
      constructor(desc) {
        this.desc = desc;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/services/editorWorker.js
var IEditorWorkerService;
var init_editorWorker = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/services/editorWorker.js"() {
    init_instantiation();
    IEditorWorkerService = createDecorator("editorWorkerService");
  }
});

// node_modules/monaco-editor/esm/vs/base/common/uint.js
function toUint8(v) {
  if (v < 0) {
    return 0;
  }
  if (v > 255) {
    return 255;
  }
  return v | 0;
}
function toUint32(v) {
  if (v < 0) {
    return 0;
  }
  if (v > 4294967295) {
    return 4294967295;
  }
  return v | 0;
}
var init_uint = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/uint.js"() {
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js
var CharacterClassifier, CharacterSet;
var init_characterClassifier = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js"() {
    init_uint();
    CharacterClassifier = class _CharacterClassifier {
      constructor(_defaultValue) {
        const defaultValue = toUint8(_defaultValue);
        this._defaultValue = defaultValue;
        this._asciiMap = _CharacterClassifier._createAsciiMap(defaultValue);
        this._map = /* @__PURE__ */ new Map();
      }
      static _createAsciiMap(defaultValue) {
        const asciiMap = new Uint8Array(256);
        asciiMap.fill(defaultValue);
        return asciiMap;
      }
      set(charCode, _value) {
        const value = toUint8(_value);
        if (charCode >= 0 && charCode < 256) {
          this._asciiMap[charCode] = value;
        } else {
          this._map.set(charCode, value);
        }
      }
      get(charCode) {
        if (charCode >= 0 && charCode < 256) {
          return this._asciiMap[charCode];
        } else {
          return this._map.get(charCode) || this._defaultValue;
        }
      }
      clear() {
        this._asciiMap.fill(this._defaultValue);
        this._map.clear();
      }
    };
    CharacterSet = class {
      constructor() {
        this._actual = new CharacterClassifier(
          0
          /* Boolean.False */
        );
      }
      add(charCode) {
        this._actual.set(
          charCode,
          1
          /* Boolean.True */
        );
      }
      has(charCode) {
        return this._actual.get(charCode) === 1;
      }
      clear() {
        return this._actual.clear();
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/selection.js
var Selection;
var init_selection = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/selection.js"() {
    init_position();
    init_range();
    Selection = class _Selection extends Range2 {
      constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
        this.selectionStartLineNumber = selectionStartLineNumber;
        this.selectionStartColumn = selectionStartColumn;
        this.positionLineNumber = positionLineNumber;
        this.positionColumn = positionColumn;
      }
      /**
       * Transform to a human-readable representation.
       */
      toString() {
        return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
      }
      /**
       * Test if equals other selection.
       */
      equalsSelection(other) {
        return _Selection.selectionsEqual(this, other);
      }
      /**
       * Test if the two selections are equal.
       */
      static selectionsEqual(a, b) {
        return a.selectionStartLineNumber === b.selectionStartLineNumber && a.selectionStartColumn === b.selectionStartColumn && a.positionLineNumber === b.positionLineNumber && a.positionColumn === b.positionColumn;
      }
      /**
       * Get directions (LTR or RTL).
       */
      getDirection() {
        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
          return 0;
        }
        return 1;
      }
      /**
       * Create a new selection with a different `positionLineNumber` and `positionColumn`.
       */
      setEndPosition(endLineNumber, endColumn) {
        if (this.getDirection() === 0) {
          return new _Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
        }
        return new _Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
      }
      /**
       * Get the position at `positionLineNumber` and `positionColumn`.
       */
      getPosition() {
        return new Position(this.positionLineNumber, this.positionColumn);
      }
      /**
       * Get the position at the start of the selection.
      */
      getSelectionStart() {
        return new Position(this.selectionStartLineNumber, this.selectionStartColumn);
      }
      /**
       * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
       */
      setStartPosition(startLineNumber, startColumn) {
        if (this.getDirection() === 0) {
          return new _Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
        }
        return new _Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
      }
      // ----
      /**
       * Create a `Selection` from one or two positions
       */
      static fromPositions(start, end = start) {
        return new _Selection(start.lineNumber, start.column, end.lineNumber, end.column);
      }
      /**
       * Creates a `Selection` from a range, given a direction.
       */
      static fromRange(range2, direction) {
        if (direction === 0) {
          return new _Selection(range2.startLineNumber, range2.startColumn, range2.endLineNumber, range2.endColumn);
        } else {
          return new _Selection(range2.endLineNumber, range2.endColumn, range2.startLineNumber, range2.startColumn);
        }
      }
      /**
       * Create a `Selection` from an `ISelection`.
       */
      static liftSelection(sel) {
        return new _Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
      }
      /**
       * `a` equals `b`.
       */
      static selectionsArrEqual(a, b) {
        if (a && !b || !a && b) {
          return false;
        }
        if (!a && !b) {
          return true;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0, len = a.length; i < len; i++) {
          if (!this.selectionsEqual(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      /**
       * Test if `obj` is an `ISelection`.
       */
      static isISelection(obj) {
        return obj && typeof obj.selectionStartLineNumber === "number" && typeof obj.selectionStartColumn === "number" && typeof obj.positionLineNumber === "number" && typeof obj.positionColumn === "number";
      }
      /**
       * Create with a direction.
       */
      static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
        if (direction === 0) {
          return new _Selection(startLineNumber, startColumn, endLineNumber, endColumn);
        }
        return new _Selection(endLineNumber, endColumn, startLineNumber, startColumn);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js
function once(computeFn) {
  const cache = {};
  return (input) => {
    if (!cache.hasOwnProperty(input)) {
      cache[input] = computeFn(input);
    }
    return cache[input];
  };
}
var WordCharacterClassifier, getMapForWordSeparators;
var init_wordCharacterClassifier = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js"() {
    init_characterClassifier();
    WordCharacterClassifier = class extends CharacterClassifier {
      constructor(wordSeparators2) {
        super(
          0
          /* WordCharacterClass.Regular */
        );
        for (let i = 0, len = wordSeparators2.length; i < len; i++) {
          this.set(
            wordSeparators2.charCodeAt(i),
            2
            /* WordCharacterClass.WordSeparator */
          );
        }
        this.set(
          32,
          1
          /* WordCharacterClass.Whitespace */
        );
        this.set(
          9,
          1
          /* WordCharacterClass.Whitespace */
        );
      }
    };
    getMapForWordSeparators = once((input) => new WordCharacterClassifier(input));
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js
function isMultilineRegexSource(searchString) {
  if (!searchString || searchString.length === 0) {
    return false;
  }
  for (let i = 0, len = searchString.length; i < len; i++) {
    const chCode = searchString.charCodeAt(i);
    if (chCode === 10) {
      return true;
    }
    if (chCode === 92) {
      i++;
      if (i >= len) {
        break;
      }
      const nextChCode = searchString.charCodeAt(i);
      if (nextChCode === 110 || nextChCode === 114 || nextChCode === 87) {
        return true;
      }
    }
  }
  return false;
}
function createFindMatch(range2, rawMatches, captureMatches) {
  if (!captureMatches) {
    return new FindMatch(range2, null);
  }
  const matches = [];
  for (let i = 0, len = rawMatches.length; i < len; i++) {
    matches[i] = rawMatches[i];
  }
  return new FindMatch(range2, matches);
}
function leftIsWordBounday(wordSeparators2, text, textLength, matchStartIndex, matchLength) {
  if (matchStartIndex === 0) {
    return true;
  }
  const charBefore = text.charCodeAt(matchStartIndex - 1);
  if (wordSeparators2.get(charBefore) !== 0) {
    return true;
  }
  if (charBefore === 13 || charBefore === 10) {
    return true;
  }
  if (matchLength > 0) {
    const firstCharInMatch = text.charCodeAt(matchStartIndex);
    if (wordSeparators2.get(firstCharInMatch) !== 0) {
      return true;
    }
  }
  return false;
}
function rightIsWordBounday(wordSeparators2, text, textLength, matchStartIndex, matchLength) {
  if (matchStartIndex + matchLength === textLength) {
    return true;
  }
  const charAfter = text.charCodeAt(matchStartIndex + matchLength);
  if (wordSeparators2.get(charAfter) !== 0) {
    return true;
  }
  if (charAfter === 13 || charAfter === 10) {
    return true;
  }
  if (matchLength > 0) {
    const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);
    if (wordSeparators2.get(lastCharInMatch) !== 0) {
      return true;
    }
  }
  return false;
}
function isValidMatch(wordSeparators2, text, textLength, matchStartIndex, matchLength) {
  return leftIsWordBounday(wordSeparators2, text, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators2, text, textLength, matchStartIndex, matchLength);
}
var LIMIT_FIND_COUNT, SearchParams, LineFeedCounter, TextModelSearch, Searcher;
var init_textModelSearch = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js"() {
    init_strings();
    init_wordCharacterClassifier();
    init_position();
    init_range();
    init_model();
    LIMIT_FIND_COUNT = 999;
    SearchParams = class {
      constructor(searchString, isRegex, matchCase, wordSeparators2) {
        this.searchString = searchString;
        this.isRegex = isRegex;
        this.matchCase = matchCase;
        this.wordSeparators = wordSeparators2;
      }
      parseSearchRequest() {
        if (this.searchString === "") {
          return null;
        }
        let multiline;
        if (this.isRegex) {
          multiline = isMultilineRegexSource(this.searchString);
        } else {
          multiline = this.searchString.indexOf("\n") >= 0;
        }
        let regex = null;
        try {
          regex = createRegExp(this.searchString, this.isRegex, {
            matchCase: this.matchCase,
            wholeWord: false,
            multiline,
            global: true,
            unicode: true
          });
        } catch (err) {
          return null;
        }
        if (!regex) {
          return null;
        }
        let canUseSimpleSearch = !this.isRegex && !multiline;
        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {
          canUseSimpleSearch = this.matchCase;
        }
        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);
      }
    };
    LineFeedCounter = class {
      constructor(text) {
        const lineFeedsOffsets = [];
        let lineFeedsOffsetsLen = 0;
        for (let i = 0, textLen = text.length; i < textLen; i++) {
          if (text.charCodeAt(i) === 10) {
            lineFeedsOffsets[lineFeedsOffsetsLen++] = i;
          }
        }
        this._lineFeedsOffsets = lineFeedsOffsets;
      }
      findLineFeedCountBeforeOffset(offset) {
        const lineFeedsOffsets = this._lineFeedsOffsets;
        let min = 0;
        let max = lineFeedsOffsets.length - 1;
        if (max === -1) {
          return 0;
        }
        if (offset <= lineFeedsOffsets[0]) {
          return 0;
        }
        while (min < max) {
          const mid = min + ((max - min) / 2 >> 0);
          if (lineFeedsOffsets[mid] >= offset) {
            max = mid - 1;
          } else {
            if (lineFeedsOffsets[mid + 1] >= offset) {
              min = mid;
              max = mid;
            } else {
              min = mid + 1;
            }
          }
        }
        return min + 1;
      }
    };
    TextModelSearch = class {
      static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {
        const searchData = searchParams.parseSearchRequest();
        if (!searchData) {
          return [];
        }
        if (searchData.regex.multiline) {
          return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);
        }
        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);
      }
      /**
       * Multiline search always executes on the lines concatenated with \n.
       * We must therefore compensate for the count of \n in case the model is CRLF
       */
      static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {
        let startOffset;
        let lineFeedCountBeforeMatch = 0;
        if (lfCounter) {
          lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);
          startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch;
        } else {
          startOffset = deltaOffset + matchIndex;
        }
        let endOffset;
        if (lfCounter) {
          const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);
          const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;
          endOffset = startOffset + match0.length + lineFeedCountInMatch;
        } else {
          endOffset = startOffset + match0.length;
        }
        const startPosition = model.getPositionAt(startOffset);
        const endPosition = model.getPositionAt(endOffset);
        return new Range2(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
      }
      static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {
        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());
        const text = model.getValueInRange(
          searchRange,
          1
          /* EndOfLinePreference.LF */
        );
        const lfCounter = model.getEOL() === "\r\n" ? new LineFeedCounter(text) : null;
        const result = [];
        let counter = 0;
        let m;
        searcher.reset(0);
        while (m = searcher.next(text)) {
          result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);
          if (counter >= limitResultCount) {
            return result;
          }
        }
        return result;
      }
      static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {
        const result = [];
        let resultLen = 0;
        if (searchRange.startLineNumber === searchRange.endLineNumber) {
          const text2 = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);
          resultLen = this._findMatchesInLine(searchData, text2, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);
          return result;
        }
        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);
        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);
        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {
          resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);
        }
        if (resultLen < limitResultCount) {
          const text2 = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);
          resultLen = this._findMatchesInLine(searchData, text2, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);
        }
        return result;
      }
      static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
        const wordSeparators2 = searchData.wordSeparators;
        if (!captureMatches && searchData.simpleSearch) {
          const searchString = searchData.simpleSearch;
          const searchStringLen = searchString.length;
          const textLength = text.length;
          let lastMatchIndex = -searchStringLen;
          while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
            if (!wordSeparators2 || isValidMatch(wordSeparators2, text, textLength, lastMatchIndex, searchStringLen)) {
              result[resultLen++] = new FindMatch(new Range2(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);
              if (resultLen >= limitResultCount) {
                return resultLen;
              }
            }
          }
          return resultLen;
        }
        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
        let m;
        searcher.reset(0);
        do {
          m = searcher.next(text);
          if (m) {
            result[resultLen++] = createFindMatch(new Range2(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);
            if (resultLen >= limitResultCount) {
              return resultLen;
            }
          }
        } while (m);
        return resultLen;
      }
      static findNextMatch(model, searchParams, searchStart, captureMatches) {
        const searchData = searchParams.parseSearchRequest();
        if (!searchData) {
          return null;
        }
        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
        if (searchData.regex.multiline) {
          return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);
        }
        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);
      }
      static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {
        const searchTextStart = new Position(searchStart.lineNumber, 1);
        const deltaOffset = model.getOffsetAt(searchTextStart);
        const lineCount = model.getLineCount();
        const text = model.getValueInRange(
          new Range2(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)),
          1
          /* EndOfLinePreference.LF */
        );
        const lfCounter = model.getEOL() === "\r\n" ? new LineFeedCounter(text) : null;
        searcher.reset(searchStart.column - 1);
        const m = searcher.next(text);
        if (m) {
          return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);
        }
        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {
          return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);
        }
        return null;
      }
      static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {
        const lineCount = model.getLineCount();
        const startLineNumber = searchStart.lineNumber;
        const text = model.getLineContent(startLineNumber);
        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);
        if (r) {
          return r;
        }
        for (let i = 1; i <= lineCount; i++) {
          const lineIndex = (startLineNumber + i - 1) % lineCount;
          const text2 = model.getLineContent(lineIndex + 1);
          const r2 = this._findFirstMatchInLine(searcher, text2, lineIndex + 1, 1, captureMatches);
          if (r2) {
            return r2;
          }
        }
        return null;
      }
      static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {
        searcher.reset(fromColumn - 1);
        const m = searcher.next(text);
        if (m) {
          return createFindMatch(new Range2(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);
        }
        return null;
      }
      static findPreviousMatch(model, searchParams, searchStart, captureMatches) {
        const searchData = searchParams.parseSearchRequest();
        if (!searchData) {
          return null;
        }
        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
        if (searchData.regex.multiline) {
          return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);
        }
        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);
      }
      static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {
        const matches = this._doFindMatchesMultiline(model, new Range2(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);
        if (matches.length > 0) {
          return matches[matches.length - 1];
        }
        const lineCount = model.getLineCount();
        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {
          return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);
        }
        return null;
      }
      static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {
        const lineCount = model.getLineCount();
        const startLineNumber = searchStart.lineNumber;
        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);
        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);
        if (r) {
          return r;
        }
        for (let i = 1; i <= lineCount; i++) {
          const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;
          const text2 = model.getLineContent(lineIndex + 1);
          const r2 = this._findLastMatchInLine(searcher, text2, lineIndex + 1, captureMatches);
          if (r2) {
            return r2;
          }
        }
        return null;
      }
      static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {
        let bestResult = null;
        let m;
        searcher.reset(0);
        while (m = searcher.next(text)) {
          bestResult = createFindMatch(new Range2(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);
        }
        return bestResult;
      }
    };
    Searcher = class {
      constructor(wordSeparators2, searchRegex) {
        this._wordSeparators = wordSeparators2;
        this._searchRegex = searchRegex;
        this._prevMatchStartIndex = -1;
        this._prevMatchLength = 0;
      }
      reset(lastIndex) {
        this._searchRegex.lastIndex = lastIndex;
        this._prevMatchStartIndex = -1;
        this._prevMatchLength = 0;
      }
      next(text) {
        const textLength = text.length;
        let m;
        do {
          if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
            return null;
          }
          m = this._searchRegex.exec(text);
          if (!m) {
            return null;
          }
          const matchStartIndex = m.index;
          const matchLength = m[0].length;
          if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
            if (matchLength === 0) {
              if (getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 65535) {
                this._searchRegex.lastIndex += 2;
              } else {
                this._searchRegex.lastIndex += 1;
              }
              continue;
            }
            return null;
          }
          this._prevMatchStartIndex = matchStartIndex;
          this._prevMatchLength = matchLength;
          if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {
            return m;
          }
        } while (m);
        return null;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js
var OffsetRange, OffsetRangeSet;
var init_offsetRange = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js"() {
    init_errors();
    OffsetRange = class _OffsetRange {
      static addRange(range2, sortedRanges) {
        let i = 0;
        while (i < sortedRanges.length && sortedRanges[i].endExclusive < range2.start) {
          i++;
        }
        let j = i;
        while (j < sortedRanges.length && sortedRanges[j].start <= range2.endExclusive) {
          j++;
        }
        if (i === j) {
          sortedRanges.splice(i, 0, range2);
        } else {
          const start = Math.min(range2.start, sortedRanges[i].start);
          const end = Math.max(range2.endExclusive, sortedRanges[j - 1].endExclusive);
          sortedRanges.splice(i, j - i, new _OffsetRange(start, end));
        }
      }
      static ofLength(length) {
        return new _OffsetRange(0, length);
      }
      static ofStartAndLength(start, length) {
        return new _OffsetRange(start, start + length);
      }
      constructor(start, endExclusive) {
        this.start = start;
        this.endExclusive = endExclusive;
        if (start > endExclusive) {
          throw new BugIndicatingError(`Invalid range: ${this.toString()}`);
        }
      }
      get isEmpty() {
        return this.start === this.endExclusive;
      }
      delta(offset) {
        return new _OffsetRange(this.start + offset, this.endExclusive + offset);
      }
      deltaStart(offset) {
        return new _OffsetRange(this.start + offset, this.endExclusive);
      }
      deltaEnd(offset) {
        return new _OffsetRange(this.start, this.endExclusive + offset);
      }
      get length() {
        return this.endExclusive - this.start;
      }
      toString() {
        return `[${this.start}, ${this.endExclusive})`;
      }
      contains(offset) {
        return this.start <= offset && offset < this.endExclusive;
      }
      /**
       * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
       * The joined range is the smallest range that contains both ranges.
       */
      join(other) {
        return new _OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));
      }
      /**
       * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
       *
       * The resulting range is empty if the ranges do not intersect, but touch.
       * If the ranges don't even touch, the result is undefined.
       */
      intersect(other) {
        const start = Math.max(this.start, other.start);
        const end = Math.min(this.endExclusive, other.endExclusive);
        if (start <= end) {
          return new _OffsetRange(start, end);
        }
        return void 0;
      }
      intersects(other) {
        const start = Math.max(this.start, other.start);
        const end = Math.min(this.endExclusive, other.endExclusive);
        return start < end;
      }
      isBefore(other) {
        return this.endExclusive <= other.start;
      }
      isAfter(other) {
        return this.start >= other.endExclusive;
      }
      slice(arr) {
        return arr.slice(this.start, this.endExclusive);
      }
      /**
       * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.
       * The range must not be empty.
       */
      clip(value) {
        if (this.isEmpty) {
          throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
        }
        return Math.max(this.start, Math.min(this.endExclusive - 1, value));
      }
      /**
       * Returns `r := value + k * length` such that `r` is contained in this range.
       * The range must not be empty.
       *
       * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.
       */
      clipCyclic(value) {
        if (this.isEmpty) {
          throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
        }
        if (value < this.start) {
          return this.endExclusive - (this.start - value) % this.length;
        }
        if (value >= this.endExclusive) {
          return this.start + (value - this.start) % this.length;
        }
        return value;
      }
      forEach(f) {
        for (let i = this.start; i < this.endExclusive; i++) {
          f(i);
        }
      }
    };
    OffsetRangeSet = class _OffsetRangeSet {
      constructor() {
        this._sortedRanges = [];
      }
      addRange(range2) {
        let i = 0;
        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range2.start) {
          i++;
        }
        let j = i;
        while (j < this._sortedRanges.length && this._sortedRanges[j].start <= range2.endExclusive) {
          j++;
        }
        if (i === j) {
          this._sortedRanges.splice(i, 0, range2);
        } else {
          const start = Math.min(range2.start, this._sortedRanges[i].start);
          const end = Math.max(range2.endExclusive, this._sortedRanges[j - 1].endExclusive);
          this._sortedRanges.splice(i, j - i, new OffsetRange(start, end));
        }
      }
      toString() {
        return this._sortedRanges.map((r) => r.toString()).join(", ");
      }
      /**
       * Returns of there is a value that is contained in this instance and the given range.
       */
      intersectsStrict(other) {
        let i = 0;
        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start) {
          i++;
        }
        return i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;
      }
      intersectWithRange(other) {
        const result = new _OffsetRangeSet();
        for (const range2 of this._sortedRanges) {
          const intersection2 = range2.intersect(other);
          if (intersection2) {
            result.addRange(intersection2);
          }
        }
        return result;
      }
      intersectWithRangeLength(other) {
        return this.intersectWithRange(other).length;
      }
      get length() {
        return this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/arraysFind.js
function findLast(array, predicate, fromIdx) {
  const idx = findLastIdx(array, predicate);
  if (idx === -1) {
    return void 0;
  }
  return array[idx];
}
function findLastIdx(array, predicate, fromIndex = array.length - 1) {
  for (let i = fromIndex; i >= 0; i--) {
    const element = array[i];
    if (predicate(element)) {
      return i;
    }
  }
  return -1;
}
function findLastMonotonous(array, predicate) {
  const idx = findLastIdxMonotonous(array, predicate);
  return idx === -1 ? void 0 : array[idx];
}
function findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {
  let i = startIdx;
  let j = endIdxEx;
  while (i < j) {
    const k = Math.floor((i + j) / 2);
    if (predicate(array[k])) {
      i = k + 1;
    } else {
      j = k;
    }
  }
  return i - 1;
}
function findFirstMonotonous(array, predicate) {
  const idx = findFirstIdxMonotonousOrArrLen(array, predicate);
  return idx === array.length ? void 0 : array[idx];
}
function findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {
  let i = startIdx;
  let j = endIdxEx;
  while (i < j) {
    const k = Math.floor((i + j) / 2);
    if (predicate(array[k])) {
      j = k;
    } else {
      i = k + 1;
    }
  }
  return i;
}
function findFirstMaxBy(array, comparator) {
  if (array.length === 0) {
    return void 0;
  }
  let max = array[0];
  for (let i = 1; i < array.length; i++) {
    const item = array[i];
    if (comparator(item, max) > 0) {
      max = item;
    }
  }
  return max;
}
function findLastMaxBy(array, comparator) {
  if (array.length === 0) {
    return void 0;
  }
  let max = array[0];
  for (let i = 1; i < array.length; i++) {
    const item = array[i];
    if (comparator(item, max) >= 0) {
      max = item;
    }
  }
  return max;
}
function findFirstMinBy(array, comparator) {
  return findFirstMaxBy(array, (a, b) => -comparator(a, b));
}
function findMaxIdxBy(array, comparator) {
  if (array.length === 0) {
    return -1;
  }
  let maxIdx = 0;
  for (let i = 1; i < array.length; i++) {
    const item = array[i];
    if (comparator(item, array[maxIdx]) > 0) {
      maxIdx = i;
    }
  }
  return maxIdx;
}
function mapFindFirst(items, mapFn) {
  for (const value of items) {
    const mapped = mapFn(value);
    if (mapped !== void 0) {
      return mapped;
    }
  }
  return void 0;
}
var MonotonousArray;
var init_arraysFind = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/arraysFind.js"() {
    MonotonousArray = class _MonotonousArray {
      constructor(_array) {
        this._array = _array;
        this._findLastMonotonousLastIdx = 0;
      }
      /**
       * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!
       * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.
       */
      findLastMonotonous(predicate) {
        if (_MonotonousArray.assertInvariants) {
          if (this._prevFindLastPredicate) {
            for (const item of this._array) {
              if (this._prevFindLastPredicate(item) && !predicate(item)) {
                throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
              }
            }
          }
          this._prevFindLastPredicate = predicate;
        }
        const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);
        this._findLastMonotonousLastIdx = idx + 1;
        return idx === -1 ? void 0 : this._array[idx];
      }
    };
    MonotonousArray.assertInvariants = false;
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js
var LineRange, LineRangeSet;
var init_lineRange = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js"() {
    init_errors();
    init_offsetRange();
    init_range();
    init_arraysFind();
    LineRange = class _LineRange {
      static fromRangeInclusive(range2) {
        return new _LineRange(range2.startLineNumber, range2.endLineNumber + 1);
      }
      /**
       * @param lineRanges An array of sorted line ranges.
       */
      static joinMany(lineRanges) {
        if (lineRanges.length === 0) {
          return [];
        }
        let result = new LineRangeSet(lineRanges[0].slice());
        for (let i = 1; i < lineRanges.length; i++) {
          result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));
        }
        return result.ranges;
      }
      static ofLength(startLineNumber, length) {
        return new _LineRange(startLineNumber, startLineNumber + length);
      }
      /**
       * @internal
       */
      static deserialize(lineRange) {
        return new _LineRange(lineRange[0], lineRange[1]);
      }
      constructor(startLineNumber, endLineNumberExclusive) {
        if (startLineNumber > endLineNumberExclusive) {
          throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);
        }
        this.startLineNumber = startLineNumber;
        this.endLineNumberExclusive = endLineNumberExclusive;
      }
      /**
       * Indicates if this line range contains the given line number.
       */
      contains(lineNumber) {
        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
      }
      /**
       * Indicates if this line range is empty.
       */
      get isEmpty() {
        return this.startLineNumber === this.endLineNumberExclusive;
      }
      /**
       * Moves this line range by the given offset of line numbers.
       */
      delta(offset) {
        return new _LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);
      }
      deltaLength(offset) {
        return new _LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);
      }
      /**
       * The number of lines this line range spans.
       */
      get length() {
        return this.endLineNumberExclusive - this.startLineNumber;
      }
      /**
       * Creates a line range that combines this and the given line range.
       */
      join(other) {
        return new _LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));
      }
      toString() {
        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
      }
      /**
       * The resulting range is empty if the ranges do not intersect, but touch.
       * If the ranges don't even touch, the result is undefined.
       */
      intersect(other) {
        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);
        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);
        if (startLineNumber <= endLineNumberExclusive) {
          return new _LineRange(startLineNumber, endLineNumberExclusive);
        }
        return void 0;
      }
      intersectsStrict(other) {
        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;
      }
      overlapOrTouch(other) {
        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;
      }
      equals(b) {
        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;
      }
      toInclusiveRange() {
        if (this.isEmpty) {
          return null;
        }
        return new Range2(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
      }
      toExclusiveRange() {
        return new Range2(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
      }
      mapToLineArray(f) {
        const result = [];
        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
          result.push(f(lineNumber));
        }
        return result;
      }
      forEach(f) {
        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
          f(lineNumber);
        }
      }
      /**
       * @internal
       */
      serialize() {
        return [this.startLineNumber, this.endLineNumberExclusive];
      }
      includes(lineNumber) {
        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
      }
      /**
       * Converts this 1-based line range to a 0-based offset range (subtracts 1!).
       * @internal
       */
      toOffsetRange() {
        return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
      }
    };
    LineRangeSet = class _LineRangeSet {
      constructor(_normalizedRanges = []) {
        this._normalizedRanges = _normalizedRanges;
      }
      get ranges() {
        return this._normalizedRanges;
      }
      addRange(range2) {
        if (range2.length === 0) {
          return;
        }
        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r) => r.endLineNumberExclusive >= range2.startLineNumber);
        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= range2.endLineNumberExclusive) + 1;
        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
          this._normalizedRanges.splice(joinRangeStartIdx, 0, range2);
        } else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {
          const joinRange = this._normalizedRanges[joinRangeStartIdx];
          this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range2);
        } else {
          const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range2);
          this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);
        }
      }
      contains(lineNumber) {
        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= lineNumber);
        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;
      }
      intersects(range2) {
        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r) => r.startLineNumber < range2.endLineNumberExclusive);
        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range2.startLineNumber;
      }
      getUnion(other) {
        if (this._normalizedRanges.length === 0) {
          return other;
        }
        if (other._normalizedRanges.length === 0) {
          return this;
        }
        const result = [];
        let i1 = 0;
        let i2 = 0;
        let current = null;
        while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {
          let next = null;
          if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
            const lineRange1 = this._normalizedRanges[i1];
            const lineRange2 = other._normalizedRanges[i2];
            if (lineRange1.startLineNumber < lineRange2.startLineNumber) {
              next = lineRange1;
              i1++;
            } else {
              next = lineRange2;
              i2++;
            }
          } else if (i1 < this._normalizedRanges.length) {
            next = this._normalizedRanges[i1];
            i1++;
          } else {
            next = other._normalizedRanges[i2];
            i2++;
          }
          if (current === null) {
            current = next;
          } else {
            if (current.endLineNumberExclusive >= next.startLineNumber) {
              current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));
            } else {
              result.push(current);
              current = next;
            }
          }
        }
        if (current !== null) {
          result.push(current);
        }
        return new _LineRangeSet(result);
      }
      /**
       * Subtracts all ranges in this set from `range` and returns the result.
       */
      subtractFrom(range2) {
        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r) => r.endLineNumberExclusive >= range2.startLineNumber);
        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= range2.endLineNumberExclusive) + 1;
        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
          return new _LineRangeSet([range2]);
        }
        const result = [];
        let startLineNumber = range2.startLineNumber;
        for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {
          const r = this._normalizedRanges[i];
          if (r.startLineNumber > startLineNumber) {
            result.push(new LineRange(startLineNumber, r.startLineNumber));
          }
          startLineNumber = r.endLineNumberExclusive;
        }
        if (startLineNumber < range2.endLineNumberExclusive) {
          result.push(new LineRange(startLineNumber, range2.endLineNumberExclusive));
        }
        return new _LineRangeSet(result);
      }
      toString() {
        return this._normalizedRanges.map((r) => r.toString()).join(", ");
      }
      getIntersection(other) {
        const result = [];
        let i1 = 0;
        let i2 = 0;
        while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
          const r1 = this._normalizedRanges[i1];
          const r2 = other._normalizedRanges[i2];
          const i = r1.intersect(r2);
          if (i && !i.isEmpty) {
            result.push(i);
          }
          if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {
            i1++;
          } else {
            i2++;
          }
        }
        return new _LineRangeSet(result);
      }
      getWithDelta(value) {
        return new _LineRangeSet(this._normalizedRanges.map((r) => r.delta(value)));
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js
var editorLineHighlight, editorLineHighlightBorder, editorRangeHighlight, editorRangeHighlightBorder, editorSymbolHighlight, editorSymbolHighlightBorder, editorCursorForeground, editorCursorBackground, editorWhitespaces, editorLineNumbers, deprecatedEditorIndentGuides, deprecatedEditorActiveIndentGuides, editorIndentGuide1, editorIndentGuide2, editorIndentGuide3, editorIndentGuide4, editorIndentGuide5, editorIndentGuide6, editorActiveIndentGuide1, editorActiveIndentGuide2, editorActiveIndentGuide3, editorActiveIndentGuide4, editorActiveIndentGuide5, editorActiveIndentGuide6, deprecatedEditorActiveLineNumber, editorActiveLineNumber, editorDimmedLineNumber, editorRuler, editorCodeLensForeground, editorBracketMatchBackground, editorBracketMatchBorder, editorOverviewRulerBorder, editorOverviewRulerBackground, editorGutter, editorUnnecessaryCodeBorder, editorUnnecessaryCodeOpacity, ghostTextBorder, ghostTextForeground, ghostTextBackground, rulerRangeDefault, overviewRulerRangeHighlight, overviewRulerError, overviewRulerWarning, overviewRulerInfo, editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground, editorBracketPairGuideBackground1, editorBracketPairGuideBackground2, editorBracketPairGuideBackground3, editorBracketPairGuideBackground4, editorBracketPairGuideBackground5, editorBracketPairGuideBackground6, editorBracketPairGuideActiveBackground1, editorBracketPairGuideActiveBackground2, editorBracketPairGuideActiveBackground3, editorBracketPairGuideActiveBackground4, editorBracketPairGuideActiveBackground5, editorBracketPairGuideActiveBackground6, editorUnicodeHighlightBorder, editorUnicodeHighlightBackground;
var init_editorColorRegistry = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js"() {
    init_nls();
    init_color();
    init_colorRegistry();
    init_themeService();
    editorLineHighlight = registerColor("editor.lineHighlightBackground", { dark: null, light: null, hcDark: null, hcLight: null }, localize("lineHighlight", "Background color for the highlight of line at the cursor position."));
    editorLineHighlightBorder = registerColor("editor.lineHighlightBorder", { dark: "#282828", light: "#eeeeee", hcDark: "#f38518", hcLight: contrastBorder }, localize("lineHighlightBorderBox", "Background color for the border around the line at the cursor position."));
    editorRangeHighlight = registerColor("editor.rangeHighlightBackground", { dark: "#ffffff0b", light: "#fdff0033", hcDark: null, hcLight: null }, localize("rangeHighlight", "Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations."), true);
    editorRangeHighlightBorder = registerColor("editor.rangeHighlightBorder", { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize("rangeHighlightBorder", "Background color of the border around highlighted ranges."), true);
    editorSymbolHighlight = registerColor("editor.symbolHighlightBackground", { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, localize("symbolHighlight", "Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations."), true);
    editorSymbolHighlightBorder = registerColor("editor.symbolHighlightBorder", { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize("symbolHighlightBorder", "Background color of the border around highlighted symbols."), true);
    editorCursorForeground = registerColor("editorCursor.foreground", { dark: "#AEAFAD", light: Color.black, hcDark: Color.white, hcLight: "#0F4A85" }, localize("caret", "Color of the editor cursor."));
    editorCursorBackground = registerColor("editorCursor.background", null, localize("editorCursorBackground", "The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor."));
    editorWhitespaces = registerColor("editorWhitespace.foreground", { dark: "#e3e4e229", light: "#33333333", hcDark: "#e3e4e229", hcLight: "#CCCCCC" }, localize("editorWhitespaces", "Color of whitespace characters in the editor."));
    editorLineNumbers = registerColor("editorLineNumber.foreground", { dark: "#858585", light: "#237893", hcDark: Color.white, hcLight: "#292929" }, localize("editorLineNumbers", "Color of editor line numbers."));
    deprecatedEditorIndentGuides = registerColor("editorIndentGuide.background", { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, localize("editorIndentGuides", "Color of the editor indentation guides."), false, localize("deprecatedEditorIndentGuides", "'editorIndentGuide.background' is deprecated. Use 'editorIndentGuide.background1' instead."));
    deprecatedEditorActiveIndentGuides = registerColor("editorIndentGuide.activeBackground", { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, localize("editorActiveIndentGuide", "Color of the active editor indentation guides."), false, localize("deprecatedEditorActiveIndentGuide", "'editorIndentGuide.activeBackground' is deprecated. Use 'editorIndentGuide.activeBackground1' instead."));
    editorIndentGuide1 = registerColor("editorIndentGuide.background1", { dark: deprecatedEditorIndentGuides, light: deprecatedEditorIndentGuides, hcDark: deprecatedEditorIndentGuides, hcLight: deprecatedEditorIndentGuides }, localize("editorIndentGuides1", "Color of the editor indentation guides (1)."));
    editorIndentGuide2 = registerColor("editorIndentGuide.background2", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorIndentGuides2", "Color of the editor indentation guides (2)."));
    editorIndentGuide3 = registerColor("editorIndentGuide.background3", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorIndentGuides3", "Color of the editor indentation guides (3)."));
    editorIndentGuide4 = registerColor("editorIndentGuide.background4", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorIndentGuides4", "Color of the editor indentation guides (4)."));
    editorIndentGuide5 = registerColor("editorIndentGuide.background5", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorIndentGuides5", "Color of the editor indentation guides (5)."));
    editorIndentGuide6 = registerColor("editorIndentGuide.background6", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorIndentGuides6", "Color of the editor indentation guides (6)."));
    editorActiveIndentGuide1 = registerColor("editorIndentGuide.activeBackground1", { dark: deprecatedEditorActiveIndentGuides, light: deprecatedEditorActiveIndentGuides, hcDark: deprecatedEditorActiveIndentGuides, hcLight: deprecatedEditorActiveIndentGuides }, localize("editorActiveIndentGuide1", "Color of the active editor indentation guides (1)."));
    editorActiveIndentGuide2 = registerColor("editorIndentGuide.activeBackground2", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorActiveIndentGuide2", "Color of the active editor indentation guides (2)."));
    editorActiveIndentGuide3 = registerColor("editorIndentGuide.activeBackground3", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorActiveIndentGuide3", "Color of the active editor indentation guides (3)."));
    editorActiveIndentGuide4 = registerColor("editorIndentGuide.activeBackground4", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorActiveIndentGuide4", "Color of the active editor indentation guides (4)."));
    editorActiveIndentGuide5 = registerColor("editorIndentGuide.activeBackground5", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorActiveIndentGuide5", "Color of the active editor indentation guides (5)."));
    editorActiveIndentGuide6 = registerColor("editorIndentGuide.activeBackground6", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorActiveIndentGuide6", "Color of the active editor indentation guides (6)."));
    deprecatedEditorActiveLineNumber = registerColor("editorActiveLineNumber.foreground", { dark: "#c6c6c6", light: "#0B216F", hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize("editorActiveLineNumber", "Color of editor active line number"), false, localize("deprecatedEditorActiveLineNumber", "Id is deprecated. Use 'editorLineNumber.activeForeground' instead."));
    editorActiveLineNumber = registerColor("editorLineNumber.activeForeground", { dark: deprecatedEditorActiveLineNumber, light: deprecatedEditorActiveLineNumber, hcDark: deprecatedEditorActiveLineNumber, hcLight: deprecatedEditorActiveLineNumber }, localize("editorActiveLineNumber", "Color of editor active line number"));
    editorDimmedLineNumber = registerColor("editorLineNumber.dimmedForeground", { dark: null, light: null, hcDark: null, hcLight: null }, localize("editorDimmedLineNumber", "Color of the final editor line when editor.renderFinalNewline is set to dimmed."));
    editorRuler = registerColor("editorRuler.foreground", { dark: "#5A5A5A", light: Color.lightgrey, hcDark: Color.white, hcLight: "#292929" }, localize("editorRuler", "Color of the editor rulers."));
    editorCodeLensForeground = registerColor("editorCodeLens.foreground", { dark: "#999999", light: "#919191", hcDark: "#999999", hcLight: "#292929" }, localize("editorCodeLensForeground", "Foreground color of editor CodeLens"));
    editorBracketMatchBackground = registerColor("editorBracketMatch.background", { dark: "#0064001a", light: "#0064001a", hcDark: "#0064001a", hcLight: "#0000" }, localize("editorBracketMatchBackground", "Background color behind matching brackets"));
    editorBracketMatchBorder = registerColor("editorBracketMatch.border", { dark: "#888", light: "#B9B9B9", hcDark: contrastBorder, hcLight: contrastBorder }, localize("editorBracketMatchBorder", "Color for matching brackets boxes"));
    editorOverviewRulerBorder = registerColor("editorOverviewRuler.border", { dark: "#7f7f7f4d", light: "#7f7f7f4d", hcDark: "#7f7f7f4d", hcLight: "#666666" }, localize("editorOverviewRulerBorder", "Color of the overview ruler border."));
    editorOverviewRulerBackground = registerColor("editorOverviewRuler.background", null, localize("editorOverviewRulerBackground", "Background color of the editor overview ruler."));
    editorGutter = registerColor("editorGutter.background", { dark: editorBackground, light: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, localize("editorGutter", "Background color of the editor gutter. The gutter contains the glyph margins and the line numbers."));
    editorUnnecessaryCodeBorder = registerColor("editorUnnecessaryCode.border", { dark: null, light: null, hcDark: Color.fromHex("#fff").transparent(0.8), hcLight: contrastBorder }, localize("unnecessaryCodeBorder", "Border color of unnecessary (unused) source code in the editor."));
    editorUnnecessaryCodeOpacity = registerColor("editorUnnecessaryCode.opacity", { dark: Color.fromHex("#000a"), light: Color.fromHex("#0007"), hcDark: null, hcLight: null }, localize("unnecessaryCodeOpacity", `Opacity of unnecessary (unused) source code in the editor. For example, "#000000c0" will render the code with 75% opacity. For high contrast themes, use the  'editorUnnecessaryCode.border' theme color to underline unnecessary code instead of fading it out.`));
    ghostTextBorder = registerColor("editorGhostText.border", { dark: null, light: null, hcDark: Color.fromHex("#fff").transparent(0.8), hcLight: Color.fromHex("#292929").transparent(0.8) }, localize("editorGhostTextBorder", "Border color of ghost text in the editor."));
    ghostTextForeground = registerColor("editorGhostText.foreground", { dark: Color.fromHex("#ffffff56"), light: Color.fromHex("#0007"), hcDark: null, hcLight: null }, localize("editorGhostTextForeground", "Foreground color of the ghost text in the editor."));
    ghostTextBackground = registerColor("editorGhostText.background", { dark: null, light: null, hcDark: null, hcLight: null }, localize("editorGhostTextBackground", "Background color of the ghost text in the editor."));
    rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));
    overviewRulerRangeHighlight = registerColor("editorOverviewRuler.rangeHighlightForeground", { dark: rulerRangeDefault, light: rulerRangeDefault, hcDark: rulerRangeDefault, hcLight: rulerRangeDefault }, localize("overviewRulerRangeHighlight", "Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations."), true);
    overviewRulerError = registerColor("editorOverviewRuler.errorForeground", { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: "#B5200D" }, localize("overviewRuleError", "Overview ruler marker color for errors."));
    overviewRulerWarning = registerColor("editorOverviewRuler.warningForeground", { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, localize("overviewRuleWarning", "Overview ruler marker color for warnings."));
    overviewRulerInfo = registerColor("editorOverviewRuler.infoForeground", { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, localize("overviewRuleInfo", "Overview ruler marker color for infos."));
    editorBracketHighlightingForeground1 = registerColor("editorBracketHighlight.foreground1", { dark: "#FFD700", light: "#0431FAFF", hcDark: "#FFD700", hcLight: "#0431FAFF" }, localize("editorBracketHighlightForeground1", "Foreground color of brackets (1). Requires enabling bracket pair colorization."));
    editorBracketHighlightingForeground2 = registerColor("editorBracketHighlight.foreground2", { dark: "#DA70D6", light: "#319331FF", hcDark: "#DA70D6", hcLight: "#319331FF" }, localize("editorBracketHighlightForeground2", "Foreground color of brackets (2). Requires enabling bracket pair colorization."));
    editorBracketHighlightingForeground3 = registerColor("editorBracketHighlight.foreground3", { dark: "#179FFF", light: "#7B3814FF", hcDark: "#87CEFA", hcLight: "#7B3814FF" }, localize("editorBracketHighlightForeground3", "Foreground color of brackets (3). Requires enabling bracket pair colorization."));
    editorBracketHighlightingForeground4 = registerColor("editorBracketHighlight.foreground4", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorBracketHighlightForeground4", "Foreground color of brackets (4). Requires enabling bracket pair colorization."));
    editorBracketHighlightingForeground5 = registerColor("editorBracketHighlight.foreground5", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorBracketHighlightForeground5", "Foreground color of brackets (5). Requires enabling bracket pair colorization."));
    editorBracketHighlightingForeground6 = registerColor("editorBracketHighlight.foreground6", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorBracketHighlightForeground6", "Foreground color of brackets (6). Requires enabling bracket pair colorization."));
    editorBracketHighlightingUnexpectedBracketForeground = registerColor("editorBracketHighlight.unexpectedBracket.foreground", { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: "" }, localize("editorBracketHighlightUnexpectedBracketForeground", "Foreground color of unexpected brackets."));
    editorBracketPairGuideBackground1 = registerColor("editorBracketPairGuide.background1", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorBracketPairGuide.background1", "Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides."));
    editorBracketPairGuideBackground2 = registerColor("editorBracketPairGuide.background2", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorBracketPairGuide.background2", "Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides."));
    editorBracketPairGuideBackground3 = registerColor("editorBracketPairGuide.background3", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorBracketPairGuide.background3", "Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides."));
    editorBracketPairGuideBackground4 = registerColor("editorBracketPairGuide.background4", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorBracketPairGuide.background4", "Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides."));
    editorBracketPairGuideBackground5 = registerColor("editorBracketPairGuide.background5", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorBracketPairGuide.background5", "Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides."));
    editorBracketPairGuideBackground6 = registerColor("editorBracketPairGuide.background6", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorBracketPairGuide.background6", "Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides."));
    editorBracketPairGuideActiveBackground1 = registerColor("editorBracketPairGuide.activeBackground1", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorBracketPairGuide.activeBackground1", "Background color of active bracket pair guides (1). Requires enabling bracket pair guides."));
    editorBracketPairGuideActiveBackground2 = registerColor("editorBracketPairGuide.activeBackground2", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorBracketPairGuide.activeBackground2", "Background color of active bracket pair guides (2). Requires enabling bracket pair guides."));
    editorBracketPairGuideActiveBackground3 = registerColor("editorBracketPairGuide.activeBackground3", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorBracketPairGuide.activeBackground3", "Background color of active bracket pair guides (3). Requires enabling bracket pair guides."));
    editorBracketPairGuideActiveBackground4 = registerColor("editorBracketPairGuide.activeBackground4", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorBracketPairGuide.activeBackground4", "Background color of active bracket pair guides (4). Requires enabling bracket pair guides."));
    editorBracketPairGuideActiveBackground5 = registerColor("editorBracketPairGuide.activeBackground5", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorBracketPairGuide.activeBackground5", "Background color of active bracket pair guides (5). Requires enabling bracket pair guides."));
    editorBracketPairGuideActiveBackground6 = registerColor("editorBracketPairGuide.activeBackground6", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, localize("editorBracketPairGuide.activeBackground6", "Background color of active bracket pair guides (6). Requires enabling bracket pair guides."));
    editorUnicodeHighlightBorder = registerColor("editorUnicodeHighlight.border", { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningForeground, hcLight: editorWarningForeground }, localize("editorUnicodeHighlight.border", "Border color used to highlight unicode characters."));
    editorUnicodeHighlightBackground = registerColor("editorUnicodeHighlight.background", { dark: editorWarningBackground, light: editorWarningBackground, hcDark: editorWarningBackground, hcLight: editorWarningBackground }, localize("editorUnicodeHighlight.background", "Background color used to highlight unicode characters."));
    registerThemingParticipant((theme, collector) => {
      const background = theme.getColor(editorBackground);
      const lineHighlight = theme.getColor(editorLineHighlight);
      const imeBackground = lineHighlight && !lineHighlight.isTransparent() ? lineHighlight : background;
      if (imeBackground) {
        collector.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${imeBackground}; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js
var CursorColumns;
var init_cursorColumns = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js"() {
    init_strings();
    CursorColumns = class _CursorColumns {
      static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {
        if (codePoint === 9) {
          return _CursorColumns.nextRenderTabStop(visibleColumn, tabSize);
        }
        if (isFullWidthCharacter(codePoint) || isEmojiImprecise(codePoint)) {
          return visibleColumn + 2;
        }
        return visibleColumn + 1;
      }
      /**
       * Returns a visible column from a column.
       * @see {@link CursorColumns}
       */
      static visibleColumnFromColumn(lineContent, column, tabSize) {
        const textLen = Math.min(column - 1, lineContent.length);
        const text = lineContent.substring(0, textLen);
        const iterator = new GraphemeIterator(text);
        let result = 0;
        while (!iterator.eol()) {
          const codePoint = getNextCodePoint(text, textLen, iterator.offset);
          iterator.nextGraphemeLength();
          result = this._nextVisibleColumn(codePoint, result, tabSize);
        }
        return result;
      }
      /**
       * Returns a column from a visible column.
       * @see {@link CursorColumns}
       */
      static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {
        if (visibleColumn <= 0) {
          return 1;
        }
        const lineContentLength = lineContent.length;
        const iterator = new GraphemeIterator(lineContent);
        let beforeVisibleColumn = 0;
        let beforeColumn = 1;
        while (!iterator.eol()) {
          const codePoint = getNextCodePoint(lineContent, lineContentLength, iterator.offset);
          iterator.nextGraphemeLength();
          const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);
          const afterColumn = iterator.offset + 1;
          if (afterVisibleColumn >= visibleColumn) {
            const beforeDelta = visibleColumn - beforeVisibleColumn;
            const afterDelta = afterVisibleColumn - visibleColumn;
            if (afterDelta < beforeDelta) {
              return afterColumn;
            } else {
              return beforeColumn;
            }
          }
          beforeVisibleColumn = afterVisibleColumn;
          beforeColumn = afterColumn;
        }
        return lineContentLength + 1;
      }
      /**
       * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
       * @see {@link CursorColumns}
       */
      static nextRenderTabStop(visibleColumn, tabSize) {
        return visibleColumn + tabSize - visibleColumn % tabSize;
      }
      /**
       * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
       * @see {@link CursorColumns}
       */
      static nextIndentTabStop(visibleColumn, indentSize) {
        return visibleColumn + indentSize - visibleColumn % indentSize;
      }
      /**
       * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
       * @see {@link CursorColumns}
       */
      static prevRenderTabStop(column, tabSize) {
        return Math.max(0, column - 1 - (column - 1) % tabSize);
      }
      /**
       * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
       * @see {@link CursorColumns}
       */
      static prevIndentTabStop(column, indentSize) {
        return Math.max(0, column - 1 - (column - 1) % indentSize);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js
function _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {
  let spacesCnt = 0;
  for (let i = 0; i < str.length; i++) {
    if (str.charAt(i) === "	") {
      spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);
    } else {
      spacesCnt++;
    }
  }
  let result = "";
  if (!insertSpaces) {
    const tabsCnt = Math.floor(spacesCnt / indentSize);
    spacesCnt = spacesCnt % indentSize;
    for (let i = 0; i < tabsCnt; i++) {
      result += "	";
    }
  }
  for (let i = 0; i < spacesCnt; i++) {
    result += " ";
  }
  return result;
}
function normalizeIndentation(str, indentSize, insertSpaces) {
  let firstNonWhitespaceIndex2 = firstNonWhitespaceIndex(str);
  if (firstNonWhitespaceIndex2 === -1) {
    firstNonWhitespaceIndex2 = str.length;
  }
  return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex2), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex2);
}
var init_indentation = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js"() {
    init_strings();
    init_cursorColumns();
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js
var BracketInfo, BracketPairInfo, BracketPairWithMinIndentationInfo;
var init_textModelBracketPairs = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js"() {
    BracketInfo = class {
      constructor(range2, nestingLevel, nestingLevelOfEqualBracketType, isInvalid) {
        this.range = range2;
        this.nestingLevel = nestingLevel;
        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;
        this.isInvalid = isInvalid;
      }
    };
    BracketPairInfo = class {
      constructor(range2, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode) {
        this.range = range2;
        this.openingBracketRange = openingBracketRange;
        this.closingBracketRange = closingBracketRange;
        this.nestingLevel = nestingLevel;
        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;
        this.bracketPairNode = bracketPairNode;
      }
      get openingBracketInfo() {
        return this.bracketPairNode.openingBracket.bracketInfo;
      }
    };
    BracketPairWithMinIndentationInfo = class extends BracketPairInfo {
      constructor(range2, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode, minVisibleColumnIndentation) {
        super(range2, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode);
        this.minVisibleColumnIndentation = minVisibleColumnIndentation;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js
function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {
  return startLineCount !== endLineCount ? toLength(endLineCount - startLineCount, endColumnCount) : toLength(0, endColumnCount - startColumnCount);
}
function lengthIsZero(length) {
  return length === 0;
}
function toLength(lineCount, columnCount) {
  return lineCount * factor + columnCount;
}
function lengthToObj(length) {
  const l = length;
  const lineCount = Math.floor(l / factor);
  const columnCount = l - lineCount * factor;
  return new LengthObj(lineCount, columnCount);
}
function lengthGetLineCount(length) {
  return Math.floor(length / factor);
}
function lengthGetColumnCountIfZeroLineCount(length) {
  return length;
}
function lengthAdd(l1, l2) {
  let r = l1 + l2;
  if (l2 >= factor) {
    r = r - l1 % factor;
  }
  return r;
}
function sumLengths(items, lengthFn) {
  return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);
}
function lengthEquals(length1, length2) {
  return length1 === length2;
}
function lengthDiffNonNegative(length1, length2) {
  const l1 = length1;
  const l2 = length2;
  const diff = l2 - l1;
  if (diff <= 0) {
    return lengthZero;
  }
  const lineCount1 = Math.floor(l1 / factor);
  const lineCount2 = Math.floor(l2 / factor);
  const colCount2 = l2 - lineCount2 * factor;
  if (lineCount1 === lineCount2) {
    const colCount1 = l1 - lineCount1 * factor;
    return toLength(0, colCount2 - colCount1);
  } else {
    return toLength(lineCount2 - lineCount1, colCount2);
  }
}
function lengthLessThan(length1, length2) {
  return length1 < length2;
}
function lengthLessThanEqual(length1, length2) {
  return length1 <= length2;
}
function lengthGreaterThanEqual(length1, length2) {
  return length1 >= length2;
}
function positionToLength(position) {
  return toLength(position.lineNumber - 1, position.column - 1);
}
function lengthsToRange(lengthStart, lengthEnd) {
  const l = lengthStart;
  const lineCount = Math.floor(l / factor);
  const colCount = l - lineCount * factor;
  const l2 = lengthEnd;
  const lineCount2 = Math.floor(l2 / factor);
  const colCount2 = l2 - lineCount2 * factor;
  return new Range2(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);
}
function lengthOfString(str) {
  const lines = splitLines(str);
  return toLength(lines.length - 1, lines[lines.length - 1].length);
}
var LengthObj, lengthZero, factor;
var init_length = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js"() {
    init_strings();
    init_range();
    LengthObj = class {
      constructor(lineCount, columnCount) {
        this.lineCount = lineCount;
        this.columnCount = columnCount;
      }
      toString() {
        return `${this.lineCount},${this.columnCount}`;
      }
    };
    LengthObj.zero = new LengthObj(0, 0);
    lengthZero = 0;
    factor = 2 ** 26;
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js
var TextEditInfo, BeforeEditPositionMapper, TextEditInfoCache;
var init_beforeEditPositionMapper = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js"() {
    init_range();
    init_length();
    TextEditInfo = class _TextEditInfo {
      static fromModelContentChanges(changes) {
        const edits = changes.map((c) => {
          const range2 = Range2.lift(c.range);
          return new _TextEditInfo(positionToLength(range2.getStartPosition()), positionToLength(range2.getEndPosition()), lengthOfString(c.text));
        }).reverse();
        return edits;
      }
      constructor(startOffset, endOffset, newLength) {
        this.startOffset = startOffset;
        this.endOffset = endOffset;
        this.newLength = newLength;
      }
      toString() {
        return `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;
      }
    };
    BeforeEditPositionMapper = class {
      /**
       * @param edits Must be sorted by offset in ascending order.
      */
      constructor(edits) {
        this.nextEditIdx = 0;
        this.deltaOldToNewLineCount = 0;
        this.deltaOldToNewColumnCount = 0;
        this.deltaLineIdxInOld = -1;
        this.edits = edits.map((edit) => TextEditInfoCache.from(edit));
      }
      /**
       * @param offset Must be equal to or greater than the last offset this method has been called with.
      */
      getOffsetBeforeChange(offset) {
        this.adjustNextEdit(offset);
        return this.translateCurToOld(offset);
      }
      /**
       * @param offset Must be equal to or greater than the last offset this method has been called with.
       * Returns null if there is no edit anymore.
      */
      getDistanceToNextChange(offset) {
        this.adjustNextEdit(offset);
        const nextEdit = this.edits[this.nextEditIdx];
        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;
        if (nextChangeOffset === null) {
          return null;
        }
        return lengthDiffNonNegative(offset, nextChangeOffset);
      }
      translateOldToCur(oldOffsetObj) {
        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {
          return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);
        } else {
          return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);
        }
      }
      translateCurToOld(newOffset) {
        const offsetObj = lengthToObj(newOffset);
        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {
          return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);
        } else {
          return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);
        }
      }
      adjustNextEdit(offset) {
        while (this.nextEditIdx < this.edits.length) {
          const nextEdit = this.edits[this.nextEditIdx];
          const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);
          if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {
            this.nextEditIdx++;
            const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);
            const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));
            const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;
            this.deltaOldToNewLineCount += lineDelta;
            const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;
            const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;
            this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;
            this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;
          } else {
            break;
          }
        }
      }
    };
    TextEditInfoCache = class _TextEditInfoCache {
      static from(edit) {
        return new _TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);
      }
      constructor(startOffset, endOffset, textLength) {
        this.endOffsetBeforeObj = lengthToObj(endOffset);
        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));
        this.offsetObj = lengthToObj(startOffset);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js
var emptyArr, SmallImmutableSet, identityKeyProvider, DenseKeyProvider;
var init_smallImmutableSet = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js"() {
    emptyArr = [];
    SmallImmutableSet = class _SmallImmutableSet {
      static create(items, additionalItems) {
        if (items <= 128 && additionalItems.length === 0) {
          let cached = _SmallImmutableSet.cache[items];
          if (!cached) {
            cached = new _SmallImmutableSet(items, additionalItems);
            _SmallImmutableSet.cache[items] = cached;
          }
          return cached;
        }
        return new _SmallImmutableSet(items, additionalItems);
      }
      static getEmpty() {
        return this.empty;
      }
      constructor(items, additionalItems) {
        this.items = items;
        this.additionalItems = additionalItems;
      }
      add(value, keyProvider) {
        const key = keyProvider.getKey(value);
        let idx = key >> 5;
        if (idx === 0) {
          const newItem = 1 << key | this.items;
          if (newItem === this.items) {
            return this;
          }
          return _SmallImmutableSet.create(newItem, this.additionalItems);
        }
        idx--;
        const newItems = this.additionalItems.slice(0);
        while (newItems.length < idx) {
          newItems.push(0);
        }
        newItems[idx] |= 1 << (key & 31);
        return _SmallImmutableSet.create(this.items, newItems);
      }
      merge(other) {
        const merged = this.items | other.items;
        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {
          if (merged === this.items) {
            return this;
          }
          if (merged === other.items) {
            return other;
          }
          return _SmallImmutableSet.create(merged, emptyArr);
        }
        const newItems = [];
        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {
          const item1 = this.additionalItems[i] || 0;
          const item2 = other.additionalItems[i] || 0;
          newItems.push(item1 | item2);
        }
        return _SmallImmutableSet.create(merged, newItems);
      }
      intersects(other) {
        if ((this.items & other.items) !== 0) {
          return true;
        }
        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {
          if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {
            return true;
          }
        }
        return false;
      }
    };
    SmallImmutableSet.cache = new Array(129);
    SmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);
    identityKeyProvider = {
      getKey(value) {
        return value;
      }
    };
    DenseKeyProvider = class {
      constructor() {
        this.items = /* @__PURE__ */ new Map();
      }
      getKey(value) {
        let existing = this.items.get(value);
        if (existing === void 0) {
          existing = this.items.size;
          this.items.set(value, existing);
        }
        return existing;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js
var BaseAstNode, PairAstNode, ListAstNode, TwoThreeListAstNode, Immutable23ListAstNode, ArrayListAstNode, ImmutableArrayListAstNode, emptyArray, ImmutableLeafAstNode, TextAstNode, BracketAstNode, InvalidBracketAstNode;
var init_ast = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js"() {
    init_errors();
    init_cursorColumns();
    init_length();
    init_smallImmutableSet();
    BaseAstNode = class {
      /**
       * The length of the entire node, which should equal the sum of lengths of all children.
      */
      get length() {
        return this._length;
      }
      constructor(length) {
        this._length = length;
      }
    };
    PairAstNode = class _PairAstNode extends BaseAstNode {
      static create(openingBracket, child, closingBracket) {
        let length = openingBracket.length;
        if (child) {
          length = lengthAdd(length, child.length);
        }
        if (closingBracket) {
          length = lengthAdd(length, closingBracket.length);
        }
        return new _PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());
      }
      get kind() {
        return 2;
      }
      get listHeight() {
        return 0;
      }
      get childrenLength() {
        return 3;
      }
      getChild(idx) {
        switch (idx) {
          case 0:
            return this.openingBracket;
          case 1:
            return this.child;
          case 2:
            return this.closingBracket;
        }
        throw new Error("Invalid child index");
      }
      /**
       * Avoid using this property, it allocates an array!
      */
      get children() {
        const result = [];
        result.push(this.openingBracket);
        if (this.child) {
          result.push(this.child);
        }
        if (this.closingBracket) {
          result.push(this.closingBracket);
        }
        return result;
      }
      constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {
        super(length);
        this.openingBracket = openingBracket;
        this.child = child;
        this.closingBracket = closingBracket;
        this.missingOpeningBracketIds = missingOpeningBracketIds;
      }
      canBeReused(openBracketIds) {
        if (this.closingBracket === null) {
          return false;
        }
        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {
          return false;
        }
        return true;
      }
      deepClone() {
        return new _PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);
      }
      computeMinIndentation(offset, textModel) {
        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;
      }
    };
    ListAstNode = class extends BaseAstNode {
      /**
       * This method uses more memory-efficient list nodes that can only store 2 or 3 children.
      */
      static create23(item1, item2, item3, immutable = false) {
        let length = item1.length;
        let missingBracketIds = item1.missingOpeningBracketIds;
        if (item1.listHeight !== item2.listHeight) {
          throw new Error("Invalid list heights");
        }
        length = lengthAdd(length, item2.length);
        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);
        if (item3) {
          if (item1.listHeight !== item3.listHeight) {
            throw new Error("Invalid list heights");
          }
          length = lengthAdd(length, item3.length);
          missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);
        }
        return immutable ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds) : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);
      }
      static getEmpty() {
        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());
      }
      get kind() {
        return 4;
      }
      get missingOpeningBracketIds() {
        return this._missingOpeningBracketIds;
      }
      /**
       * Use ListAstNode.create.
      */
      constructor(length, listHeight, _missingOpeningBracketIds) {
        super(length);
        this.listHeight = listHeight;
        this._missingOpeningBracketIds = _missingOpeningBracketIds;
        this.cachedMinIndentation = -1;
      }
      throwIfImmutable() {
      }
      makeLastElementMutable() {
        this.throwIfImmutable();
        const childCount = this.childrenLength;
        if (childCount === 0) {
          return void 0;
        }
        const lastChild = this.getChild(childCount - 1);
        const mutable = lastChild.kind === 4 ? lastChild.toMutable() : lastChild;
        if (lastChild !== mutable) {
          this.setChild(childCount - 1, mutable);
        }
        return mutable;
      }
      makeFirstElementMutable() {
        this.throwIfImmutable();
        const childCount = this.childrenLength;
        if (childCount === 0) {
          return void 0;
        }
        const firstChild = this.getChild(0);
        const mutable = firstChild.kind === 4 ? firstChild.toMutable() : firstChild;
        if (firstChild !== mutable) {
          this.setChild(0, mutable);
        }
        return mutable;
      }
      canBeReused(openBracketIds) {
        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {
          return false;
        }
        if (this.childrenLength === 0) {
          return false;
        }
        let lastChild = this;
        while (lastChild.kind === 4) {
          const lastLength = lastChild.childrenLength;
          if (lastLength === 0) {
            throw new BugIndicatingError();
          }
          lastChild = lastChild.getChild(lastLength - 1);
        }
        return lastChild.canBeReused(openBracketIds);
      }
      handleChildrenChanged() {
        this.throwIfImmutable();
        const count = this.childrenLength;
        let length = this.getChild(0).length;
        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;
        for (let i = 1; i < count; i++) {
          const child = this.getChild(i);
          length = lengthAdd(length, child.length);
          unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);
        }
        this._length = length;
        this._missingOpeningBracketIds = unopenedBrackets;
        this.cachedMinIndentation = -1;
      }
      computeMinIndentation(offset, textModel) {
        if (this.cachedMinIndentation !== -1) {
          return this.cachedMinIndentation;
        }
        let minIndentation = Number.MAX_SAFE_INTEGER;
        let childOffset = offset;
        for (let i = 0; i < this.childrenLength; i++) {
          const child = this.getChild(i);
          if (child) {
            minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));
            childOffset = lengthAdd(childOffset, child.length);
          }
        }
        this.cachedMinIndentation = minIndentation;
        return minIndentation;
      }
    };
    TwoThreeListAstNode = class _TwoThreeListAstNode extends ListAstNode {
      get childrenLength() {
        return this._item3 !== null ? 3 : 2;
      }
      getChild(idx) {
        switch (idx) {
          case 0:
            return this._item1;
          case 1:
            return this._item2;
          case 2:
            return this._item3;
        }
        throw new Error("Invalid child index");
      }
      setChild(idx, node) {
        switch (idx) {
          case 0:
            this._item1 = node;
            return;
          case 1:
            this._item2 = node;
            return;
          case 2:
            this._item3 = node;
            return;
        }
        throw new Error("Invalid child index");
      }
      get children() {
        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];
      }
      get item1() {
        return this._item1;
      }
      get item2() {
        return this._item2;
      }
      get item3() {
        return this._item3;
      }
      constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {
        super(length, listHeight, missingOpeningBracketIds);
        this._item1 = _item1;
        this._item2 = _item2;
        this._item3 = _item3;
      }
      deepClone() {
        return new _TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);
      }
      appendChildOfSameHeight(node) {
        if (this._item3) {
          throw new Error("Cannot append to a full (2,3) tree node");
        }
        this.throwIfImmutable();
        this._item3 = node;
        this.handleChildrenChanged();
      }
      unappendChild() {
        if (!this._item3) {
          throw new Error("Cannot remove from a non-full (2,3) tree node");
        }
        this.throwIfImmutable();
        const result = this._item3;
        this._item3 = null;
        this.handleChildrenChanged();
        return result;
      }
      prependChildOfSameHeight(node) {
        if (this._item3) {
          throw new Error("Cannot prepend to a full (2,3) tree node");
        }
        this.throwIfImmutable();
        this._item3 = this._item2;
        this._item2 = this._item1;
        this._item1 = node;
        this.handleChildrenChanged();
      }
      unprependChild() {
        if (!this._item3) {
          throw new Error("Cannot remove from a non-full (2,3) tree node");
        }
        this.throwIfImmutable();
        const result = this._item1;
        this._item1 = this._item2;
        this._item2 = this._item3;
        this._item3 = null;
        this.handleChildrenChanged();
        return result;
      }
      toMutable() {
        return this;
      }
    };
    Immutable23ListAstNode = class extends TwoThreeListAstNode {
      toMutable() {
        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);
      }
      throwIfImmutable() {
        throw new Error("this instance is immutable");
      }
    };
    ArrayListAstNode = class _ArrayListAstNode extends ListAstNode {
      get childrenLength() {
        return this._children.length;
      }
      getChild(idx) {
        return this._children[idx];
      }
      setChild(idx, child) {
        this._children[idx] = child;
      }
      get children() {
        return this._children;
      }
      constructor(length, listHeight, _children, missingOpeningBracketIds) {
        super(length, listHeight, missingOpeningBracketIds);
        this._children = _children;
      }
      deepClone() {
        const children = new Array(this._children.length);
        for (let i = 0; i < this._children.length; i++) {
          children[i] = this._children[i].deepClone();
        }
        return new _ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);
      }
      appendChildOfSameHeight(node) {
        this.throwIfImmutable();
        this._children.push(node);
        this.handleChildrenChanged();
      }
      unappendChild() {
        this.throwIfImmutable();
        const item = this._children.pop();
        this.handleChildrenChanged();
        return item;
      }
      prependChildOfSameHeight(node) {
        this.throwIfImmutable();
        this._children.unshift(node);
        this.handleChildrenChanged();
      }
      unprependChild() {
        this.throwIfImmutable();
        const item = this._children.shift();
        this.handleChildrenChanged();
        return item;
      }
      toMutable() {
        return this;
      }
    };
    ImmutableArrayListAstNode = class extends ArrayListAstNode {
      toMutable() {
        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);
      }
      throwIfImmutable() {
        throw new Error("this instance is immutable");
      }
    };
    emptyArray = [];
    ImmutableLeafAstNode = class extends BaseAstNode {
      get listHeight() {
        return 0;
      }
      get childrenLength() {
        return 0;
      }
      getChild(idx) {
        return null;
      }
      get children() {
        return emptyArray;
      }
      deepClone() {
        return this;
      }
    };
    TextAstNode = class extends ImmutableLeafAstNode {
      get kind() {
        return 0;
      }
      get missingOpeningBracketIds() {
        return SmallImmutableSet.getEmpty();
      }
      canBeReused(_openedBracketIds) {
        return true;
      }
      computeMinIndentation(offset, textModel) {
        const start = lengthToObj(offset);
        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;
        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;
        let result = Number.MAX_SAFE_INTEGER;
        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
          const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);
          const lineContent = textModel.getLineContent(lineNumber);
          if (firstNonWsColumn === 0) {
            continue;
          }
          const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);
          result = Math.min(result, visibleColumn);
        }
        return result;
      }
    };
    BracketAstNode = class _BracketAstNode extends ImmutableLeafAstNode {
      static create(length, bracketInfo, bracketIds) {
        const node = new _BracketAstNode(length, bracketInfo, bracketIds);
        return node;
      }
      get kind() {
        return 1;
      }
      get missingOpeningBracketIds() {
        return SmallImmutableSet.getEmpty();
      }
      constructor(length, bracketInfo, bracketIds) {
        super(length);
        this.bracketInfo = bracketInfo;
        this.bracketIds = bracketIds;
      }
      get text() {
        return this.bracketInfo.bracketText;
      }
      get languageId() {
        return this.bracketInfo.languageId;
      }
      canBeReused(_openedBracketIds) {
        return false;
      }
      computeMinIndentation(offset, textModel) {
        return Number.MAX_SAFE_INTEGER;
      }
    };
    InvalidBracketAstNode = class extends ImmutableLeafAstNode {
      get kind() {
        return 3;
      }
      constructor(closingBrackets, length) {
        super(length);
        this.missingOpeningBracketIds = closingBrackets;
      }
      canBeReused(openedBracketIds) {
        return !openedBracketIds.intersects(this.missingOpeningBracketIds);
      }
      computeMinIndentation(offset, textModel) {
        return Number.MAX_SAFE_INTEGER;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js
var Token2, TextBufferTokenizer, NonPeekableTextBufferTokenizer, FastTokenizer;
var init_tokenizer = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js"() {
    init_errors();
    init_encodedTokenAttributes();
    init_ast();
    init_length();
    init_smallImmutableSet();
    Token2 = class {
      constructor(length, kind, bracketId, bracketIds, astNode) {
        this.length = length;
        this.kind = kind;
        this.bracketId = bracketId;
        this.bracketIds = bracketIds;
        this.astNode = astNode;
      }
    };
    TextBufferTokenizer = class {
      constructor(textModel, bracketTokens) {
        this.textModel = textModel;
        this.bracketTokens = bracketTokens;
        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);
        this._offset = lengthZero;
        this.didPeek = false;
        this.peeked = null;
        this.textBufferLineCount = textModel.getLineCount();
        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);
      }
      get offset() {
        return this._offset;
      }
      get length() {
        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);
      }
      skip(length) {
        this.didPeek = false;
        this._offset = lengthAdd(this._offset, length);
        const obj = lengthToObj(this._offset);
        this.reader.setPosition(obj.lineCount, obj.columnCount);
      }
      read() {
        let token;
        if (this.peeked) {
          this.didPeek = false;
          token = this.peeked;
        } else {
          token = this.reader.read();
        }
        if (token) {
          this._offset = lengthAdd(this._offset, token.length);
        }
        return token;
      }
      peek() {
        if (!this.didPeek) {
          this.peeked = this.reader.read();
          this.didPeek = true;
        }
        return this.peeked;
      }
    };
    NonPeekableTextBufferTokenizer = class {
      constructor(textModel, bracketTokens) {
        this.textModel = textModel;
        this.bracketTokens = bracketTokens;
        this.lineIdx = 0;
        this.line = null;
        this.lineCharOffset = 0;
        this.lineTokens = null;
        this.lineTokenOffset = 0;
        this.peekedToken = null;
        this.textBufferLineCount = textModel.getLineCount();
        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);
      }
      setPosition(lineIdx, column) {
        if (lineIdx === this.lineIdx) {
          this.lineCharOffset = column;
          if (this.line !== null) {
            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);
          }
        } else {
          this.lineIdx = lineIdx;
          this.lineCharOffset = column;
          this.line = null;
        }
        this.peekedToken = null;
      }
      read() {
        if (this.peekedToken) {
          const token = this.peekedToken;
          this.peekedToken = null;
          this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);
          return token;
        }
        if (this.lineIdx > this.textBufferLineCount - 1 || this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength) {
          return null;
        }
        if (this.line === null) {
          this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);
          this.line = this.lineTokens.getLineContent();
          this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);
        }
        const startLineIdx = this.lineIdx;
        const startLineCharOffset = this.lineCharOffset;
        let lengthHeuristic = 0;
        while (true) {
          const lineTokens = this.lineTokens;
          const tokenCount = lineTokens.getCount();
          let peekedBracketToken = null;
          if (this.lineTokenOffset < tokenCount) {
            const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);
            while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {
              this.lineTokenOffset++;
            }
            const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0;
            const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);
            const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);
            if (containsBracketType && isOther && this.lineCharOffset < endOffset) {
              const languageId = lineTokens.getLanguageId(this.lineTokenOffset);
              const text = this.line.substring(this.lineCharOffset, endOffset);
              const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);
              const regexp = brackets.regExpGlobal;
              if (regexp) {
                regexp.lastIndex = 0;
                const match2 = regexp.exec(text);
                if (match2) {
                  peekedBracketToken = brackets.getToken(match2[0]);
                  if (peekedBracketToken) {
                    this.lineCharOffset += match2.index;
                  }
                }
              }
            }
            lengthHeuristic += endOffset - this.lineCharOffset;
            if (peekedBracketToken) {
              if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {
                this.peekedToken = peekedBracketToken;
                break;
              } else {
                this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);
                return peekedBracketToken;
              }
            } else {
              this.lineTokenOffset++;
              this.lineCharOffset = endOffset;
            }
          } else {
            if (this.lineIdx === this.textBufferLineCount - 1) {
              break;
            }
            this.lineIdx++;
            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);
            this.lineTokenOffset = 0;
            this.line = this.lineTokens.getLineContent();
            this.lineCharOffset = 0;
            lengthHeuristic += 33;
            if (lengthHeuristic > 1e3) {
              break;
            }
          }
          if (lengthHeuristic > 1500) {
            break;
          }
        }
        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);
        return new Token2(length, 0, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));
      }
    };
    FastTokenizer = class {
      constructor(text, brackets) {
        this.text = text;
        this._offset = lengthZero;
        this.idx = 0;
        const regExpStr = brackets.getRegExpStr();
        const regexp = regExpStr ? new RegExp(regExpStr + "|\n", "gi") : null;
        const tokens = [];
        let match2;
        let curLineCount = 0;
        let lastLineBreakOffset = 0;
        let lastTokenEndOffset = 0;
        let lastTokenEndLine = 0;
        const smallTextTokens0Line = [];
        for (let i = 0; i < 60; i++) {
          smallTextTokens0Line.push(new Token2(toLength(0, i), 0, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));
        }
        const smallTextTokens1Line = [];
        for (let i = 0; i < 60; i++) {
          smallTextTokens1Line.push(new Token2(toLength(1, i), 0, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));
        }
        if (regexp) {
          regexp.lastIndex = 0;
          while ((match2 = regexp.exec(text)) !== null) {
            const curOffset = match2.index;
            const value = match2[0];
            if (value === "\n") {
              curLineCount++;
              lastLineBreakOffset = curOffset + 1;
            } else {
              if (lastTokenEndOffset !== curOffset) {
                let token;
                if (lastTokenEndLine === curLineCount) {
                  const colCount = curOffset - lastTokenEndOffset;
                  if (colCount < smallTextTokens0Line.length) {
                    token = smallTextTokens0Line[colCount];
                  } else {
                    const length = toLength(0, colCount);
                    token = new Token2(length, 0, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));
                  }
                } else {
                  const lineCount = curLineCount - lastTokenEndLine;
                  const colCount = curOffset - lastLineBreakOffset;
                  if (lineCount === 1 && colCount < smallTextTokens1Line.length) {
                    token = smallTextTokens1Line[colCount];
                  } else {
                    const length = toLength(lineCount, colCount);
                    token = new Token2(length, 0, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));
                  }
                }
                tokens.push(token);
              }
              tokens.push(brackets.getToken(value));
              lastTokenEndOffset = curOffset + value.length;
              lastTokenEndLine = curLineCount;
            }
          }
        }
        const offset = text.length;
        if (lastTokenEndOffset !== offset) {
          const length = lastTokenEndLine === curLineCount ? toLength(0, offset - lastTokenEndOffset) : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);
          tokens.push(new Token2(length, 0, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));
        }
        this.length = toLength(curLineCount, offset - lastLineBreakOffset);
        this.tokens = tokens;
      }
      get offset() {
        return this._offset;
      }
      read() {
        return this.tokens[this.idx++] || null;
      }
      peek() {
        return this.tokens[this.idx] || null;
      }
      skip(length) {
        throw new NotSupportedError();
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js
function prepareBracketForRegExp2(str) {
  let escaped = escapeRegExpCharacters(str);
  if (/^[\w ]+/.test(str)) {
    escaped = `\\b${escaped}`;
  }
  if (/[\w ]+$/.test(str)) {
    escaped = `${escaped}\\b`;
  }
  return escaped;
}
var BracketTokens, LanguageAgnosticBracketTokens;
var init_brackets = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js"() {
    init_strings();
    init_ast();
    init_length();
    init_smallImmutableSet();
    init_tokenizer();
    BracketTokens = class _BracketTokens {
      static createFromLanguage(configuration, denseKeyProvider) {
        function getId(bracketInfo) {
          return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);
        }
        const map = /* @__PURE__ */ new Map();
        for (const openingBracket of configuration.bracketsNew.openingBrackets) {
          const length = toLength(0, openingBracket.bracketText.length);
          const openingTextId = getId(openingBracket);
          const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);
          map.set(openingBracket.bracketText, new Token2(length, 1, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));
        }
        for (const closingBracket of configuration.bracketsNew.closingBrackets) {
          const length = toLength(0, closingBracket.bracketText.length);
          let bracketIds = SmallImmutableSet.getEmpty();
          const closingBrackets = closingBracket.getOpeningBrackets();
          for (const bracket of closingBrackets) {
            bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);
          }
          map.set(closingBracket.bracketText, new Token2(length, 2, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));
        }
        return new _BracketTokens(map);
      }
      constructor(map) {
        this.map = map;
        this.hasRegExp = false;
        this._regExpGlobal = null;
      }
      getRegExpStr() {
        if (this.isEmpty) {
          return null;
        } else {
          const keys = [...this.map.keys()];
          keys.sort();
          keys.reverse();
          return keys.map((k) => prepareBracketForRegExp2(k)).join("|");
        }
      }
      /**
       * Returns null if there is no such regexp (because there are no brackets).
      */
      get regExpGlobal() {
        if (!this.hasRegExp) {
          const regExpStr = this.getRegExpStr();
          this._regExpGlobal = regExpStr ? new RegExp(regExpStr, "gi") : null;
          this.hasRegExp = true;
        }
        return this._regExpGlobal;
      }
      getToken(value) {
        return this.map.get(value.toLowerCase());
      }
      findClosingTokenText(openingBracketIds) {
        for (const [closingText, info] of this.map) {
          if (info.kind === 2 && info.bracketIds.intersects(openingBracketIds)) {
            return closingText;
          }
        }
        return void 0;
      }
      get isEmpty() {
        return this.map.size === 0;
      }
    };
    LanguageAgnosticBracketTokens = class {
      constructor(denseKeyProvider, getLanguageConfiguration) {
        this.denseKeyProvider = denseKeyProvider;
        this.getLanguageConfiguration = getLanguageConfiguration;
        this.languageIdToBracketTokens = /* @__PURE__ */ new Map();
      }
      didLanguageChange(languageId) {
        return this.languageIdToBracketTokens.has(languageId);
      }
      getSingleLanguageBracketTokens(languageId) {
        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);
        if (!singleLanguageBracketTokens) {
          singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);
          this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);
        }
        return singleLanguageBracketTokens;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js
function concat23Trees(items) {
  if (items.length === 0) {
    return null;
  }
  if (items.length === 1) {
    return items[0];
  }
  let i = 0;
  function readNode() {
    if (i >= items.length) {
      return null;
    }
    const start = i;
    const height = items[start].listHeight;
    i++;
    while (i < items.length && items[i].listHeight === height) {
      i++;
    }
    if (i - start >= 2) {
      return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);
    } else {
      return items[start];
    }
  }
  let first = readNode();
  let second = readNode();
  if (!second) {
    return first;
  }
  for (let item = readNode(); item; item = readNode()) {
    if (heightDiff(first, second) <= heightDiff(second, item)) {
      first = concat2(first, second);
      second = item;
    } else {
      second = concat2(second, item);
    }
  }
  const result = concat2(first, second);
  return result;
}
function concat23TreesOfSameHeight(items, createImmutableLists = false) {
  if (items.length === 0) {
    return null;
  }
  if (items.length === 1) {
    return items[0];
  }
  let length = items.length;
  while (length > 3) {
    const newLength = length >> 1;
    for (let i = 0; i < newLength; i++) {
      const j = i << 1;
      items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);
    }
    length = newLength;
  }
  return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);
}
function heightDiff(node1, node2) {
  return Math.abs(node1.listHeight - node2.listHeight);
}
function concat2(node1, node2) {
  if (node1.listHeight === node2.listHeight) {
    return ListAstNode.create23(node1, node2, null, false);
  } else if (node1.listHeight > node2.listHeight) {
    return append2(node1, node2);
  } else {
    return prepend2(node2, node1);
  }
}
function append2(list, nodeToAppend) {
  list = list.toMutable();
  let curNode = list;
  const parents = [];
  let nodeToAppendOfCorrectHeight;
  while (true) {
    if (nodeToAppend.listHeight === curNode.listHeight) {
      nodeToAppendOfCorrectHeight = nodeToAppend;
      break;
    }
    if (curNode.kind !== 4) {
      throw new Error("unexpected");
    }
    parents.push(curNode);
    curNode = curNode.makeLastElementMutable();
  }
  for (let i = parents.length - 1; i >= 0; i--) {
    const parent = parents[i];
    if (nodeToAppendOfCorrectHeight) {
      if (parent.childrenLength >= 3) {
        nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);
      } else {
        parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);
        nodeToAppendOfCorrectHeight = void 0;
      }
    } else {
      parent.handleChildrenChanged();
    }
  }
  if (nodeToAppendOfCorrectHeight) {
    return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);
  } else {
    return list;
  }
}
function prepend2(list, nodeToAppend) {
  list = list.toMutable();
  let curNode = list;
  const parents = [];
  while (nodeToAppend.listHeight !== curNode.listHeight) {
    if (curNode.kind !== 4) {
      throw new Error("unexpected");
    }
    parents.push(curNode);
    curNode = curNode.makeFirstElementMutable();
  }
  let nodeToPrependOfCorrectHeight = nodeToAppend;
  for (let i = parents.length - 1; i >= 0; i--) {
    const parent = parents[i];
    if (nodeToPrependOfCorrectHeight) {
      if (parent.childrenLength >= 3) {
        nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);
      } else {
        parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);
        nodeToPrependOfCorrectHeight = void 0;
      }
    } else {
      parent.handleChildrenChanged();
    }
  }
  if (nodeToPrependOfCorrectHeight) {
    return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);
  } else {
    return list;
  }
}
var init_concat23Trees = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js"() {
    init_ast();
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js
function getNextChildIdx(node, curIdx = -1) {
  while (true) {
    curIdx++;
    if (curIdx >= node.childrenLength) {
      return -1;
    }
    if (node.getChild(curIdx)) {
      return curIdx;
    }
  }
}
function lastOrUndefined(arr) {
  return arr.length > 0 ? arr[arr.length - 1] : void 0;
}
var NodeReader;
var init_nodeReader = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js"() {
    init_length();
    NodeReader = class {
      constructor(node) {
        this.lastOffset = lengthZero;
        this.nextNodes = [node];
        this.offsets = [lengthZero];
        this.idxs = [];
      }
      /**
       * Returns the longest node at `offset` that satisfies the predicate.
       * @param offset must be greater than or equal to the last offset this method has been called with!
      */
      readLongestNodeAt(offset, predicate) {
        if (lengthLessThan(offset, this.lastOffset)) {
          throw new Error("Invalid offset");
        }
        this.lastOffset = offset;
        while (true) {
          const curNode = lastOrUndefined(this.nextNodes);
          if (!curNode) {
            return void 0;
          }
          const curNodeOffset = lastOrUndefined(this.offsets);
          if (lengthLessThan(offset, curNodeOffset)) {
            return void 0;
          }
          if (lengthLessThan(curNodeOffset, offset)) {
            if (lengthAdd(curNodeOffset, curNode.length) <= offset) {
              this.nextNodeAfterCurrent();
            } else {
              const nextChildIdx = getNextChildIdx(curNode);
              if (nextChildIdx !== -1) {
                this.nextNodes.push(curNode.getChild(nextChildIdx));
                this.offsets.push(curNodeOffset);
                this.idxs.push(nextChildIdx);
              } else {
                this.nextNodeAfterCurrent();
              }
            }
          } else {
            if (predicate(curNode)) {
              this.nextNodeAfterCurrent();
              return curNode;
            } else {
              const nextChildIdx = getNextChildIdx(curNode);
              if (nextChildIdx === -1) {
                this.nextNodeAfterCurrent();
                return void 0;
              } else {
                this.nextNodes.push(curNode.getChild(nextChildIdx));
                this.offsets.push(curNodeOffset);
                this.idxs.push(nextChildIdx);
              }
            }
          }
        }
      }
      // Navigates to the longest node that continues after the current node.
      nextNodeAfterCurrent() {
        while (true) {
          const currentOffset = lastOrUndefined(this.offsets);
          const currentNode = lastOrUndefined(this.nextNodes);
          this.nextNodes.pop();
          this.offsets.pop();
          if (this.idxs.length === 0) {
            break;
          }
          const parent = lastOrUndefined(this.nextNodes);
          const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);
          if (nextChildIdx !== -1) {
            this.nextNodes.push(parent.getChild(nextChildIdx));
            this.offsets.push(lengthAdd(currentOffset, currentNode.length));
            this.idxs[this.idxs.length - 1] = nextChildIdx;
            break;
          } else {
            this.idxs.pop();
          }
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js
function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {
  const parser2 = new Parser3(tokenizer, edits, oldNode, createImmutableLists);
  return parser2.parseDocument();
}
var Parser3;
var init_parser = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js"() {
    init_ast();
    init_beforeEditPositionMapper();
    init_smallImmutableSet();
    init_length();
    init_concat23Trees();
    init_nodeReader();
    Parser3 = class {
      constructor(tokenizer, edits, oldNode, createImmutableLists) {
        this.tokenizer = tokenizer;
        this.createImmutableLists = createImmutableLists;
        this._itemsConstructed = 0;
        this._itemsFromCache = 0;
        if (oldNode && createImmutableLists) {
          throw new Error("Not supported");
        }
        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : void 0;
        this.positionMapper = new BeforeEditPositionMapper(edits);
      }
      parseDocument() {
        this._itemsConstructed = 0;
        this._itemsFromCache = 0;
        let result = this.parseList(SmallImmutableSet.getEmpty(), 0);
        if (!result) {
          result = ListAstNode.getEmpty();
        }
        return result;
      }
      parseList(openedBracketIds, level) {
        const items = [];
        while (true) {
          let child = this.tryReadChildFromCache(openedBracketIds);
          if (!child) {
            const token = this.tokenizer.peek();
            if (!token || token.kind === 2 && token.bracketIds.intersects(openedBracketIds)) {
              break;
            }
            child = this.parseChild(openedBracketIds, level + 1);
          }
          if (child.kind === 4 && child.childrenLength === 0) {
            continue;
          }
          items.push(child);
        }
        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);
        return result;
      }
      tryReadChildFromCache(openedBracketIds) {
        if (this.oldNodeReader) {
          const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);
          if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {
            const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), (curNode) => {
              if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {
                return false;
              }
              const canBeReused = curNode.canBeReused(openedBracketIds);
              return canBeReused;
            });
            if (cachedNode) {
              this._itemsFromCache++;
              this.tokenizer.skip(cachedNode.length);
              return cachedNode;
            }
          }
        }
        return void 0;
      }
      parseChild(openedBracketIds, level) {
        this._itemsConstructed++;
        const token = this.tokenizer.read();
        switch (token.kind) {
          case 2:
            return new InvalidBracketAstNode(token.bracketIds, token.length);
          case 0:
            return token.astNode;
          case 1: {
            if (level > 300) {
              return new TextAstNode(token.length);
            }
            const set = openedBracketIds.merge(token.bracketIds);
            const child = this.parseList(set, level + 1);
            const nextToken = this.tokenizer.peek();
            if (nextToken && nextToken.kind === 2 && (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {
              this.tokenizer.read();
              return PairAstNode.create(token.astNode, child, nextToken.astNode);
            } else {
              return PairAstNode.create(token.astNode, child, null);
            }
          }
          default:
            throw new Error("unexpected");
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js
function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {
  if (textEditInfoFirst.length === 0) {
    return textEditInfoSecond;
  }
  if (textEditInfoSecond.length === 0) {
    return textEditInfoFirst;
  }
  const s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));
  const s1ToS2Map = toLengthMapping(textEditInfoSecond);
  s1ToS2Map.push({ modified: false, lengthBefore: void 0, lengthAfter: void 0 });
  let curItem = s0ToS1Map.dequeue();
  function nextS0ToS1MapWithS1LengthOf(s1Length) {
    if (s1Length === void 0) {
      const arr = s0ToS1Map.takeWhile((v) => true) || [];
      if (curItem) {
        arr.unshift(curItem);
      }
      return arr;
    }
    const result2 = [];
    while (curItem && !lengthIsZero(s1Length)) {
      const [item, remainingItem] = curItem.splitAt(s1Length);
      result2.push(item);
      s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);
      curItem = remainingItem !== null && remainingItem !== void 0 ? remainingItem : s0ToS1Map.dequeue();
    }
    if (!lengthIsZero(s1Length)) {
      result2.push(new LengthMapping(false, s1Length, s1Length));
    }
    return result2;
  }
  const result = [];
  function pushEdit(startOffset, endOffset, newLength) {
    if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {
      const lastResult = result[result.length - 1];
      result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));
    } else {
      result.push({ startOffset, endOffset, newLength });
    }
  }
  let s0offset = lengthZero;
  for (const s1ToS2 of s1ToS2Map) {
    const s0ToS1Map2 = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);
    if (s1ToS2.modified) {
      const s0Length = sumLengths(s0ToS1Map2, (s) => s.lengthBefore);
      const s0EndOffset = lengthAdd(s0offset, s0Length);
      pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);
      s0offset = s0EndOffset;
    } else {
      for (const s1 of s0ToS1Map2) {
        const s0startOffset = s0offset;
        s0offset = lengthAdd(s0offset, s1.lengthBefore);
        if (s1.modified) {
          pushEdit(s0startOffset, s0offset, s1.lengthAfter);
        }
      }
    }
  }
  return result;
}
function toLengthMapping(textEditInfos) {
  const result = [];
  let lastOffset = lengthZero;
  for (const textEditInfo of textEditInfos) {
    const spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);
    if (!lengthIsZero(spaceLength)) {
      result.push(new LengthMapping(false, spaceLength, spaceLength));
    }
    const lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);
    result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));
    lastOffset = textEditInfo.endOffset;
  }
  return result;
}
var LengthMapping;
var init_combineTextEditInfos = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js"() {
    init_arrays();
    init_beforeEditPositionMapper();
    init_length();
    LengthMapping = class _LengthMapping {
      constructor(modified, lengthBefore, lengthAfter) {
        this.modified = modified;
        this.lengthBefore = lengthBefore;
        this.lengthAfter = lengthAfter;
      }
      splitAt(lengthAfter) {
        const remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);
        if (lengthEquals(remainingLengthAfter, lengthZero)) {
          return [this, void 0];
        } else if (this.modified) {
          return [
            new _LengthMapping(this.modified, this.lengthBefore, lengthAfter),
            new _LengthMapping(this.modified, lengthZero, remainingLengthAfter)
          ];
        } else {
          return [
            new _LengthMapping(this.modified, lengthAfter, lengthAfter),
            new _LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)
          ];
        }
      }
      toString() {
        return `${this.modified ? "M" : "U"}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js
function getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {
  if (node.kind === 4 || node.kind === 2) {
    const lengths = [];
    for (const child of node.children) {
      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);
      lengths.push({ nodeOffsetStart, nodeOffsetEnd });
      nodeOffsetStart = nodeOffsetEnd;
    }
    for (let i = lengths.length - 1; i >= 0; i--) {
      const { nodeOffsetStart: nodeOffsetStart2, nodeOffsetEnd: nodeOffsetEnd2 } = lengths[i];
      if (lengthLessThan(nodeOffsetStart2, position)) {
        const result = getFirstBracketBefore(node.children[i], nodeOffsetStart2, nodeOffsetEnd2, position);
        if (result) {
          return result;
        }
      }
    }
    return null;
  } else if (node.kind === 3) {
    return null;
  } else if (node.kind === 1) {
    const range2 = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);
    return {
      bracketInfo: node.bracketInfo,
      range: range2
    };
  }
  return null;
}
function getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {
  if (node.kind === 4 || node.kind === 2) {
    for (const child of node.children) {
      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);
      if (lengthLessThan(position, nodeOffsetEnd)) {
        const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);
        if (result) {
          return result;
        }
      }
      nodeOffsetStart = nodeOffsetEnd;
    }
    return null;
  } else if (node.kind === 3) {
    return null;
  } else if (node.kind === 1) {
    const range2 = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);
    return {
      bracketInfo: node.bracketInfo,
      range: range2
    };
  }
  return null;
}
function collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {
  if (level > 200) {
    return true;
  }
  whileLoop:
    while (true) {
      switch (node.kind) {
        case 4: {
          const childCount = node.childrenLength;
          for (let i = 0; i < childCount; i++) {
            const child = node.getChild(i);
            if (!child) {
              continue;
            }
            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);
            if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {
              const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);
              if (childEndsAfterEnd) {
                node = child;
                continue whileLoop;
              }
              const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);
              if (!shouldContinue) {
                return false;
              }
            }
            nodeOffsetStart = nodeOffsetEnd;
          }
          return true;
        }
        case 2: {
          const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);
          let levelPerBracket = 0;
          if (levelPerBracketType) {
            let existing = levelPerBracketType.get(node.openingBracket.text);
            if (existing === void 0) {
              existing = 0;
            }
            levelPerBracket = existing;
            if (colorize) {
              existing++;
              levelPerBracketType.set(node.openingBracket.text, existing);
            }
          }
          const childCount = node.childrenLength;
          for (let i = 0; i < childCount; i++) {
            const child = node.getChild(i);
            if (!child) {
              continue;
            }
            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);
            if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {
              const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);
              if (childEndsAfterEnd && child.kind !== 1) {
                node = child;
                if (colorize) {
                  level++;
                  nestingLevelOfEqualBracketType = levelPerBracket + 1;
                } else {
                  nestingLevelOfEqualBracketType = levelPerBracket;
                }
                continue whileLoop;
              }
              if (colorize || child.kind !== 1 || !node.closingBracket) {
                const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);
                if (!shouldContinue) {
                  return false;
                }
              }
            }
            nodeOffsetStart = nodeOffsetEnd;
          }
          levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);
          return true;
        }
        case 3: {
          const range2 = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);
          return push(new BracketInfo(range2, level - 1, 0, true));
        }
        case 1: {
          const range2 = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);
          return push(new BracketInfo(range2, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));
        }
        case 0:
          return true;
      }
    }
}
function collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {
  var _a2;
  if (level > 200) {
    return true;
  }
  let shouldContinue = true;
  if (node.kind === 2) {
    let levelPerBracket = 0;
    if (levelPerBracketType) {
      let existing = levelPerBracketType.get(node.openingBracket.text);
      if (existing === void 0) {
        existing = 0;
      }
      levelPerBracket = existing;
      existing++;
      levelPerBracketType.set(node.openingBracket.text, existing);
    }
    const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);
    let minIndentation = -1;
    if (context.includeMinIndentation) {
      minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);
    }
    shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a2 = node.child) === null || _a2 === void 0 ? void 0 : _a2.length) || lengthZero), nodeOffsetEnd) : void 0, level, levelPerBracket, node, minIndentation));
    nodeOffsetStart = openingBracketEnd;
    if (shouldContinue && node.child) {
      const child = node.child;
      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);
      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {
        shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);
        if (!shouldContinue) {
          return false;
        }
      }
    }
    levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);
  } else {
    let curOffset = nodeOffsetStart;
    for (const child of node.children) {
      const childOffset = curOffset;
      curOffset = lengthAdd(curOffset, child.length);
      if (lengthLessThanEqual(childOffset, endOffset) && lengthLessThanEqual(startOffset, curOffset)) {
        shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);
        if (!shouldContinue) {
          return false;
        }
      }
    }
  }
  return shouldContinue;
}
var BracketPairsTree, CollectBracketPairsContext;
var init_bracketPairsTree = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js"() {
    init_event();
    init_lifecycle();
    init_textModelBracketPairs();
    init_beforeEditPositionMapper();
    init_brackets();
    init_length();
    init_parser();
    init_smallImmutableSet();
    init_tokenizer();
    init_arrays();
    init_combineTextEditInfos();
    BracketPairsTree = class extends Disposable {
      didLanguageChange(languageId) {
        return this.brackets.didLanguageChange(languageId);
      }
      constructor(textModel, getLanguageConfiguration) {
        super();
        this.textModel = textModel;
        this.getLanguageConfiguration = getLanguageConfiguration;
        this.didChangeEmitter = new Emitter();
        this.denseKeyProvider = new DenseKeyProvider();
        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);
        this.onDidChange = this.didChangeEmitter.event;
        this.queuedTextEditsForInitialAstWithoutTokens = [];
        this.queuedTextEdits = [];
        if (!textModel.tokenization.hasTokens) {
          const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());
          const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);
          this.initialAstWithoutTokens = parseDocument(tokenizer, [], void 0, true);
          this.astWithTokens = this.initialAstWithoutTokens;
        } else if (textModel.tokenization.backgroundTokenizationState === 2) {
          this.initialAstWithoutTokens = void 0;
          this.astWithTokens = this.parseDocumentFromTextBuffer([], void 0, false);
        } else {
          this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], void 0, true);
          this.astWithTokens = this.initialAstWithoutTokens;
        }
      }
      //#region TextModel events
      handleDidChangeBackgroundTokenizationState() {
        if (this.textModel.tokenization.backgroundTokenizationState === 2) {
          const wasUndefined = this.initialAstWithoutTokens === void 0;
          this.initialAstWithoutTokens = void 0;
          if (!wasUndefined) {
            this.didChangeEmitter.fire();
          }
        }
      }
      handleDidChangeTokens({ ranges }) {
        const edits = ranges.map((r) => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));
        this.handleEdits(edits, true);
        if (!this.initialAstWithoutTokens) {
          this.didChangeEmitter.fire();
        }
      }
      handleContentChanged(change) {
        const edits = TextEditInfo.fromModelContentChanges(change.changes);
        this.handleEdits(edits, false);
      }
      handleEdits(edits, tokenChange) {
        const result = combineTextEditInfos(this.queuedTextEdits, edits);
        this.queuedTextEdits = result;
        if (this.initialAstWithoutTokens && !tokenChange) {
          this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);
        }
      }
      //#endregion
      flushQueue() {
        if (this.queuedTextEdits.length > 0) {
          this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);
          this.queuedTextEdits = [];
        }
        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {
          if (this.initialAstWithoutTokens) {
            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);
          }
          this.queuedTextEditsForInitialAstWithoutTokens = [];
        }
      }
      /**
       * @pure (only if isPure = true)
      */
      parseDocumentFromTextBuffer(edits, previousAst, immutable) {
        const isPure = false;
        const previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;
        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);
        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);
        return result;
      }
      getBracketsInRange(range2, onlyColorizedBrackets) {
        this.flushQueue();
        const startOffset = toLength(range2.startLineNumber - 1, range2.startColumn - 1);
        const endOffset = toLength(range2.endLineNumber - 1, range2.endColumn - 1);
        return new CallbackIterable((cb) => {
          const node = this.initialAstWithoutTokens || this.astWithTokens;
          collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, /* @__PURE__ */ new Map(), onlyColorizedBrackets);
        });
      }
      getBracketPairsInRange(range2, includeMinIndentation) {
        this.flushQueue();
        const startLength = positionToLength(range2.getStartPosition());
        const endLength = positionToLength(range2.getEndPosition());
        return new CallbackIterable((cb) => {
          const node = this.initialAstWithoutTokens || this.astWithTokens;
          const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);
          collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, /* @__PURE__ */ new Map());
        });
      }
      getFirstBracketAfter(position) {
        this.flushQueue();
        const node = this.initialAstWithoutTokens || this.astWithTokens;
        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));
      }
      getFirstBracketBefore(position) {
        this.flushQueue();
        const node = this.initialAstWithoutTokens || this.astWithTokens;
        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));
      }
    };
    CollectBracketPairsContext = class {
      constructor(push, includeMinIndentation, textModel) {
        this.push = push;
        this.includeMinIndentation = includeMinIndentation;
        this.textModel = textModel;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js
function createDisposableRef(object, disposable) {
  return {
    object,
    dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose()
  };
}
function createTimeBasedContinueBracketSearchPredicate(maxDuration) {
  if (typeof maxDuration === "undefined") {
    return () => true;
  } else {
    const startTime = Date.now();
    return () => {
      return Date.now() - startTime <= maxDuration;
    };
  }
}
function stripBracketSearchCanceled(result) {
  if (result instanceof BracketSearchCanceled) {
    return null;
  }
  return result;
}
var BracketPairsTextModelPart, BracketSearchCanceled;
var init_bracketPairsImpl = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js"() {
    init_arrays();
    init_event();
    init_lifecycle();
    init_range();
    init_supports();
    init_richEditBrackets();
    init_bracketPairsTree();
    BracketPairsTextModelPart = class extends Disposable {
      get canBuildAST() {
        const maxSupportedDocumentLength = (
          /* max lines */
          5e4 * /* average column count */
          100
        );
        return this.textModel.getValueLength() <= maxSupportedDocumentLength;
      }
      constructor(textModel, languageConfigurationService) {
        super();
        this.textModel = textModel;
        this.languageConfigurationService = languageConfigurationService;
        this.bracketPairsTree = this._register(new MutableDisposable());
        this.onDidChangeEmitter = new Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.bracketsRequested = false;
        this._register(this.languageConfigurationService.onDidChange((e) => {
          var _a2;
          if (!e.languageId || ((_a2 = this.bracketPairsTree.value) === null || _a2 === void 0 ? void 0 : _a2.object.didLanguageChange(e.languageId))) {
            this.bracketPairsTree.clear();
            this.updateBracketPairsTree();
          }
        }));
      }
      //#region TextModel events
      handleDidChangeOptions(e) {
        this.bracketPairsTree.clear();
        this.updateBracketPairsTree();
      }
      handleDidChangeLanguage(e) {
        this.bracketPairsTree.clear();
        this.updateBracketPairsTree();
      }
      handleDidChangeContent(change) {
        var _a2;
        (_a2 = this.bracketPairsTree.value) === null || _a2 === void 0 ? void 0 : _a2.object.handleContentChanged(change);
      }
      handleDidChangeBackgroundTokenizationState() {
        var _a2;
        (_a2 = this.bracketPairsTree.value) === null || _a2 === void 0 ? void 0 : _a2.object.handleDidChangeBackgroundTokenizationState();
      }
      handleDidChangeTokens(e) {
        var _a2;
        (_a2 = this.bracketPairsTree.value) === null || _a2 === void 0 ? void 0 : _a2.object.handleDidChangeTokens(e);
      }
      //#endregion
      updateBracketPairsTree() {
        if (this.bracketsRequested && this.canBuildAST) {
          if (!this.bracketPairsTree.value) {
            const store = new DisposableStore();
            this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {
              return this.languageConfigurationService.getLanguageConfiguration(languageId);
            })), store);
            store.add(this.bracketPairsTree.value.object.onDidChange((e) => this.onDidChangeEmitter.fire(e)));
            this.onDidChangeEmitter.fire();
          }
        } else {
          if (this.bracketPairsTree.value) {
            this.bracketPairsTree.clear();
            this.onDidChangeEmitter.fire();
          }
        }
      }
      /**
       * Returns all bracket pairs that intersect the given range.
       * The result is sorted by the start position.
      */
      getBracketPairsInRange(range2) {
        var _a2;
        this.bracketsRequested = true;
        this.updateBracketPairsTree();
        return ((_a2 = this.bracketPairsTree.value) === null || _a2 === void 0 ? void 0 : _a2.object.getBracketPairsInRange(range2, false)) || CallbackIterable.empty;
      }
      getBracketPairsInRangeWithMinIndentation(range2) {
        var _a2;
        this.bracketsRequested = true;
        this.updateBracketPairsTree();
        return ((_a2 = this.bracketPairsTree.value) === null || _a2 === void 0 ? void 0 : _a2.object.getBracketPairsInRange(range2, true)) || CallbackIterable.empty;
      }
      getBracketsInRange(range2, onlyColorizedBrackets = false) {
        var _a2;
        this.bracketsRequested = true;
        this.updateBracketPairsTree();
        return ((_a2 = this.bracketPairsTree.value) === null || _a2 === void 0 ? void 0 : _a2.object.getBracketsInRange(range2, onlyColorizedBrackets)) || CallbackIterable.empty;
      }
      findMatchingBracketUp(_bracket, _position, maxDuration) {
        const position = this.textModel.validatePosition(_position);
        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);
        if (this.canBuildAST) {
          const closingBracketInfo = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew.getClosingBracketInfo(_bracket);
          if (!closingBracketInfo) {
            return null;
          }
          const bracketPair = this.getBracketPairsInRange(Range2.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));
          if (bracketPair) {
            return bracketPair.openingBracketRange;
          }
          return null;
        } else {
          const bracket = _bracket.toLowerCase();
          const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
          if (!bracketsSupport) {
            return null;
          }
          const data = bracketsSupport.textIsBracket[bracket];
          if (!data) {
            return null;
          }
          return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));
        }
      }
      matchBracket(position, maxDuration) {
        if (this.canBuildAST) {
          const bracketPair = this.getBracketPairsInRange(Range2.fromPositions(position, position)).filter((item) => item.closingBracketRange !== void 0 && (item.openingBracketRange.containsPosition(position) || item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position) ? item.openingBracketRange : item.closingBracketRange, Range2.compareRangesUsingStarts));
          if (bracketPair) {
            return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];
          }
          return null;
        } else {
          const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);
          return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);
        }
      }
      _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {
        const tokenCount = lineTokens.getCount();
        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);
        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);
        for (let i = tokenIndex - 1; i >= 0; i--) {
          const tokenEndOffset = lineTokens.getEndOffset(i);
          if (tokenEndOffset <= searchStartOffset) {
            break;
          }
          if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {
            searchStartOffset = tokenEndOffset;
            break;
          }
        }
        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);
        for (let i = tokenIndex + 1; i < tokenCount; i++) {
          const tokenStartOffset = lineTokens.getStartOffset(i);
          if (tokenStartOffset >= searchEndOffset) {
            break;
          }
          if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {
            searchEndOffset = tokenStartOffset;
            break;
          }
        }
        return { searchStartOffset, searchEndOffset };
      }
      _matchBracket(position, continueSearchPredicate) {
        const lineNumber = position.lineNumber;
        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);
        const lineText = this.textModel.getLineContent(lineNumber);
        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        if (tokenIndex < 0) {
          return null;
        }
        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;
        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {
          let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);
          let bestResult = null;
          while (true) {
            const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (!foundBracket) {
              break;
            }
            if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
              const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();
              const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);
              if (r) {
                if (r instanceof BracketSearchCanceled) {
                  return null;
                }
                bestResult = r;
              }
            }
            searchStartOffset = foundBracket.endColumn - 1;
          }
          if (bestResult) {
            return bestResult;
          }
        }
        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {
          const prevTokenIndex = tokenIndex - 1;
          const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;
          if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {
            const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);
            const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
              const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();
              const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);
              if (r) {
                if (r instanceof BracketSearchCanceled) {
                  return null;
                }
                return r;
              }
            }
          }
        }
        return null;
      }
      _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {
        if (!data) {
          return null;
        }
        const matched = isOpen ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate) : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate);
        if (!matched) {
          return null;
        }
        if (matched instanceof BracketSearchCanceled) {
          return matched;
        }
        return [foundBracket, matched];
      }
      _findMatchingBracketUp(bracket, position, continueSearchPredicate) {
        const languageId = bracket.languageId;
        const reversedBracketRegex = bracket.reversedRegex;
        let count = -1;
        let totalCallCount = 0;
        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {
          while (true) {
            if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {
              return BracketSearchCanceled.INSTANCE;
            }
            const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (!r) {
              break;
            }
            const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
            if (bracket.isOpen(hitText)) {
              count++;
            } else if (bracket.isClose(hitText)) {
              count--;
            }
            if (count === 0) {
              return r;
            }
            searchEndOffset = r.startColumn - 1;
          }
          return null;
        };
        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
          const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);
          const tokenCount = lineTokens.getCount();
          const lineText = this.textModel.getLineContent(lineNumber);
          let tokenIndex = tokenCount - 1;
          let searchStartOffset = lineText.length;
          let searchEndOffset = lineText.length;
          if (lineNumber === position.lineNumber) {
            tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
            searchStartOffset = position.column - 1;
            searchEndOffset = position.column - 1;
          }
          let prevSearchInToken = true;
          for (; tokenIndex >= 0; tokenIndex--) {
            const searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));
            if (searchInToken) {
              if (prevSearchInToken) {
                searchStartOffset = lineTokens.getStartOffset(tokenIndex);
              } else {
                searchStartOffset = lineTokens.getStartOffset(tokenIndex);
                searchEndOffset = lineTokens.getEndOffset(tokenIndex);
              }
            } else {
              if (prevSearchInToken && searchStartOffset !== searchEndOffset) {
                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (r) {
                  return r;
                }
              }
            }
            prevSearchInToken = searchInToken;
          }
          if (prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return r;
            }
          }
        }
        return null;
      }
      _findMatchingBracketDown(bracket, position, continueSearchPredicate) {
        const languageId = bracket.languageId;
        const bracketRegex = bracket.forwardRegex;
        let count = 1;
        let totalCallCount = 0;
        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {
          while (true) {
            if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {
              return BracketSearchCanceled.INSTANCE;
            }
            const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (!r) {
              break;
            }
            const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
            if (bracket.isOpen(hitText)) {
              count++;
            } else if (bracket.isClose(hitText)) {
              count--;
            }
            if (count === 0) {
              return r;
            }
            searchStartOffset = r.endColumn - 1;
          }
          return null;
        };
        const lineCount = this.textModel.getLineCount();
        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {
          const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);
          const tokenCount = lineTokens.getCount();
          const lineText = this.textModel.getLineContent(lineNumber);
          let tokenIndex = 0;
          let searchStartOffset = 0;
          let searchEndOffset = 0;
          if (lineNumber === position.lineNumber) {
            tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
            searchStartOffset = position.column - 1;
            searchEndOffset = position.column - 1;
          }
          let prevSearchInToken = true;
          for (; tokenIndex < tokenCount; tokenIndex++) {
            const searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));
            if (searchInToken) {
              if (prevSearchInToken) {
                searchEndOffset = lineTokens.getEndOffset(tokenIndex);
              } else {
                searchStartOffset = lineTokens.getStartOffset(tokenIndex);
                searchEndOffset = lineTokens.getEndOffset(tokenIndex);
              }
            } else {
              if (prevSearchInToken && searchStartOffset !== searchEndOffset) {
                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (r) {
                  return r;
                }
              }
            }
            prevSearchInToken = searchInToken;
          }
          if (prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return r;
            }
          }
        }
        return null;
      }
      findPrevBracket(_position) {
        var _a2;
        const position = this.textModel.validatePosition(_position);
        if (this.canBuildAST) {
          this.bracketsRequested = true;
          this.updateBracketPairsTree();
          return ((_a2 = this.bracketPairsTree.value) === null || _a2 === void 0 ? void 0 : _a2.object.getFirstBracketBefore(position)) || null;
        }
        let languageId = null;
        let modeBrackets = null;
        let bracketConfig = null;
        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
          const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);
          const tokenCount = lineTokens.getCount();
          const lineText = this.textModel.getLineContent(lineNumber);
          let tokenIndex = tokenCount - 1;
          let searchStartOffset = lineText.length;
          let searchEndOffset = lineText.length;
          if (lineNumber === position.lineNumber) {
            tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
            searchStartOffset = position.column - 1;
            searchEndOffset = position.column - 1;
            const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
            if (languageId !== tokenLanguageId) {
              languageId = tokenLanguageId;
              modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
              bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;
            }
          }
          let prevSearchInToken = true;
          for (; tokenIndex >= 0; tokenIndex--) {
            const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
            if (languageId !== tokenLanguageId) {
              if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {
                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (r) {
                  return this._toFoundBracket(bracketConfig, r);
                }
                prevSearchInToken = false;
              }
              languageId = tokenLanguageId;
              modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
              bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;
            }
            const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));
            if (searchInToken) {
              if (prevSearchInToken) {
                searchStartOffset = lineTokens.getStartOffset(tokenIndex);
              } else {
                searchStartOffset = lineTokens.getStartOffset(tokenIndex);
                searchEndOffset = lineTokens.getEndOffset(tokenIndex);
              }
            } else {
              if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (r) {
                  return this._toFoundBracket(bracketConfig, r);
                }
              }
            }
            prevSearchInToken = searchInToken;
          }
          if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return this._toFoundBracket(bracketConfig, r);
            }
          }
        }
        return null;
      }
      findNextBracket(_position) {
        var _a2;
        const position = this.textModel.validatePosition(_position);
        if (this.canBuildAST) {
          this.bracketsRequested = true;
          this.updateBracketPairsTree();
          return ((_a2 = this.bracketPairsTree.value) === null || _a2 === void 0 ? void 0 : _a2.object.getFirstBracketAfter(position)) || null;
        }
        const lineCount = this.textModel.getLineCount();
        let languageId = null;
        let modeBrackets = null;
        let bracketConfig = null;
        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {
          const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);
          const tokenCount = lineTokens.getCount();
          const lineText = this.textModel.getLineContent(lineNumber);
          let tokenIndex = 0;
          let searchStartOffset = 0;
          let searchEndOffset = 0;
          if (lineNumber === position.lineNumber) {
            tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
            searchStartOffset = position.column - 1;
            searchEndOffset = position.column - 1;
            const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
            if (languageId !== tokenLanguageId) {
              languageId = tokenLanguageId;
              modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
              bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;
            }
          }
          let prevSearchInToken = true;
          for (; tokenIndex < tokenCount; tokenIndex++) {
            const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
            if (languageId !== tokenLanguageId) {
              if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (r) {
                  return this._toFoundBracket(bracketConfig, r);
                }
                prevSearchInToken = false;
              }
              languageId = tokenLanguageId;
              modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
              bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;
            }
            const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));
            if (searchInToken) {
              if (prevSearchInToken) {
                searchEndOffset = lineTokens.getEndOffset(tokenIndex);
              } else {
                searchStartOffset = lineTokens.getStartOffset(tokenIndex);
                searchEndOffset = lineTokens.getEndOffset(tokenIndex);
              }
            } else {
              if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (r) {
                  return this._toFoundBracket(bracketConfig, r);
                }
              }
            }
            prevSearchInToken = searchInToken;
          }
          if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return this._toFoundBracket(bracketConfig, r);
            }
          }
        }
        return null;
      }
      findEnclosingBrackets(_position, maxDuration) {
        const position = this.textModel.validatePosition(_position);
        if (this.canBuildAST) {
          const range2 = Range2.fromPositions(position);
          const bracketPair = this.getBracketPairsInRange(Range2.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== void 0 && item.range.strictContainsRange(range2));
          if (bracketPair) {
            return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];
          }
          return null;
        }
        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);
        const lineCount = this.textModel.getLineCount();
        const savedCounts = /* @__PURE__ */ new Map();
        let counts = [];
        const resetCounts = (languageId2, modeBrackets2) => {
          if (!savedCounts.has(languageId2)) {
            const tmp = [];
            for (let i = 0, len = modeBrackets2 ? modeBrackets2.brackets.length : 0; i < len; i++) {
              tmp[i] = 0;
            }
            savedCounts.set(languageId2, tmp);
          }
          counts = savedCounts.get(languageId2);
        };
        let totalCallCount = 0;
        const searchInRange = (modeBrackets2, lineNumber, lineText, searchStartOffset, searchEndOffset) => {
          while (true) {
            if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {
              return BracketSearchCanceled.INSTANCE;
            }
            const r = BracketsUtils.findNextBracketInRange(modeBrackets2.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (!r) {
              break;
            }
            const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
            const bracket = modeBrackets2.textIsBracket[hitText];
            if (bracket) {
              if (bracket.isOpen(hitText)) {
                counts[bracket.index]++;
              } else if (bracket.isClose(hitText)) {
                counts[bracket.index]--;
              }
              if (counts[bracket.index] === -1) {
                return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);
              }
            }
            searchStartOffset = r.endColumn - 1;
          }
          return null;
        };
        let languageId = null;
        let modeBrackets = null;
        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {
          const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);
          const tokenCount = lineTokens.getCount();
          const lineText = this.textModel.getLineContent(lineNumber);
          let tokenIndex = 0;
          let searchStartOffset = 0;
          let searchEndOffset = 0;
          if (lineNumber === position.lineNumber) {
            tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
            searchStartOffset = position.column - 1;
            searchEndOffset = position.column - 1;
            const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
            if (languageId !== tokenLanguageId) {
              languageId = tokenLanguageId;
              modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
              resetCounts(languageId, modeBrackets);
            }
          }
          let prevSearchInToken = true;
          for (; tokenIndex < tokenCount; tokenIndex++) {
            const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);
            if (languageId !== tokenLanguageId) {
              if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (r) {
                  return stripBracketSearchCanceled(r);
                }
                prevSearchInToken = false;
              }
              languageId = tokenLanguageId;
              modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;
              resetCounts(languageId, modeBrackets);
            }
            const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));
            if (searchInToken) {
              if (prevSearchInToken) {
                searchEndOffset = lineTokens.getEndOffset(tokenIndex);
              } else {
                searchStartOffset = lineTokens.getStartOffset(tokenIndex);
                searchEndOffset = lineTokens.getEndOffset(tokenIndex);
              }
            } else {
              if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (r) {
                  return stripBracketSearchCanceled(r);
                }
              }
            }
            prevSearchInToken = searchInToken;
          }
          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {
            const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);
            if (r) {
              return stripBracketSearchCanceled(r);
            }
          }
        }
        return null;
      }
      _toFoundBracket(bracketConfig, r) {
        if (!r) {
          return null;
        }
        let text = this.textModel.getValueInRange(r);
        text = text.toLowerCase();
        const bracketInfo = bracketConfig.getBracketInfo(text);
        if (!bracketInfo) {
          return null;
        }
        return {
          range: r,
          bracketInfo
        };
      }
    };
    BracketSearchCanceled = class {
      constructor() {
        this._searchCanceledBrand = void 0;
      }
    };
    BracketSearchCanceled.INSTANCE = new BracketSearchCanceled();
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js
var ColorizedBracketPairsDecorationProvider, ColorProvider;
var init_colorizedBracketPairsDecorationProvider = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js"() {
    init_event();
    init_lifecycle();
    init_range();
    init_editorColorRegistry();
    init_themeService();
    ColorizedBracketPairsDecorationProvider = class extends Disposable {
      constructor(textModel) {
        super();
        this.textModel = textModel;
        this.colorProvider = new ColorProvider();
        this.onDidChangeEmitter = new Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;
        this._register(textModel.bracketPairs.onDidChange((e) => {
          this.onDidChangeEmitter.fire();
        }));
      }
      //#region TextModel events
      handleDidChangeOptions(e) {
        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;
      }
      //#endregion
      getDecorationsInRange(range2, ownerId, filterOutValidation, onlyMinimapDecorations) {
        if (onlyMinimapDecorations) {
          return [];
        }
        if (ownerId === void 0) {
          return [];
        }
        if (!this.colorizationOptions.enabled) {
          return [];
        }
        const result = this.textModel.bracketPairs.getBracketsInRange(range2, true).map((bracket) => ({
          id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,
          options: {
            description: "BracketPairColorization",
            inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType)
          },
          ownerId: 0,
          range: bracket.range
        })).toArray();
        return result;
      }
      getAllDecorations(ownerId, filterOutValidation) {
        if (ownerId === void 0) {
          return [];
        }
        if (!this.colorizationOptions.enabled) {
          return [];
        }
        return this.getDecorationsInRange(new Range2(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);
      }
    };
    ColorProvider = class {
      constructor() {
        this.unexpectedClosingBracketClassName = "unexpected-closing-bracket";
      }
      getInlineClassName(bracket, independentColorPoolPerBracketType) {
        if (bracket.isInvalid) {
          return this.unexpectedClosingBracketClassName;
        }
        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);
      }
      getInlineClassNameOfLevel(level) {
        return `bracket-highlighting-${level % 30}`;
      }
    };
    registerThemingParticipant((theme, collector) => {
      const colors = [
        editorBracketHighlightingForeground1,
        editorBracketHighlightingForeground2,
        editorBracketHighlightingForeground3,
        editorBracketHighlightingForeground4,
        editorBracketHighlightingForeground5,
        editorBracketHighlightingForeground6
      ];
      const colorProvider = new ColorProvider();
      collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);
      const colorValues = colors.map((c) => theme.getColor(c)).filter((c) => !!c).filter((c) => !c.isTransparent());
      for (let level = 0; level < 30; level++) {
        const color = colorValues[level % colorValues.length];
        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js
function escapeNewLine(str) {
  return str.replace(/\n/g, "\\n").replace(/\r/g, "\\r");
}
function compressConsecutiveTextChanges(prevEdits, currEdits) {
  if (prevEdits === null || prevEdits.length === 0) {
    return currEdits;
  }
  const compressor = new TextChangeCompressor(prevEdits, currEdits);
  return compressor.compress();
}
var TextChange, TextChangeCompressor;
var init_textChange = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js"() {
    init_buffer();
    init_stringBuilder();
    TextChange = class _TextChange {
      get oldLength() {
        return this.oldText.length;
      }
      get oldEnd() {
        return this.oldPosition + this.oldText.length;
      }
      get newLength() {
        return this.newText.length;
      }
      get newEnd() {
        return this.newPosition + this.newText.length;
      }
      constructor(oldPosition, oldText, newPosition, newText) {
        this.oldPosition = oldPosition;
        this.oldText = oldText;
        this.newPosition = newPosition;
        this.newText = newText;
      }
      toString() {
        if (this.oldText.length === 0) {
          return `(insert@${this.oldPosition} "${escapeNewLine(this.newText)}")`;
        }
        if (this.newText.length === 0) {
          return `(delete@${this.oldPosition} "${escapeNewLine(this.oldText)}")`;
        }
        return `(replace@${this.oldPosition} "${escapeNewLine(this.oldText)}" with "${escapeNewLine(this.newText)}")`;
      }
      static _writeStringSize(str) {
        return 4 + 2 * str.length;
      }
      static _writeString(b, str, offset) {
        const len = str.length;
        writeUInt32BE(b, len, offset);
        offset += 4;
        for (let i = 0; i < len; i++) {
          writeUInt16LE(b, str.charCodeAt(i), offset);
          offset += 2;
        }
        return offset;
      }
      static _readString(b, offset) {
        const len = readUInt32BE(b, offset);
        offset += 4;
        return decodeUTF16LE(b, offset, len);
      }
      writeSize() {
        return 4 + 4 + _TextChange._writeStringSize(this.oldText) + _TextChange._writeStringSize(this.newText);
      }
      write(b, offset) {
        writeUInt32BE(b, this.oldPosition, offset);
        offset += 4;
        writeUInt32BE(b, this.newPosition, offset);
        offset += 4;
        offset = _TextChange._writeString(b, this.oldText, offset);
        offset = _TextChange._writeString(b, this.newText, offset);
        return offset;
      }
      static read(b, offset, dest) {
        const oldPosition = readUInt32BE(b, offset);
        offset += 4;
        const newPosition = readUInt32BE(b, offset);
        offset += 4;
        const oldText = _TextChange._readString(b, offset);
        offset += _TextChange._writeStringSize(oldText);
        const newText = _TextChange._readString(b, offset);
        offset += _TextChange._writeStringSize(newText);
        dest.push(new _TextChange(oldPosition, oldText, newPosition, newText));
        return offset;
      }
    };
    TextChangeCompressor = class _TextChangeCompressor {
      constructor(prevEdits, currEdits) {
        this._prevEdits = prevEdits;
        this._currEdits = currEdits;
        this._result = [];
        this._resultLen = 0;
        this._prevLen = this._prevEdits.length;
        this._prevDeltaOffset = 0;
        this._currLen = this._currEdits.length;
        this._currDeltaOffset = 0;
      }
      compress() {
        let prevIndex = 0;
        let currIndex = 0;
        let prevEdit = this._getPrev(prevIndex);
        let currEdit = this._getCurr(currIndex);
        while (prevIndex < this._prevLen || currIndex < this._currLen) {
          if (prevEdit === null) {
            this._acceptCurr(currEdit);
            currEdit = this._getCurr(++currIndex);
            continue;
          }
          if (currEdit === null) {
            this._acceptPrev(prevEdit);
            prevEdit = this._getPrev(++prevIndex);
            continue;
          }
          if (currEdit.oldEnd <= prevEdit.newPosition) {
            this._acceptCurr(currEdit);
            currEdit = this._getCurr(++currIndex);
            continue;
          }
          if (prevEdit.newEnd <= currEdit.oldPosition) {
            this._acceptPrev(prevEdit);
            prevEdit = this._getPrev(++prevIndex);
            continue;
          }
          if (currEdit.oldPosition < prevEdit.newPosition) {
            const [e1, e2] = _TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);
            this._acceptCurr(e1);
            currEdit = e2;
            continue;
          }
          if (prevEdit.newPosition < currEdit.oldPosition) {
            const [e1, e2] = _TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);
            this._acceptPrev(e1);
            prevEdit = e2;
            continue;
          }
          let mergePrev;
          let mergeCurr;
          if (currEdit.oldEnd === prevEdit.newEnd) {
            mergePrev = prevEdit;
            mergeCurr = currEdit;
            prevEdit = this._getPrev(++prevIndex);
            currEdit = this._getCurr(++currIndex);
          } else if (currEdit.oldEnd < prevEdit.newEnd) {
            const [e1, e2] = _TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);
            mergePrev = e1;
            mergeCurr = currEdit;
            prevEdit = e2;
            currEdit = this._getCurr(++currIndex);
          } else {
            const [e1, e2] = _TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);
            mergePrev = prevEdit;
            mergeCurr = e1;
            prevEdit = this._getPrev(++prevIndex);
            currEdit = e2;
          }
          this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);
          this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;
          this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;
        }
        const merged = _TextChangeCompressor._merge(this._result);
        const cleaned = _TextChangeCompressor._removeNoOps(merged);
        return cleaned;
      }
      _acceptCurr(currEdit) {
        this._result[this._resultLen++] = _TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);
        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;
      }
      _getCurr(currIndex) {
        return currIndex < this._currLen ? this._currEdits[currIndex] : null;
      }
      _acceptPrev(prevEdit) {
        this._result[this._resultLen++] = _TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);
        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;
      }
      _getPrev(prevIndex) {
        return prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null;
      }
      static _rebaseCurr(prevDeltaOffset, currEdit) {
        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);
      }
      static _rebasePrev(currDeltaOffset, prevEdit) {
        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);
      }
      static _splitPrev(edit, offset) {
        const preText = edit.newText.substr(0, offset);
        const postText = edit.newText.substr(offset);
        return [
          new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),
          new TextChange(edit.oldEnd, "", edit.newPosition + offset, postText)
        ];
      }
      static _splitCurr(edit, offset) {
        const preText = edit.oldText.substr(0, offset);
        const postText = edit.oldText.substr(offset);
        return [
          new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),
          new TextChange(edit.oldPosition + offset, postText, edit.newEnd, "")
        ];
      }
      static _merge(edits) {
        if (edits.length === 0) {
          return edits;
        }
        const result = [];
        let resultLen = 0;
        let prev = edits[0];
        for (let i = 1; i < edits.length; i++) {
          const curr = edits[i];
          if (prev.oldEnd === curr.oldPosition) {
            prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);
          } else {
            result[resultLen++] = prev;
            prev = curr;
          }
        }
        result[resultLen++] = prev;
        return result;
      }
      static _removeNoOps(edits) {
        if (edits.length === 0) {
          return edits;
        }
        const result = [];
        let resultLen = 0;
        for (let i = 0; i < edits.length; i++) {
          const edit = edits[i];
          if (edit.oldText === edit.newText) {
            continue;
          }
          result[resultLen++] = edit;
        }
        return result;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js
function uriGetComparisonKey(resource) {
  return resource.toString();
}
function getModelEOL(model) {
  const eol = model.getEOL();
  if (eol === "\n") {
    return 0;
  } else {
    return 1;
  }
}
function isEditStackElement(element) {
  if (!element) {
    return false;
  }
  return element instanceof SingleModelEditStackElement || element instanceof MultiModelEditStackElement;
}
var SingleModelEditStackData, SingleModelEditStackElement, MultiModelEditStackElement, EditStack;
var init_editStack = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js"() {
    init_nls();
    init_errors();
    init_selection();
    init_uri();
    init_textChange();
    init_buffer();
    init_resources();
    SingleModelEditStackData = class _SingleModelEditStackData {
      static create(model, beforeCursorState) {
        const alternativeVersionId = model.getAlternativeVersionId();
        const eol = getModelEOL(model);
        return new _SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);
      }
      constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {
        this.beforeVersionId = beforeVersionId;
        this.afterVersionId = afterVersionId;
        this.beforeEOL = beforeEOL;
        this.afterEOL = afterEOL;
        this.beforeCursorState = beforeCursorState;
        this.afterCursorState = afterCursorState;
        this.changes = changes;
      }
      append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {
        if (textChanges.length > 0) {
          this.changes = compressConsecutiveTextChanges(this.changes, textChanges);
        }
        this.afterEOL = afterEOL;
        this.afterVersionId = afterVersionId;
        this.afterCursorState = afterCursorState;
      }
      static _writeSelectionsSize(selections) {
        return 4 + 4 * 4 * (selections ? selections.length : 0);
      }
      static _writeSelections(b, selections, offset) {
        writeUInt32BE(b, selections ? selections.length : 0, offset);
        offset += 4;
        if (selections) {
          for (const selection of selections) {
            writeUInt32BE(b, selection.selectionStartLineNumber, offset);
            offset += 4;
            writeUInt32BE(b, selection.selectionStartColumn, offset);
            offset += 4;
            writeUInt32BE(b, selection.positionLineNumber, offset);
            offset += 4;
            writeUInt32BE(b, selection.positionColumn, offset);
            offset += 4;
          }
        }
        return offset;
      }
      static _readSelections(b, offset, dest) {
        const count = readUInt32BE(b, offset);
        offset += 4;
        for (let i = 0; i < count; i++) {
          const selectionStartLineNumber = readUInt32BE(b, offset);
          offset += 4;
          const selectionStartColumn = readUInt32BE(b, offset);
          offset += 4;
          const positionLineNumber = readUInt32BE(b, offset);
          offset += 4;
          const positionColumn = readUInt32BE(b, offset);
          offset += 4;
          dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));
        }
        return offset;
      }
      serialize() {
        let necessarySize = 4 + 4 + 1 + 1 + _SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState) + _SingleModelEditStackData._writeSelectionsSize(this.afterCursorState) + 4;
        for (const change of this.changes) {
          necessarySize += change.writeSize();
        }
        const b = new Uint8Array(necessarySize);
        let offset = 0;
        writeUInt32BE(b, this.beforeVersionId, offset);
        offset += 4;
        writeUInt32BE(b, this.afterVersionId, offset);
        offset += 4;
        writeUInt8(b, this.beforeEOL, offset);
        offset += 1;
        writeUInt8(b, this.afterEOL, offset);
        offset += 1;
        offset = _SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);
        offset = _SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);
        writeUInt32BE(b, this.changes.length, offset);
        offset += 4;
        for (const change of this.changes) {
          offset = change.write(b, offset);
        }
        return b.buffer;
      }
      static deserialize(source) {
        const b = new Uint8Array(source);
        let offset = 0;
        const beforeVersionId = readUInt32BE(b, offset);
        offset += 4;
        const afterVersionId = readUInt32BE(b, offset);
        offset += 4;
        const beforeEOL = readUInt8(b, offset);
        offset += 1;
        const afterEOL = readUInt8(b, offset);
        offset += 1;
        const beforeCursorState = [];
        offset = _SingleModelEditStackData._readSelections(b, offset, beforeCursorState);
        const afterCursorState = [];
        offset = _SingleModelEditStackData._readSelections(b, offset, afterCursorState);
        const changeCount = readUInt32BE(b, offset);
        offset += 4;
        const changes = [];
        for (let i = 0; i < changeCount; i++) {
          offset = TextChange.read(b, offset, changes);
        }
        return new _SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);
      }
    };
    SingleModelEditStackElement = class {
      get type() {
        return 0;
      }
      get resource() {
        if (URI.isUri(this.model)) {
          return this.model;
        }
        return this.model.uri;
      }
      constructor(label, code, model, beforeCursorState) {
        this.label = label;
        this.code = code;
        this.model = model;
        this._data = SingleModelEditStackData.create(model, beforeCursorState);
      }
      toString() {
        const data = this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data);
        return data.changes.map((change) => change.toString()).join(", ");
      }
      matchesResource(resource) {
        const uri = URI.isUri(this.model) ? this.model : this.model.uri;
        return uri.toString() === resource.toString();
      }
      setModel(model) {
        this.model = model;
      }
      canAppend(model) {
        return this.model === model && this._data instanceof SingleModelEditStackData;
      }
      append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {
        if (this._data instanceof SingleModelEditStackData) {
          this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);
        }
      }
      close() {
        if (this._data instanceof SingleModelEditStackData) {
          this._data = this._data.serialize();
        }
      }
      open() {
        if (!(this._data instanceof SingleModelEditStackData)) {
          this._data = SingleModelEditStackData.deserialize(this._data);
        }
      }
      undo() {
        if (URI.isUri(this.model)) {
          throw new Error(`Invalid SingleModelEditStackElement`);
        }
        if (this._data instanceof SingleModelEditStackData) {
          this._data = this._data.serialize();
        }
        const data = SingleModelEditStackData.deserialize(this._data);
        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);
      }
      redo() {
        if (URI.isUri(this.model)) {
          throw new Error(`Invalid SingleModelEditStackElement`);
        }
        if (this._data instanceof SingleModelEditStackData) {
          this._data = this._data.serialize();
        }
        const data = SingleModelEditStackData.deserialize(this._data);
        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);
      }
      heapSize() {
        if (this._data instanceof SingleModelEditStackData) {
          this._data = this._data.serialize();
        }
        return this._data.byteLength + 168;
      }
    };
    MultiModelEditStackElement = class {
      get resources() {
        return this._editStackElementsArr.map((editStackElement) => editStackElement.resource);
      }
      constructor(label, code, editStackElements) {
        this.label = label;
        this.code = code;
        this.type = 1;
        this._isOpen = true;
        this._editStackElementsArr = editStackElements.slice(0);
        this._editStackElementsMap = /* @__PURE__ */ new Map();
        for (const editStackElement of this._editStackElementsArr) {
          const key = uriGetComparisonKey(editStackElement.resource);
          this._editStackElementsMap.set(key, editStackElement);
        }
        this._delegate = null;
      }
      prepareUndoRedo() {
        if (this._delegate) {
          return this._delegate.prepareUndoRedo(this);
        }
      }
      matchesResource(resource) {
        const key = uriGetComparisonKey(resource);
        return this._editStackElementsMap.has(key);
      }
      setModel(model) {
        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);
        if (this._editStackElementsMap.has(key)) {
          this._editStackElementsMap.get(key).setModel(model);
        }
      }
      canAppend(model) {
        if (!this._isOpen) {
          return false;
        }
        const key = uriGetComparisonKey(model.uri);
        if (this._editStackElementsMap.has(key)) {
          const editStackElement = this._editStackElementsMap.get(key);
          return editStackElement.canAppend(model);
        }
        return false;
      }
      append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {
        const key = uriGetComparisonKey(model.uri);
        const editStackElement = this._editStackElementsMap.get(key);
        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);
      }
      close() {
        this._isOpen = false;
      }
      open() {
      }
      undo() {
        this._isOpen = false;
        for (const editStackElement of this._editStackElementsArr) {
          editStackElement.undo();
        }
      }
      redo() {
        for (const editStackElement of this._editStackElementsArr) {
          editStackElement.redo();
        }
      }
      heapSize(resource) {
        const key = uriGetComparisonKey(resource);
        if (this._editStackElementsMap.has(key)) {
          const editStackElement = this._editStackElementsMap.get(key);
          return editStackElement.heapSize();
        }
        return 0;
      }
      split() {
        return this._editStackElementsArr;
      }
      toString() {
        const result = [];
        for (const editStackElement of this._editStackElementsArr) {
          result.push(`${basename2(editStackElement.resource)}: ${editStackElement}`);
        }
        return `{${result.join(", ")}}`;
      }
    };
    EditStack = class _EditStack {
      constructor(model, undoRedoService) {
        this._model = model;
        this._undoRedoService = undoRedoService;
      }
      pushStackElement() {
        const lastElement = this._undoRedoService.getLastElement(this._model.uri);
        if (isEditStackElement(lastElement)) {
          lastElement.close();
        }
      }
      popStackElement() {
        const lastElement = this._undoRedoService.getLastElement(this._model.uri);
        if (isEditStackElement(lastElement)) {
          lastElement.open();
        }
      }
      clear() {
        this._undoRedoService.removeElements(this._model.uri);
      }
      _getOrCreateEditStackElement(beforeCursorState, group) {
        const lastElement = this._undoRedoService.getLastElement(this._model.uri);
        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {
          return lastElement;
        }
        const newElement = new SingleModelEditStackElement(localize("edit", "Typing"), "undoredo.textBufferEdit", this._model, beforeCursorState);
        this._undoRedoService.pushElement(newElement, group);
        return newElement;
      }
      pushEOL(eol) {
        const editStackElement = this._getOrCreateEditStackElement(null, void 0);
        this._model.setEOL(eol);
        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);
      }
      pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {
        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);
        const inverseEditOperations = this._model.applyEdits(editOperations, true);
        const afterCursorState = _EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);
        const textChanges = inverseEditOperations.map((op, index) => ({ index, textChange: op.textChange }));
        textChanges.sort((a, b) => {
          if (a.textChange.oldPosition === b.textChange.oldPosition) {
            return a.index - b.index;
          }
          return a.textChange.oldPosition - b.textChange.oldPosition;
        });
        editStackElement.append(this._model, textChanges.map((op) => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);
        return afterCursorState;
      }
      static _computeCursorState(cursorStateComputer, inverseEditOperations) {
        try {
          return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;
        } catch (e) {
          onUnexpectedError(e);
          return null;
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js
var TextModelPart;
var init_textModelPart = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js"() {
    init_lifecycle();
    TextModelPart = class extends Disposable {
      constructor() {
        super(...arguments);
        this._isDisposed = false;
      }
      dispose() {
        super.dispose();
        this._isDisposed = true;
      }
      assertNotDisposed() {
        if (this._isDisposed) {
          throw new Error("TextModelPart is disposed!");
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/utils.js
function computeIndentLevel(line, tabSize) {
  let indent = 0;
  let i = 0;
  const len = line.length;
  while (i < len) {
    const chCode = line.charCodeAt(i);
    if (chCode === 32) {
      indent++;
    } else if (chCode === 9) {
      indent = indent - indent % tabSize + tabSize;
    } else {
      break;
    }
    i++;
  }
  if (i === len) {
    return -1;
  }
  return indent;
}
var init_utils = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/utils.js"() {
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js
var HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine;
var init_textModelGuides = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js"() {
    (function(HorizontalGuidesState2) {
      HorizontalGuidesState2[HorizontalGuidesState2["Disabled"] = 0] = "Disabled";
      HorizontalGuidesState2[HorizontalGuidesState2["EnabledForActive"] = 1] = "EnabledForActive";
      HorizontalGuidesState2[HorizontalGuidesState2["Enabled"] = 2] = "Enabled";
    })(HorizontalGuidesState || (HorizontalGuidesState = {}));
    IndentGuide = class {
      constructor(visibleColumn, column, className, horizontalLine, forWrappedLinesAfterColumn, forWrappedLinesBeforeOrAtColumn) {
        this.visibleColumn = visibleColumn;
        this.column = column;
        this.className = className;
        this.horizontalLine = horizontalLine;
        this.forWrappedLinesAfterColumn = forWrappedLinesAfterColumn;
        this.forWrappedLinesBeforeOrAtColumn = forWrappedLinesBeforeOrAtColumn;
        if (visibleColumn !== -1 === (column !== -1)) {
          throw new Error();
        }
      }
    };
    IndentGuideHorizontalLine = class {
      constructor(top, endColumn) {
        this.top = top;
        this.endColumn = endColumn;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js
var GuidesTextModelPart, BracketPairGuidesClassNames;
var init_guidesTextModelPart = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js"() {
    init_arraysFind();
    init_strings();
    init_cursorColumns();
    init_range();
    init_textModelPart();
    init_utils();
    init_textModelGuides();
    init_errors();
    GuidesTextModelPart = class extends TextModelPart {
      constructor(textModel, languageConfigurationService) {
        super();
        this.textModel = textModel;
        this.languageConfigurationService = languageConfigurationService;
      }
      getLanguageConfiguration(languageId) {
        return this.languageConfigurationService.getLanguageConfiguration(languageId);
      }
      _computeIndentLevel(lineIndex) {
        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);
      }
      getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {
        this.assertNotDisposed();
        const lineCount = this.textModel.getLineCount();
        if (lineNumber < 1 || lineNumber > lineCount) {
          throw new BugIndicatingError("Illegal value for lineNumber");
        }
        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;
        const offSide = Boolean(foldingRules && foldingRules.offSide);
        let up_aboveContentLineIndex = -2;
        let up_aboveContentLineIndent = -1;
        let up_belowContentLineIndex = -2;
        let up_belowContentLineIndent = -1;
        const up_resolveIndents = (lineNumber2) => {
          if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber2 - 1)) {
            up_aboveContentLineIndex = -1;
            up_aboveContentLineIndent = -1;
            for (let lineIndex = lineNumber2 - 2; lineIndex >= 0; lineIndex--) {
              const indent2 = this._computeIndentLevel(lineIndex);
              if (indent2 >= 0) {
                up_aboveContentLineIndex = lineIndex;
                up_aboveContentLineIndent = indent2;
                break;
              }
            }
          }
          if (up_belowContentLineIndex === -2) {
            up_belowContentLineIndex = -1;
            up_belowContentLineIndent = -1;
            for (let lineIndex = lineNumber2; lineIndex < lineCount; lineIndex++) {
              const indent2 = this._computeIndentLevel(lineIndex);
              if (indent2 >= 0) {
                up_belowContentLineIndex = lineIndex;
                up_belowContentLineIndent = indent2;
                break;
              }
            }
          }
        };
        let down_aboveContentLineIndex = -2;
        let down_aboveContentLineIndent = -1;
        let down_belowContentLineIndex = -2;
        let down_belowContentLineIndent = -1;
        const down_resolveIndents = (lineNumber2) => {
          if (down_aboveContentLineIndex === -2) {
            down_aboveContentLineIndex = -1;
            down_aboveContentLineIndent = -1;
            for (let lineIndex = lineNumber2 - 2; lineIndex >= 0; lineIndex--) {
              const indent2 = this._computeIndentLevel(lineIndex);
              if (indent2 >= 0) {
                down_aboveContentLineIndex = lineIndex;
                down_aboveContentLineIndent = indent2;
                break;
              }
            }
          }
          if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber2 - 1)) {
            down_belowContentLineIndex = -1;
            down_belowContentLineIndent = -1;
            for (let lineIndex = lineNumber2; lineIndex < lineCount; lineIndex++) {
              const indent2 = this._computeIndentLevel(lineIndex);
              if (indent2 >= 0) {
                down_belowContentLineIndex = lineIndex;
                down_belowContentLineIndent = indent2;
                break;
              }
            }
          }
        };
        let startLineNumber = 0;
        let goUp = true;
        let endLineNumber = 0;
        let goDown = true;
        let indent = 0;
        let initialIndent = 0;
        for (let distance = 0; goUp || goDown; distance++) {
          const upLineNumber = lineNumber - distance;
          const downLineNumber = lineNumber + distance;
          if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {
            goUp = false;
          }
          if (distance > 1 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {
            goDown = false;
          }
          if (distance > 5e4) {
            goUp = false;
            goDown = false;
          }
          let upLineIndentLevel = -1;
          if (goUp && upLineNumber >= 1) {
            const currentIndent = this._computeIndentLevel(upLineNumber - 1);
            if (currentIndent >= 0) {
              up_belowContentLineIndex = upLineNumber - 1;
              up_belowContentLineIndent = currentIndent;
              upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);
            } else {
              up_resolveIndents(upLineNumber);
              upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);
            }
          }
          let downLineIndentLevel = -1;
          if (goDown && downLineNumber <= lineCount) {
            const currentIndent = this._computeIndentLevel(downLineNumber - 1);
            if (currentIndent >= 0) {
              down_aboveContentLineIndex = downLineNumber - 1;
              down_aboveContentLineIndent = currentIndent;
              downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);
            } else {
              down_resolveIndents(downLineNumber);
              downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);
            }
          }
          if (distance === 0) {
            initialIndent = upLineIndentLevel;
            continue;
          }
          if (distance === 1) {
            if (downLineNumber <= lineCount && downLineIndentLevel >= 0 && initialIndent + 1 === downLineIndentLevel) {
              goUp = false;
              startLineNumber = downLineNumber;
              endLineNumber = downLineNumber;
              indent = downLineIndentLevel;
              continue;
            }
            if (upLineNumber >= 1 && upLineIndentLevel >= 0 && upLineIndentLevel - 1 === initialIndent) {
              goDown = false;
              startLineNumber = upLineNumber;
              endLineNumber = upLineNumber;
              indent = upLineIndentLevel;
              continue;
            }
            startLineNumber = lineNumber;
            endLineNumber = lineNumber;
            indent = initialIndent;
            if (indent === 0) {
              return { startLineNumber, endLineNumber, indent };
            }
          }
          if (goUp) {
            if (upLineIndentLevel >= indent) {
              startLineNumber = upLineNumber;
            } else {
              goUp = false;
            }
          }
          if (goDown) {
            if (downLineIndentLevel >= indent) {
              endLineNumber = downLineNumber;
            } else {
              goDown = false;
            }
          }
        }
        return { startLineNumber, endLineNumber, indent };
      }
      getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options2) {
        var _a2;
        const result = [];
        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
          result.push([]);
        }
        const includeSingleLinePairs = true;
        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range2(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();
        let activeBracketPairRange = void 0;
        if (activePosition && bracketPairs.length > 0) {
          const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber && activePosition.lineNumber <= endLineNumber ? bracketPairs : this.textModel.bracketPairs.getBracketPairsInRange(Range2.fromPositions(activePosition)).toArray()).filter((bp) => Range2.strictContainsPosition(bp.range, activePosition));
          activeBracketPairRange = (_a2 = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)) === null || _a2 === void 0 ? void 0 : _a2.range;
        }
        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;
        const colorProvider = new BracketPairGuidesClassNames();
        for (const pair of bracketPairs) {
          if (!pair.closingBracketRange) {
            continue;
          }
          const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);
          if (!isActive && !options2.includeInactive) {
            continue;
          }
          const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) + (options2.highlightActive && isActive ? " " + colorProvider.activeClassName : "");
          const start = pair.openingBracketRange.getStartPosition();
          const end = pair.closingBracketRange.getStartPosition();
          const horizontalGuides = options2.horizontalGuides === HorizontalGuidesState.Enabled || options2.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive;
          if (pair.range.startLineNumber === pair.range.endLineNumber) {
            if (includeSingleLinePairs && horizontalGuides) {
              result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));
            }
            continue;
          }
          const endVisibleColumn = this.getVisibleColumnFromPosition(end);
          const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());
          const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);
          let renderHorizontalEndLineAtTheBottom = false;
          const firstNonWsIndex = firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));
          const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;
          if (hasTextBeforeClosingBracket) {
            renderHorizontalEndLineAtTheBottom = true;
          }
          const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);
          const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);
          const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;
          for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {
            result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));
          }
          if (horizontalGuides) {
            if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {
              result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));
            }
            if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {
              result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));
            }
          }
        }
        for (const guides of result) {
          guides.sort((a, b) => a.visibleColumn - b.visibleColumn);
        }
        return result;
      }
      getVisibleColumnFromPosition(position) {
        return CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1;
      }
      getLinesIndentGuides(startLineNumber, endLineNumber) {
        this.assertNotDisposed();
        const lineCount = this.textModel.getLineCount();
        if (startLineNumber < 1 || startLineNumber > lineCount) {
          throw new Error("Illegal value for startLineNumber");
        }
        if (endLineNumber < 1 || endLineNumber > lineCount) {
          throw new Error("Illegal value for endLineNumber");
        }
        const options2 = this.textModel.getOptions();
        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;
        const offSide = Boolean(foldingRules && foldingRules.offSide);
        const result = new Array(endLineNumber - startLineNumber + 1);
        let aboveContentLineIndex = -2;
        let aboveContentLineIndent = -1;
        let belowContentLineIndex = -2;
        let belowContentLineIndent = -1;
        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
          const resultIndex = lineNumber - startLineNumber;
          const currentIndent = this._computeIndentLevel(lineNumber - 1);
          if (currentIndent >= 0) {
            aboveContentLineIndex = lineNumber - 1;
            aboveContentLineIndent = currentIndent;
            result[resultIndex] = Math.ceil(currentIndent / options2.indentSize);
            continue;
          }
          if (aboveContentLineIndex === -2) {
            aboveContentLineIndex = -1;
            aboveContentLineIndent = -1;
            for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {
              const indent = this._computeIndentLevel(lineIndex);
              if (indent >= 0) {
                aboveContentLineIndex = lineIndex;
                aboveContentLineIndent = indent;
                break;
              }
            }
          }
          if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {
            belowContentLineIndex = -1;
            belowContentLineIndent = -1;
            for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {
              const indent = this._computeIndentLevel(lineIndex);
              if (indent >= 0) {
                belowContentLineIndex = lineIndex;
                belowContentLineIndent = indent;
                break;
              }
            }
          }
          result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);
        }
        return result;
      }
      _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {
        const options2 = this.textModel.getOptions();
        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {
          return 0;
        } else if (aboveContentLineIndent < belowContentLineIndent) {
          return 1 + Math.floor(aboveContentLineIndent / options2.indentSize);
        } else if (aboveContentLineIndent === belowContentLineIndent) {
          return Math.ceil(belowContentLineIndent / options2.indentSize);
        } else {
          if (offSide) {
            return Math.ceil(belowContentLineIndent / options2.indentSize);
          } else {
            return 1 + Math.floor(belowContentLineIndent / options2.indentSize);
          }
        }
      }
    };
    BracketPairGuidesClassNames = class {
      constructor() {
        this.activeClassName = "indent-active";
      }
      getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {
        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);
      }
      getInlineClassNameOfLevel(level) {
        return `bracket-indent-guide lvl-${level % 30}`;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js
function spacesDiff(a, aLength, b, bLength, result) {
  result.spacesDiff = 0;
  result.looksLikeAlignment = false;
  let i;
  for (i = 0; i < aLength && i < bLength; i++) {
    const aCharCode = a.charCodeAt(i);
    const bCharCode = b.charCodeAt(i);
    if (aCharCode !== bCharCode) {
      break;
    }
  }
  let aSpacesCnt = 0, aTabsCount = 0;
  for (let j = i; j < aLength; j++) {
    const aCharCode = a.charCodeAt(j);
    if (aCharCode === 32) {
      aSpacesCnt++;
    } else {
      aTabsCount++;
    }
  }
  let bSpacesCnt = 0, bTabsCount = 0;
  for (let j = i; j < bLength; j++) {
    const bCharCode = b.charCodeAt(j);
    if (bCharCode === 32) {
      bSpacesCnt++;
    } else {
      bTabsCount++;
    }
  }
  if (aSpacesCnt > 0 && aTabsCount > 0) {
    return;
  }
  if (bSpacesCnt > 0 && bTabsCount > 0) {
    return;
  }
  const tabsDiff = Math.abs(aTabsCount - bTabsCount);
  const spacesDiff2 = Math.abs(aSpacesCnt - bSpacesCnt);
  if (tabsDiff === 0) {
    result.spacesDiff = spacesDiff2;
    if (spacesDiff2 > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {
      if (b.charCodeAt(bSpacesCnt) !== 32 && a.charCodeAt(bSpacesCnt - 1) === 32) {
        if (a.charCodeAt(a.length - 1) === 44) {
          result.looksLikeAlignment = true;
        }
      }
    }
    return;
  }
  if (spacesDiff2 % tabsDiff === 0) {
    result.spacesDiff = spacesDiff2 / tabsDiff;
    return;
  }
}
function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {
  const linesCount = Math.min(source.getLineCount(), 1e4);
  let linesIndentedWithTabsCount = 0;
  let linesIndentedWithSpacesCount = 0;
  let previousLineText = "";
  let previousLineIndentation = 0;
  const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7];
  const MAX_ALLOWED_TAB_SIZE_GUESS = 8;
  const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  const tmp = new SpacesDiffResult();
  for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {
    const currentLineLength = source.getLineLength(lineNumber);
    const currentLineText = source.getLineContent(lineNumber);
    const useCurrentLineText = currentLineLength <= 65536;
    let currentLineHasContent = false;
    let currentLineIndentation = 0;
    let currentLineSpacesCount = 0;
    let currentLineTabsCount = 0;
    for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {
      const charCode = useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j);
      if (charCode === 9) {
        currentLineTabsCount++;
      } else if (charCode === 32) {
        currentLineSpacesCount++;
      } else {
        currentLineHasContent = true;
        currentLineIndentation = j;
        break;
      }
    }
    if (!currentLineHasContent) {
      continue;
    }
    if (currentLineTabsCount > 0) {
      linesIndentedWithTabsCount++;
    } else if (currentLineSpacesCount > 1) {
      linesIndentedWithSpacesCount++;
    }
    spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);
    if (tmp.looksLikeAlignment) {
      if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {
        continue;
      }
    }
    const currentSpacesDiff = tmp.spacesDiff;
    if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {
      spacesDiffCount[currentSpacesDiff]++;
    }
    previousLineText = currentLineText;
    previousLineIndentation = currentLineIndentation;
  }
  let insertSpaces = defaultInsertSpaces;
  if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {
    insertSpaces = linesIndentedWithTabsCount < linesIndentedWithSpacesCount;
  }
  let tabSize = defaultTabSize;
  if (insertSpaces) {
    let tabSizeScore = insertSpaces ? 0 : 0.1 * linesCount;
    ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {
      const possibleTabSizeScore = spacesDiffCount[possibleTabSize];
      if (possibleTabSizeScore > tabSizeScore) {
        tabSizeScore = possibleTabSizeScore;
        tabSize = possibleTabSize;
      }
    });
    if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {
      tabSize = 2;
    }
  }
  return {
    insertSpaces,
    tabSize
  };
}
var SpacesDiffResult;
var init_indentationGuesser = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js"() {
    SpacesDiffResult = class {
      constructor() {
        this.spacesDiff = 0;
        this.looksLikeAlignment = false;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js
function getNodeColor(node) {
  return (node.metadata & 1) >>> 0;
}
function setNodeColor(node, color) {
  node.metadata = node.metadata & 254 | color << 0;
}
function getNodeIsVisited(node) {
  return (node.metadata & 2) >>> 1 === 1;
}
function setNodeIsVisited(node, value) {
  node.metadata = node.metadata & 253 | (value ? 1 : 0) << 1;
}
function getNodeIsForValidation(node) {
  return (node.metadata & 4) >>> 2 === 1;
}
function setNodeIsForValidation(node, value) {
  node.metadata = node.metadata & 251 | (value ? 1 : 0) << 2;
}
function getNodeIsInGlyphMargin(node) {
  return (node.metadata & 64) >>> 6 === 1;
}
function setNodeIsInGlyphMargin(node, value) {
  node.metadata = node.metadata & 191 | (value ? 1 : 0) << 6;
}
function getNodeStickiness(node) {
  return (node.metadata & 24) >>> 3;
}
function _setNodeStickiness(node, stickiness) {
  node.metadata = node.metadata & 231 | stickiness << 3;
}
function getCollapseOnReplaceEdit(node) {
  return (node.metadata & 32) >>> 5 === 1;
}
function setCollapseOnReplaceEdit(node, value) {
  node.metadata = node.metadata & 223 | (value ? 1 : 0) << 5;
}
function normalizeDelta(T) {
  let node = T.root;
  let delta = 0;
  while (node !== SENTINEL) {
    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
      node = node.left;
      continue;
    }
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      delta += node.delta;
      node = node.right;
      continue;
    }
    node.start = delta + node.start;
    node.end = delta + node.end;
    node.delta = 0;
    recomputeMaxEnd(node);
    setNodeIsVisited(node, true);
    setNodeIsVisited(node.left, false);
    setNodeIsVisited(node.right, false);
    if (node === node.parent.right) {
      delta -= node.parent.delta;
    }
    node = node.parent;
  }
  setNodeIsVisited(T.root, false);
}
function adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {
  if (markerOffset < checkOffset) {
    return true;
  }
  if (markerOffset > checkOffset) {
    return false;
  }
  if (moveSemantics === 1) {
    return false;
  }
  if (moveSemantics === 2) {
    return true;
  }
  return markerStickToPreviousCharacter;
}
function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {
  const nodeStickiness = getNodeStickiness(node);
  const startStickToPreviousCharacter = nodeStickiness === 0 || nodeStickiness === 2;
  const endStickToPreviousCharacter = nodeStickiness === 1 || nodeStickiness === 2;
  const deletingCnt = end - start;
  const insertingCnt = textLength;
  const commonLength = Math.min(deletingCnt, insertingCnt);
  const nodeStart = node.start;
  let startDone = false;
  const nodeEnd = node.end;
  let endDone = false;
  if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {
    node.start = start;
    startDone = true;
    node.end = start;
    endDone = true;
  }
  {
    const moveSemantics = forceMoveMarkers ? 1 : deletingCnt > 0 ? 2 : 0;
    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {
      startDone = true;
    }
    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {
      endDone = true;
    }
  }
  if (commonLength > 0 && !forceMoveMarkers) {
    const moveSemantics = deletingCnt > insertingCnt ? 2 : 0;
    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {
      startDone = true;
    }
    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {
      endDone = true;
    }
  }
  {
    const moveSemantics = forceMoveMarkers ? 1 : 0;
    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {
      node.start = start + insertingCnt;
      startDone = true;
    }
    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {
      node.end = start + insertingCnt;
      endDone = true;
    }
  }
  const deltaColumn = insertingCnt - deletingCnt;
  if (!startDone) {
    node.start = Math.max(0, nodeStart + deltaColumn);
  }
  if (!endDone) {
    node.end = Math.max(0, nodeEnd + deltaColumn);
  }
  if (node.start > node.end) {
    node.end = node.start;
  }
}
function searchForEditing(T, start, end) {
  let node = T.root;
  let delta = 0;
  let nodeMaxEnd = 0;
  let nodeStart = 0;
  let nodeEnd = 0;
  const result = [];
  let resultLen = 0;
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      if (node === node.parent.right) {
        delta -= node.parent.delta;
      }
      node = node.parent;
      continue;
    }
    if (!getNodeIsVisited(node.left)) {
      nodeMaxEnd = delta + node.maxEnd;
      if (nodeMaxEnd < start) {
        setNodeIsVisited(node, true);
        continue;
      }
      if (node.left !== SENTINEL) {
        node = node.left;
        continue;
      }
    }
    nodeStart = delta + node.start;
    if (nodeStart > end) {
      setNodeIsVisited(node, true);
      continue;
    }
    nodeEnd = delta + node.end;
    if (nodeEnd >= start) {
      node.setCachedOffsets(nodeStart, nodeEnd, 0);
      result[resultLen++] = node;
    }
    setNodeIsVisited(node, true);
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      delta += node.delta;
      node = node.right;
      continue;
    }
  }
  setNodeIsVisited(T.root, false);
  return result;
}
function noOverlapReplace(T, start, end, textLength) {
  let node = T.root;
  let delta = 0;
  let nodeMaxEnd = 0;
  let nodeStart = 0;
  const editDelta = textLength - (end - start);
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      if (node === node.parent.right) {
        delta -= node.parent.delta;
      }
      recomputeMaxEnd(node);
      node = node.parent;
      continue;
    }
    if (!getNodeIsVisited(node.left)) {
      nodeMaxEnd = delta + node.maxEnd;
      if (nodeMaxEnd < start) {
        setNodeIsVisited(node, true);
        continue;
      }
      if (node.left !== SENTINEL) {
        node = node.left;
        continue;
      }
    }
    nodeStart = delta + node.start;
    if (nodeStart > end) {
      node.start += editDelta;
      node.end += editDelta;
      node.delta += editDelta;
      if (node.delta < -1073741824 || node.delta > 1073741824) {
        T.requestNormalizeDelta = true;
      }
      setNodeIsVisited(node, true);
      continue;
    }
    setNodeIsVisited(node, true);
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      delta += node.delta;
      node = node.right;
      continue;
    }
  }
  setNodeIsVisited(T.root, false);
}
function collectNodesFromOwner(T, ownerId) {
  let node = T.root;
  const result = [];
  let resultLen = 0;
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      node = node.parent;
      continue;
    }
    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
      node = node.left;
      continue;
    }
    if (node.ownerId === ownerId) {
      result[resultLen++] = node;
    }
    setNodeIsVisited(node, true);
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      node = node.right;
      continue;
    }
  }
  setNodeIsVisited(T.root, false);
  return result;
}
function collectNodesPostOrder(T) {
  let node = T.root;
  const result = [];
  let resultLen = 0;
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      node = node.parent;
      continue;
    }
    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
      node = node.left;
      continue;
    }
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      node = node.right;
      continue;
    }
    result[resultLen++] = node;
    setNodeIsVisited(node, true);
  }
  setNodeIsVisited(T.root, false);
  return result;
}
function search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {
  let node = T.root;
  let delta = 0;
  let nodeStart = 0;
  let nodeEnd = 0;
  const result = [];
  let resultLen = 0;
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      if (node === node.parent.right) {
        delta -= node.parent.delta;
      }
      node = node.parent;
      continue;
    }
    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {
      node = node.left;
      continue;
    }
    nodeStart = delta + node.start;
    nodeEnd = delta + node.end;
    node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
    let include = true;
    if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {
      include = false;
    }
    if (filterOutValidation && getNodeIsForValidation(node)) {
      include = false;
    }
    if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {
      include = false;
    }
    if (include) {
      result[resultLen++] = node;
    }
    setNodeIsVisited(node, true);
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      delta += node.delta;
      node = node.right;
      continue;
    }
  }
  setNodeIsVisited(T.root, false);
  return result;
}
function intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {
  let node = T.root;
  let delta = 0;
  let nodeMaxEnd = 0;
  let nodeStart = 0;
  let nodeEnd = 0;
  const result = [];
  let resultLen = 0;
  while (node !== SENTINEL) {
    if (getNodeIsVisited(node)) {
      setNodeIsVisited(node.left, false);
      setNodeIsVisited(node.right, false);
      if (node === node.parent.right) {
        delta -= node.parent.delta;
      }
      node = node.parent;
      continue;
    }
    if (!getNodeIsVisited(node.left)) {
      nodeMaxEnd = delta + node.maxEnd;
      if (nodeMaxEnd < intervalStart) {
        setNodeIsVisited(node, true);
        continue;
      }
      if (node.left !== SENTINEL) {
        node = node.left;
        continue;
      }
    }
    nodeStart = delta + node.start;
    if (nodeStart > intervalEnd) {
      setNodeIsVisited(node, true);
      continue;
    }
    nodeEnd = delta + node.end;
    if (nodeEnd >= intervalStart) {
      node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
      let include = true;
      if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {
        include = false;
      }
      if (filterOutValidation && getNodeIsForValidation(node)) {
        include = false;
      }
      if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {
        include = false;
      }
      if (include) {
        result[resultLen++] = node;
      }
    }
    setNodeIsVisited(node, true);
    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {
      delta += node.delta;
      node = node.right;
      continue;
    }
  }
  setNodeIsVisited(T.root, false);
  return result;
}
function rbTreeInsert(T, newNode) {
  if (T.root === SENTINEL) {
    newNode.parent = SENTINEL;
    newNode.left = SENTINEL;
    newNode.right = SENTINEL;
    setNodeColor(
      newNode,
      0
      /* NodeColor.Black */
    );
    T.root = newNode;
    return T.root;
  }
  treeInsert(T, newNode);
  recomputeMaxEndWalkToRoot(newNode.parent);
  let x = newNode;
  while (x !== T.root && getNodeColor(x.parent) === 1) {
    if (x.parent === x.parent.parent.left) {
      const y = x.parent.parent.right;
      if (getNodeColor(y) === 1) {
        setNodeColor(
          x.parent,
          0
          /* NodeColor.Black */
        );
        setNodeColor(
          y,
          0
          /* NodeColor.Black */
        );
        setNodeColor(
          x.parent.parent,
          1
          /* NodeColor.Red */
        );
        x = x.parent.parent;
      } else {
        if (x === x.parent.right) {
          x = x.parent;
          leftRotate(T, x);
        }
        setNodeColor(
          x.parent,
          0
          /* NodeColor.Black */
        );
        setNodeColor(
          x.parent.parent,
          1
          /* NodeColor.Red */
        );
        rightRotate(T, x.parent.parent);
      }
    } else {
      const y = x.parent.parent.left;
      if (getNodeColor(y) === 1) {
        setNodeColor(
          x.parent,
          0
          /* NodeColor.Black */
        );
        setNodeColor(
          y,
          0
          /* NodeColor.Black */
        );
        setNodeColor(
          x.parent.parent,
          1
          /* NodeColor.Red */
        );
        x = x.parent.parent;
      } else {
        if (x === x.parent.left) {
          x = x.parent;
          rightRotate(T, x);
        }
        setNodeColor(
          x.parent,
          0
          /* NodeColor.Black */
        );
        setNodeColor(
          x.parent.parent,
          1
          /* NodeColor.Red */
        );
        leftRotate(T, x.parent.parent);
      }
    }
  }
  setNodeColor(
    T.root,
    0
    /* NodeColor.Black */
  );
  return newNode;
}
function treeInsert(T, z) {
  let delta = 0;
  let x = T.root;
  const zAbsoluteStart = z.start;
  const zAbsoluteEnd = z.end;
  while (true) {
    const cmp3 = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);
    if (cmp3 < 0) {
      if (x.left === SENTINEL) {
        z.start -= delta;
        z.end -= delta;
        z.maxEnd -= delta;
        x.left = z;
        break;
      } else {
        x = x.left;
      }
    } else {
      if (x.right === SENTINEL) {
        z.start -= delta + x.delta;
        z.end -= delta + x.delta;
        z.maxEnd -= delta + x.delta;
        x.right = z;
        break;
      } else {
        delta += x.delta;
        x = x.right;
      }
    }
  }
  z.parent = x;
  z.left = SENTINEL;
  z.right = SENTINEL;
  setNodeColor(
    z,
    1
    /* NodeColor.Red */
  );
}
function rbTreeDelete(T, z) {
  let x;
  let y;
  if (z.left === SENTINEL) {
    x = z.right;
    y = z;
    x.delta += z.delta;
    if (x.delta < -1073741824 || x.delta > 1073741824) {
      T.requestNormalizeDelta = true;
    }
    x.start += z.delta;
    x.end += z.delta;
  } else if (z.right === SENTINEL) {
    x = z.left;
    y = z;
  } else {
    y = leftest(z.right);
    x = y.right;
    x.start += y.delta;
    x.end += y.delta;
    x.delta += y.delta;
    if (x.delta < -1073741824 || x.delta > 1073741824) {
      T.requestNormalizeDelta = true;
    }
    y.start += z.delta;
    y.end += z.delta;
    y.delta = z.delta;
    if (y.delta < -1073741824 || y.delta > 1073741824) {
      T.requestNormalizeDelta = true;
    }
  }
  if (y === T.root) {
    T.root = x;
    setNodeColor(
      x,
      0
      /* NodeColor.Black */
    );
    z.detach();
    resetSentinel();
    recomputeMaxEnd(x);
    T.root.parent = SENTINEL;
    return;
  }
  const yWasRed = getNodeColor(y) === 1;
  if (y === y.parent.left) {
    y.parent.left = x;
  } else {
    y.parent.right = x;
  }
  if (y === z) {
    x.parent = y.parent;
  } else {
    if (y.parent === z) {
      x.parent = y;
    } else {
      x.parent = y.parent;
    }
    y.left = z.left;
    y.right = z.right;
    y.parent = z.parent;
    setNodeColor(y, getNodeColor(z));
    if (z === T.root) {
      T.root = y;
    } else {
      if (z === z.parent.left) {
        z.parent.left = y;
      } else {
        z.parent.right = y;
      }
    }
    if (y.left !== SENTINEL) {
      y.left.parent = y;
    }
    if (y.right !== SENTINEL) {
      y.right.parent = y;
    }
  }
  z.detach();
  if (yWasRed) {
    recomputeMaxEndWalkToRoot(x.parent);
    if (y !== z) {
      recomputeMaxEndWalkToRoot(y);
      recomputeMaxEndWalkToRoot(y.parent);
    }
    resetSentinel();
    return;
  }
  recomputeMaxEndWalkToRoot(x);
  recomputeMaxEndWalkToRoot(x.parent);
  if (y !== z) {
    recomputeMaxEndWalkToRoot(y);
    recomputeMaxEndWalkToRoot(y.parent);
  }
  let w;
  while (x !== T.root && getNodeColor(x) === 0) {
    if (x === x.parent.left) {
      w = x.parent.right;
      if (getNodeColor(w) === 1) {
        setNodeColor(
          w,
          0
          /* NodeColor.Black */
        );
        setNodeColor(
          x.parent,
          1
          /* NodeColor.Red */
        );
        leftRotate(T, x.parent);
        w = x.parent.right;
      }
      if (getNodeColor(w.left) === 0 && getNodeColor(w.right) === 0) {
        setNodeColor(
          w,
          1
          /* NodeColor.Red */
        );
        x = x.parent;
      } else {
        if (getNodeColor(w.right) === 0) {
          setNodeColor(
            w.left,
            0
            /* NodeColor.Black */
          );
          setNodeColor(
            w,
            1
            /* NodeColor.Red */
          );
          rightRotate(T, w);
          w = x.parent.right;
        }
        setNodeColor(w, getNodeColor(x.parent));
        setNodeColor(
          x.parent,
          0
          /* NodeColor.Black */
        );
        setNodeColor(
          w.right,
          0
          /* NodeColor.Black */
        );
        leftRotate(T, x.parent);
        x = T.root;
      }
    } else {
      w = x.parent.left;
      if (getNodeColor(w) === 1) {
        setNodeColor(
          w,
          0
          /* NodeColor.Black */
        );
        setNodeColor(
          x.parent,
          1
          /* NodeColor.Red */
        );
        rightRotate(T, x.parent);
        w = x.parent.left;
      }
      if (getNodeColor(w.left) === 0 && getNodeColor(w.right) === 0) {
        setNodeColor(
          w,
          1
          /* NodeColor.Red */
        );
        x = x.parent;
      } else {
        if (getNodeColor(w.left) === 0) {
          setNodeColor(
            w.right,
            0
            /* NodeColor.Black */
          );
          setNodeColor(
            w,
            1
            /* NodeColor.Red */
          );
          leftRotate(T, w);
          w = x.parent.left;
        }
        setNodeColor(w, getNodeColor(x.parent));
        setNodeColor(
          x.parent,
          0
          /* NodeColor.Black */
        );
        setNodeColor(
          w.left,
          0
          /* NodeColor.Black */
        );
        rightRotate(T, x.parent);
        x = T.root;
      }
    }
  }
  setNodeColor(
    x,
    0
    /* NodeColor.Black */
  );
  resetSentinel();
}
function leftest(node) {
  while (node.left !== SENTINEL) {
    node = node.left;
  }
  return node;
}
function resetSentinel() {
  SENTINEL.parent = SENTINEL;
  SENTINEL.delta = 0;
  SENTINEL.start = 0;
  SENTINEL.end = 0;
}
function leftRotate(T, x) {
  const y = x.right;
  y.delta += x.delta;
  if (y.delta < -1073741824 || y.delta > 1073741824) {
    T.requestNormalizeDelta = true;
  }
  y.start += x.delta;
  y.end += x.delta;
  x.right = y.left;
  if (y.left !== SENTINEL) {
    y.left.parent = x;
  }
  y.parent = x.parent;
  if (x.parent === SENTINEL) {
    T.root = y;
  } else if (x === x.parent.left) {
    x.parent.left = y;
  } else {
    x.parent.right = y;
  }
  y.left = x;
  x.parent = y;
  recomputeMaxEnd(x);
  recomputeMaxEnd(y);
}
function rightRotate(T, y) {
  const x = y.left;
  y.delta -= x.delta;
  if (y.delta < -1073741824 || y.delta > 1073741824) {
    T.requestNormalizeDelta = true;
  }
  y.start -= x.delta;
  y.end -= x.delta;
  y.left = x.right;
  if (x.right !== SENTINEL) {
    x.right.parent = y;
  }
  x.parent = y.parent;
  if (y.parent === SENTINEL) {
    T.root = x;
  } else if (y === y.parent.right) {
    y.parent.right = x;
  } else {
    y.parent.left = x;
  }
  x.right = y;
  y.parent = x;
  recomputeMaxEnd(y);
  recomputeMaxEnd(x);
}
function computeMaxEnd(node) {
  let maxEnd = node.end;
  if (node.left !== SENTINEL) {
    const leftMaxEnd = node.left.maxEnd;
    if (leftMaxEnd > maxEnd) {
      maxEnd = leftMaxEnd;
    }
  }
  if (node.right !== SENTINEL) {
    const rightMaxEnd = node.right.maxEnd + node.delta;
    if (rightMaxEnd > maxEnd) {
      maxEnd = rightMaxEnd;
    }
  }
  return maxEnd;
}
function recomputeMaxEnd(node) {
  node.maxEnd = computeMaxEnd(node);
}
function recomputeMaxEndWalkToRoot(node) {
  while (node !== SENTINEL) {
    const maxEnd = computeMaxEnd(node);
    if (node.maxEnd === maxEnd) {
      return;
    }
    node.maxEnd = maxEnd;
    node = node.parent;
  }
}
function intervalCompare(aStart, aEnd, bStart, bEnd) {
  if (aStart === bStart) {
    return aEnd - bEnd;
  }
  return aStart - bStart;
}
var IntervalNode, SENTINEL, IntervalTree;
var init_intervalTree = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js"() {
    IntervalNode = class {
      constructor(id, start, end) {
        this.metadata = 0;
        this.parent = this;
        this.left = this;
        this.right = this;
        setNodeColor(
          this,
          1
          /* NodeColor.Red */
        );
        this.start = start;
        this.end = end;
        this.delta = 0;
        this.maxEnd = end;
        this.id = id;
        this.ownerId = 0;
        this.options = null;
        setNodeIsForValidation(this, false);
        setNodeIsInGlyphMargin(this, false);
        _setNodeStickiness(
          this,
          1
          /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
        );
        setCollapseOnReplaceEdit(this, false);
        this.cachedVersionId = 0;
        this.cachedAbsoluteStart = start;
        this.cachedAbsoluteEnd = end;
        this.range = null;
        setNodeIsVisited(this, false);
      }
      reset(versionId, start, end, range2) {
        this.start = start;
        this.end = end;
        this.maxEnd = end;
        this.cachedVersionId = versionId;
        this.cachedAbsoluteStart = start;
        this.cachedAbsoluteEnd = end;
        this.range = range2;
      }
      setOptions(options2) {
        this.options = options2;
        const className = this.options.className;
        setNodeIsForValidation(this, className === "squiggly-error" || className === "squiggly-warning" || className === "squiggly-info");
        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);
        _setNodeStickiness(this, this.options.stickiness);
        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);
      }
      setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {
        if (this.cachedVersionId !== cachedVersionId) {
          this.range = null;
        }
        this.cachedVersionId = cachedVersionId;
        this.cachedAbsoluteStart = absoluteStart;
        this.cachedAbsoluteEnd = absoluteEnd;
      }
      detach() {
        this.parent = null;
        this.left = null;
        this.right = null;
      }
    };
    SENTINEL = new IntervalNode(null, 0, 0);
    SENTINEL.parent = SENTINEL;
    SENTINEL.left = SENTINEL;
    SENTINEL.right = SENTINEL;
    setNodeColor(
      SENTINEL,
      0
      /* NodeColor.Black */
    );
    IntervalTree = class {
      constructor() {
        this.root = SENTINEL;
        this.requestNormalizeDelta = false;
      }
      intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {
        if (this.root === SENTINEL) {
          return [];
        }
        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
      }
      search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {
        if (this.root === SENTINEL) {
          return [];
        }
        return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
      }
      /**
       * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
       */
      collectNodesFromOwner(ownerId) {
        return collectNodesFromOwner(this, ownerId);
      }
      /**
       * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
       */
      collectNodesPostOrder() {
        return collectNodesPostOrder(this);
      }
      insert(node) {
        rbTreeInsert(this, node);
        this._normalizeDeltaIfNecessary();
      }
      delete(node) {
        rbTreeDelete(this, node);
        this._normalizeDeltaIfNecessary();
      }
      resolveNode(node, cachedVersionId) {
        const initialNode = node;
        let delta = 0;
        while (node !== this.root) {
          if (node === node.parent.right) {
            delta += node.parent.delta;
          }
          node = node.parent;
        }
        const nodeStart = initialNode.start + delta;
        const nodeEnd = initialNode.end + delta;
        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);
      }
      acceptReplace(offset, length, textLength, forceMoveMarkers) {
        const nodesOfInterest = searchForEditing(this, offset, offset + length);
        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {
          const node = nodesOfInterest[i];
          rbTreeDelete(this, node);
        }
        this._normalizeDeltaIfNecessary();
        noOverlapReplace(this, offset, offset + length, textLength);
        this._normalizeDeltaIfNecessary();
        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {
          const node = nodesOfInterest[i];
          node.start = node.cachedAbsoluteStart;
          node.end = node.cachedAbsoluteEnd;
          nodeAcceptEdit(node, offset, offset + length, textLength, forceMoveMarkers);
          node.maxEnd = node.end;
          rbTreeInsert(this, node);
        }
        this._normalizeDeltaIfNecessary();
      }
      _normalizeDeltaIfNecessary() {
        if (!this.requestNormalizeDelta) {
          return;
        }
        this.requestNormalizeDelta = false;
        normalizeDelta(this);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js
function leftest2(node) {
  while (node.left !== SENTINEL2) {
    node = node.left;
  }
  return node;
}
function righttest(node) {
  while (node.right !== SENTINEL2) {
    node = node.right;
  }
  return node;
}
function calculateSize(node) {
  if (node === SENTINEL2) {
    return 0;
  }
  return node.size_left + node.piece.length + calculateSize(node.right);
}
function calculateLF(node) {
  if (node === SENTINEL2) {
    return 0;
  }
  return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);
}
function resetSentinel2() {
  SENTINEL2.parent = SENTINEL2;
}
function leftRotate2(tree, x) {
  const y = x.right;
  y.size_left += x.size_left + (x.piece ? x.piece.length : 0);
  y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
  x.right = y.left;
  if (y.left !== SENTINEL2) {
    y.left.parent = x;
  }
  y.parent = x.parent;
  if (x.parent === SENTINEL2) {
    tree.root = y;
  } else if (x.parent.left === x) {
    x.parent.left = y;
  } else {
    x.parent.right = y;
  }
  y.left = x;
  x.parent = y;
}
function rightRotate2(tree, y) {
  const x = y.left;
  y.left = x.right;
  if (x.right !== SENTINEL2) {
    x.right.parent = y;
  }
  x.parent = y.parent;
  y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);
  y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
  if (y.parent === SENTINEL2) {
    tree.root = x;
  } else if (y === y.parent.right) {
    y.parent.right = x;
  } else {
    y.parent.left = x;
  }
  x.right = y;
  y.parent = x;
}
function rbDelete(tree, z) {
  let x;
  let y;
  if (z.left === SENTINEL2) {
    y = z;
    x = y.right;
  } else if (z.right === SENTINEL2) {
    y = z;
    x = y.left;
  } else {
    y = leftest2(z.right);
    x = y.right;
  }
  if (y === tree.root) {
    tree.root = x;
    x.color = 0;
    z.detach();
    resetSentinel2();
    tree.root.parent = SENTINEL2;
    return;
  }
  const yWasRed = y.color === 1;
  if (y === y.parent.left) {
    y.parent.left = x;
  } else {
    y.parent.right = x;
  }
  if (y === z) {
    x.parent = y.parent;
    recomputeTreeMetadata(tree, x);
  } else {
    if (y.parent === z) {
      x.parent = y;
    } else {
      x.parent = y.parent;
    }
    recomputeTreeMetadata(tree, x);
    y.left = z.left;
    y.right = z.right;
    y.parent = z.parent;
    y.color = z.color;
    if (z === tree.root) {
      tree.root = y;
    } else {
      if (z === z.parent.left) {
        z.parent.left = y;
      } else {
        z.parent.right = y;
      }
    }
    if (y.left !== SENTINEL2) {
      y.left.parent = y;
    }
    if (y.right !== SENTINEL2) {
      y.right.parent = y;
    }
    y.size_left = z.size_left;
    y.lf_left = z.lf_left;
    recomputeTreeMetadata(tree, y);
  }
  z.detach();
  if (x.parent.left === x) {
    const newSizeLeft = calculateSize(x);
    const newLFLeft = calculateLF(x);
    if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {
      const delta = newSizeLeft - x.parent.size_left;
      const lf_delta = newLFLeft - x.parent.lf_left;
      x.parent.size_left = newSizeLeft;
      x.parent.lf_left = newLFLeft;
      updateTreeMetadata(tree, x.parent, delta, lf_delta);
    }
  }
  recomputeTreeMetadata(tree, x.parent);
  if (yWasRed) {
    resetSentinel2();
    return;
  }
  let w;
  while (x !== tree.root && x.color === 0) {
    if (x === x.parent.left) {
      w = x.parent.right;
      if (w.color === 1) {
        w.color = 0;
        x.parent.color = 1;
        leftRotate2(tree, x.parent);
        w = x.parent.right;
      }
      if (w.left.color === 0 && w.right.color === 0) {
        w.color = 1;
        x = x.parent;
      } else {
        if (w.right.color === 0) {
          w.left.color = 0;
          w.color = 1;
          rightRotate2(tree, w);
          w = x.parent.right;
        }
        w.color = x.parent.color;
        x.parent.color = 0;
        w.right.color = 0;
        leftRotate2(tree, x.parent);
        x = tree.root;
      }
    } else {
      w = x.parent.left;
      if (w.color === 1) {
        w.color = 0;
        x.parent.color = 1;
        rightRotate2(tree, x.parent);
        w = x.parent.left;
      }
      if (w.left.color === 0 && w.right.color === 0) {
        w.color = 1;
        x = x.parent;
      } else {
        if (w.left.color === 0) {
          w.right.color = 0;
          w.color = 1;
          leftRotate2(tree, w);
          w = x.parent.left;
        }
        w.color = x.parent.color;
        x.parent.color = 0;
        w.left.color = 0;
        rightRotate2(tree, x.parent);
        x = tree.root;
      }
    }
  }
  x.color = 0;
  resetSentinel2();
}
function fixInsert(tree, x) {
  recomputeTreeMetadata(tree, x);
  while (x !== tree.root && x.parent.color === 1) {
    if (x.parent === x.parent.parent.left) {
      const y = x.parent.parent.right;
      if (y.color === 1) {
        x.parent.color = 0;
        y.color = 0;
        x.parent.parent.color = 1;
        x = x.parent.parent;
      } else {
        if (x === x.parent.right) {
          x = x.parent;
          leftRotate2(tree, x);
        }
        x.parent.color = 0;
        x.parent.parent.color = 1;
        rightRotate2(tree, x.parent.parent);
      }
    } else {
      const y = x.parent.parent.left;
      if (y.color === 1) {
        x.parent.color = 0;
        y.color = 0;
        x.parent.parent.color = 1;
        x = x.parent.parent;
      } else {
        if (x === x.parent.left) {
          x = x.parent;
          rightRotate2(tree, x);
        }
        x.parent.color = 0;
        x.parent.parent.color = 1;
        leftRotate2(tree, x.parent.parent);
      }
    }
  }
  tree.root.color = 0;
}
function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {
  while (x !== tree.root && x !== SENTINEL2) {
    if (x.parent.left === x) {
      x.parent.size_left += delta;
      x.parent.lf_left += lineFeedCntDelta;
    }
    x = x.parent;
  }
}
function recomputeTreeMetadata(tree, x) {
  let delta = 0;
  let lf_delta = 0;
  if (x === tree.root) {
    return;
  }
  while (x !== tree.root && x === x.parent.right) {
    x = x.parent;
  }
  if (x === tree.root) {
    return;
  }
  x = x.parent;
  delta = calculateSize(x.left) - x.size_left;
  lf_delta = calculateLF(x.left) - x.lf_left;
  x.size_left += delta;
  x.lf_left += lf_delta;
  while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {
    if (x.parent.left === x) {
      x.parent.size_left += delta;
      x.parent.lf_left += lf_delta;
    }
    x = x.parent;
  }
}
var TreeNode, SENTINEL2;
var init_rbTreeBase = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js"() {
    TreeNode = class {
      constructor(piece, color) {
        this.piece = piece;
        this.color = color;
        this.size_left = 0;
        this.lf_left = 0;
        this.parent = this;
        this.left = this;
        this.right = this;
      }
      next() {
        if (this.right !== SENTINEL2) {
          return leftest2(this.right);
        }
        let node = this;
        while (node.parent !== SENTINEL2) {
          if (node.parent.left === node) {
            break;
          }
          node = node.parent;
        }
        if (node.parent === SENTINEL2) {
          return SENTINEL2;
        } else {
          return node.parent;
        }
      }
      prev() {
        if (this.left !== SENTINEL2) {
          return righttest(this.left);
        }
        let node = this;
        while (node.parent !== SENTINEL2) {
          if (node.parent.right === node) {
            break;
          }
          node = node.parent;
        }
        if (node.parent === SENTINEL2) {
          return SENTINEL2;
        } else {
          return node.parent;
        }
      }
      detach() {
        this.parent = null;
        this.left = null;
        this.right = null;
      }
    };
    SENTINEL2 = new TreeNode(
      null,
      0
      /* NodeColor.Black */
    );
    SENTINEL2.parent = SENTINEL2;
    SENTINEL2.left = SENTINEL2;
    SENTINEL2.right = SENTINEL2;
    SENTINEL2.color = 0;
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js
function createUintArray(arr) {
  let r;
  if (arr[arr.length - 1] < 65536) {
    r = new Uint16Array(arr.length);
  } else {
    r = new Uint32Array(arr.length);
  }
  r.set(arr, 0);
  return r;
}
function createLineStartsFast(str, readonly = true) {
  const r = [0];
  let rLength = 1;
  for (let i = 0, len = str.length; i < len; i++) {
    const chr = str.charCodeAt(i);
    if (chr === 13) {
      if (i + 1 < len && str.charCodeAt(i + 1) === 10) {
        r[rLength++] = i + 2;
        i++;
      } else {
        r[rLength++] = i + 1;
      }
    } else if (chr === 10) {
      r[rLength++] = i + 1;
    }
  }
  if (readonly) {
    return createUintArray(r);
  } else {
    return r;
  }
}
function createLineStarts(r, str) {
  r.length = 0;
  r[0] = 0;
  let rLength = 1;
  let cr = 0, lf = 0, crlf = 0;
  let isBasicASCII2 = true;
  for (let i = 0, len = str.length; i < len; i++) {
    const chr = str.charCodeAt(i);
    if (chr === 13) {
      if (i + 1 < len && str.charCodeAt(i + 1) === 10) {
        crlf++;
        r[rLength++] = i + 2;
        i++;
      } else {
        cr++;
        r[rLength++] = i + 1;
      }
    } else if (chr === 10) {
      lf++;
      r[rLength++] = i + 1;
    } else {
      if (isBasicASCII2) {
        if (chr !== 9 && (chr < 32 || chr > 126)) {
          isBasicASCII2 = false;
        }
      }
    }
  }
  const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII2);
  r.length = 0;
  return result;
}
var AverageBufferSize, LineStarts, Piece, StringBuffer, PieceTreeSnapshot, PieceTreeSearchCache, PieceTreeBase;
var init_pieceTreeBase = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js"() {
    init_position();
    init_range();
    init_model();
    init_rbTreeBase();
    init_textModelSearch();
    AverageBufferSize = 65535;
    LineStarts = class {
      constructor(lineStarts, cr, lf, crlf, isBasicASCII2) {
        this.lineStarts = lineStarts;
        this.cr = cr;
        this.lf = lf;
        this.crlf = crlf;
        this.isBasicASCII = isBasicASCII2;
      }
    };
    Piece = class {
      constructor(bufferIndex, start, end, lineFeedCnt, length) {
        this.bufferIndex = bufferIndex;
        this.start = start;
        this.end = end;
        this.lineFeedCnt = lineFeedCnt;
        this.length = length;
      }
    };
    StringBuffer = class {
      constructor(buffer, lineStarts) {
        this.buffer = buffer;
        this.lineStarts = lineStarts;
      }
    };
    PieceTreeSnapshot = class {
      constructor(tree, BOM) {
        this._pieces = [];
        this._tree = tree;
        this._BOM = BOM;
        this._index = 0;
        if (tree.root !== SENTINEL2) {
          tree.iterate(tree.root, (node) => {
            if (node !== SENTINEL2) {
              this._pieces.push(node.piece);
            }
            return true;
          });
        }
      }
      read() {
        if (this._pieces.length === 0) {
          if (this._index === 0) {
            this._index++;
            return this._BOM;
          } else {
            return null;
          }
        }
        if (this._index > this._pieces.length - 1) {
          return null;
        }
        if (this._index === 0) {
          return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);
        }
        return this._tree.getPieceContent(this._pieces[this._index++]);
      }
    };
    PieceTreeSearchCache = class {
      constructor(limit) {
        this._limit = limit;
        this._cache = [];
      }
      get(offset) {
        for (let i = this._cache.length - 1; i >= 0; i--) {
          const nodePos = this._cache[i];
          if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {
            return nodePos;
          }
        }
        return null;
      }
      get2(lineNumber) {
        for (let i = this._cache.length - 1; i >= 0; i--) {
          const nodePos = this._cache[i];
          if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {
            return nodePos;
          }
        }
        return null;
      }
      set(nodePosition) {
        if (this._cache.length >= this._limit) {
          this._cache.shift();
        }
        this._cache.push(nodePosition);
      }
      validate(offset) {
        let hasInvalidVal = false;
        const tmp = this._cache;
        for (let i = 0; i < tmp.length; i++) {
          const nodePos = tmp[i];
          if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {
            tmp[i] = null;
            hasInvalidVal = true;
            continue;
          }
        }
        if (hasInvalidVal) {
          const newArr = [];
          for (const entry of tmp) {
            if (entry !== null) {
              newArr.push(entry);
            }
          }
          this._cache = newArr;
        }
      }
    };
    PieceTreeBase = class {
      constructor(chunks, eol, eolNormalized) {
        this.create(chunks, eol, eolNormalized);
      }
      create(chunks, eol, eolNormalized) {
        this._buffers = [
          new StringBuffer("", [0])
        ];
        this._lastChangeBufferPos = { line: 0, column: 0 };
        this.root = SENTINEL2;
        this._lineCnt = 1;
        this._length = 0;
        this._EOL = eol;
        this._EOLLength = eol.length;
        this._EOLNormalized = eolNormalized;
        let lastNode = null;
        for (let i = 0, len = chunks.length; i < len; i++) {
          if (chunks[i].buffer.length > 0) {
            if (!chunks[i].lineStarts) {
              chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);
            }
            const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);
            this._buffers.push(chunks[i]);
            lastNode = this.rbInsertRight(lastNode, piece);
          }
        }
        this._searchCache = new PieceTreeSearchCache(1);
        this._lastVisitedLine = { lineNumber: 0, value: "" };
        this.computeBufferMetadata();
      }
      normalizeEOL(eol) {
        const averageBufferSize = AverageBufferSize;
        const min = averageBufferSize - Math.floor(averageBufferSize / 3);
        const max = min * 2;
        let tempChunk = "";
        let tempChunkLen = 0;
        const chunks = [];
        this.iterate(this.root, (node) => {
          const str = this.getNodeContent(node);
          const len = str.length;
          if (tempChunkLen <= min || tempChunkLen + len < max) {
            tempChunk += str;
            tempChunkLen += len;
            return true;
          }
          const text = tempChunk.replace(/\r\n|\r|\n/g, eol);
          chunks.push(new StringBuffer(text, createLineStartsFast(text)));
          tempChunk = str;
          tempChunkLen = len;
          return true;
        });
        if (tempChunkLen > 0) {
          const text = tempChunk.replace(/\r\n|\r|\n/g, eol);
          chunks.push(new StringBuffer(text, createLineStartsFast(text)));
        }
        this.create(chunks, eol, true);
      }
      // #region Buffer API
      getEOL() {
        return this._EOL;
      }
      setEOL(newEOL) {
        this._EOL = newEOL;
        this._EOLLength = this._EOL.length;
        this.normalizeEOL(newEOL);
      }
      createSnapshot(BOM) {
        return new PieceTreeSnapshot(this, BOM);
      }
      getOffsetAt(lineNumber, column) {
        let leftLen = 0;
        let x = this.root;
        while (x !== SENTINEL2) {
          if (x.left !== SENTINEL2 && x.lf_left + 1 >= lineNumber) {
            x = x.left;
          } else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {
            leftLen += x.size_left;
            const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
            return leftLen += accumualtedValInCurrentIndex + column - 1;
          } else {
            lineNumber -= x.lf_left + x.piece.lineFeedCnt;
            leftLen += x.size_left + x.piece.length;
            x = x.right;
          }
        }
        return leftLen;
      }
      getPositionAt(offset) {
        offset = Math.floor(offset);
        offset = Math.max(0, offset);
        let x = this.root;
        let lfCnt = 0;
        const originalOffset = offset;
        while (x !== SENTINEL2) {
          if (x.size_left !== 0 && x.size_left >= offset) {
            x = x.left;
          } else if (x.size_left + x.piece.length >= offset) {
            const out = this.getIndexOf(x, offset - x.size_left);
            lfCnt += x.lf_left + out.index;
            if (out.index === 0) {
              const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
              const column = originalOffset - lineStartOffset;
              return new Position(lfCnt + 1, column + 1);
            }
            return new Position(lfCnt + 1, out.remainder + 1);
          } else {
            offset -= x.size_left + x.piece.length;
            lfCnt += x.lf_left + x.piece.lineFeedCnt;
            if (x.right === SENTINEL2) {
              const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
              const column = originalOffset - offset - lineStartOffset;
              return new Position(lfCnt + 1, column + 1);
            } else {
              x = x.right;
            }
          }
        }
        return new Position(1, 1);
      }
      getValueInRange(range2, eol) {
        if (range2.startLineNumber === range2.endLineNumber && range2.startColumn === range2.endColumn) {
          return "";
        }
        const startPosition = this.nodeAt2(range2.startLineNumber, range2.startColumn);
        const endPosition = this.nodeAt2(range2.endLineNumber, range2.endColumn);
        const value = this.getValueInRange2(startPosition, endPosition);
        if (eol) {
          if (eol !== this._EOL || !this._EOLNormalized) {
            return value.replace(/\r\n|\r|\n/g, eol);
          }
          if (eol === this.getEOL() && this._EOLNormalized) {
            if (eol === "\r\n") {
            }
            return value;
          }
          return value.replace(/\r\n|\r|\n/g, eol);
        }
        return value;
      }
      getValueInRange2(startPosition, endPosition) {
        if (startPosition.node === endPosition.node) {
          const node = startPosition.node;
          const buffer2 = this._buffers[node.piece.bufferIndex].buffer;
          const startOffset2 = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
          return buffer2.substring(startOffset2 + startPosition.remainder, startOffset2 + endPosition.remainder);
        }
        let x = startPosition.node;
        const buffer = this._buffers[x.piece.bufferIndex].buffer;
        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);
        x = x.next();
        while (x !== SENTINEL2) {
          const buffer2 = this._buffers[x.piece.bufferIndex].buffer;
          const startOffset2 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
          if (x === endPosition.node) {
            ret += buffer2.substring(startOffset2, startOffset2 + endPosition.remainder);
            break;
          } else {
            ret += buffer2.substr(startOffset2, x.piece.length);
          }
          x = x.next();
        }
        return ret;
      }
      getLinesContent() {
        const lines = [];
        let linesLength = 0;
        let currentLine = "";
        let danglingCR = false;
        this.iterate(this.root, (node) => {
          if (node === SENTINEL2) {
            return true;
          }
          const piece = node.piece;
          let pieceLength = piece.length;
          if (pieceLength === 0) {
            return true;
          }
          const buffer = this._buffers[piece.bufferIndex].buffer;
          const lineStarts = this._buffers[piece.bufferIndex].lineStarts;
          const pieceStartLine = piece.start.line;
          const pieceEndLine = piece.end.line;
          let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;
          if (danglingCR) {
            if (buffer.charCodeAt(pieceStartOffset) === 10) {
              pieceStartOffset++;
              pieceLength--;
            }
            lines[linesLength++] = currentLine;
            currentLine = "";
            danglingCR = false;
            if (pieceLength === 0) {
              return true;
            }
          }
          if (pieceStartLine === pieceEndLine) {
            if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13) {
              danglingCR = true;
              currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);
            } else {
              currentLine += buffer.substr(pieceStartOffset, pieceLength);
            }
            return true;
          }
          currentLine += this._EOLNormalized ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength)) : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\r\n|\r|\n)$/, "");
          lines[linesLength++] = currentLine;
          for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {
            currentLine = this._EOLNormalized ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength) : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\r\n|\r|\n)$/, "");
            lines[linesLength++] = currentLine;
          }
          if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13) {
            danglingCR = true;
            if (piece.end.column === 0) {
              linesLength--;
            } else {
              currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);
            }
          } else {
            currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);
          }
          return true;
        });
        if (danglingCR) {
          lines[linesLength++] = currentLine;
          currentLine = "";
        }
        lines[linesLength++] = currentLine;
        return lines;
      }
      getLength() {
        return this._length;
      }
      getLineCount() {
        return this._lineCnt;
      }
      getLineContent(lineNumber) {
        if (this._lastVisitedLine.lineNumber === lineNumber) {
          return this._lastVisitedLine.value;
        }
        this._lastVisitedLine.lineNumber = lineNumber;
        if (lineNumber === this._lineCnt) {
          this._lastVisitedLine.value = this.getLineRawContent(lineNumber);
        } else if (this._EOLNormalized) {
          this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);
        } else {
          this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\r\n|\r|\n)$/, "");
        }
        return this._lastVisitedLine.value;
      }
      _getCharCode(nodePos) {
        if (nodePos.remainder === nodePos.node.piece.length) {
          const matchingNode = nodePos.node.next();
          if (!matchingNode) {
            return 0;
          }
          const buffer = this._buffers[matchingNode.piece.bufferIndex];
          const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);
          return buffer.buffer.charCodeAt(startOffset);
        } else {
          const buffer = this._buffers[nodePos.node.piece.bufferIndex];
          const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);
          const targetOffset = startOffset + nodePos.remainder;
          return buffer.buffer.charCodeAt(targetOffset);
        }
      }
      getLineCharCode(lineNumber, index) {
        const nodePos = this.nodeAt2(lineNumber, index + 1);
        return this._getCharCode(nodePos);
      }
      getLineLength(lineNumber) {
        if (lineNumber === this.getLineCount()) {
          const startOffset = this.getOffsetAt(lineNumber, 1);
          return this.getLength() - startOffset;
        }
        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;
      }
      findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {
        const buffer = this._buffers[node.piece.bufferIndex];
        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);
        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);
        let m;
        const ret = { line: 0, column: 0 };
        let searchText;
        let offsetInBuffer;
        if (searcher._wordSeparators) {
          searchText = buffer.buffer.substring(start, end);
          offsetInBuffer = (offset) => offset + start;
          searcher.reset(0);
        } else {
          searchText = buffer.buffer;
          offsetInBuffer = (offset) => offset;
          searcher.reset(start);
        }
        do {
          m = searcher.next(searchText);
          if (m) {
            if (offsetInBuffer(m.index) >= end) {
              return resultLen;
            }
            this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);
            const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);
            const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;
            const retEndColumn = retStartColumn + m[0].length;
            result[resultLen++] = createFindMatch(new Range2(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);
            if (offsetInBuffer(m.index) + m[0].length >= end) {
              return resultLen;
            }
            if (resultLen >= limitResultCount) {
              return resultLen;
            }
          }
        } while (m);
        return resultLen;
      }
      findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
        const result = [];
        let resultLen = 0;
        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);
        if (startPosition === null) {
          return [];
        }
        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);
        if (endPosition === null) {
          return [];
        }
        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);
        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);
        if (startPosition.node === endPosition.node) {
          this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
          return result;
        }
        let startLineNumber = searchRange.startLineNumber;
        let currentNode = startPosition.node;
        while (currentNode !== endPosition.node) {
          const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);
          if (lineBreakCnt >= 1) {
            const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;
            const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);
            const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];
            const startColumn3 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
            resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn3, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);
            if (resultLen >= limitResultCount) {
              return result;
            }
            startLineNumber += lineBreakCnt;
          }
          const startColumn2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
          if (startLineNumber === searchRange.endLineNumber) {
            const text = this.getLineContent(startLineNumber).substring(startColumn2, searchRange.endColumn - 1);
            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn2, resultLen, result, captureMatches, limitResultCount);
            return result;
          }
          resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn2), startLineNumber, startColumn2, resultLen, result, captureMatches, limitResultCount);
          if (resultLen >= limitResultCount) {
            return result;
          }
          startLineNumber++;
          startPosition = this.nodeAt2(startLineNumber, 1);
          currentNode = startPosition.node;
          start = this.positionInBuffer(startPosition.node, startPosition.remainder);
        }
        if (startLineNumber === searchRange.endLineNumber) {
          const startColumn2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
          const text = this.getLineContent(startLineNumber).substring(startColumn2, searchRange.endColumn - 1);
          resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn2, resultLen, result, captureMatches, limitResultCount);
          return result;
        }
        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
        return result;
      }
      _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
        const wordSeparators2 = searchData.wordSeparators;
        if (!captureMatches && searchData.simpleSearch) {
          const searchString = searchData.simpleSearch;
          const searchStringLen = searchString.length;
          const textLength = text.length;
          let lastMatchIndex = -searchStringLen;
          while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
            if (!wordSeparators2 || isValidMatch(wordSeparators2, text, textLength, lastMatchIndex, searchStringLen)) {
              result[resultLen++] = new FindMatch(new Range2(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);
              if (resultLen >= limitResultCount) {
                return resultLen;
              }
            }
          }
          return resultLen;
        }
        let m;
        searcher.reset(0);
        do {
          m = searcher.next(text);
          if (m) {
            result[resultLen++] = createFindMatch(new Range2(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);
            if (resultLen >= limitResultCount) {
              return resultLen;
            }
          }
        } while (m);
        return resultLen;
      }
      // #endregion
      // #region Piece Table
      insert(offset, value, eolNormalized = false) {
        this._EOLNormalized = this._EOLNormalized && eolNormalized;
        this._lastVisitedLine.lineNumber = 0;
        this._lastVisitedLine.value = "";
        if (this.root !== SENTINEL2) {
          const { node, remainder, nodeStartOffset } = this.nodeAt(offset);
          const piece = node.piece;
          const bufferIndex = piece.bufferIndex;
          const insertPosInBuffer = this.positionInBuffer(node, remainder);
          if (node.piece.bufferIndex === 0 && piece.end.line === this._lastChangeBufferPos.line && piece.end.column === this._lastChangeBufferPos.column && nodeStartOffset + piece.length === offset && value.length < AverageBufferSize) {
            this.appendToNode(node, value);
            this.computeBufferMetadata();
            return;
          }
          if (nodeStartOffset === offset) {
            this.insertContentToNodeLeft(value, node);
            this._searchCache.validate(offset);
          } else if (nodeStartOffset + node.piece.length > offset) {
            const nodesToDel = [];
            let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));
            if (this.shouldCheckCRLF() && this.endWithCR(value)) {
              const headOfRight = this.nodeCharCodeAt(node, remainder);
              if (headOfRight === 10) {
                const newStart = { line: newRightPiece.start.line + 1, column: 0 };
                newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);
                value += "\n";
              }
            }
            if (this.shouldCheckCRLF() && this.startWithLF(value)) {
              const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);
              if (tailOfLeft === 13) {
                const previousPos = this.positionInBuffer(node, remainder - 1);
                this.deleteNodeTail(node, previousPos);
                value = "\r" + value;
                if (node.piece.length === 0) {
                  nodesToDel.push(node);
                }
              } else {
                this.deleteNodeTail(node, insertPosInBuffer);
              }
            } else {
              this.deleteNodeTail(node, insertPosInBuffer);
            }
            const newPieces = this.createNewPieces(value);
            if (newRightPiece.length > 0) {
              this.rbInsertRight(node, newRightPiece);
            }
            let tmpNode = node;
            for (let k = 0; k < newPieces.length; k++) {
              tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);
            }
            this.deleteNodes(nodesToDel);
          } else {
            this.insertContentToNodeRight(value, node);
          }
        } else {
          const pieces = this.createNewPieces(value);
          let node = this.rbInsertLeft(null, pieces[0]);
          for (let k = 1; k < pieces.length; k++) {
            node = this.rbInsertRight(node, pieces[k]);
          }
        }
        this.computeBufferMetadata();
      }
      delete(offset, cnt) {
        this._lastVisitedLine.lineNumber = 0;
        this._lastVisitedLine.value = "";
        if (cnt <= 0 || this.root === SENTINEL2) {
          return;
        }
        const startPosition = this.nodeAt(offset);
        const endPosition = this.nodeAt(offset + cnt);
        const startNode = startPosition.node;
        const endNode = endPosition.node;
        if (startNode === endNode) {
          const startSplitPosInBuffer2 = this.positionInBuffer(startNode, startPosition.remainder);
          const endSplitPosInBuffer2 = this.positionInBuffer(startNode, endPosition.remainder);
          if (startPosition.nodeStartOffset === offset) {
            if (cnt === startNode.piece.length) {
              const next = startNode.next();
              rbDelete(this, startNode);
              this.validateCRLFWithPrevNode(next);
              this.computeBufferMetadata();
              return;
            }
            this.deleteNodeHead(startNode, endSplitPosInBuffer2);
            this._searchCache.validate(offset);
            this.validateCRLFWithPrevNode(startNode);
            this.computeBufferMetadata();
            return;
          }
          if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {
            this.deleteNodeTail(startNode, startSplitPosInBuffer2);
            this.validateCRLFWithNextNode(startNode);
            this.computeBufferMetadata();
            return;
          }
          this.shrinkNode(startNode, startSplitPosInBuffer2, endSplitPosInBuffer2);
          this.computeBufferMetadata();
          return;
        }
        const nodesToDel = [];
        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);
        this.deleteNodeTail(startNode, startSplitPosInBuffer);
        this._searchCache.validate(offset);
        if (startNode.piece.length === 0) {
          nodesToDel.push(startNode);
        }
        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);
        this.deleteNodeHead(endNode, endSplitPosInBuffer);
        if (endNode.piece.length === 0) {
          nodesToDel.push(endNode);
        }
        const secondNode = startNode.next();
        for (let node = secondNode; node !== SENTINEL2 && node !== endNode; node = node.next()) {
          nodesToDel.push(node);
        }
        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;
        this.deleteNodes(nodesToDel);
        this.validateCRLFWithNextNode(prev);
        this.computeBufferMetadata();
      }
      insertContentToNodeLeft(value, node) {
        const nodesToDel = [];
        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {
          const piece = node.piece;
          const newStart = { line: piece.start.line + 1, column: 0 };
          const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);
          node.piece = nPiece;
          value += "\n";
          updateTreeMetadata(this, node, -1, -1);
          if (node.piece.length === 0) {
            nodesToDel.push(node);
          }
        }
        const newPieces = this.createNewPieces(value);
        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);
        for (let k = newPieces.length - 2; k >= 0; k--) {
          newNode = this.rbInsertLeft(newNode, newPieces[k]);
        }
        this.validateCRLFWithPrevNode(newNode);
        this.deleteNodes(nodesToDel);
      }
      insertContentToNodeRight(value, node) {
        if (this.adjustCarriageReturnFromNext(value, node)) {
          value += "\n";
        }
        const newPieces = this.createNewPieces(value);
        const newNode = this.rbInsertRight(node, newPieces[0]);
        let tmpNode = newNode;
        for (let k = 1; k < newPieces.length; k++) {
          tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);
        }
        this.validateCRLFWithPrevNode(newNode);
      }
      positionInBuffer(node, remainder, ret) {
        const piece = node.piece;
        const bufferIndex = node.piece.bufferIndex;
        const lineStarts = this._buffers[bufferIndex].lineStarts;
        const startOffset = lineStarts[piece.start.line] + piece.start.column;
        const offset = startOffset + remainder;
        let low = piece.start.line;
        let high = piece.end.line;
        let mid = 0;
        let midStop = 0;
        let midStart = 0;
        while (low <= high) {
          mid = low + (high - low) / 2 | 0;
          midStart = lineStarts[mid];
          if (mid === high) {
            break;
          }
          midStop = lineStarts[mid + 1];
          if (offset < midStart) {
            high = mid - 1;
          } else if (offset >= midStop) {
            low = mid + 1;
          } else {
            break;
          }
        }
        if (ret) {
          ret.line = mid;
          ret.column = offset - midStart;
          return null;
        }
        return {
          line: mid,
          column: offset - midStart
        };
      }
      getLineFeedCnt(bufferIndex, start, end) {
        if (end.column === 0) {
          return end.line - start.line;
        }
        const lineStarts = this._buffers[bufferIndex].lineStarts;
        if (end.line === lineStarts.length - 1) {
          return end.line - start.line;
        }
        const nextLineStartOffset = lineStarts[end.line + 1];
        const endOffset = lineStarts[end.line] + end.column;
        if (nextLineStartOffset > endOffset + 1) {
          return end.line - start.line;
        }
        const previousCharOffset = endOffset - 1;
        const buffer = this._buffers[bufferIndex].buffer;
        if (buffer.charCodeAt(previousCharOffset) === 13) {
          return end.line - start.line + 1;
        } else {
          return end.line - start.line;
        }
      }
      offsetInBuffer(bufferIndex, cursor) {
        const lineStarts = this._buffers[bufferIndex].lineStarts;
        return lineStarts[cursor.line] + cursor.column;
      }
      deleteNodes(nodes) {
        for (let i = 0; i < nodes.length; i++) {
          rbDelete(this, nodes[i]);
        }
      }
      createNewPieces(text) {
        if (text.length > AverageBufferSize) {
          const newPieces = [];
          while (text.length > AverageBufferSize) {
            const lastChar = text.charCodeAt(AverageBufferSize - 1);
            let splitText;
            if (lastChar === 13 || lastChar >= 55296 && lastChar <= 56319) {
              splitText = text.substring(0, AverageBufferSize - 1);
              text = text.substring(AverageBufferSize - 1);
            } else {
              splitText = text.substring(0, AverageBufferSize);
              text = text.substring(AverageBufferSize);
            }
            const lineStarts3 = createLineStartsFast(splitText);
            newPieces.push(new Piece(
              this._buffers.length,
              /* buffer index */
              { line: 0, column: 0 },
              { line: lineStarts3.length - 1, column: splitText.length - lineStarts3[lineStarts3.length - 1] },
              lineStarts3.length - 1,
              splitText.length
            ));
            this._buffers.push(new StringBuffer(splitText, lineStarts3));
          }
          const lineStarts2 = createLineStartsFast(text);
          newPieces.push(new Piece(
            this._buffers.length,
            /* buffer index */
            { line: 0, column: 0 },
            { line: lineStarts2.length - 1, column: text.length - lineStarts2[lineStarts2.length - 1] },
            lineStarts2.length - 1,
            text.length
          ));
          this._buffers.push(new StringBuffer(text, lineStarts2));
          return newPieces;
        }
        let startOffset = this._buffers[0].buffer.length;
        const lineStarts = createLineStartsFast(text, false);
        let start = this._lastChangeBufferPos;
        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset && startOffset !== 0 && this.startWithLF(text) && this.endWithCR(this._buffers[0].buffer)) {
          this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };
          start = this._lastChangeBufferPos;
          for (let i = 0; i < lineStarts.length; i++) {
            lineStarts[i] += startOffset + 1;
          }
          this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
          this._buffers[0].buffer += "_" + text;
          startOffset += 1;
        } else {
          if (startOffset !== 0) {
            for (let i = 0; i < lineStarts.length; i++) {
              lineStarts[i] += startOffset;
            }
          }
          this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
          this._buffers[0].buffer += text;
        }
        const endOffset = this._buffers[0].buffer.length;
        const endIndex = this._buffers[0].lineStarts.length - 1;
        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];
        const endPos = { line: endIndex, column: endColumn };
        const newPiece = new Piece(
          0,
          /** todo@peng */
          start,
          endPos,
          this.getLineFeedCnt(0, start, endPos),
          endOffset - startOffset
        );
        this._lastChangeBufferPos = endPos;
        return [newPiece];
      }
      getLineRawContent(lineNumber, endOffset = 0) {
        let x = this.root;
        let ret = "";
        const cache = this._searchCache.get2(lineNumber);
        if (cache) {
          x = cache.node;
          const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);
          const buffer = this._buffers[x.piece.bufferIndex].buffer;
          const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
          if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {
            ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);
          } else {
            const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);
            return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);
          }
        } else {
          let nodeStartOffset = 0;
          const originalLineNumber = lineNumber;
          while (x !== SENTINEL2) {
            if (x.left !== SENTINEL2 && x.lf_left >= lineNumber - 1) {
              x = x.left;
            } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
              const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
              const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
              const buffer = this._buffers[x.piece.bufferIndex].buffer;
              const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
              nodeStartOffset += x.size_left;
              this._searchCache.set({
                node: x,
                nodeStartOffset,
                nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)
              });
              return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);
            } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
              const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
              const buffer = this._buffers[x.piece.bufferIndex].buffer;
              const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
              ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);
              break;
            } else {
              lineNumber -= x.lf_left + x.piece.lineFeedCnt;
              nodeStartOffset += x.size_left + x.piece.length;
              x = x.right;
            }
          }
        }
        x = x.next();
        while (x !== SENTINEL2) {
          const buffer = this._buffers[x.piece.bufferIndex].buffer;
          if (x.piece.lineFeedCnt > 0) {
            const accumulatedValue = this.getAccumulatedValue(x, 0);
            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
            ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);
            return ret;
          } else {
            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
            ret += buffer.substr(startOffset, x.piece.length);
          }
          x = x.next();
        }
        return ret;
      }
      computeBufferMetadata() {
        let x = this.root;
        let lfCnt = 1;
        let len = 0;
        while (x !== SENTINEL2) {
          lfCnt += x.lf_left + x.piece.lineFeedCnt;
          len += x.size_left + x.piece.length;
          x = x.right;
        }
        this._lineCnt = lfCnt;
        this._length = len;
        this._searchCache.validate(this._length);
      }
      // #region node operations
      getIndexOf(node, accumulatedValue) {
        const piece = node.piece;
        const pos = this.positionInBuffer(node, accumulatedValue);
        const lineCnt = pos.line - piece.start.line;
        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {
          const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);
          if (realLineCnt !== lineCnt) {
            return { index: realLineCnt, remainder: 0 };
          }
        }
        return { index: lineCnt, remainder: pos.column };
      }
      getAccumulatedValue(node, index) {
        if (index < 0) {
          return 0;
        }
        const piece = node.piece;
        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;
        const expectedLineStartIndex = piece.start.line + index + 1;
        if (expectedLineStartIndex > piece.end.line) {
          return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;
        } else {
          return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;
        }
      }
      deleteNodeTail(node, pos) {
        const piece = node.piece;
        const originalLFCnt = piece.lineFeedCnt;
        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
        const newEnd = pos;
        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);
        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);
        const lf_delta = newLineFeedCnt - originalLFCnt;
        const size_delta = newEndOffset - originalEndOffset;
        const newLength = piece.length + size_delta;
        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
        updateTreeMetadata(this, node, size_delta, lf_delta);
      }
      deleteNodeHead(node, pos) {
        const piece = node.piece;
        const originalLFCnt = piece.lineFeedCnt;
        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
        const newStart = pos;
        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);
        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);
        const lf_delta = newLineFeedCnt - originalLFCnt;
        const size_delta = originalStartOffset - newStartOffset;
        const newLength = piece.length + size_delta;
        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
        updateTreeMetadata(this, node, size_delta, lf_delta);
      }
      shrinkNode(node, start, end) {
        const piece = node.piece;
        const originalStartPos = piece.start;
        const originalEndPos = piece.end;
        const oldLength = piece.length;
        const oldLFCnt = piece.lineFeedCnt;
        const newEnd = start;
        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);
        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);
        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);
        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));
        const newNode = this.rbInsertRight(node, newPiece);
        this.validateCRLFWithPrevNode(newNode);
      }
      appendToNode(node, value) {
        if (this.adjustCarriageReturnFromNext(value, node)) {
          value += "\n";
        }
        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);
        const startOffset = this._buffers[0].buffer.length;
        this._buffers[0].buffer += value;
        const lineStarts = createLineStartsFast(value, false);
        for (let i = 0; i < lineStarts.length; i++) {
          lineStarts[i] += startOffset;
        }
        if (hitCRLF) {
          const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
          this._buffers[0].lineStarts.pop();
          this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };
        }
        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
        const endIndex = this._buffers[0].lineStarts.length - 1;
        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];
        const newEnd = { line: endIndex, column: endColumn };
        const newLength = node.piece.length + value.length;
        const oldLineFeedCnt = node.piece.lineFeedCnt;
        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);
        const lf_delta = newLineFeedCnt - oldLineFeedCnt;
        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);
        this._lastChangeBufferPos = newEnd;
        updateTreeMetadata(this, node, value.length, lf_delta);
      }
      nodeAt(offset) {
        let x = this.root;
        const cache = this._searchCache.get(offset);
        if (cache) {
          return {
            node: cache.node,
            nodeStartOffset: cache.nodeStartOffset,
            remainder: offset - cache.nodeStartOffset
          };
        }
        let nodeStartOffset = 0;
        while (x !== SENTINEL2) {
          if (x.size_left > offset) {
            x = x.left;
          } else if (x.size_left + x.piece.length >= offset) {
            nodeStartOffset += x.size_left;
            const ret = {
              node: x,
              remainder: offset - x.size_left,
              nodeStartOffset
            };
            this._searchCache.set(ret);
            return ret;
          } else {
            offset -= x.size_left + x.piece.length;
            nodeStartOffset += x.size_left + x.piece.length;
            x = x.right;
          }
        }
        return null;
      }
      nodeAt2(lineNumber, column) {
        let x = this.root;
        let nodeStartOffset = 0;
        while (x !== SENTINEL2) {
          if (x.left !== SENTINEL2 && x.lf_left >= lineNumber - 1) {
            x = x.left;
          } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
            const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
            const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
            nodeStartOffset += x.size_left;
            return {
              node: x,
              remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),
              nodeStartOffset
            };
          } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
            const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
            if (prevAccumualtedValue + column - 1 <= x.piece.length) {
              return {
                node: x,
                remainder: prevAccumualtedValue + column - 1,
                nodeStartOffset
              };
            } else {
              column -= x.piece.length - prevAccumualtedValue;
              break;
            }
          } else {
            lineNumber -= x.lf_left + x.piece.lineFeedCnt;
            nodeStartOffset += x.size_left + x.piece.length;
            x = x.right;
          }
        }
        x = x.next();
        while (x !== SENTINEL2) {
          if (x.piece.lineFeedCnt > 0) {
            const accumulatedValue = this.getAccumulatedValue(x, 0);
            const nodeStartOffset2 = this.offsetOfNode(x);
            return {
              node: x,
              remainder: Math.min(column - 1, accumulatedValue),
              nodeStartOffset: nodeStartOffset2
            };
          } else {
            if (x.piece.length >= column - 1) {
              const nodeStartOffset2 = this.offsetOfNode(x);
              return {
                node: x,
                remainder: column - 1,
                nodeStartOffset: nodeStartOffset2
              };
            } else {
              column -= x.piece.length;
            }
          }
          x = x.next();
        }
        return null;
      }
      nodeCharCodeAt(node, offset) {
        if (node.piece.lineFeedCnt < 1) {
          return -1;
        }
        const buffer = this._buffers[node.piece.bufferIndex];
        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;
        return buffer.buffer.charCodeAt(newOffset);
      }
      offsetOfNode(node) {
        if (!node) {
          return 0;
        }
        let pos = node.size_left;
        while (node !== this.root) {
          if (node.parent.right === node) {
            pos += node.parent.size_left + node.parent.piece.length;
          }
          node = node.parent;
        }
        return pos;
      }
      // #endregion
      // #region CRLF
      shouldCheckCRLF() {
        return !(this._EOLNormalized && this._EOL === "\n");
      }
      startWithLF(val) {
        if (typeof val === "string") {
          return val.charCodeAt(0) === 10;
        }
        if (val === SENTINEL2 || val.piece.lineFeedCnt === 0) {
          return false;
        }
        const piece = val.piece;
        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;
        const line = piece.start.line;
        const startOffset = lineStarts[line] + piece.start.column;
        if (line === lineStarts.length - 1) {
          return false;
        }
        const nextLineOffset = lineStarts[line + 1];
        if (nextLineOffset > startOffset + 1) {
          return false;
        }
        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;
      }
      endWithCR(val) {
        if (typeof val === "string") {
          return val.charCodeAt(val.length - 1) === 13;
        }
        if (val === SENTINEL2 || val.piece.lineFeedCnt === 0) {
          return false;
        }
        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;
      }
      validateCRLFWithPrevNode(nextNode) {
        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {
          const node = nextNode.prev();
          if (this.endWithCR(node)) {
            this.fixCRLF(node, nextNode);
          }
        }
      }
      validateCRLFWithNextNode(node) {
        if (this.shouldCheckCRLF() && this.endWithCR(node)) {
          const nextNode = node.next();
          if (this.startWithLF(nextNode)) {
            this.fixCRLF(node, nextNode);
          }
        }
      }
      fixCRLF(prev, next) {
        const nodesToDel = [];
        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;
        let newEnd;
        if (prev.piece.end.column === 0) {
          newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };
        } else {
          newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };
        }
        const prevNewLength = prev.piece.length - 1;
        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;
        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);
        updateTreeMetadata(this, prev, -1, -1);
        if (prev.piece.length === 0) {
          nodesToDel.push(prev);
        }
        const newStart = { line: next.piece.start.line + 1, column: 0 };
        const newLength = next.piece.length - 1;
        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);
        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);
        updateTreeMetadata(this, next, -1, -1);
        if (next.piece.length === 0) {
          nodesToDel.push(next);
        }
        const pieces = this.createNewPieces("\r\n");
        this.rbInsertRight(prev, pieces[0]);
        for (let i = 0; i < nodesToDel.length; i++) {
          rbDelete(this, nodesToDel[i]);
        }
      }
      adjustCarriageReturnFromNext(value, node) {
        if (this.shouldCheckCRLF() && this.endWithCR(value)) {
          const nextNode = node.next();
          if (this.startWithLF(nextNode)) {
            value += "\n";
            if (nextNode.piece.length === 1) {
              rbDelete(this, nextNode);
            } else {
              const piece = nextNode.piece;
              const newStart = { line: piece.start.line + 1, column: 0 };
              const newLength = piece.length - 1;
              const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);
              nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
              updateTreeMetadata(this, nextNode, -1, -1);
            }
            return true;
          }
        }
        return false;
      }
      // #endregion
      // #endregion
      // #region Tree operations
      iterate(node, callback) {
        if (node === SENTINEL2) {
          return callback(SENTINEL2);
        }
        const leftRet = this.iterate(node.left, callback);
        if (!leftRet) {
          return leftRet;
        }
        return callback(node) && this.iterate(node.right, callback);
      }
      getNodeContent(node) {
        if (node === SENTINEL2) {
          return "";
        }
        const buffer = this._buffers[node.piece.bufferIndex];
        const piece = node.piece;
        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
        const currentContent = buffer.buffer.substring(startOffset, endOffset);
        return currentContent;
      }
      getPieceContent(piece) {
        const buffer = this._buffers[piece.bufferIndex];
        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
        const currentContent = buffer.buffer.substring(startOffset, endOffset);
        return currentContent;
      }
      /**
       *      node              node
       *     /  \              /  \
       *    a   b    <----   a    b
       *                         /
       *                        z
       */
      rbInsertRight(node, p) {
        const z = new TreeNode(
          p,
          1
          /* NodeColor.Red */
        );
        z.left = SENTINEL2;
        z.right = SENTINEL2;
        z.parent = SENTINEL2;
        z.size_left = 0;
        z.lf_left = 0;
        const x = this.root;
        if (x === SENTINEL2) {
          this.root = z;
          z.color = 0;
        } else if (node.right === SENTINEL2) {
          node.right = z;
          z.parent = node;
        } else {
          const nextNode = leftest2(node.right);
          nextNode.left = z;
          z.parent = nextNode;
        }
        fixInsert(this, z);
        return z;
      }
      /**
       *      node              node
       *     /  \              /  \
       *    a   b     ---->   a    b
       *                       \
       *                        z
       */
      rbInsertLeft(node, p) {
        const z = new TreeNode(
          p,
          1
          /* NodeColor.Red */
        );
        z.left = SENTINEL2;
        z.right = SENTINEL2;
        z.parent = SENTINEL2;
        z.size_left = 0;
        z.lf_left = 0;
        if (this.root === SENTINEL2) {
          this.root = z;
          z.color = 0;
        } else if (node.left === SENTINEL2) {
          node.left = z;
          z.parent = node;
        } else {
          const prevNode = righttest(node.left);
          prevNode.right = z;
          z.parent = prevNode;
        }
        fixInsert(this, z);
        return z;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js
var PieceTreeTextBuffer;
var init_pieceTreeTextBuffer = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js"() {
    init_event();
    init_strings();
    init_range();
    init_model();
    init_pieceTreeBase();
    init_eolCounter();
    init_textChange();
    init_lifecycle();
    PieceTreeTextBuffer = class _PieceTreeTextBuffer extends Disposable {
      constructor(chunks, BOM, eol, containsRTL2, containsUnusualLineTerminators2, isBasicASCII2, eolNormalized) {
        super();
        this._onDidChangeContent = this._register(new Emitter());
        this._BOM = BOM;
        this._mightContainNonBasicASCII = !isBasicASCII2;
        this._mightContainRTL = containsRTL2;
        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators2;
        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);
      }
      mightContainRTL() {
        return this._mightContainRTL;
      }
      mightContainUnusualLineTerminators() {
        return this._mightContainUnusualLineTerminators;
      }
      resetMightContainUnusualLineTerminators() {
        this._mightContainUnusualLineTerminators = false;
      }
      mightContainNonBasicASCII() {
        return this._mightContainNonBasicASCII;
      }
      getBOM() {
        return this._BOM;
      }
      getEOL() {
        return this._pieceTree.getEOL();
      }
      createSnapshot(preserveBOM) {
        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : "");
      }
      getOffsetAt(lineNumber, column) {
        return this._pieceTree.getOffsetAt(lineNumber, column);
      }
      getPositionAt(offset) {
        return this._pieceTree.getPositionAt(offset);
      }
      getRangeAt(start, length) {
        const end = start + length;
        const startPosition = this.getPositionAt(start);
        const endPosition = this.getPositionAt(end);
        return new Range2(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
      }
      getValueInRange(range2, eol = 0) {
        if (range2.isEmpty()) {
          return "";
        }
        const lineEnding = this._getEndOfLine(eol);
        return this._pieceTree.getValueInRange(range2, lineEnding);
      }
      getValueLengthInRange(range2, eol = 0) {
        if (range2.isEmpty()) {
          return 0;
        }
        if (range2.startLineNumber === range2.endLineNumber) {
          return range2.endColumn - range2.startColumn;
        }
        const startOffset = this.getOffsetAt(range2.startLineNumber, range2.startColumn);
        const endOffset = this.getOffsetAt(range2.endLineNumber, range2.endColumn);
        let eolOffsetCompensation = 0;
        const desiredEOL = this._getEndOfLine(eol);
        const actualEOL = this.getEOL();
        if (desiredEOL.length !== actualEOL.length) {
          const delta = desiredEOL.length - actualEOL.length;
          const eolCount = range2.endLineNumber - range2.startLineNumber;
          eolOffsetCompensation = delta * eolCount;
        }
        return endOffset - startOffset + eolOffsetCompensation;
      }
      getCharacterCountInRange(range2, eol = 0) {
        if (this._mightContainNonBasicASCII) {
          let result = 0;
          const fromLineNumber = range2.startLineNumber;
          const toLineNumber = range2.endLineNumber;
          for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
            const lineContent = this.getLineContent(lineNumber);
            const fromOffset = lineNumber === fromLineNumber ? range2.startColumn - 1 : 0;
            const toOffset = lineNumber === toLineNumber ? range2.endColumn - 1 : lineContent.length;
            for (let offset = fromOffset; offset < toOffset; offset++) {
              if (isHighSurrogate(lineContent.charCodeAt(offset))) {
                result = result + 1;
                offset = offset + 1;
              } else {
                result = result + 1;
              }
            }
          }
          result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);
          return result;
        }
        return this.getValueLengthInRange(range2, eol);
      }
      getLength() {
        return this._pieceTree.getLength();
      }
      getLineCount() {
        return this._pieceTree.getLineCount();
      }
      getLinesContent() {
        return this._pieceTree.getLinesContent();
      }
      getLineContent(lineNumber) {
        return this._pieceTree.getLineContent(lineNumber);
      }
      getLineCharCode(lineNumber, index) {
        return this._pieceTree.getLineCharCode(lineNumber, index);
      }
      getLineLength(lineNumber) {
        return this._pieceTree.getLineLength(lineNumber);
      }
      getLineFirstNonWhitespaceColumn(lineNumber) {
        const result = firstNonWhitespaceIndex(this.getLineContent(lineNumber));
        if (result === -1) {
          return 0;
        }
        return result + 1;
      }
      getLineLastNonWhitespaceColumn(lineNumber) {
        const result = lastNonWhitespaceIndex(this.getLineContent(lineNumber));
        if (result === -1) {
          return 0;
        }
        return result + 2;
      }
      _getEndOfLine(eol) {
        switch (eol) {
          case 1:
            return "\n";
          case 2:
            return "\r\n";
          case 0:
            return this.getEOL();
          default:
            throw new Error("Unknown EOL preference");
        }
      }
      setEOL(newEOL) {
        this._pieceTree.setEOL(newEOL);
      }
      applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {
        let mightContainRTL = this._mightContainRTL;
        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;
        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;
        let canReduceOperations = true;
        let operations = [];
        for (let i = 0; i < rawOperations.length; i++) {
          const op = rawOperations[i];
          if (canReduceOperations && op._isTracked) {
            canReduceOperations = false;
          }
          const validatedRange = op.range;
          if (op.text) {
            let textMightContainNonBasicASCII = true;
            if (!mightContainNonBasicASCII) {
              textMightContainNonBasicASCII = !isBasicASCII(op.text);
              mightContainNonBasicASCII = textMightContainNonBasicASCII;
            }
            if (!mightContainRTL && textMightContainNonBasicASCII) {
              mightContainRTL = containsRTL(op.text);
            }
            if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {
              mightContainUnusualLineTerminators = containsUnusualLineTerminators(op.text);
            }
          }
          let validText = "";
          let eolCount = 0;
          let firstLineLength = 0;
          let lastLineLength = 0;
          if (op.text) {
            let strEOL;
            [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);
            const bufferEOL = this.getEOL();
            const expectedStrEOL = bufferEOL === "\r\n" ? 2 : 1;
            if (strEOL === 0 || strEOL === expectedStrEOL) {
              validText = op.text;
            } else {
              validText = op.text.replace(/\r\n|\r|\n/g, bufferEOL);
            }
          }
          operations[i] = {
            sortIndex: i,
            identifier: op.identifier || null,
            range: validatedRange,
            rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),
            rangeLength: this.getValueLengthInRange(validatedRange),
            text: validText,
            eolCount,
            firstLineLength,
            lastLineLength,
            forceMoveMarkers: Boolean(op.forceMoveMarkers),
            isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false
          };
        }
        operations.sort(_PieceTreeTextBuffer._sortOpsAscending);
        let hasTouchingRanges = false;
        for (let i = 0, count = operations.length - 1; i < count; i++) {
          const rangeEnd = operations[i].range.getEndPosition();
          const nextRangeStart = operations[i + 1].range.getStartPosition();
          if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {
            if (nextRangeStart.isBefore(rangeEnd)) {
              throw new Error("Overlapping ranges are not allowed!");
            }
            hasTouchingRanges = true;
          }
        }
        if (canReduceOperations) {
          operations = this._reduceOperations(operations);
        }
        const reverseRanges = computeUndoEdits || recordTrimAutoWhitespace ? _PieceTreeTextBuffer._getInverseEditRanges(operations) : [];
        const newTrimAutoWhitespaceCandidates = [];
        if (recordTrimAutoWhitespace) {
          for (let i = 0; i < operations.length; i++) {
            const op = operations[i];
            const reverseRange = reverseRanges[i];
            if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {
              for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {
                let currentLineContent = "";
                if (lineNumber === reverseRange.startLineNumber) {
                  currentLineContent = this.getLineContent(op.range.startLineNumber);
                  if (firstNonWhitespaceIndex(currentLineContent) !== -1) {
                    continue;
                  }
                }
                newTrimAutoWhitespaceCandidates.push({ lineNumber, oldContent: currentLineContent });
              }
            }
          }
        }
        let reverseOperations = null;
        if (computeUndoEdits) {
          let reverseRangeDeltaOffset = 0;
          reverseOperations = [];
          for (let i = 0; i < operations.length; i++) {
            const op = operations[i];
            const reverseRange = reverseRanges[i];
            const bufferText = this.getValueInRange(op.range);
            const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;
            reverseRangeDeltaOffset += op.text.length - bufferText.length;
            reverseOperations[i] = {
              sortIndex: op.sortIndex,
              identifier: op.identifier,
              range: reverseRange,
              text: bufferText,
              textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)
            };
          }
          if (!hasTouchingRanges) {
            reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);
          }
        }
        this._mightContainRTL = mightContainRTL;
        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;
        this._mightContainNonBasicASCII = mightContainNonBasicASCII;
        const contentChanges = this._doApplyEdits(operations);
        let trimAutoWhitespaceLineNumbers = null;
        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {
          newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);
          trimAutoWhitespaceLineNumbers = [];
          for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {
            const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;
            if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {
              continue;
            }
            const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;
            const lineContent = this.getLineContent(lineNumber);
            if (lineContent.length === 0 || lineContent === prevContent || firstNonWhitespaceIndex(lineContent) !== -1) {
              continue;
            }
            trimAutoWhitespaceLineNumbers.push(lineNumber);
          }
        }
        this._onDidChangeContent.fire();
        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);
      }
      /**
       * Transform operations such that they represent the same logic edit,
       * but that they also do not cause OOM crashes.
       */
      _reduceOperations(operations) {
        if (operations.length < 1e3) {
          return operations;
        }
        return [this._toSingleEditOperation(operations)];
      }
      _toSingleEditOperation(operations) {
        let forceMoveMarkers = false;
        const firstEditRange = operations[0].range;
        const lastEditRange = operations[operations.length - 1].range;
        const entireEditRange = new Range2(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);
        let lastEndLineNumber = firstEditRange.startLineNumber;
        let lastEndColumn = firstEditRange.startColumn;
        const result = [];
        for (let i = 0, len = operations.length; i < len; i++) {
          const operation = operations[i];
          const range2 = operation.range;
          forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;
          result.push(this.getValueInRange(new Range2(lastEndLineNumber, lastEndColumn, range2.startLineNumber, range2.startColumn)));
          if (operation.text.length > 0) {
            result.push(operation.text);
          }
          lastEndLineNumber = range2.endLineNumber;
          lastEndColumn = range2.endColumn;
        }
        const text = result.join("");
        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);
        return {
          sortIndex: 0,
          identifier: operations[0].identifier,
          range: entireEditRange,
          rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),
          rangeLength: this.getValueLengthInRange(
            entireEditRange,
            0
            /* EndOfLinePreference.TextDefined */
          ),
          text,
          eolCount,
          firstLineLength,
          lastLineLength,
          forceMoveMarkers,
          isAutoWhitespaceEdit: false
        };
      }
      _doApplyEdits(operations) {
        operations.sort(_PieceTreeTextBuffer._sortOpsDescending);
        const contentChanges = [];
        for (let i = 0; i < operations.length; i++) {
          const op = operations[i];
          const startLineNumber = op.range.startLineNumber;
          const startColumn = op.range.startColumn;
          const endLineNumber = op.range.endLineNumber;
          const endColumn = op.range.endColumn;
          if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {
            continue;
          }
          if (op.text) {
            this._pieceTree.delete(op.rangeOffset, op.rangeLength);
            this._pieceTree.insert(op.rangeOffset, op.text, true);
          } else {
            this._pieceTree.delete(op.rangeOffset, op.rangeLength);
          }
          const contentChangeRange = new Range2(startLineNumber, startColumn, endLineNumber, endColumn);
          contentChanges.push({
            range: contentChangeRange,
            rangeLength: op.rangeLength,
            text: op.text,
            rangeOffset: op.rangeOffset,
            forceMoveMarkers: op.forceMoveMarkers
          });
        }
        return contentChanges;
      }
      findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
      }
      /**
       * Assumes `operations` are validated and sorted ascending
       */
      static _getInverseEditRanges(operations) {
        const result = [];
        let prevOpEndLineNumber = 0;
        let prevOpEndColumn = 0;
        let prevOp = null;
        for (let i = 0, len = operations.length; i < len; i++) {
          const op = operations[i];
          let startLineNumber;
          let startColumn;
          if (prevOp) {
            if (prevOp.range.endLineNumber === op.range.startLineNumber) {
              startLineNumber = prevOpEndLineNumber;
              startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);
            } else {
              startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);
              startColumn = op.range.startColumn;
            }
          } else {
            startLineNumber = op.range.startLineNumber;
            startColumn = op.range.startColumn;
          }
          let resultRange;
          if (op.text.length > 0) {
            const lineCount = op.eolCount + 1;
            if (lineCount === 1) {
              resultRange = new Range2(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);
            } else {
              resultRange = new Range2(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);
            }
          } else {
            resultRange = new Range2(startLineNumber, startColumn, startLineNumber, startColumn);
          }
          prevOpEndLineNumber = resultRange.endLineNumber;
          prevOpEndColumn = resultRange.endColumn;
          result.push(resultRange);
          prevOp = op;
        }
        return result;
      }
      static _sortOpsAscending(a, b) {
        const r = Range2.compareRangesUsingEnds(a.range, b.range);
        if (r === 0) {
          return a.sortIndex - b.sortIndex;
        }
        return r;
      }
      static _sortOpsDescending(a, b) {
        const r = Range2.compareRangesUsingEnds(a.range, b.range);
        if (r === 0) {
          return b.sortIndex - a.sortIndex;
        }
        return -r;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js
var PieceTreeTextBufferFactory, PieceTreeTextBufferBuilder;
var init_pieceTreeTextBufferBuilder = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js"() {
    init_strings();
    init_pieceTreeBase();
    init_pieceTreeTextBuffer();
    PieceTreeTextBufferFactory = class {
      constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {
        this._chunks = _chunks;
        this._bom = _bom;
        this._cr = _cr;
        this._lf = _lf;
        this._crlf = _crlf;
        this._containsRTL = _containsRTL;
        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;
        this._isBasicASCII = _isBasicASCII;
        this._normalizeEOL = _normalizeEOL;
      }
      _getEOL(defaultEOL) {
        const totalEOLCount = this._cr + this._lf + this._crlf;
        const totalCRCount = this._cr + this._crlf;
        if (totalEOLCount === 0) {
          return defaultEOL === 1 ? "\n" : "\r\n";
        }
        if (totalCRCount > totalEOLCount / 2) {
          return "\r\n";
        }
        return "\n";
      }
      create(defaultEOL) {
        const eol = this._getEOL(defaultEOL);
        const chunks = this._chunks;
        if (this._normalizeEOL && (eol === "\r\n" && (this._cr > 0 || this._lf > 0) || eol === "\n" && (this._cr > 0 || this._crlf > 0))) {
          for (let i = 0, len = chunks.length; i < len; i++) {
            const str = chunks[i].buffer.replace(/\r\n|\r|\n/g, eol);
            const newLineStart = createLineStartsFast(str);
            chunks[i] = new StringBuffer(str, newLineStart);
          }
        }
        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
        return { textBuffer, disposable: textBuffer };
      }
    };
    PieceTreeTextBufferBuilder = class {
      constructor() {
        this.chunks = [];
        this.BOM = "";
        this._hasPreviousChar = false;
        this._previousChar = 0;
        this._tmpLineStarts = [];
        this.cr = 0;
        this.lf = 0;
        this.crlf = 0;
        this.containsRTL = false;
        this.containsUnusualLineTerminators = false;
        this.isBasicASCII = true;
      }
      acceptChunk(chunk) {
        if (chunk.length === 0) {
          return;
        }
        if (this.chunks.length === 0) {
          if (startsWithUTF8BOM(chunk)) {
            this.BOM = UTF8_BOM_CHARACTER;
            chunk = chunk.substr(1);
          }
        }
        const lastChar = chunk.charCodeAt(chunk.length - 1);
        if (lastChar === 13 || lastChar >= 55296 && lastChar <= 56319) {
          this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);
          this._hasPreviousChar = true;
          this._previousChar = lastChar;
        } else {
          this._acceptChunk1(chunk, false);
          this._hasPreviousChar = false;
          this._previousChar = lastChar;
        }
      }
      _acceptChunk1(chunk, allowEmptyStrings) {
        if (!allowEmptyStrings && chunk.length === 0) {
          return;
        }
        if (this._hasPreviousChar) {
          this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);
        } else {
          this._acceptChunk2(chunk);
        }
      }
      _acceptChunk2(chunk) {
        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);
        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));
        this.cr += lineStarts.cr;
        this.lf += lineStarts.lf;
        this.crlf += lineStarts.crlf;
        if (!lineStarts.isBasicASCII) {
          this.isBasicASCII = false;
          if (!this.containsRTL) {
            this.containsRTL = containsRTL(chunk);
          }
          if (!this.containsUnusualLineTerminators) {
            this.containsUnusualLineTerminators = containsUnusualLineTerminators(chunk);
          }
        }
      }
      finish(normalizeEOL = true) {
        this._finish();
        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);
      }
      _finish() {
        if (this.chunks.length === 0) {
          this._acceptChunk1("", true);
        }
        if (this._hasPreviousChar) {
          this._hasPreviousChar = false;
          const lastChunk = this.chunks[this.chunks.length - 1];
          lastChunk.buffer += String.fromCharCode(this._previousChar);
          const newLineStarts = createLineStartsFast(lastChunk.buffer);
          lastChunk.lineStarts = newLineStarts;
          if (this._previousChar === 13) {
            this.cr++;
          }
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js
function arrayFill(length, value) {
  const arr = [];
  for (let i = 0; i < length; i++) {
    arr[i] = value;
  }
  return arr;
}
var FixedArray;
var init_fixedArray = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js"() {
    init_arrays();
    FixedArray = class {
      constructor(_default) {
        this._default = _default;
        this._store = [];
      }
      get(index) {
        if (index < this._store.length) {
          return this._store[index];
        }
        return this._default;
      }
      set(index, value) {
        while (index >= this._store.length) {
          this._store[this._store.length] = this._default;
        }
        this._store[index] = value;
      }
      replace(index, oldLength, newLength) {
        if (index >= this._store.length) {
          return;
        }
        if (oldLength === 0) {
          this.insert(index, newLength);
          return;
        } else if (newLength === 0) {
          this.delete(index, oldLength);
          return;
        }
        const before = this._store.slice(0, index);
        const after2 = this._store.slice(index + oldLength);
        const insertArr = arrayFill(newLength, this._default);
        this._store = before.concat(insertArr, after2);
      }
      delete(deleteIndex, deleteCount) {
        if (deleteCount === 0 || deleteIndex >= this._store.length) {
          return;
        }
        this._store.splice(deleteIndex, deleteCount);
      }
      insert(insertIndex, insertCount) {
        if (insertCount === 0 || insertIndex >= this._store.length) {
          return;
        }
        const arr = [];
        for (let i = 0; i < insertCount; i++) {
          arr[i] = this._default;
        }
        this._store = arrayInsert(this._store, insertIndex, arr);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js
var ContiguousMultilineTokens;
var init_contiguousMultilineTokens = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js"() {
    ContiguousMultilineTokens = class {
      /**
       * (Inclusive) start line number for these tokens.
       */
      get startLineNumber() {
        return this._startLineNumber;
      }
      /**
       * (Inclusive) end line number for these tokens.
       */
      get endLineNumber() {
        return this._startLineNumber + this._tokens.length - 1;
      }
      constructor(startLineNumber, tokens) {
        this._startLineNumber = startLineNumber;
        this._tokens = tokens;
      }
      /**
       * @see {@link _tokens}
       */
      getLineTokens(lineNumber) {
        return this._tokens[lineNumber - this._startLineNumber];
      }
      appendLineTokens(lineTokens) {
        this._tokens.push(lineTokens);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js
var ContiguousMultilineTokensBuilder;
var init_contiguousMultilineTokensBuilder = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js"() {
    init_contiguousMultilineTokens();
    ContiguousMultilineTokensBuilder = class {
      constructor() {
        this._tokens = [];
      }
      add(lineNumber, lineTokens) {
        if (this._tokens.length > 0) {
          const last = this._tokens[this._tokens.length - 1];
          if (last.endLineNumber + 1 === lineNumber) {
            last.appendLineTokens(lineTokens);
            return;
          }
        }
        this._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));
      }
      finalize() {
        return this._tokens;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js
function safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {
  let r = null;
  if (tokenizationSupport) {
    try {
      r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());
    } catch (e) {
      onUnexpectedError(e);
    }
  }
  if (!r) {
    r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);
  }
  LineTokens.convertToEndOffset(r.tokens, text.length);
  return r;
}
var TokenizerWithStateStore, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore, TokenizationStateStore, RangePriorityQueueImpl, DefaultBackgroundTokenizer;
var init_textModelTokens = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js"() {
    init_async();
    init_errors();
    init_platform();
    init_stopwatch();
    init_eolCounter();
    init_lineRange();
    init_offsetRange();
    init_nullTokenize();
    init_fixedArray();
    init_contiguousMultilineTokensBuilder();
    init_lineTokens();
    TokenizerWithStateStore = class {
      constructor(lineCount, tokenizationSupport) {
        this.tokenizationSupport = tokenizationSupport;
        this.initialState = this.tokenizationSupport.getInitialState();
        this.store = new TrackingTokenizationStateStore(lineCount);
      }
      getStartState(lineNumber) {
        return this.store.getStartState(lineNumber, this.initialState);
      }
      getFirstInvalidLine() {
        return this.store.getFirstInvalidLine(this.initialState);
      }
    };
    TokenizerWithStateStoreAndTextModel = class extends TokenizerWithStateStore {
      constructor(lineCount, tokenizationSupport, _textModel, _languageIdCodec) {
        super(lineCount, tokenizationSupport);
        this._textModel = _textModel;
        this._languageIdCodec = _languageIdCodec;
      }
      updateTokensUntilLine(builder, lineNumber) {
        const languageId = this._textModel.getLanguageId();
        while (true) {
          const lineToTokenize = this.getFirstInvalidLine();
          if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {
            break;
          }
          const text = this._textModel.getLineContent(lineToTokenize.lineNumber);
          const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);
          builder.add(lineToTokenize.lineNumber, r.tokens);
          this.store.setEndState(lineToTokenize.lineNumber, r.endState);
        }
      }
      /** assumes state is up to date */
      getTokenTypeIfInsertingCharacter(position, character) {
        const lineStartState = this.getStartState(position.lineNumber);
        if (!lineStartState) {
          return 0;
        }
        const languageId = this._textModel.getLanguageId();
        const lineContent = this._textModel.getLineContent(position.lineNumber);
        const text = lineContent.substring(0, position.column - 1) + character + lineContent.substring(position.column - 1);
        const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);
        const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);
        if (lineTokens.getCount() === 0) {
          return 0;
        }
        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        return lineTokens.getStandardTokenType(tokenIndex);
      }
      /** assumes state is up to date */
      tokenizeLineWithEdit(position, length, newText) {
        const lineNumber = position.lineNumber;
        const column = position.column;
        const lineStartState = this.getStartState(lineNumber);
        if (!lineStartState) {
          return null;
        }
        const curLineContent = this._textModel.getLineContent(lineNumber);
        const newLineContent = curLineContent.substring(0, column - 1) + newText + curLineContent.substring(column - 1 + length);
        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);
        const result = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, newLineContent, true, lineStartState);
        const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);
        return lineTokens;
      }
      isCheapToTokenize(lineNumber) {
        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();
        if (lineNumber < firstInvalidLineNumber) {
          return true;
        }
        if (lineNumber === firstInvalidLineNumber && this._textModel.getLineLength(lineNumber) < 2048) {
          return true;
        }
        return false;
      }
      /**
       * The result is not cached.
       */
      tokenizeHeuristically(builder, startLineNumber, endLineNumber) {
        if (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {
          return { heuristicTokens: false };
        }
        if (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {
          this.updateTokensUntilLine(builder, endLineNumber);
          return { heuristicTokens: false };
        }
        let state = this.guessStartState(startLineNumber);
        const languageId = this._textModel.getLanguageId();
        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
          const text = this._textModel.getLineContent(lineNumber);
          const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);
          builder.add(lineNumber, r.tokens);
          state = r.endState;
        }
        return { heuristicTokens: true };
      }
      guessStartState(lineNumber) {
        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);
        const likelyRelevantLines = [];
        let initialState = null;
        for (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {
          const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);
          if (newNonWhitespaceIndex === 0) {
            continue;
          }
          if (newNonWhitespaceIndex < nonWhitespaceColumn) {
            likelyRelevantLines.push(this._textModel.getLineContent(i));
            nonWhitespaceColumn = newNonWhitespaceIndex;
            initialState = this.getStartState(i);
            if (initialState) {
              break;
            }
          }
        }
        if (!initialState) {
          initialState = this.tokenizationSupport.getInitialState();
        }
        likelyRelevantLines.reverse();
        const languageId = this._textModel.getLanguageId();
        let state = initialState;
        for (const line of likelyRelevantLines) {
          const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);
          state = r.endState;
        }
        return state;
      }
    };
    TrackingTokenizationStateStore = class {
      constructor(lineCount) {
        this.lineCount = lineCount;
        this._tokenizationStateStore = new TokenizationStateStore();
        this._invalidEndStatesLineNumbers = new RangePriorityQueueImpl();
        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));
      }
      getEndState(lineNumber) {
        return this._tokenizationStateStore.getEndState(lineNumber);
      }
      /**
       * @returns if the end state has changed.
       */
      setEndState(lineNumber, state) {
        if (!state) {
          throw new BugIndicatingError("Cannot set null/undefined state");
        }
        this._invalidEndStatesLineNumbers.delete(lineNumber);
        const r = this._tokenizationStateStore.setEndState(lineNumber, state);
        if (r && lineNumber < this.lineCount) {
          this._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));
        }
        return r;
      }
      acceptChange(range2, newLineCount) {
        this.lineCount += newLineCount - range2.length;
        this._tokenizationStateStore.acceptChange(range2, newLineCount);
        this._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range2.startLineNumber, range2.endLineNumberExclusive), newLineCount);
      }
      acceptChanges(changes) {
        for (const c of changes) {
          const [eolCount] = countEOL(c.text);
          this.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);
        }
      }
      invalidateEndStateRange(range2) {
        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(range2.startLineNumber, range2.endLineNumberExclusive));
      }
      getFirstInvalidEndStateLineNumber() {
        return this._invalidEndStatesLineNumbers.min;
      }
      getFirstInvalidEndStateLineNumberOrMax() {
        return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;
      }
      allStatesValid() {
        return this._invalidEndStatesLineNumbers.min === null;
      }
      getStartState(lineNumber, initialState) {
        if (lineNumber === 1) {
          return initialState;
        }
        return this.getEndState(lineNumber - 1);
      }
      getFirstInvalidLine(initialState) {
        const lineNumber = this.getFirstInvalidEndStateLineNumber();
        if (lineNumber === null) {
          return null;
        }
        const startState = this.getStartState(lineNumber, initialState);
        if (!startState) {
          throw new BugIndicatingError("Start state must be defined");
        }
        return { lineNumber, startState };
      }
    };
    TokenizationStateStore = class {
      constructor() {
        this._lineEndStates = new FixedArray(null);
      }
      getEndState(lineNumber) {
        return this._lineEndStates.get(lineNumber);
      }
      setEndState(lineNumber, state) {
        const oldState = this._lineEndStates.get(lineNumber);
        if (oldState && oldState.equals(state)) {
          return false;
        }
        this._lineEndStates.set(lineNumber, state);
        return true;
      }
      acceptChange(range2, newLineCount) {
        let length = range2.length;
        if (newLineCount > 0 && length > 0) {
          length--;
          newLineCount--;
        }
        this._lineEndStates.replace(range2.startLineNumber, length, newLineCount);
      }
    };
    RangePriorityQueueImpl = class {
      constructor() {
        this._ranges = [];
      }
      get min() {
        if (this._ranges.length === 0) {
          return null;
        }
        return this._ranges[0].start;
      }
      delete(value) {
        const idx = this._ranges.findIndex((r) => r.contains(value));
        if (idx !== -1) {
          const range2 = this._ranges[idx];
          if (range2.start === value) {
            if (range2.endExclusive === value + 1) {
              this._ranges.splice(idx, 1);
            } else {
              this._ranges[idx] = new OffsetRange(value + 1, range2.endExclusive);
            }
          } else {
            if (range2.endExclusive === value + 1) {
              this._ranges[idx] = new OffsetRange(range2.start, value);
            } else {
              this._ranges.splice(idx, 1, new OffsetRange(range2.start, value), new OffsetRange(value + 1, range2.endExclusive));
            }
          }
        }
      }
      addRange(range2) {
        OffsetRange.addRange(range2, this._ranges);
      }
      addRangeAndResize(range2, newLength) {
        let idxFirstMightBeIntersecting = 0;
        while (!(idxFirstMightBeIntersecting >= this._ranges.length || range2.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {
          idxFirstMightBeIntersecting++;
        }
        let idxFirstIsAfter = idxFirstMightBeIntersecting;
        while (!(idxFirstIsAfter >= this._ranges.length || range2.endExclusive < this._ranges[idxFirstIsAfter].start)) {
          idxFirstIsAfter++;
        }
        const delta = newLength - range2.length;
        for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {
          this._ranges[i] = this._ranges[i].delta(delta);
        }
        if (idxFirstMightBeIntersecting === idxFirstIsAfter) {
          const newRange = new OffsetRange(range2.start, range2.start + newLength);
          if (!newRange.isEmpty) {
            this._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);
          }
        } else {
          const start = Math.min(range2.start, this._ranges[idxFirstMightBeIntersecting].start);
          const endEx = Math.max(range2.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);
          const newRange = new OffsetRange(start, endEx + delta);
          if (!newRange.isEmpty) {
            this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);
          } else {
            this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);
          }
        }
      }
      toString() {
        return this._ranges.map((r) => r.toString()).join(" + ");
      }
    };
    DefaultBackgroundTokenizer = class {
      constructor(_tokenizerWithStateStore, _backgroundTokenStore) {
        this._tokenizerWithStateStore = _tokenizerWithStateStore;
        this._backgroundTokenStore = _backgroundTokenStore;
        this._isDisposed = false;
        this._isScheduled = false;
      }
      dispose() {
        this._isDisposed = true;
      }
      handleChanges() {
        this._beginBackgroundTokenization();
      }
      _beginBackgroundTokenization() {
        if (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {
          return;
        }
        this._isScheduled = true;
        runWhenGlobalIdle((deadline) => {
          this._isScheduled = false;
          this._backgroundTokenizeWithDeadline(deadline);
        });
      }
      /**
       * Tokenize until the deadline occurs, but try to yield every 1-2ms.
       */
      _backgroundTokenizeWithDeadline(deadline) {
        const endTime = Date.now() + deadline.timeRemaining();
        const execute = () => {
          if (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {
            return;
          }
          this._backgroundTokenizeForAtLeast1ms();
          if (Date.now() < endTime) {
            setTimeout0(execute);
          } else {
            this._beginBackgroundTokenization();
          }
        };
        execute();
      }
      /**
       * Tokenize for at least 1ms.
       */
      _backgroundTokenizeForAtLeast1ms() {
        const lineCount = this._tokenizerWithStateStore._textModel.getLineCount();
        const builder = new ContiguousMultilineTokensBuilder();
        const sw = StopWatch.create(false);
        do {
          if (sw.elapsed() > 1) {
            break;
          }
          const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);
          if (tokenizedLineNumber >= lineCount) {
            break;
          }
        } while (this._hasLinesToTokenize());
        this._backgroundTokenStore.setTokens(builder.finalize());
        this.checkFinished();
      }
      _hasLinesToTokenize() {
        if (!this._tokenizerWithStateStore) {
          return false;
        }
        return !this._tokenizerWithStateStore.store.allStatesValid();
      }
      _tokenizeOneInvalidLine(builder) {
        var _a2;
        const firstInvalidLine = (_a2 = this._tokenizerWithStateStore) === null || _a2 === void 0 ? void 0 : _a2.getFirstInvalidLine();
        if (!firstInvalidLine) {
          return this._tokenizerWithStateStore._textModel.getLineCount() + 1;
        }
        this._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);
        return firstInvalidLine.lineNumber;
      }
      checkFinished() {
        if (this._isDisposed) {
          return;
        }
        if (this._tokenizerWithStateStore.store.allStatesValid()) {
          this._backgroundTokenStore.backgroundTokenizationFinished();
        }
      }
      requestTokens(startLineNumber, endLineNumberExclusive) {
        this._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js
function toUint32Array(arr) {
  if (arr instanceof Uint32Array) {
    return arr;
  } else {
    return new Uint32Array(arr);
  }
}
var EMPTY_LINE_TOKENS, ContiguousTokensEditing;
var init_contiguousTokensEditing = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js"() {
    init_lineTokens();
    EMPTY_LINE_TOKENS = new Uint32Array(0).buffer;
    ContiguousTokensEditing = class _ContiguousTokensEditing {
      static deleteBeginning(lineTokens, toChIndex) {
        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
          return lineTokens;
        }
        return _ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);
      }
      static deleteEnding(lineTokens, fromChIndex) {
        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
          return lineTokens;
        }
        const tokens = toUint32Array(lineTokens);
        const lineTextLength = tokens[tokens.length - 2];
        return _ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);
      }
      static delete(lineTokens, fromChIndex, toChIndex) {
        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {
          return lineTokens;
        }
        const tokens = toUint32Array(lineTokens);
        const tokensCount = tokens.length >>> 1;
        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {
          return EMPTY_LINE_TOKENS;
        }
        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);
        const fromTokenStartOffset = fromTokenIndex > 0 ? tokens[fromTokenIndex - 1 << 1] : 0;
        const fromTokenEndOffset = tokens[fromTokenIndex << 1];
        if (toChIndex < fromTokenEndOffset) {
          const delta2 = toChIndex - fromChIndex;
          for (let i = fromTokenIndex; i < tokensCount; i++) {
            tokens[i << 1] -= delta2;
          }
          return lineTokens;
        }
        let dest;
        let lastEnd;
        if (fromTokenStartOffset !== fromChIndex) {
          tokens[fromTokenIndex << 1] = fromChIndex;
          dest = fromTokenIndex + 1 << 1;
          lastEnd = fromChIndex;
        } else {
          dest = fromTokenIndex << 1;
          lastEnd = fromTokenStartOffset;
        }
        const delta = toChIndex - fromChIndex;
        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {
          const tokenEndOffset = tokens[tokenIndex << 1] - delta;
          if (tokenEndOffset > lastEnd) {
            tokens[dest++] = tokenEndOffset;
            tokens[dest++] = tokens[(tokenIndex << 1) + 1];
            lastEnd = tokenEndOffset;
          }
        }
        if (dest === tokens.length) {
          return lineTokens;
        }
        const tmp = new Uint32Array(dest);
        tmp.set(tokens.subarray(0, dest), 0);
        return tmp.buffer;
      }
      static append(lineTokens, _otherTokens) {
        if (_otherTokens === EMPTY_LINE_TOKENS) {
          return lineTokens;
        }
        if (lineTokens === EMPTY_LINE_TOKENS) {
          return _otherTokens;
        }
        if (lineTokens === null) {
          return lineTokens;
        }
        if (_otherTokens === null) {
          return null;
        }
        const myTokens = toUint32Array(lineTokens);
        const otherTokens = toUint32Array(_otherTokens);
        const otherTokensCount = otherTokens.length >>> 1;
        const result = new Uint32Array(myTokens.length + otherTokens.length);
        result.set(myTokens, 0);
        let dest = myTokens.length;
        const delta = myTokens[myTokens.length - 2];
        for (let i = 0; i < otherTokensCount; i++) {
          result[dest++] = otherTokens[i << 1] + delta;
          result[dest++] = otherTokens[(i << 1) + 1];
        }
        return result.buffer;
      }
      static insert(lineTokens, chIndex, textLength) {
        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
          return lineTokens;
        }
        const tokens = toUint32Array(lineTokens);
        const tokensCount = tokens.length >>> 1;
        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);
        if (fromTokenIndex > 0) {
          const fromTokenStartOffset = tokens[fromTokenIndex - 1 << 1];
          if (fromTokenStartOffset === chIndex) {
            fromTokenIndex--;
          }
        }
        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {
          tokens[tokenIndex << 1] += textLength;
        }
        return lineTokens;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js
function getDefaultMetadata(topLevelLanguageId) {
  return (topLevelLanguageId << 0 | 0 << 8 | 0 << 11 | 1 << 15 | 2 << 24 | 1024) >>> 0;
}
var ContiguousTokensStore;
var init_contiguousTokensStore = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js"() {
    init_arrays();
    init_position();
    init_contiguousTokensEditing();
    init_lineTokens();
    init_encodedTokenAttributes();
    ContiguousTokensStore = class _ContiguousTokensStore {
      constructor(languageIdCodec) {
        this._lineTokens = [];
        this._len = 0;
        this._languageIdCodec = languageIdCodec;
      }
      flush() {
        this._lineTokens = [];
        this._len = 0;
      }
      get hasTokens() {
        return this._lineTokens.length > 0;
      }
      getTokens(topLevelLanguageId, lineIndex, lineText) {
        let rawLineTokens = null;
        if (lineIndex < this._len) {
          rawLineTokens = this._lineTokens[lineIndex];
        }
        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {
          return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);
        }
        const lineTokens = new Uint32Array(2);
        lineTokens[0] = lineText.length;
        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));
        return new LineTokens(lineTokens, lineText, this._languageIdCodec);
      }
      static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {
        const tokens = _tokens ? toUint32Array(_tokens) : null;
        if (lineTextLength === 0) {
          let hasDifferentLanguageId = false;
          if (tokens && tokens.length > 1) {
            hasDifferentLanguageId = TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId;
          }
          if (!hasDifferentLanguageId) {
            return EMPTY_LINE_TOKENS;
          }
        }
        if (!tokens || tokens.length === 0) {
          const tokens2 = new Uint32Array(2);
          tokens2[0] = lineTextLength;
          tokens2[1] = getDefaultMetadata(topLevelLanguageId);
          return tokens2.buffer;
        }
        tokens[tokens.length - 2] = lineTextLength;
        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {
          return tokens.buffer;
        }
        return tokens;
      }
      _ensureLine(lineIndex) {
        while (lineIndex >= this._len) {
          this._lineTokens[this._len] = null;
          this._len++;
        }
      }
      _deleteLines(start, deleteCount) {
        if (deleteCount === 0) {
          return;
        }
        if (start + deleteCount > this._len) {
          deleteCount = this._len - start;
        }
        this._lineTokens.splice(start, deleteCount);
        this._len -= deleteCount;
      }
      _insertLines(insertIndex, insertCount) {
        if (insertCount === 0) {
          return;
        }
        const lineTokens = [];
        for (let i = 0; i < insertCount; i++) {
          lineTokens[i] = null;
        }
        this._lineTokens = arrayInsert(this._lineTokens, insertIndex, lineTokens);
        this._len += insertCount;
      }
      setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {
        const tokens = _ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);
        this._ensureLine(lineIndex);
        const oldTokens = this._lineTokens[lineIndex];
        this._lineTokens[lineIndex] = tokens;
        if (checkEquality) {
          return !_ContiguousTokensStore._equals(oldTokens, tokens);
        }
        return false;
      }
      static _equals(_a2, _b2) {
        if (!_a2 || !_b2) {
          return !_a2 && !_b2;
        }
        const a = toUint32Array(_a2);
        const b = toUint32Array(_b2);
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0, len = a.length; i < len; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      //#region Editing
      acceptEdit(range2, eolCount, firstLineLength) {
        this._acceptDeleteRange(range2);
        this._acceptInsertText(new Position(range2.startLineNumber, range2.startColumn), eolCount, firstLineLength);
      }
      _acceptDeleteRange(range2) {
        const firstLineIndex = range2.startLineNumber - 1;
        if (firstLineIndex >= this._len) {
          return;
        }
        if (range2.startLineNumber === range2.endLineNumber) {
          if (range2.startColumn === range2.endColumn) {
            return;
          }
          this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range2.startColumn - 1, range2.endColumn - 1);
          return;
        }
        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range2.startColumn - 1);
        const lastLineIndex = range2.endLineNumber - 1;
        let lastLineTokens = null;
        if (lastLineIndex < this._len) {
          lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range2.endColumn - 1);
        }
        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);
        this._deleteLines(range2.startLineNumber, range2.endLineNumber - range2.startLineNumber);
      }
      _acceptInsertText(position, eolCount, firstLineLength) {
        if (eolCount === 0 && firstLineLength === 0) {
          return;
        }
        const lineIndex = position.lineNumber - 1;
        if (lineIndex >= this._len) {
          return;
        }
        if (eolCount === 0) {
          this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);
          return;
        }
        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);
        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);
        this._insertLines(position.lineNumber, eolCount);
      }
      //#endregion
      setMultilineTokens(tokens, textModel) {
        if (tokens.length === 0) {
          return { changes: [] };
        }
        const ranges = [];
        for (let i = 0, len = tokens.length; i < len; i++) {
          const element = tokens[i];
          let minChangedLineNumber = 0;
          let maxChangedLineNumber = 0;
          let hasChange = false;
          for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {
            if (hasChange) {
              this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);
              maxChangedLineNumber = lineNumber;
            } else {
              const lineHasChange = this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);
              if (lineHasChange) {
                hasChange = true;
                minChangedLineNumber = lineNumber;
                maxChangedLineNumber = lineNumber;
              }
            }
          }
          if (hasChange) {
            ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber });
          }
        }
        return { changes: ranges };
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js
var SparseTokensStore;
var init_sparseTokensStore = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js"() {
    init_arrays();
    init_lineTokens();
    SparseTokensStore = class _SparseTokensStore {
      constructor(languageIdCodec) {
        this._pieces = [];
        this._isComplete = false;
        this._languageIdCodec = languageIdCodec;
      }
      flush() {
        this._pieces = [];
        this._isComplete = false;
      }
      isEmpty() {
        return this._pieces.length === 0;
      }
      set(pieces, isComplete) {
        this._pieces = pieces || [];
        this._isComplete = isComplete;
      }
      setPartial(_range, pieces) {
        let range2 = _range;
        if (pieces.length > 0) {
          const _firstRange = pieces[0].getRange();
          const _lastRange = pieces[pieces.length - 1].getRange();
          if (!_firstRange || !_lastRange) {
            return _range;
          }
          range2 = _range.plusRange(_firstRange).plusRange(_lastRange);
        }
        let insertPosition = null;
        for (let i = 0, len = this._pieces.length; i < len; i++) {
          const piece = this._pieces[i];
          if (piece.endLineNumber < range2.startLineNumber) {
            continue;
          }
          if (piece.startLineNumber > range2.endLineNumber) {
            insertPosition = insertPosition || { index: i };
            break;
          }
          piece.removeTokens(range2);
          if (piece.isEmpty()) {
            this._pieces.splice(i, 1);
            i--;
            len--;
            continue;
          }
          if (piece.endLineNumber < range2.startLineNumber) {
            continue;
          }
          if (piece.startLineNumber > range2.endLineNumber) {
            insertPosition = insertPosition || { index: i };
            continue;
          }
          const [a, b] = piece.split(range2);
          if (a.isEmpty()) {
            insertPosition = insertPosition || { index: i };
            continue;
          }
          if (b.isEmpty()) {
            continue;
          }
          this._pieces.splice(i, 1, a, b);
          i++;
          len++;
          insertPosition = insertPosition || { index: i };
        }
        insertPosition = insertPosition || { index: this._pieces.length };
        if (pieces.length > 0) {
          this._pieces = arrayInsert(this._pieces, insertPosition.index, pieces);
        }
        return range2;
      }
      isComplete() {
        return this._isComplete;
      }
      addSparseTokens(lineNumber, aTokens) {
        if (aTokens.getLineContent().length === 0) {
          return aTokens;
        }
        const pieces = this._pieces;
        if (pieces.length === 0) {
          return aTokens;
        }
        const pieceIndex = _SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);
        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);
        if (!bTokens) {
          return aTokens;
        }
        const aLen = aTokens.getCount();
        const bLen = bTokens.getCount();
        let aIndex = 0;
        const result = [];
        let resultLen = 0;
        let lastEndOffset = 0;
        const emitToken = (endOffset, metadata) => {
          if (endOffset === lastEndOffset) {
            return;
          }
          lastEndOffset = endOffset;
          result[resultLen++] = endOffset;
          result[resultLen++] = metadata;
        };
        for (let bIndex = 0; bIndex < bLen; bIndex++) {
          const bStartCharacter = bTokens.getStartCharacter(bIndex);
          const bEndCharacter = bTokens.getEndCharacter(bIndex);
          const bMetadata = bTokens.getMetadata(bIndex);
          const bMask = ((bMetadata & 1 ? 2048 : 0) | (bMetadata & 2 ? 4096 : 0) | (bMetadata & 4 ? 8192 : 0) | (bMetadata & 8 ? 16384 : 0) | (bMetadata & 16 ? 16744448 : 0) | (bMetadata & 32 ? 4278190080 : 0)) >>> 0;
          const aMask = ~bMask >>> 0;
          while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {
            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));
            aIndex++;
          }
          if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {
            emitToken(bStartCharacter, aTokens.getMetadata(aIndex));
          }
          while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {
            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask);
            aIndex++;
          }
          if (aIndex < aLen) {
            emitToken(bEndCharacter, aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask);
            if (aTokens.getEndOffset(aIndex) === bEndCharacter) {
              aIndex++;
            }
          } else {
            const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);
            emitToken(bEndCharacter, aTokens.getMetadata(aMergeIndex) & aMask | bMetadata & bMask);
          }
        }
        while (aIndex < aLen) {
          emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));
          aIndex++;
        }
        return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);
      }
      static _findFirstPieceWithLine(pieces, lineNumber) {
        let low = 0;
        let high = pieces.length - 1;
        while (low < high) {
          let mid = low + Math.floor((high - low) / 2);
          if (pieces[mid].endLineNumber < lineNumber) {
            low = mid + 1;
          } else if (pieces[mid].startLineNumber > lineNumber) {
            high = mid - 1;
          } else {
            while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {
              mid--;
            }
            return mid;
          }
        }
        return low;
      }
      acceptEdit(range2, eolCount, firstLineLength, lastLineLength, firstCharCode) {
        for (const piece of this._pieces) {
          piece.acceptEdit(range2, eolCount, firstLineLength, lastLineLength, firstCharCode);
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js
var TokenizationTextModelPart, GrammarTokens, AttachedViewHandler;
var init_tokenizationTextModelPart = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js"() {
    init_arrays();
    init_async();
    init_errors();
    init_event();
    init_lifecycle();
    init_eolCounter();
    init_lineRange();
    init_position();
    init_wordHelper();
    init_languages();
    init_textModelPart();
    init_textModelTokens();
    init_contiguousMultilineTokensBuilder();
    init_contiguousTokensStore();
    init_sparseTokensStore();
    TokenizationTextModelPart = class _TokenizationTextModelPart extends TextModelPart {
      constructor(_languageService, _languageConfigurationService, _textModel, _bracketPairsTextModelPart, _languageId, _attachedViews) {
        super();
        this._languageService = _languageService;
        this._languageConfigurationService = _languageConfigurationService;
        this._textModel = _textModel;
        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;
        this._languageId = _languageId;
        this._attachedViews = _attachedViews;
        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);
        this._onDidChangeLanguage = this._register(new Emitter());
        this.onDidChangeLanguage = this._onDidChangeLanguage.event;
        this._onDidChangeLanguageConfiguration = this._register(new Emitter());
        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;
        this._onDidChangeTokens = this._register(new Emitter());
        this.onDidChangeTokens = this._onDidChangeTokens.event;
        this.grammarTokens = this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));
        this._register(this._languageConfigurationService.onDidChange((e) => {
          if (e.affects(this._languageId)) {
            this._onDidChangeLanguageConfiguration.fire({});
          }
        }));
        this._register(this.grammarTokens.onDidChangeTokens((e) => {
          this._emitModelTokensChangedEvent(e);
        }));
        this._register(this.grammarTokens.onDidChangeBackgroundTokenizationState((e) => {
          this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();
        }));
      }
      handleDidChangeContent(e) {
        if (e.isFlush) {
          this._semanticTokens.flush();
        } else if (!e.isEolChange) {
          for (const c of e.changes) {
            const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);
            this._semanticTokens.acceptEdit(
              c.range,
              eolCount,
              firstLineLength,
              lastLineLength,
              c.text.length > 0 ? c.text.charCodeAt(0) : 0
              /* CharCode.Null */
            );
          }
        }
        this.grammarTokens.handleDidChangeContent(e);
      }
      handleDidChangeAttached() {
        this.grammarTokens.handleDidChangeAttached();
      }
      /**
       * Includes grammar and semantic tokens.
       */
      getLineTokens(lineNumber) {
        this.validateLineNumber(lineNumber);
        const syntacticTokens = this.grammarTokens.getLineTokens(lineNumber);
        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);
      }
      _emitModelTokensChangedEvent(e) {
        if (!this._textModel._isDisposing()) {
          this._bracketPairsTextModelPart.handleDidChangeTokens(e);
          this._onDidChangeTokens.fire(e);
        }
      }
      // #region Grammar Tokens
      validateLineNumber(lineNumber) {
        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {
          throw new BugIndicatingError("Illegal value for lineNumber");
        }
      }
      get hasTokens() {
        return this.grammarTokens.hasTokens;
      }
      resetTokenization() {
        this.grammarTokens.resetTokenization();
      }
      get backgroundTokenizationState() {
        return this.grammarTokens.backgroundTokenizationState;
      }
      forceTokenization(lineNumber) {
        this.validateLineNumber(lineNumber);
        this.grammarTokens.forceTokenization(lineNumber);
      }
      isCheapToTokenize(lineNumber) {
        this.validateLineNumber(lineNumber);
        return this.grammarTokens.isCheapToTokenize(lineNumber);
      }
      tokenizeIfCheap(lineNumber) {
        this.validateLineNumber(lineNumber);
        this.grammarTokens.tokenizeIfCheap(lineNumber);
      }
      getTokenTypeIfInsertingCharacter(lineNumber, column, character) {
        return this.grammarTokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);
      }
      tokenizeLineWithEdit(position, length, newText) {
        return this.grammarTokens.tokenizeLineWithEdit(position, length, newText);
      }
      // #endregion
      // #region Semantic Tokens
      setSemanticTokens(tokens, isComplete) {
        this._semanticTokens.set(tokens, isComplete);
        this._emitModelTokensChangedEvent({
          semanticTokensApplied: tokens !== null,
          ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }]
        });
      }
      hasCompleteSemanticTokens() {
        return this._semanticTokens.isComplete();
      }
      hasSomeSemanticTokens() {
        return !this._semanticTokens.isEmpty();
      }
      setPartialSemanticTokens(range2, tokens) {
        if (this.hasCompleteSemanticTokens()) {
          return;
        }
        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range2, tokens));
        this._emitModelTokensChangedEvent({
          semanticTokensApplied: true,
          ranges: [
            {
              fromLineNumber: changedRange.startLineNumber,
              toLineNumber: changedRange.endLineNumber
            }
          ]
        });
      }
      // #endregion
      // #region Utility Methods
      getWordAtPosition(_position) {
        this.assertNotDisposed();
        const position = this._textModel.validatePosition(_position);
        const lineContent = this._textModel.getLineContent(position.lineNumber);
        const lineTokens = this.getLineTokens(position.lineNumber);
        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        const [rbStartOffset, rbEndOffset] = _TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex);
        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);
        if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {
          return rightBiasedWord;
        }
        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {
          const [lbStartOffset, lbEndOffset] = _TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex - 1);
          const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);
          if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {
            return leftBiasedWord;
          }
        }
        return null;
      }
      getLanguageConfiguration(languageId) {
        return this._languageConfigurationService.getLanguageConfiguration(languageId);
      }
      static _findLanguageBoundaries(lineTokens, tokenIndex) {
        const languageId = lineTokens.getLanguageId(tokenIndex);
        let startOffset = 0;
        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {
          startOffset = lineTokens.getStartOffset(i);
        }
        let endOffset = lineTokens.getLineContent().length;
        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {
          endOffset = lineTokens.getEndOffset(i);
        }
        return [startOffset, endOffset];
      }
      getWordUntilPosition(position) {
        const wordAtPosition = this.getWordAtPosition(position);
        if (!wordAtPosition) {
          return { word: "", startColumn: position.column, endColumn: position.column };
        }
        return {
          word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),
          startColumn: wordAtPosition.startColumn,
          endColumn: position.column
        };
      }
      // #endregion
      // #region Language Id handling
      getLanguageId() {
        return this._languageId;
      }
      getLanguageIdAtPosition(lineNumber, column) {
        const position = this._textModel.validatePosition(new Position(lineNumber, column));
        const lineTokens = this.getLineTokens(position.lineNumber);
        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));
      }
      setLanguageId(languageId, source = "api") {
        if (this._languageId === languageId) {
          return;
        }
        const e = {
          oldLanguage: this._languageId,
          newLanguage: languageId,
          source
        };
        this._languageId = languageId;
        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);
        this.grammarTokens.resetTokenization();
        this._onDidChangeLanguage.fire(e);
        this._onDidChangeLanguageConfiguration.fire({});
      }
    };
    GrammarTokens = class extends Disposable {
      get backgroundTokenizationState() {
        return this._backgroundTokenizationState;
      }
      constructor(_languageIdCodec, _textModel, getLanguageId, attachedViews) {
        super();
        this._languageIdCodec = _languageIdCodec;
        this._textModel = _textModel;
        this.getLanguageId = getLanguageId;
        this._tokenizer = null;
        this._defaultBackgroundTokenizer = null;
        this._backgroundTokenizer = this._register(new MutableDisposable());
        this._tokens = new ContiguousTokensStore(this._languageIdCodec);
        this._debugBackgroundTokenizer = this._register(new MutableDisposable());
        this._backgroundTokenizationState = 1;
        this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());
        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;
        this._onDidChangeTokens = this._register(new Emitter());
        this.onDidChangeTokens = this._onDidChangeTokens.event;
        this._attachedViewStates = this._register(new DisposableMap());
        this._register(TokenizationRegistry2.onDidChange((e) => {
          const languageId = this.getLanguageId();
          if (e.changedLanguages.indexOf(languageId) === -1) {
            return;
          }
          this.resetTokenization();
        }));
        this.resetTokenization();
        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {
          if (state) {
            let existing = this._attachedViewStates.get(view);
            if (!existing) {
              existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));
              this._attachedViewStates.set(view, existing);
            }
            existing.handleStateChange(state);
          } else {
            this._attachedViewStates.deleteAndDispose(view);
          }
        }));
      }
      resetTokenization(fireTokenChangeEvent = true) {
        var _a2;
        this._tokens.flush();
        (_a2 = this._debugBackgroundTokens) === null || _a2 === void 0 ? void 0 : _a2.flush();
        if (this._debugBackgroundStates) {
          this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());
        }
        if (fireTokenChangeEvent) {
          this._onDidChangeTokens.fire({
            semanticTokensApplied: false,
            ranges: [
              {
                fromLineNumber: 1,
                toLineNumber: this._textModel.getLineCount()
              }
            ]
          });
        }
        const initializeTokenization = () => {
          if (this._textModel.isTooLargeForTokenization()) {
            return [null, null];
          }
          const tokenizationSupport2 = TokenizationRegistry2.get(this.getLanguageId());
          if (!tokenizationSupport2) {
            return [null, null];
          }
          let initialState2;
          try {
            initialState2 = tokenizationSupport2.getInitialState();
          } catch (e) {
            onUnexpectedError(e);
            return [null, null];
          }
          return [tokenizationSupport2, initialState2];
        };
        const [tokenizationSupport, initialState] = initializeTokenization();
        if (tokenizationSupport && initialState) {
          this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);
        } else {
          this._tokenizer = null;
        }
        this._backgroundTokenizer.clear();
        this._defaultBackgroundTokenizer = null;
        if (this._tokenizer) {
          const b = {
            setTokens: (tokens) => {
              this.setTokens(tokens);
            },
            backgroundTokenizationFinished: () => {
              if (this._backgroundTokenizationState === 2) {
                return;
              }
              const newState = 2;
              this._backgroundTokenizationState = newState;
              this._onDidChangeBackgroundTokenizationState.fire();
            },
            setEndState: (lineNumber, state) => {
              var _a3;
              if (!this._tokenizer) {
                return;
              }
              const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();
              if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {
                (_a3 = this._tokenizer) === null || _a3 === void 0 ? void 0 : _a3.store.setEndState(lineNumber, state);
              }
            }
          };
          if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {
            this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);
          }
          if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {
            this._backgroundTokenizer.value = this._defaultBackgroundTokenizer = new DefaultBackgroundTokenizer(this._tokenizer, b);
            this._defaultBackgroundTokenizer.handleChanges();
          }
          if ((tokenizationSupport === null || tokenizationSupport === void 0 ? void 0 : tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) && tokenizationSupport.createBackgroundTokenizer) {
            this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);
            this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());
            this._debugBackgroundTokenizer.clear();
            this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {
              setTokens: (tokens) => {
                var _a3;
                (_a3 = this._debugBackgroundTokens) === null || _a3 === void 0 ? void 0 : _a3.setMultilineTokens(tokens, this._textModel);
              },
              backgroundTokenizationFinished() {
              },
              setEndState: (lineNumber, state) => {
                var _a3;
                (_a3 = this._debugBackgroundStates) === null || _a3 === void 0 ? void 0 : _a3.setEndState(lineNumber, state);
              }
            });
          } else {
            this._debugBackgroundTokens = void 0;
            this._debugBackgroundStates = void 0;
            this._debugBackgroundTokenizer.value = void 0;
          }
        }
        this.refreshAllVisibleLineTokens();
      }
      handleDidChangeAttached() {
        var _a2;
        (_a2 = this._defaultBackgroundTokenizer) === null || _a2 === void 0 ? void 0 : _a2.handleChanges();
      }
      handleDidChangeContent(e) {
        var _a2, _b2, _c;
        if (e.isFlush) {
          this.resetTokenization(false);
        } else if (!e.isEolChange) {
          for (const c of e.changes) {
            const [eolCount, firstLineLength] = countEOL(c.text);
            this._tokens.acceptEdit(c.range, eolCount, firstLineLength);
            (_a2 = this._debugBackgroundTokens) === null || _a2 === void 0 ? void 0 : _a2.acceptEdit(c.range, eolCount, firstLineLength);
          }
          (_b2 = this._debugBackgroundStates) === null || _b2 === void 0 ? void 0 : _b2.acceptChanges(e.changes);
          if (this._tokenizer) {
            this._tokenizer.store.acceptChanges(e.changes);
          }
          (_c = this._defaultBackgroundTokenizer) === null || _c === void 0 ? void 0 : _c.handleChanges();
        }
      }
      setTokens(tokens) {
        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);
        if (changes.length > 0) {
          this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes });
        }
        return { changes };
      }
      refreshAllVisibleLineTokens() {
        const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));
        this.refreshRanges(ranges);
      }
      refreshRanges(ranges) {
        for (const range2 of ranges) {
          this.refreshRange(range2.startLineNumber, range2.endLineNumberExclusive - 1);
        }
      }
      refreshRange(startLineNumber, endLineNumber) {
        var _a2, _b2;
        if (!this._tokenizer) {
          return;
        }
        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));
        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);
        const builder = new ContiguousMultilineTokensBuilder();
        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);
        const changedTokens = this.setTokens(builder.finalize());
        if (heuristicTokens) {
          for (const c of changedTokens.changes) {
            (_a2 = this._backgroundTokenizer.value) === null || _a2 === void 0 ? void 0 : _a2.requestTokens(c.fromLineNumber, c.toLineNumber + 1);
          }
        }
        (_b2 = this._defaultBackgroundTokenizer) === null || _b2 === void 0 ? void 0 : _b2.checkFinished();
      }
      forceTokenization(lineNumber) {
        var _a2, _b2;
        const builder = new ContiguousMultilineTokensBuilder();
        (_a2 = this._tokenizer) === null || _a2 === void 0 ? void 0 : _a2.updateTokensUntilLine(builder, lineNumber);
        this.setTokens(builder.finalize());
        (_b2 = this._defaultBackgroundTokenizer) === null || _b2 === void 0 ? void 0 : _b2.checkFinished();
      }
      isCheapToTokenize(lineNumber) {
        if (!this._tokenizer) {
          return true;
        }
        return this._tokenizer.isCheapToTokenize(lineNumber);
      }
      tokenizeIfCheap(lineNumber) {
        if (this.isCheapToTokenize(lineNumber)) {
          this.forceTokenization(lineNumber);
        }
      }
      getLineTokens(lineNumber) {
        var _a2;
        const lineText = this._textModel.getLineContent(lineNumber);
        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);
        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {
          if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {
            const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);
            if (!result.equals(backgroundResult) && ((_a2 = this._debugBackgroundTokenizer.value) === null || _a2 === void 0 ? void 0 : _a2.reportMismatchingTokens)) {
              this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);
            }
          }
        }
        return result;
      }
      getTokenTypeIfInsertingCharacter(lineNumber, column, character) {
        if (!this._tokenizer) {
          return 0;
        }
        const position = this._textModel.validatePosition(new Position(lineNumber, column));
        this.forceTokenization(position.lineNumber);
        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);
      }
      tokenizeLineWithEdit(position, length, newText) {
        if (!this._tokenizer) {
          return null;
        }
        const validatedPosition = this._textModel.validatePosition(position);
        this.forceTokenization(validatedPosition.lineNumber);
        return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);
      }
      get hasTokens() {
        return this._tokens.hasTokens;
      }
    };
    AttachedViewHandler = class extends Disposable {
      get lineRanges() {
        return this._lineRanges;
      }
      constructor(_refreshTokens) {
        super();
        this._refreshTokens = _refreshTokens;
        this.runner = this._register(new RunOnceScheduler(() => this.update(), 50));
        this._computedLineRanges = [];
        this._lineRanges = [];
      }
      update() {
        if (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {
          return;
        }
        this._computedLineRanges = this._lineRanges;
        this._refreshTokens();
      }
      handleStateChange(state) {
        this._lineRanges = state.visibleLineRanges;
        if (state.stabilized) {
          this.runner.cancel();
          this.update();
        } else {
          this.runner.schedule();
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js
var ModelRawFlush, LineInjectedText, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted, ModelRawEOLChanged, ModelRawContentChangedEvent, ModelInjectedTextChangedEvent, InternalModelContentChangeEvent;
var init_textModelEvents = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js"() {
    ModelRawFlush = class {
      constructor() {
        this.changeType = 1;
      }
    };
    LineInjectedText = class _LineInjectedText {
      static applyInjectedText(lineText, injectedTexts) {
        if (!injectedTexts || injectedTexts.length === 0) {
          return lineText;
        }
        let result = "";
        let lastOriginalOffset = 0;
        for (const injectedText of injectedTexts) {
          result += lineText.substring(lastOriginalOffset, injectedText.column - 1);
          lastOriginalOffset = injectedText.column - 1;
          result += injectedText.options.content;
        }
        result += lineText.substring(lastOriginalOffset);
        return result;
      }
      static fromDecorations(decorations) {
        const result = [];
        for (const decoration of decorations) {
          if (decoration.options.before && decoration.options.before.content.length > 0) {
            result.push(new _LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0));
          }
          if (decoration.options.after && decoration.options.after.content.length > 0) {
            result.push(new _LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));
          }
        }
        result.sort((a, b) => {
          if (a.lineNumber === b.lineNumber) {
            if (a.column === b.column) {
              return a.order - b.order;
            }
            return a.column - b.column;
          }
          return a.lineNumber - b.lineNumber;
        });
        return result;
      }
      constructor(ownerId, lineNumber, column, options2, order) {
        this.ownerId = ownerId;
        this.lineNumber = lineNumber;
        this.column = column;
        this.options = options2;
        this.order = order;
      }
    };
    ModelRawLineChanged = class {
      constructor(lineNumber, detail, injectedText) {
        this.changeType = 2;
        this.lineNumber = lineNumber;
        this.detail = detail;
        this.injectedText = injectedText;
      }
    };
    ModelRawLinesDeleted = class {
      constructor(fromLineNumber, toLineNumber) {
        this.changeType = 3;
        this.fromLineNumber = fromLineNumber;
        this.toLineNumber = toLineNumber;
      }
    };
    ModelRawLinesInserted = class {
      constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {
        this.changeType = 4;
        this.injectedTexts = injectedTexts;
        this.fromLineNumber = fromLineNumber;
        this.toLineNumber = toLineNumber;
        this.detail = detail;
      }
    };
    ModelRawEOLChanged = class {
      constructor() {
        this.changeType = 5;
      }
    };
    ModelRawContentChangedEvent = class _ModelRawContentChangedEvent {
      constructor(changes, versionId, isUndoing, isRedoing) {
        this.changes = changes;
        this.versionId = versionId;
        this.isUndoing = isUndoing;
        this.isRedoing = isRedoing;
        this.resultingSelection = null;
      }
      containsEvent(type) {
        for (let i = 0, len = this.changes.length; i < len; i++) {
          const change = this.changes[i];
          if (change.changeType === type) {
            return true;
          }
        }
        return false;
      }
      static merge(a, b) {
        const changes = [].concat(a.changes).concat(b.changes);
        const versionId = b.versionId;
        const isUndoing = a.isUndoing || b.isUndoing;
        const isRedoing = a.isRedoing || b.isRedoing;
        return new _ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);
      }
    };
    ModelInjectedTextChangedEvent = class {
      constructor(changes) {
        this.changes = changes;
      }
    };
    InternalModelContentChangeEvent = class _InternalModelContentChangeEvent {
      constructor(rawContentChangedEvent, contentChangedEvent) {
        this.rawContentChangedEvent = rawContentChangedEvent;
        this.contentChangedEvent = contentChangedEvent;
      }
      merge(other) {
        const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);
        const contentChangedEvent = _InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);
        return new _InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);
      }
      static _mergeChangeEvents(a, b) {
        const changes = [].concat(a.changes).concat(b.changes);
        const eol = b.eol;
        const versionId = b.versionId;
        const isUndoing = a.isUndoing || b.isUndoing;
        const isRedoing = a.isRedoing || b.isRedoing;
        const isFlush = a.isFlush || b.isFlush;
        const isEolChange = a.isEolChange && b.isEolChange;
        return {
          changes,
          eol,
          isEolChange,
          versionId,
          isUndoing,
          isRedoing,
          isFlush
        };
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js
function createTextBufferFactory(text) {
  const builder = new PieceTreeTextBufferBuilder();
  builder.acceptChunk(text);
  return builder.finish();
}
function createTextBufferFactoryFromSnapshot(snapshot) {
  const builder = new PieceTreeTextBufferBuilder();
  let chunk;
  while (typeof (chunk = snapshot.read()) === "string") {
    builder.acceptChunk(chunk);
  }
  return builder.finish();
}
function createTextBuffer(value, defaultEOL) {
  let factory;
  if (typeof value === "string") {
    factory = createTextBufferFactory(value);
  } else if (isITextSnapshot(value)) {
    factory = createTextBufferFactoryFromSnapshot(value);
  } else {
    factory = value;
  }
  return factory.create(defaultEOL);
}
function indentOfLine(line) {
  let indent = 0;
  for (const c of line) {
    if (c === " " || c === "	") {
      indent++;
    } else {
      break;
    }
  }
  return indent;
}
function isNodeInOverviewRuler(node) {
  return node.options.overviewRuler && node.options.overviewRuler.color ? true : false;
}
function isOptionsInjectedText(options2) {
  return !!options2.after || !!options2.before;
}
function isNodeInjectedText(node) {
  return !!node.options.after || !!node.options.before;
}
function cleanClassName(className) {
  return className.replace(/[^a-z0-9\-_]/gi, " ");
}
function _normalizeOptions(options2) {
  if (options2 instanceof ModelDecorationOptions) {
    return options2;
  }
  return ModelDecorationOptions.createDynamic(options2);
}
var __decorate22, __param19, TextModel_1, MODEL_ID, LIMIT_FIND_COUNT2, LONG_LINE_BOUNDARY, TextModelSnapshot, invalidFunc, TextModel, DecorationsTrees, DecorationOptions, ModelDecorationOverviewRulerOptions, ModelDecorationGlyphMarginOptions, ModelDecorationMinimapOptions, ModelDecorationInjectedTextOptions, ModelDecorationOptions, TRACKED_RANGE_OPTIONS, DidChangeDecorationsEmitter, DidChangeContentEmitter, AttachedViews, AttachedViewImpl;
var init_textModel = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js"() {
    init_arrays();
    init_color();
    init_errors();
    init_event();
    init_lifecycle();
    init_strings();
    init_uri();
    init_eolCounter();
    init_indentation();
    init_lineRange();
    init_position();
    init_range();
    init_selection();
    init_textModelDefaults();
    init_language();
    init_languageConfigurationRegistry();
    init_model();
    init_bracketPairsImpl();
    init_colorizedBracketPairsDecorationProvider();
    init_editStack();
    init_guidesTextModelPart();
    init_indentationGuesser();
    init_intervalTree();
    init_pieceTreeTextBuffer();
    init_pieceTreeTextBufferBuilder();
    init_textModelSearch();
    init_tokenizationTextModelPart();
    init_textModelEvents();
    init_undoRedo();
    __decorate22 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param19 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    MODEL_ID = 0;
    LIMIT_FIND_COUNT2 = 999;
    LONG_LINE_BOUNDARY = 1e4;
    TextModelSnapshot = class {
      constructor(source) {
        this._source = source;
        this._eos = false;
      }
      read() {
        if (this._eos) {
          return null;
        }
        const result = [];
        let resultCnt = 0;
        let resultLength = 0;
        do {
          const tmp = this._source.read();
          if (tmp === null) {
            this._eos = true;
            if (resultCnt === 0) {
              return null;
            } else {
              return result.join("");
            }
          }
          if (tmp.length > 0) {
            result[resultCnt++] = tmp;
            resultLength += tmp.length;
          }
          if (resultLength >= 64 * 1024) {
            return result.join("");
          }
        } while (true);
      }
    };
    invalidFunc = () => {
      throw new Error(`Invalid change accessor`);
    };
    TextModel = TextModel_1 = class TextModel2 extends Disposable {
      static resolveOptions(textBuffer, options2) {
        if (options2.detectIndentation) {
          const guessedIndentation = guessIndentation(textBuffer, options2.tabSize, options2.insertSpaces);
          return new TextModelResolvedOptions({
            tabSize: guessedIndentation.tabSize,
            indentSize: "tabSize",
            // TODO@Alex: guess indentSize independent of tabSize
            insertSpaces: guessedIndentation.insertSpaces,
            trimAutoWhitespace: options2.trimAutoWhitespace,
            defaultEOL: options2.defaultEOL,
            bracketPairColorizationOptions: options2.bracketPairColorizationOptions
          });
        }
        return new TextModelResolvedOptions(options2);
      }
      get onDidChangeLanguage() {
        return this._tokenizationTextModelPart.onDidChangeLanguage;
      }
      get onDidChangeLanguageConfiguration() {
        return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration;
      }
      get onDidChangeTokens() {
        return this._tokenizationTextModelPart.onDidChangeTokens;
      }
      onDidChangeContent(listener) {
        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));
      }
      onDidChangeContentOrInjectedText(listener) {
        return combinedDisposable(this._eventEmitter.fastEvent((e) => listener(e)), this._onDidChangeInjectedText.event((e) => listener(e)));
      }
      _isDisposing() {
        return this.__isDisposing;
      }
      get tokenization() {
        return this._tokenizationTextModelPart;
      }
      get bracketPairs() {
        return this._bracketPairs;
      }
      get guides() {
        return this._guidesTextModelPart;
      }
      constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService) {
        super();
        this._undoRedoService = _undoRedoService;
        this._languageService = _languageService;
        this._languageConfigurationService = _languageConfigurationService;
        this._onWillDispose = this._register(new Emitter());
        this.onWillDispose = this._onWillDispose.event;
        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter((affectedInjectedTextLines) => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));
        this.onDidChangeDecorations = this._onDidChangeDecorations.event;
        this._onDidChangeOptions = this._register(new Emitter());
        this.onDidChangeOptions = this._onDidChangeOptions.event;
        this._onDidChangeAttached = this._register(new Emitter());
        this.onDidChangeAttached = this._onDidChangeAttached.event;
        this._onDidChangeInjectedText = this._register(new Emitter());
        this._eventEmitter = this._register(new DidChangeContentEmitter());
        this._languageSelectionListener = this._register(new MutableDisposable());
        this._deltaDecorationCallCnt = 0;
        this._attachedViews = new AttachedViews();
        MODEL_ID++;
        this.id = "$model" + MODEL_ID;
        this.isForSimpleWidget = creationOptions.isForSimpleWidget;
        if (typeof associatedResource === "undefined" || associatedResource === null) {
          this._associatedResource = URI.parse("inmemory://model/" + MODEL_ID);
        } else {
          this._associatedResource = associatedResource;
        }
        this._attachedEditorCount = 0;
        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);
        this._buffer = textBuffer;
        this._bufferDisposable = disposable;
        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);
        const languageId = typeof languageIdOrSelection === "string" ? languageIdOrSelection : languageIdOrSelection.languageId;
        if (typeof languageIdOrSelection !== "string") {
          this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));
        }
        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));
        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));
        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));
        this._tokenizationTextModelPart = new TokenizationTextModelPart(this._languageService, this._languageConfigurationService, this, this._bracketPairs, languageId, this._attachedViews);
        const bufferLineCount = this._buffer.getLineCount();
        const bufferTextLength = this._buffer.getValueLengthInRange(
          new Range2(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1),
          0
          /* model.EndOfLinePreference.TextDefined */
        );
        if (creationOptions.largeFileOptimizations) {
          this._isTooLargeForTokenization = bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD || bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD;
          this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;
        } else {
          this._isTooLargeForTokenization = false;
          this._isTooLargeForHeapOperation = false;
        }
        this._isTooLargeForSyncing = bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT;
        this._versionId = 1;
        this._alternativeVersionId = 1;
        this._initialUndoRedoSnapshot = null;
        this._isDisposed = false;
        this.__isDisposing = false;
        this._instanceId = singleLetterHash(MODEL_ID);
        this._lastDecorationId = 0;
        this._decorations = /* @__PURE__ */ Object.create(null);
        this._decorationsTree = new DecorationsTrees();
        this._commandManager = new EditStack(this, this._undoRedoService);
        this._isUndoing = false;
        this._isRedoing = false;
        this._trimAutoWhitespaceLines = null;
        this._register(this._decorationProvider.onDidChange(() => {
          this._onDidChangeDecorations.beginDeferredEmit();
          this._onDidChangeDecorations.fire();
          this._onDidChangeDecorations.endDeferredEmit();
        }));
        this._languageService.requestRichLanguageFeatures(languageId);
      }
      dispose() {
        this.__isDisposing = true;
        this._onWillDispose.fire();
        this._tokenizationTextModelPart.dispose();
        this._isDisposed = true;
        super.dispose();
        this._bufferDisposable.dispose();
        this.__isDisposing = false;
        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], "", "\n", false, false, true, true);
        emptyDisposedTextBuffer.dispose();
        this._buffer = emptyDisposedTextBuffer;
        this._bufferDisposable = Disposable.None;
      }
      _assertNotDisposed() {
        if (this._isDisposed) {
          throw new Error("Model is disposed!");
        }
      }
      _emitContentChangedEvent(rawChange, change) {
        if (this.__isDisposing) {
          return;
        }
        this._tokenizationTextModelPart.handleDidChangeContent(change);
        this._bracketPairs.handleDidChangeContent(change);
        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));
      }
      setValue(value) {
        this._assertNotDisposed();
        if (value === null || value === void 0) {
          throw illegalArgument();
        }
        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);
        this._setValueFromTextBuffer(textBuffer, disposable);
      }
      _createContentChanged2(range2, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {
        return {
          changes: [{
            range: range2,
            rangeOffset,
            rangeLength,
            text
          }],
          eol: this._buffer.getEOL(),
          isEolChange,
          versionId: this.getVersionId(),
          isUndoing,
          isRedoing,
          isFlush
        };
      }
      _setValueFromTextBuffer(textBuffer, textBufferDisposable) {
        this._assertNotDisposed();
        const oldFullModelRange = this.getFullModelRange();
        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
        const endLineNumber = this.getLineCount();
        const endColumn = this.getLineMaxColumn(endLineNumber);
        this._buffer = textBuffer;
        this._bufferDisposable.dispose();
        this._bufferDisposable = textBufferDisposable;
        this._increaseVersionId();
        this._decorations = /* @__PURE__ */ Object.create(null);
        this._decorationsTree = new DecorationsTrees();
        this._commandManager.clear();
        this._trimAutoWhitespaceLines = null;
        this._emitContentChangedEvent(new ModelRawContentChangedEvent([
          new ModelRawFlush()
        ], this._versionId, false, false), this._createContentChanged2(new Range2(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));
      }
      setEOL(eol) {
        this._assertNotDisposed();
        const newEOL = eol === 1 ? "\r\n" : "\n";
        if (this._buffer.getEOL() === newEOL) {
          return;
        }
        const oldFullModelRange = this.getFullModelRange();
        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
        const endLineNumber = this.getLineCount();
        const endColumn = this.getLineMaxColumn(endLineNumber);
        this._onBeforeEOLChange();
        this._buffer.setEOL(newEOL);
        this._increaseVersionId();
        this._onAfterEOLChange();
        this._emitContentChangedEvent(new ModelRawContentChangedEvent([
          new ModelRawEOLChanged()
        ], this._versionId, false, false), this._createContentChanged2(new Range2(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));
      }
      _onBeforeEOLChange() {
        this._decorationsTree.ensureAllNodesHaveRanges(this);
      }
      _onAfterEOLChange() {
        const versionId = this.getVersionId();
        const allDecorations = this._decorationsTree.collectNodesPostOrder();
        for (let i = 0, len = allDecorations.length; i < len; i++) {
          const node = allDecorations[i];
          const range2 = node.range;
          const delta = node.cachedAbsoluteStart - node.start;
          const startOffset = this._buffer.getOffsetAt(range2.startLineNumber, range2.startColumn);
          const endOffset = this._buffer.getOffsetAt(range2.endLineNumber, range2.endColumn);
          node.cachedAbsoluteStart = startOffset;
          node.cachedAbsoluteEnd = endOffset;
          node.cachedVersionId = versionId;
          node.start = startOffset - delta;
          node.end = endOffset - delta;
          recomputeMaxEnd(node);
        }
      }
      onBeforeAttached() {
        this._attachedEditorCount++;
        if (this._attachedEditorCount === 1) {
          this._tokenizationTextModelPart.handleDidChangeAttached();
          this._onDidChangeAttached.fire(void 0);
        }
        return this._attachedViews.attachView();
      }
      onBeforeDetached(view) {
        this._attachedEditorCount--;
        if (this._attachedEditorCount === 0) {
          this._tokenizationTextModelPart.handleDidChangeAttached();
          this._onDidChangeAttached.fire(void 0);
        }
        this._attachedViews.detachView(view);
      }
      isAttachedToEditor() {
        return this._attachedEditorCount > 0;
      }
      getAttachedEditorCount() {
        return this._attachedEditorCount;
      }
      isTooLargeForSyncing() {
        return this._isTooLargeForSyncing;
      }
      isTooLargeForTokenization() {
        return this._isTooLargeForTokenization;
      }
      isTooLargeForHeapOperation() {
        return this._isTooLargeForHeapOperation;
      }
      isDisposed() {
        return this._isDisposed;
      }
      isDominatedByLongLines() {
        this._assertNotDisposed();
        if (this.isTooLargeForTokenization()) {
          return false;
        }
        let smallLineCharCount = 0;
        let longLineCharCount = 0;
        const lineCount = this._buffer.getLineCount();
        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {
          const lineLength = this._buffer.getLineLength(lineNumber);
          if (lineLength >= LONG_LINE_BOUNDARY) {
            longLineCharCount += lineLength;
          } else {
            smallLineCharCount += lineLength;
          }
        }
        return longLineCharCount > smallLineCharCount;
      }
      get uri() {
        return this._associatedResource;
      }
      //#region Options
      getOptions() {
        this._assertNotDisposed();
        return this._options;
      }
      getFormattingOptions() {
        return {
          tabSize: this._options.indentSize,
          insertSpaces: this._options.insertSpaces
        };
      }
      updateOptions(_newOpts) {
        this._assertNotDisposed();
        const tabSize = typeof _newOpts.tabSize !== "undefined" ? _newOpts.tabSize : this._options.tabSize;
        const indentSize = typeof _newOpts.indentSize !== "undefined" ? _newOpts.indentSize : this._options.originalIndentSize;
        const insertSpaces = typeof _newOpts.insertSpaces !== "undefined" ? _newOpts.insertSpaces : this._options.insertSpaces;
        const trimAutoWhitespace = typeof _newOpts.trimAutoWhitespace !== "undefined" ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;
        const bracketPairColorizationOptions = typeof _newOpts.bracketColorizationOptions !== "undefined" ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;
        const newOpts = new TextModelResolvedOptions({
          tabSize,
          indentSize,
          insertSpaces,
          defaultEOL: this._options.defaultEOL,
          trimAutoWhitespace,
          bracketPairColorizationOptions
        });
        if (this._options.equals(newOpts)) {
          return;
        }
        const e = this._options.createChangeEvent(newOpts);
        this._options = newOpts;
        this._bracketPairs.handleDidChangeOptions(e);
        this._decorationProvider.handleDidChangeOptions(e);
        this._onDidChangeOptions.fire(e);
      }
      detectIndentation(defaultInsertSpaces, defaultTabSize) {
        this._assertNotDisposed();
        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);
        this.updateOptions({
          insertSpaces: guessedIndentation.insertSpaces,
          tabSize: guessedIndentation.tabSize,
          indentSize: guessedIndentation.tabSize
          // TODO@Alex: guess indentSize independent of tabSize
        });
      }
      normalizeIndentation(str) {
        this._assertNotDisposed();
        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);
      }
      //#endregion
      //#region Reading
      getVersionId() {
        this._assertNotDisposed();
        return this._versionId;
      }
      mightContainRTL() {
        return this._buffer.mightContainRTL();
      }
      mightContainUnusualLineTerminators() {
        return this._buffer.mightContainUnusualLineTerminators();
      }
      removeUnusualLineTerminators(selections = null) {
        const matches = this.findMatches(
          UNUSUAL_LINE_TERMINATORS.source,
          false,
          true,
          false,
          null,
          false,
          1073741824
          /* Constants.MAX_SAFE_SMALL_INTEGER */
        );
        this._buffer.resetMightContainUnusualLineTerminators();
        this.pushEditOperations(selections, matches.map((m) => ({ range: m.range, text: null })), () => null);
      }
      mightContainNonBasicASCII() {
        return this._buffer.mightContainNonBasicASCII();
      }
      getAlternativeVersionId() {
        this._assertNotDisposed();
        return this._alternativeVersionId;
      }
      getInitialUndoRedoSnapshot() {
        this._assertNotDisposed();
        return this._initialUndoRedoSnapshot;
      }
      getOffsetAt(rawPosition) {
        this._assertNotDisposed();
        const position = this._validatePosition(
          rawPosition.lineNumber,
          rawPosition.column,
          0
          /* StringOffsetValidationType.Relaxed */
        );
        return this._buffer.getOffsetAt(position.lineNumber, position.column);
      }
      getPositionAt(rawOffset) {
        this._assertNotDisposed();
        const offset = Math.min(this._buffer.getLength(), Math.max(0, rawOffset));
        return this._buffer.getPositionAt(offset);
      }
      _increaseVersionId() {
        this._versionId = this._versionId + 1;
        this._alternativeVersionId = this._versionId;
      }
      _overwriteVersionId(versionId) {
        this._versionId = versionId;
      }
      _overwriteAlternativeVersionId(newAlternativeVersionId) {
        this._alternativeVersionId = newAlternativeVersionId;
      }
      _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {
        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;
      }
      getValue(eol, preserveBOM = false) {
        this._assertNotDisposed();
        if (this.isTooLargeForHeapOperation()) {
          throw new BugIndicatingError("Operation would exceed heap memory limits");
        }
        const fullModelRange = this.getFullModelRange();
        const fullModelValue = this.getValueInRange(fullModelRange, eol);
        if (preserveBOM) {
          return this._buffer.getBOM() + fullModelValue;
        }
        return fullModelValue;
      }
      createSnapshot(preserveBOM = false) {
        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));
      }
      getValueLength(eol, preserveBOM = false) {
        this._assertNotDisposed();
        const fullModelRange = this.getFullModelRange();
        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);
        if (preserveBOM) {
          return this._buffer.getBOM().length + fullModelValue;
        }
        return fullModelValue;
      }
      getValueInRange(rawRange, eol = 0) {
        this._assertNotDisposed();
        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);
      }
      getValueLengthInRange(rawRange, eol = 0) {
        this._assertNotDisposed();
        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);
      }
      getCharacterCountInRange(rawRange, eol = 0) {
        this._assertNotDisposed();
        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);
      }
      getLineCount() {
        this._assertNotDisposed();
        return this._buffer.getLineCount();
      }
      getLineContent(lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
          throw new BugIndicatingError("Illegal value for lineNumber");
        }
        return this._buffer.getLineContent(lineNumber);
      }
      getLineLength(lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
          throw new BugIndicatingError("Illegal value for lineNumber");
        }
        return this._buffer.getLineLength(lineNumber);
      }
      getLinesContent() {
        this._assertNotDisposed();
        if (this.isTooLargeForHeapOperation()) {
          throw new BugIndicatingError("Operation would exceed heap memory limits");
        }
        return this._buffer.getLinesContent();
      }
      getEOL() {
        this._assertNotDisposed();
        return this._buffer.getEOL();
      }
      getEndOfLineSequence() {
        this._assertNotDisposed();
        return this._buffer.getEOL() === "\n" ? 0 : 1;
      }
      getLineMinColumn(lineNumber) {
        this._assertNotDisposed();
        return 1;
      }
      getLineMaxColumn(lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
          throw new BugIndicatingError("Illegal value for lineNumber");
        }
        return this._buffer.getLineLength(lineNumber) + 1;
      }
      getLineFirstNonWhitespaceColumn(lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
          throw new BugIndicatingError("Illegal value for lineNumber");
        }
        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);
      }
      getLineLastNonWhitespaceColumn(lineNumber) {
        this._assertNotDisposed();
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
          throw new BugIndicatingError("Illegal value for lineNumber");
        }
        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);
      }
      /**
       * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.
       * Will try to not allocate if possible.
       */
      _validateRangeRelaxedNoAllocations(range2) {
        const linesCount = this._buffer.getLineCount();
        const initialStartLineNumber = range2.startLineNumber;
        const initialStartColumn = range2.startColumn;
        let startLineNumber = Math.floor(typeof initialStartLineNumber === "number" && !isNaN(initialStartLineNumber) ? initialStartLineNumber : 1);
        let startColumn = Math.floor(typeof initialStartColumn === "number" && !isNaN(initialStartColumn) ? initialStartColumn : 1);
        if (startLineNumber < 1) {
          startLineNumber = 1;
          startColumn = 1;
        } else if (startLineNumber > linesCount) {
          startLineNumber = linesCount;
          startColumn = this.getLineMaxColumn(startLineNumber);
        } else {
          if (startColumn <= 1) {
            startColumn = 1;
          } else {
            const maxColumn = this.getLineMaxColumn(startLineNumber);
            if (startColumn >= maxColumn) {
              startColumn = maxColumn;
            }
          }
        }
        const initialEndLineNumber = range2.endLineNumber;
        const initialEndColumn = range2.endColumn;
        let endLineNumber = Math.floor(typeof initialEndLineNumber === "number" && !isNaN(initialEndLineNumber) ? initialEndLineNumber : 1);
        let endColumn = Math.floor(typeof initialEndColumn === "number" && !isNaN(initialEndColumn) ? initialEndColumn : 1);
        if (endLineNumber < 1) {
          endLineNumber = 1;
          endColumn = 1;
        } else if (endLineNumber > linesCount) {
          endLineNumber = linesCount;
          endColumn = this.getLineMaxColumn(endLineNumber);
        } else {
          if (endColumn <= 1) {
            endColumn = 1;
          } else {
            const maxColumn = this.getLineMaxColumn(endLineNumber);
            if (endColumn >= maxColumn) {
              endColumn = maxColumn;
            }
          }
        }
        if (initialStartLineNumber === startLineNumber && initialStartColumn === startColumn && initialEndLineNumber === endLineNumber && initialEndColumn === endColumn && range2 instanceof Range2 && !(range2 instanceof Selection)) {
          return range2;
        }
        return new Range2(startLineNumber, startColumn, endLineNumber, endColumn);
      }
      _isValidPosition(lineNumber, column, validationType) {
        if (typeof lineNumber !== "number" || typeof column !== "number") {
          return false;
        }
        if (isNaN(lineNumber) || isNaN(column)) {
          return false;
        }
        if (lineNumber < 1 || column < 1) {
          return false;
        }
        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {
          return false;
        }
        const lineCount = this._buffer.getLineCount();
        if (lineNumber > lineCount) {
          return false;
        }
        if (column === 1) {
          return true;
        }
        const maxColumn = this.getLineMaxColumn(lineNumber);
        if (column > maxColumn) {
          return false;
        }
        if (validationType === 1) {
          const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);
          if (isHighSurrogate(charCodeBefore)) {
            return false;
          }
        }
        return true;
      }
      _validatePosition(_lineNumber, _column, validationType) {
        const lineNumber = Math.floor(typeof _lineNumber === "number" && !isNaN(_lineNumber) ? _lineNumber : 1);
        const column = Math.floor(typeof _column === "number" && !isNaN(_column) ? _column : 1);
        const lineCount = this._buffer.getLineCount();
        if (lineNumber < 1) {
          return new Position(1, 1);
        }
        if (lineNumber > lineCount) {
          return new Position(lineCount, this.getLineMaxColumn(lineCount));
        }
        if (column <= 1) {
          return new Position(lineNumber, 1);
        }
        const maxColumn = this.getLineMaxColumn(lineNumber);
        if (column >= maxColumn) {
          return new Position(lineNumber, maxColumn);
        }
        if (validationType === 1) {
          const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);
          if (isHighSurrogate(charCodeBefore)) {
            return new Position(lineNumber, column - 1);
          }
        }
        return new Position(lineNumber, column);
      }
      validatePosition(position) {
        const validationType = 1;
        this._assertNotDisposed();
        if (position instanceof Position) {
          if (this._isValidPosition(position.lineNumber, position.column, validationType)) {
            return position;
          }
        }
        return this._validatePosition(position.lineNumber, position.column, validationType);
      }
      _isValidRange(range2, validationType) {
        const startLineNumber = range2.startLineNumber;
        const startColumn = range2.startColumn;
        const endLineNumber = range2.endLineNumber;
        const endColumn = range2.endColumn;
        if (!this._isValidPosition(
          startLineNumber,
          startColumn,
          0
          /* StringOffsetValidationType.Relaxed */
        )) {
          return false;
        }
        if (!this._isValidPosition(
          endLineNumber,
          endColumn,
          0
          /* StringOffsetValidationType.Relaxed */
        )) {
          return false;
        }
        if (validationType === 1) {
          const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;
          const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;
          const startInsideSurrogatePair = isHighSurrogate(charCodeBeforeStart);
          const endInsideSurrogatePair = isHighSurrogate(charCodeBeforeEnd);
          if (!startInsideSurrogatePair && !endInsideSurrogatePair) {
            return true;
          }
          return false;
        }
        return true;
      }
      validateRange(_range) {
        const validationType = 1;
        this._assertNotDisposed();
        if (_range instanceof Range2 && !(_range instanceof Selection)) {
          if (this._isValidRange(_range, validationType)) {
            return _range;
          }
        }
        const start = this._validatePosition(
          _range.startLineNumber,
          _range.startColumn,
          0
          /* StringOffsetValidationType.Relaxed */
        );
        const end = this._validatePosition(
          _range.endLineNumber,
          _range.endColumn,
          0
          /* StringOffsetValidationType.Relaxed */
        );
        const startLineNumber = start.lineNumber;
        const startColumn = start.column;
        const endLineNumber = end.lineNumber;
        const endColumn = end.column;
        if (validationType === 1) {
          const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;
          const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;
          const startInsideSurrogatePair = isHighSurrogate(charCodeBeforeStart);
          const endInsideSurrogatePair = isHighSurrogate(charCodeBeforeEnd);
          if (!startInsideSurrogatePair && !endInsideSurrogatePair) {
            return new Range2(startLineNumber, startColumn, endLineNumber, endColumn);
          }
          if (startLineNumber === endLineNumber && startColumn === endColumn) {
            return new Range2(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);
          }
          if (startInsideSurrogatePair && endInsideSurrogatePair) {
            return new Range2(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);
          }
          if (startInsideSurrogatePair) {
            return new Range2(startLineNumber, startColumn - 1, endLineNumber, endColumn);
          }
          return new Range2(startLineNumber, startColumn, endLineNumber, endColumn + 1);
        }
        return new Range2(startLineNumber, startColumn, endLineNumber, endColumn);
      }
      modifyPosition(rawPosition, offset) {
        this._assertNotDisposed();
        const candidate = this.getOffsetAt(rawPosition) + offset;
        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));
      }
      getFullModelRange() {
        this._assertNotDisposed();
        const lineCount = this.getLineCount();
        return new Range2(1, 1, lineCount, this.getLineMaxColumn(lineCount));
      }
      findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
      }
      findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators2, captureMatches, limitResultCount = LIMIT_FIND_COUNT2) {
        this._assertNotDisposed();
        let searchRanges = null;
        if (rawSearchScope !== null) {
          if (!Array.isArray(rawSearchScope)) {
            rawSearchScope = [rawSearchScope];
          }
          if (rawSearchScope.every((searchScope) => Range2.isIRange(searchScope))) {
            searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));
          }
        }
        if (searchRanges === null) {
          searchRanges = [this.getFullModelRange()];
        }
        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);
        const uniqueSearchRanges = [];
        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {
          if (Range2.areIntersecting(prev, curr)) {
            return prev.plusRange(curr);
          }
          uniqueSearchRanges.push(prev);
          return curr;
        }));
        let matchMapper;
        if (!isRegex && searchString.indexOf("\n") < 0) {
          const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators2);
          const searchData = searchParams.parseSearchRequest();
          if (!searchData) {
            return [];
          }
          matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
        } else {
          matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators2), searchRange, captureMatches, limitResultCount);
        }
        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);
      }
      findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators2, captureMatches) {
        this._assertNotDisposed();
        const searchStart = this.validatePosition(rawSearchStart);
        if (!isRegex && searchString.indexOf("\n") < 0) {
          const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators2);
          const searchData = searchParams.parseSearchRequest();
          if (!searchData) {
            return null;
          }
          const lineCount = this.getLineCount();
          let searchRange = new Range2(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));
          let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);
          TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators2), searchStart, captureMatches);
          if (ret.length > 0) {
            return ret[0];
          }
          searchRange = new Range2(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));
          ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);
          if (ret.length > 0) {
            return ret[0];
          }
          return null;
        }
        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators2), searchStart, captureMatches);
      }
      findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators2, captureMatches) {
        this._assertNotDisposed();
        const searchStart = this.validatePosition(rawSearchStart);
        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators2), searchStart, captureMatches);
      }
      //#endregion
      //#region Editing
      pushStackElement() {
        this._commandManager.pushStackElement();
      }
      popStackElement() {
        this._commandManager.popStackElement();
      }
      pushEOL(eol) {
        const currentEOL = this.getEOL() === "\n" ? 0 : 1;
        if (currentEOL === eol) {
          return;
        }
        try {
          this._onDidChangeDecorations.beginDeferredEmit();
          this._eventEmitter.beginDeferredEmit();
          if (this._initialUndoRedoSnapshot === null) {
            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);
          }
          this._commandManager.pushEOL(eol);
        } finally {
          this._eventEmitter.endDeferredEmit();
          this._onDidChangeDecorations.endDeferredEmit();
        }
      }
      _validateEditOperation(rawOperation) {
        if (rawOperation instanceof ValidAnnotatedEditOperation) {
          return rawOperation;
        }
        return new ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);
      }
      _validateEditOperations(rawOperations) {
        const result = [];
        for (let i = 0, len = rawOperations.length; i < len; i++) {
          result[i] = this._validateEditOperation(rawOperations[i]);
        }
        return result;
      }
      pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {
        try {
          this._onDidChangeDecorations.beginDeferredEmit();
          this._eventEmitter.beginDeferredEmit();
          return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);
        } finally {
          this._eventEmitter.endDeferredEmit();
          this._onDidChangeDecorations.endDeferredEmit();
        }
      }
      _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {
        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
          const incomingEdits = editOperations.map((op) => {
            return {
              range: this.validateRange(op.range),
              text: op.text
            };
          });
          let editsAreNearCursors = true;
          if (beforeCursorState) {
            for (let i = 0, len = beforeCursorState.length; i < len; i++) {
              const sel = beforeCursorState[i];
              let foundEditNearSel = false;
              for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
                const editRange = incomingEdits[j].range;
                const selIsAbove = editRange.startLineNumber > sel.endLineNumber;
                const selIsBelow = sel.startLineNumber > editRange.endLineNumber;
                if (!selIsAbove && !selIsBelow) {
                  foundEditNearSel = true;
                  break;
                }
              }
              if (!foundEditNearSel) {
                editsAreNearCursors = false;
                break;
              }
            }
          }
          if (editsAreNearCursors) {
            for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {
              const trimLineNumber = this._trimAutoWhitespaceLines[i];
              const maxLineColumn = this.getLineMaxColumn(trimLineNumber);
              let allowTrimLine = true;
              for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
                const editRange = incomingEdits[j].range;
                const editText = incomingEdits[j].text;
                if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {
                  continue;
                }
                if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === "\n") {
                  continue;
                }
                if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1 && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === "\n") {
                  continue;
                }
                allowTrimLine = false;
                break;
              }
              if (allowTrimLine) {
                const trimRange = new Range2(trimLineNumber, 1, trimLineNumber, maxLineColumn);
                editOperations.push(new ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));
              }
            }
          }
          this._trimAutoWhitespaceLines = null;
        }
        if (this._initialUndoRedoSnapshot === null) {
          this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);
        }
        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);
      }
      _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {
        const edits = changes.map((change) => {
          const rangeStart = this.getPositionAt(change.newPosition);
          const rangeEnd = this.getPositionAt(change.newEnd);
          return {
            range: new Range2(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),
            text: change.oldText
          };
        });
        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);
      }
      _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {
        const edits = changes.map((change) => {
          const rangeStart = this.getPositionAt(change.oldPosition);
          const rangeEnd = this.getPositionAt(change.oldEnd);
          return {
            range: new Range2(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),
            text: change.newText
          };
        });
        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);
      }
      _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {
        try {
          this._onDidChangeDecorations.beginDeferredEmit();
          this._eventEmitter.beginDeferredEmit();
          this._isUndoing = isUndoing;
          this._isRedoing = isRedoing;
          this.applyEdits(edits, false);
          this.setEOL(eol);
          this._overwriteAlternativeVersionId(resultingAlternativeVersionId);
        } finally {
          this._isUndoing = false;
          this._isRedoing = false;
          this._eventEmitter.endDeferredEmit(resultingSelection);
          this._onDidChangeDecorations.endDeferredEmit();
        }
      }
      applyEdits(rawOperations, computeUndoEdits = false) {
        try {
          this._onDidChangeDecorations.beginDeferredEmit();
          this._eventEmitter.beginDeferredEmit();
          const operations = this._validateEditOperations(rawOperations);
          return this._doApplyEdits(operations, computeUndoEdits);
        } finally {
          this._eventEmitter.endDeferredEmit();
          this._onDidChangeDecorations.endDeferredEmit();
        }
      }
      _doApplyEdits(rawOperations, computeUndoEdits) {
        const oldLineCount = this._buffer.getLineCount();
        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);
        const newLineCount = this._buffer.getLineCount();
        const contentChanges = result.changes;
        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;
        if (contentChanges.length !== 0) {
          for (let i = 0, len = contentChanges.length; i < len; i++) {
            const change = contentChanges[i];
            this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);
          }
          const rawContentChanges = [];
          this._increaseVersionId();
          let lineCount = oldLineCount;
          for (let i = 0, len = contentChanges.length; i < len; i++) {
            const change = contentChanges[i];
            const [eolCount] = countEOL(change.text);
            this._onDidChangeDecorations.fire();
            const startLineNumber = change.range.startLineNumber;
            const endLineNumber = change.range.endLineNumber;
            const deletingLinesCnt = endLineNumber - startLineNumber;
            const insertingLinesCnt = eolCount;
            const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);
            const changeLineCountDelta = insertingLinesCnt - deletingLinesCnt;
            const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;
            const firstEditLineNumber = currentEditStartLineNumber;
            const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;
            const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);
            const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);
            const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);
            for (let j = editingLinesCnt; j >= 0; j--) {
              const editLineNumber = startLineNumber + j;
              const currentEditLineNumber = currentEditStartLineNumber + j;
              injectedTextInEditedRangeQueue.takeFromEndWhile((r) => r.lineNumber > currentEditLineNumber);
              const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile((r) => r.lineNumber === currentEditLineNumber);
              rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));
            }
            if (editingLinesCnt < deletingLinesCnt) {
              const spliceStartLineNumber = startLineNumber + editingLinesCnt;
              rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));
            }
            if (editingLinesCnt < insertingLinesCnt) {
              const injectedTextInEditedRangeQueue2 = new ArrayQueue(injectedTextInEditedRange);
              const spliceLineNumber = startLineNumber + editingLinesCnt;
              const cnt = insertingLinesCnt - editingLinesCnt;
              const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;
              const injectedTexts = [];
              const newLines = [];
              for (let i2 = 0; i2 < cnt; i2++) {
                const lineNumber = fromLineNumber + i2;
                newLines[i2] = this.getLineContent(lineNumber);
                injectedTextInEditedRangeQueue2.takeWhile((r) => r.lineNumber < lineNumber);
                injectedTexts[i2] = injectedTextInEditedRangeQueue2.takeWhile((r) => r.lineNumber === lineNumber);
              }
              rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));
            }
            lineCount += changeLineCountDelta;
          }
          this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {
            changes: contentChanges,
            eol: this._buffer.getEOL(),
            isEolChange: false,
            versionId: this.getVersionId(),
            isUndoing: this._isUndoing,
            isRedoing: this._isRedoing,
            isFlush: false
          });
        }
        return result.reverseEdits === null ? void 0 : result.reverseEdits;
      }
      undo() {
        return this._undoRedoService.undo(this.uri);
      }
      canUndo() {
        return this._undoRedoService.canUndo(this.uri);
      }
      redo() {
        return this._undoRedoService.redo(this.uri);
      }
      canRedo() {
        return this._undoRedoService.canRedo(this.uri);
      }
      //#endregion
      //#region Decorations
      handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {
        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {
          return;
        }
        const affectedLines = Array.from(affectedInjectedTextLines);
        const lineChangeEvents = affectedLines.map((lineNumber) => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));
        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));
      }
      changeDecorations(callback, ownerId = 0) {
        this._assertNotDisposed();
        try {
          this._onDidChangeDecorations.beginDeferredEmit();
          return this._changeDecorations(ownerId, callback);
        } finally {
          this._onDidChangeDecorations.endDeferredEmit();
        }
      }
      _changeDecorations(ownerId, callback) {
        const changeAccessor = {
          addDecoration: (range2, options2) => {
            return this._deltaDecorationsImpl(ownerId, [], [{ range: range2, options: options2 }])[0];
          },
          changeDecoration: (id, newRange) => {
            this._changeDecorationImpl(id, newRange);
          },
          changeDecorationOptions: (id, options2) => {
            this._changeDecorationOptionsImpl(id, _normalizeOptions(options2));
          },
          removeDecoration: (id) => {
            this._deltaDecorationsImpl(ownerId, [id], []);
          },
          deltaDecorations: (oldDecorations, newDecorations) => {
            if (oldDecorations.length === 0 && newDecorations.length === 0) {
              return [];
            }
            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);
          }
        };
        let result = null;
        try {
          result = callback(changeAccessor);
        } catch (e) {
          onUnexpectedError(e);
        }
        changeAccessor.addDecoration = invalidFunc;
        changeAccessor.changeDecoration = invalidFunc;
        changeAccessor.changeDecorationOptions = invalidFunc;
        changeAccessor.removeDecoration = invalidFunc;
        changeAccessor.deltaDecorations = invalidFunc;
        return result;
      }
      deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {
        this._assertNotDisposed();
        if (!oldDecorations) {
          oldDecorations = [];
        }
        if (oldDecorations.length === 0 && newDecorations.length === 0) {
          return [];
        }
        try {
          this._deltaDecorationCallCnt++;
          if (this._deltaDecorationCallCnt > 1) {
            console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);
            onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));
          }
          this._onDidChangeDecorations.beginDeferredEmit();
          return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);
        } finally {
          this._onDidChangeDecorations.endDeferredEmit();
          this._deltaDecorationCallCnt--;
        }
      }
      _getTrackedRange(id) {
        return this.getDecorationRange(id);
      }
      _setTrackedRange(id, newRange, newStickiness) {
        const node = id ? this._decorations[id] : null;
        if (!node) {
          if (!newRange) {
            return null;
          }
          return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];
        }
        if (!newRange) {
          this._decorationsTree.delete(node);
          delete this._decorations[node.id];
          return null;
        }
        const range2 = this._validateRangeRelaxedNoAllocations(newRange);
        const startOffset = this._buffer.getOffsetAt(range2.startLineNumber, range2.startColumn);
        const endOffset = this._buffer.getOffsetAt(range2.endLineNumber, range2.endColumn);
        this._decorationsTree.delete(node);
        node.reset(this.getVersionId(), startOffset, endOffset, range2);
        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);
        this._decorationsTree.insert(node);
        return node.id;
      }
      removeAllDecorationsWithOwnerId(ownerId) {
        if (this._isDisposed) {
          return;
        }
        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);
        for (let i = 0, len = nodes.length; i < len; i++) {
          const node = nodes[i];
          this._decorationsTree.delete(node);
          delete this._decorations[node.id];
        }
      }
      getDecorationOptions(decorationId) {
        const node = this._decorations[decorationId];
        if (!node) {
          return null;
        }
        return node.options;
      }
      getDecorationRange(decorationId) {
        const node = this._decorations[decorationId];
        if (!node) {
          return null;
        }
        return this._decorationsTree.getNodeRange(this, node);
      }
      getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
          return [];
        }
        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);
      }
      getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {
        const lineCount = this.getLineCount();
        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));
        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));
        const endColumn = this.getLineMaxColumn(endLineNumber);
        const range2 = new Range2(startLineNumber, 1, endLineNumber, endColumn);
        const decorations = this._getDecorationsInRange(range2, ownerId, filterOutValidation, onlyMarginDecorations);
        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range2, ownerId, filterOutValidation));
        return decorations;
      }
      getDecorationsInRange(range2, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {
        const validatedRange = this.validateRange(range2);
        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);
        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));
        return decorations;
      }
      getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {
        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);
      }
      getInjectedTextDecorations(ownerId = 0) {
        return this._decorationsTree.getAllInjectedText(this, ownerId);
      }
      _getInjectedTextInLine(lineNumber) {
        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);
        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);
        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);
        return LineInjectedText.fromDecorations(result).filter((t) => t.lineNumber === lineNumber);
      }
      getAllDecorations(ownerId = 0, filterOutValidation = false) {
        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);
        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));
        return result;
      }
      getAllMarginDecorations(ownerId = 0) {
        return this._decorationsTree.getAll(this, ownerId, false, false, true);
      }
      _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {
        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);
        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);
        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);
      }
      getRangeAt(start, end) {
        return this._buffer.getRangeAt(start, end - start);
      }
      _changeDecorationImpl(decorationId, _range) {
        const node = this._decorations[decorationId];
        if (!node) {
          return;
        }
        if (node.options.after) {
          const oldRange = this.getDecorationRange(decorationId);
          this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);
        }
        if (node.options.before) {
          const oldRange = this.getDecorationRange(decorationId);
          this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);
        }
        const range2 = this._validateRangeRelaxedNoAllocations(_range);
        const startOffset = this._buffer.getOffsetAt(range2.startLineNumber, range2.startColumn);
        const endOffset = this._buffer.getOffsetAt(range2.endLineNumber, range2.endColumn);
        this._decorationsTree.delete(node);
        node.reset(this.getVersionId(), startOffset, endOffset, range2);
        this._decorationsTree.insert(node);
        this._onDidChangeDecorations.checkAffectedAndFire(node.options);
        if (node.options.after) {
          this._onDidChangeDecorations.recordLineAffectedByInjectedText(range2.endLineNumber);
        }
        if (node.options.before) {
          this._onDidChangeDecorations.recordLineAffectedByInjectedText(range2.startLineNumber);
        }
      }
      _changeDecorationOptionsImpl(decorationId, options2) {
        const node = this._decorations[decorationId];
        if (!node) {
          return;
        }
        const nodeWasInOverviewRuler = node.options.overviewRuler && node.options.overviewRuler.color ? true : false;
        const nodeIsInOverviewRuler = options2.overviewRuler && options2.overviewRuler.color ? true : false;
        this._onDidChangeDecorations.checkAffectedAndFire(node.options);
        this._onDidChangeDecorations.checkAffectedAndFire(options2);
        if (node.options.after || options2.after) {
          const nodeRange = this._decorationsTree.getNodeRange(this, node);
          this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);
        }
        if (node.options.before || options2.before) {
          const nodeRange = this._decorationsTree.getNodeRange(this, node);
          this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);
        }
        const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;
        const changedWhetherInjectedText = isOptionsInjectedText(options2) !== isNodeInjectedText(node);
        if (movedInOverviewRuler || changedWhetherInjectedText) {
          this._decorationsTree.delete(node);
          node.setOptions(options2);
          this._decorationsTree.insert(node);
        } else {
          node.setOptions(options2);
        }
      }
      _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {
        const versionId = this.getVersionId();
        const oldDecorationsLen = oldDecorationsIds.length;
        let oldDecorationIndex = 0;
        const newDecorationsLen = newDecorations.length;
        let newDecorationIndex = 0;
        this._onDidChangeDecorations.beginDeferredEmit();
        try {
          const result = new Array(newDecorationsLen);
          while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {
            let node = null;
            if (oldDecorationIndex < oldDecorationsLen) {
              do {
                node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];
              } while (!node && oldDecorationIndex < oldDecorationsLen);
              if (node) {
                if (node.options.after) {
                  const nodeRange = this._decorationsTree.getNodeRange(this, node);
                  this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);
                }
                if (node.options.before) {
                  const nodeRange = this._decorationsTree.getNodeRange(this, node);
                  this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);
                }
                this._decorationsTree.delete(node);
                if (!suppressEvents) {
                  this._onDidChangeDecorations.checkAffectedAndFire(node.options);
                }
              }
            }
            if (newDecorationIndex < newDecorationsLen) {
              if (!node) {
                const internalDecorationId = ++this._lastDecorationId;
                const decorationId = `${this._instanceId};${internalDecorationId}`;
                node = new IntervalNode(decorationId, 0, 0);
                this._decorations[decorationId] = node;
              }
              const newDecoration = newDecorations[newDecorationIndex];
              const range2 = this._validateRangeRelaxedNoAllocations(newDecoration.range);
              const options2 = _normalizeOptions(newDecoration.options);
              const startOffset = this._buffer.getOffsetAt(range2.startLineNumber, range2.startColumn);
              const endOffset = this._buffer.getOffsetAt(range2.endLineNumber, range2.endColumn);
              node.ownerId = ownerId;
              node.reset(versionId, startOffset, endOffset, range2);
              node.setOptions(options2);
              if (node.options.after) {
                this._onDidChangeDecorations.recordLineAffectedByInjectedText(range2.endLineNumber);
              }
              if (node.options.before) {
                this._onDidChangeDecorations.recordLineAffectedByInjectedText(range2.startLineNumber);
              }
              if (!suppressEvents) {
                this._onDidChangeDecorations.checkAffectedAndFire(options2);
              }
              this._decorationsTree.insert(node);
              result[newDecorationIndex] = node.id;
              newDecorationIndex++;
            } else {
              if (node) {
                delete this._decorations[node.id];
              }
            }
          }
          return result;
        } finally {
          this._onDidChangeDecorations.endDeferredEmit();
        }
      }
      //#endregion
      //#region Tokenization
      // TODO move them to the tokenization part.
      getLanguageId() {
        return this.tokenization.getLanguageId();
      }
      setLanguage(languageIdOrSelection, source) {
        if (typeof languageIdOrSelection === "string") {
          this._languageSelectionListener.clear();
          this._setLanguage(languageIdOrSelection, source);
        } else {
          this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));
          this._setLanguage(languageIdOrSelection.languageId, source);
        }
      }
      _setLanguage(languageId, source) {
        this.tokenization.setLanguageId(languageId, source);
        this._languageService.requestRichLanguageFeatures(languageId);
      }
      getLanguageIdAtPosition(lineNumber, column) {
        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);
      }
      getWordAtPosition(position) {
        return this._tokenizationTextModelPart.getWordAtPosition(position);
      }
      getWordUntilPosition(position) {
        return this._tokenizationTextModelPart.getWordUntilPosition(position);
      }
      //#endregion
      normalizePosition(position, affinity) {
        return position;
      }
      /**
       * Gets the column at which indentation stops at a given line.
       * @internal
      */
      getLineIndentColumn(lineNumber) {
        return indentOfLine(this.getLineContent(lineNumber)) + 1;
      }
    };
    TextModel._MODEL_SYNC_LIMIT = 50 * 1024 * 1024;
    TextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024;
    TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1e3;
    TextModel.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024;
    TextModel.DEFAULT_CREATION_OPTIONS = {
      isForSimpleWidget: false,
      tabSize: EDITOR_MODEL_DEFAULTS.tabSize,
      indentSize: EDITOR_MODEL_DEFAULTS.indentSize,
      insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,
      detectIndentation: false,
      defaultEOL: 1,
      trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,
      largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,
      bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions
    };
    TextModel = TextModel_1 = __decorate22([
      __param19(4, IUndoRedoService),
      __param19(5, ILanguageService),
      __param19(6, ILanguageConfigurationService)
    ], TextModel);
    DecorationsTrees = class {
      constructor() {
        this._decorationsTree0 = new IntervalTree();
        this._decorationsTree1 = new IntervalTree();
        this._injectedTextDecorationsTree = new IntervalTree();
      }
      ensureAllNodesHaveRanges(host) {
        this.getAll(host, 0, false, false, false);
      }
      _ensureNodesHaveRanges(host, nodes) {
        for (const node of nodes) {
          if (node.range === null) {
            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);
          }
        }
        return nodes;
      }
      getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {
        const versionId = host.getVersionId();
        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);
        return this._ensureNodesHaveRanges(host, result);
      }
      _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {
        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
        return r0.concat(r1).concat(r2);
      }
      getInjectedTextInInterval(host, start, end, filterOwnerId) {
        const versionId = host.getVersionId();
        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);
        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());
      }
      getAllInjectedText(host, filterOwnerId) {
        const versionId = host.getVersionId();
        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);
        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());
      }
      getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {
        const versionId = host.getVersionId();
        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);
        return this._ensureNodesHaveRanges(host, result);
      }
      _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {
        if (overviewRulerOnly) {
          return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
        } else {
          const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
          const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
          const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);
          return r0.concat(r1).concat(r2);
        }
      }
      collectNodesFromOwner(ownerId) {
        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);
        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);
        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);
        return r0.concat(r1).concat(r2);
      }
      collectNodesPostOrder() {
        const r0 = this._decorationsTree0.collectNodesPostOrder();
        const r1 = this._decorationsTree1.collectNodesPostOrder();
        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();
        return r0.concat(r1).concat(r2);
      }
      insert(node) {
        if (isNodeInjectedText(node)) {
          this._injectedTextDecorationsTree.insert(node);
        } else if (isNodeInOverviewRuler(node)) {
          this._decorationsTree1.insert(node);
        } else {
          this._decorationsTree0.insert(node);
        }
      }
      delete(node) {
        if (isNodeInjectedText(node)) {
          this._injectedTextDecorationsTree.delete(node);
        } else if (isNodeInOverviewRuler(node)) {
          this._decorationsTree1.delete(node);
        } else {
          this._decorationsTree0.delete(node);
        }
      }
      getNodeRange(host, node) {
        const versionId = host.getVersionId();
        if (node.cachedVersionId !== versionId) {
          this._resolveNode(node, versionId);
        }
        if (node.range === null) {
          node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);
        }
        return node.range;
      }
      _resolveNode(node, cachedVersionId) {
        if (isNodeInjectedText(node)) {
          this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);
        } else if (isNodeInOverviewRuler(node)) {
          this._decorationsTree1.resolveNode(node, cachedVersionId);
        } else {
          this._decorationsTree0.resolveNode(node, cachedVersionId);
        }
      }
      acceptReplace(offset, length, textLength, forceMoveMarkers) {
        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);
        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);
        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);
      }
    };
    DecorationOptions = class {
      constructor(options2) {
        this.color = options2.color || "";
        this.darkColor = options2.darkColor || "";
      }
    };
    ModelDecorationOverviewRulerOptions = class extends DecorationOptions {
      constructor(options2) {
        super(options2);
        this._resolvedColor = null;
        this.position = typeof options2.position === "number" ? options2.position : OverviewRulerLane.Center;
      }
      getColor(theme) {
        if (!this._resolvedColor) {
          if (theme.type !== "light" && this.darkColor) {
            this._resolvedColor = this._resolveColor(this.darkColor, theme);
          } else {
            this._resolvedColor = this._resolveColor(this.color, theme);
          }
        }
        return this._resolvedColor;
      }
      invalidateCachedColor() {
        this._resolvedColor = null;
      }
      _resolveColor(color, theme) {
        if (typeof color === "string") {
          return color;
        }
        const c = color ? theme.getColor(color.id) : null;
        if (!c) {
          return "";
        }
        return c.toString();
      }
    };
    ModelDecorationGlyphMarginOptions = class {
      constructor(options2) {
        var _a2;
        this.position = (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.position) !== null && _a2 !== void 0 ? _a2 : GlyphMarginLane.Center;
        this.persistLane = options2 === null || options2 === void 0 ? void 0 : options2.persistLane;
      }
    };
    ModelDecorationMinimapOptions = class extends DecorationOptions {
      constructor(options2) {
        super(options2);
        this.position = options2.position;
      }
      getColor(theme) {
        if (!this._resolvedColor) {
          if (theme.type !== "light" && this.darkColor) {
            this._resolvedColor = this._resolveColor(this.darkColor, theme);
          } else {
            this._resolvedColor = this._resolveColor(this.color, theme);
          }
        }
        return this._resolvedColor;
      }
      invalidateCachedColor() {
        this._resolvedColor = void 0;
      }
      _resolveColor(color, theme) {
        if (typeof color === "string") {
          return Color.fromHex(color);
        }
        return theme.getColor(color.id);
      }
    };
    ModelDecorationInjectedTextOptions = class _ModelDecorationInjectedTextOptions {
      static from(options2) {
        if (options2 instanceof _ModelDecorationInjectedTextOptions) {
          return options2;
        }
        return new _ModelDecorationInjectedTextOptions(options2);
      }
      constructor(options2) {
        this.content = options2.content || "";
        this.inlineClassName = options2.inlineClassName || null;
        this.inlineClassNameAffectsLetterSpacing = options2.inlineClassNameAffectsLetterSpacing || false;
        this.attachedData = options2.attachedData || null;
        this.cursorStops = options2.cursorStops || null;
      }
    };
    ModelDecorationOptions = class _ModelDecorationOptions {
      static register(options2) {
        return new _ModelDecorationOptions(options2);
      }
      static createDynamic(options2) {
        return new _ModelDecorationOptions(options2);
      }
      constructor(options2) {
        var _a2, _b2, _c, _d, _e, _f;
        this.description = options2.description;
        this.blockClassName = options2.blockClassName ? cleanClassName(options2.blockClassName) : null;
        this.blockDoesNotCollapse = (_a2 = options2.blockDoesNotCollapse) !== null && _a2 !== void 0 ? _a2 : null;
        this.blockIsAfterEnd = (_b2 = options2.blockIsAfterEnd) !== null && _b2 !== void 0 ? _b2 : null;
        this.blockPadding = (_c = options2.blockPadding) !== null && _c !== void 0 ? _c : null;
        this.stickiness = options2.stickiness || 0;
        this.zIndex = options2.zIndex || 0;
        this.className = options2.className ? cleanClassName(options2.className) : null;
        this.shouldFillLineOnLineBreak = (_d = options2.shouldFillLineOnLineBreak) !== null && _d !== void 0 ? _d : null;
        this.hoverMessage = options2.hoverMessage || null;
        this.glyphMarginHoverMessage = options2.glyphMarginHoverMessage || null;
        this.lineNumberHoverMessage = options2.lineNumberHoverMessage || null;
        this.isWholeLine = options2.isWholeLine || false;
        this.showIfCollapsed = options2.showIfCollapsed || false;
        this.collapseOnReplaceEdit = options2.collapseOnReplaceEdit || false;
        this.overviewRuler = options2.overviewRuler ? new ModelDecorationOverviewRulerOptions(options2.overviewRuler) : null;
        this.minimap = options2.minimap ? new ModelDecorationMinimapOptions(options2.minimap) : null;
        this.glyphMargin = options2.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options2.glyphMargin) : null;
        this.glyphMarginClassName = options2.glyphMarginClassName ? cleanClassName(options2.glyphMarginClassName) : null;
        this.linesDecorationsClassName = options2.linesDecorationsClassName ? cleanClassName(options2.linesDecorationsClassName) : null;
        this.lineNumberClassName = options2.lineNumberClassName ? cleanClassName(options2.lineNumberClassName) : null;
        this.linesDecorationsTooltip = options2.linesDecorationsTooltip ? htmlAttributeEncodeValue(options2.linesDecorationsTooltip) : null;
        this.firstLineDecorationClassName = options2.firstLineDecorationClassName ? cleanClassName(options2.firstLineDecorationClassName) : null;
        this.marginClassName = options2.marginClassName ? cleanClassName(options2.marginClassName) : null;
        this.inlineClassName = options2.inlineClassName ? cleanClassName(options2.inlineClassName) : null;
        this.inlineClassNameAffectsLetterSpacing = options2.inlineClassNameAffectsLetterSpacing || false;
        this.beforeContentClassName = options2.beforeContentClassName ? cleanClassName(options2.beforeContentClassName) : null;
        this.afterContentClassName = options2.afterContentClassName ? cleanClassName(options2.afterContentClassName) : null;
        this.after = options2.after ? ModelDecorationInjectedTextOptions.from(options2.after) : null;
        this.before = options2.before ? ModelDecorationInjectedTextOptions.from(options2.before) : null;
        this.hideInCommentTokens = (_e = options2.hideInCommentTokens) !== null && _e !== void 0 ? _e : false;
        this.hideInStringTokens = (_f = options2.hideInStringTokens) !== null && _f !== void 0 ? _f : false;
      }
    };
    ModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: "empty" });
    TRACKED_RANGE_OPTIONS = [
      ModelDecorationOptions.register({
        description: "tracked-range-always-grows-when-typing-at-edges",
        stickiness: 0
        /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
      }),
      ModelDecorationOptions.register({
        description: "tracked-range-never-grows-when-typing-at-edges",
        stickiness: 1
        /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
      }),
      ModelDecorationOptions.register({
        description: "tracked-range-grows-only-when-typing-before",
        stickiness: 2
        /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */
      }),
      ModelDecorationOptions.register({
        description: "tracked-range-grows-only-when-typing-after",
        stickiness: 3
        /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */
      })
    ];
    DidChangeDecorationsEmitter = class extends Disposable {
      constructor(handleBeforeFire) {
        super();
        this.handleBeforeFire = handleBeforeFire;
        this._actual = this._register(new Emitter());
        this.event = this._actual.event;
        this._affectedInjectedTextLines = null;
        this._deferredCnt = 0;
        this._shouldFireDeferred = false;
        this._affectsMinimap = false;
        this._affectsOverviewRuler = false;
        this._affectsGlyphMargin = false;
        this._affectsLineNumber = false;
      }
      beginDeferredEmit() {
        this._deferredCnt++;
      }
      endDeferredEmit() {
        var _a2;
        this._deferredCnt--;
        if (this._deferredCnt === 0) {
          if (this._shouldFireDeferred) {
            this.doFire();
          }
          (_a2 = this._affectedInjectedTextLines) === null || _a2 === void 0 ? void 0 : _a2.clear();
          this._affectedInjectedTextLines = null;
        }
      }
      recordLineAffectedByInjectedText(lineNumber) {
        if (!this._affectedInjectedTextLines) {
          this._affectedInjectedTextLines = /* @__PURE__ */ new Set();
        }
        this._affectedInjectedTextLines.add(lineNumber);
      }
      checkAffectedAndFire(options2) {
        var _a2, _b2;
        this._affectsMinimap || (this._affectsMinimap = !!((_a2 = options2.minimap) === null || _a2 === void 0 ? void 0 : _a2.position));
        this._affectsOverviewRuler || (this._affectsOverviewRuler = !!((_b2 = options2.overviewRuler) === null || _b2 === void 0 ? void 0 : _b2.color));
        this._affectsGlyphMargin || (this._affectsGlyphMargin = !!options2.glyphMarginClassName);
        this._affectsLineNumber || (this._affectsLineNumber = !!options2.lineNumberClassName);
        this.tryFire();
      }
      fire() {
        this._affectsMinimap = true;
        this._affectsOverviewRuler = true;
        this._affectsGlyphMargin = true;
        this.tryFire();
      }
      tryFire() {
        if (this._deferredCnt === 0) {
          this.doFire();
        } else {
          this._shouldFireDeferred = true;
        }
      }
      doFire() {
        this.handleBeforeFire(this._affectedInjectedTextLines);
        const event = {
          affectsMinimap: this._affectsMinimap,
          affectsOverviewRuler: this._affectsOverviewRuler,
          affectsGlyphMargin: this._affectsGlyphMargin,
          affectsLineNumber: this._affectsLineNumber
        };
        this._shouldFireDeferred = false;
        this._affectsMinimap = false;
        this._affectsOverviewRuler = false;
        this._affectsGlyphMargin = false;
        this._actual.fire(event);
      }
    };
    DidChangeContentEmitter = class extends Disposable {
      constructor() {
        super();
        this._fastEmitter = this._register(new Emitter());
        this.fastEvent = this._fastEmitter.event;
        this._slowEmitter = this._register(new Emitter());
        this.slowEvent = this._slowEmitter.event;
        this._deferredCnt = 0;
        this._deferredEvent = null;
      }
      beginDeferredEmit() {
        this._deferredCnt++;
      }
      endDeferredEmit(resultingSelection = null) {
        this._deferredCnt--;
        if (this._deferredCnt === 0) {
          if (this._deferredEvent !== null) {
            this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;
            const e = this._deferredEvent;
            this._deferredEvent = null;
            this._fastEmitter.fire(e);
            this._slowEmitter.fire(e);
          }
        }
      }
      fire(e) {
        if (this._deferredCnt > 0) {
          if (this._deferredEvent) {
            this._deferredEvent = this._deferredEvent.merge(e);
          } else {
            this._deferredEvent = e;
          }
          return;
        }
        this._fastEmitter.fire(e);
        this._slowEmitter.fire(e);
      }
    };
    AttachedViews = class {
      constructor() {
        this._onDidChangeVisibleRanges = new Emitter();
        this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;
        this._views = /* @__PURE__ */ new Set();
      }
      attachView() {
        const view = new AttachedViewImpl((state) => {
          this._onDidChangeVisibleRanges.fire({ view, state });
        });
        this._views.add(view);
        return view;
      }
      detachView(view) {
        this._views.delete(view);
        this._onDidChangeVisibleRanges.fire({ view, state: void 0 });
      }
    };
    AttachedViewImpl = class {
      constructor(handleStateChange) {
        this.handleStateChange = handleStateChange;
      }
      setVisibleLines(visibleLines, stabilized) {
        const visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));
        this.handleStateChange({ visibleLineRanges, stabilized });
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/browser/editorExtensions.js
function registerModelAndPositionCommand(id, handler) {
  CommandsRegistry.registerCommand(id, function(accessor, ...args) {
    const instaService = accessor.get(IInstantiationService);
    const [resource, position] = args;
    assertType(URI.isUri(resource));
    assertType(Position.isIPosition(position));
    const model = accessor.get(IModelService).getModel(resource);
    if (model) {
      const editorPosition = Position.lift(position);
      return instaService.invokeFunction(handler, model, editorPosition, ...args.slice(2));
    }
    return accessor.get(ITextModelService).createModelReference(resource).then((reference) => {
      return new Promise((resolve2, reject) => {
        try {
          const result = instaService.invokeFunction(handler, reference.object.textEditorModel, Position.lift(position), args.slice(2));
          resolve2(result);
        } catch (err) {
          reject(err);
        }
      }).finally(() => {
        reference.dispose();
      });
    });
  });
}
function registerEditorCommand(editorCommand) {
  EditorContributionRegistry.INSTANCE.registerEditorCommand(editorCommand);
  return editorCommand;
}
function registerEditorAction(ctor) {
  const action = new ctor();
  EditorContributionRegistry.INSTANCE.registerEditorAction(action);
  return action;
}
function registerMultiEditorAction(action) {
  EditorContributionRegistry.INSTANCE.registerEditorAction(action);
  return action;
}
function registerInstantiatedEditorAction(editorAction) {
  EditorContributionRegistry.INSTANCE.registerEditorAction(editorAction);
}
function registerEditorContribution(id, ctor, instantiation) {
  EditorContributionRegistry.INSTANCE.registerEditorContribution(id, ctor, instantiation);
}
function registerCommand(command) {
  command.register();
  return command;
}
var Command2, MultiCommand, ProxyCommand, EditorCommand, EditorAction, MultiEditorAction, EditorAction2, EditorExtensionsRegistry, Extensions7, EditorContributionRegistry, UndoCommand, RedoCommand, SelectAllCommand;
var init_editorExtensions = __esm({
  "node_modules/monaco-editor/esm/vs/editor/browser/editorExtensions.js"() {
    init_nls();
    init_uri();
    init_codeEditorService();
    init_position();
    init_model2();
    init_resolverService();
    init_actions2();
    init_commands();
    init_contextkey();
    init_instantiation();
    init_keybindingsRegistry();
    init_platform2();
    init_telemetry();
    init_types();
    init_log();
    init_dom();
    Command2 = class {
      constructor(opts) {
        this.id = opts.id;
        this.precondition = opts.precondition;
        this._kbOpts = opts.kbOpts;
        this._menuOpts = opts.menuOpts;
        this.metadata = opts.metadata;
      }
      register() {
        if (Array.isArray(this._menuOpts)) {
          this._menuOpts.forEach(this._registerMenuItem, this);
        } else if (this._menuOpts) {
          this._registerMenuItem(this._menuOpts);
        }
        if (this._kbOpts) {
          const kbOptsArr = Array.isArray(this._kbOpts) ? this._kbOpts : [this._kbOpts];
          for (const kbOpts of kbOptsArr) {
            let kbWhen = kbOpts.kbExpr;
            if (this.precondition) {
              if (kbWhen) {
                kbWhen = ContextKeyExpr.and(kbWhen, this.precondition);
              } else {
                kbWhen = this.precondition;
              }
            }
            const desc = {
              id: this.id,
              weight: kbOpts.weight,
              args: kbOpts.args,
              when: kbWhen,
              primary: kbOpts.primary,
              secondary: kbOpts.secondary,
              win: kbOpts.win,
              linux: kbOpts.linux,
              mac: kbOpts.mac
            };
            KeybindingsRegistry.registerKeybindingRule(desc);
          }
        }
        CommandsRegistry.registerCommand({
          id: this.id,
          handler: (accessor, args) => this.runCommand(accessor, args),
          metadata: this.metadata
        });
      }
      _registerMenuItem(item) {
        MenuRegistry.appendMenuItem(item.menuId, {
          group: item.group,
          command: {
            id: this.id,
            title: item.title,
            icon: item.icon,
            precondition: this.precondition
          },
          when: item.when,
          order: item.order
        });
      }
    };
    MultiCommand = class extends Command2 {
      constructor() {
        super(...arguments);
        this._implementations = [];
      }
      /**
       * A higher priority gets to be looked at first
       */
      addImplementation(priority, name, implementation, when) {
        this._implementations.push({ priority, name, implementation, when });
        this._implementations.sort((a, b) => b.priority - a.priority);
        return {
          dispose: () => {
            for (let i = 0; i < this._implementations.length; i++) {
              if (this._implementations[i].implementation === implementation) {
                this._implementations.splice(i, 1);
                return;
              }
            }
          }
        };
      }
      runCommand(accessor, args) {
        const logService = accessor.get(ILogService);
        const contextKeyService = accessor.get(IContextKeyService);
        logService.trace(`Executing Command '${this.id}' which has ${this._implementations.length} bound.`);
        for (const impl of this._implementations) {
          if (impl.when) {
            const context = contextKeyService.getContext(getActiveElement());
            const value = impl.when.evaluate(context);
            if (!value) {
              continue;
            }
          }
          const result = impl.implementation(accessor, args);
          if (result) {
            logService.trace(`Command '${this.id}' was handled by '${impl.name}'.`);
            if (typeof result === "boolean") {
              return;
            }
            return result;
          }
        }
        logService.trace(`The Command '${this.id}' was not handled by any implementation.`);
      }
    };
    ProxyCommand = class extends Command2 {
      constructor(command, opts) {
        super(opts);
        this.command = command;
      }
      runCommand(accessor, args) {
        return this.command.runCommand(accessor, args);
      }
    };
    EditorCommand = class _EditorCommand extends Command2 {
      /**
       * Create a command class that is bound to a certain editor contribution.
       */
      static bindToContribution(controllerGetter) {
        return class EditorControllerCommandImpl extends _EditorCommand {
          constructor(opts) {
            super(opts);
            this._callback = opts.handler;
          }
          runEditorCommand(accessor, editor, args) {
            const controller = controllerGetter(editor);
            if (controller) {
              this._callback(controller, args);
            }
          }
        };
      }
      static runEditorCommand(accessor, args, precondition, runner) {
        const codeEditorService = accessor.get(ICodeEditorService);
        const editor = codeEditorService.getFocusedCodeEditor() || codeEditorService.getActiveCodeEditor();
        if (!editor) {
          return;
        }
        return editor.invokeWithinContext((editorAccessor) => {
          const kbService = editorAccessor.get(IContextKeyService);
          if (!kbService.contextMatchesRules(precondition !== null && precondition !== void 0 ? precondition : void 0)) {
            return;
          }
          return runner(editorAccessor, editor, args);
        });
      }
      runCommand(accessor, args) {
        return _EditorCommand.runEditorCommand(accessor, args, this.precondition, (accessor2, editor, args2) => this.runEditorCommand(accessor2, editor, args2));
      }
    };
    EditorAction = class _EditorAction extends EditorCommand {
      static convertOptions(opts) {
        let menuOpts;
        if (Array.isArray(opts.menuOpts)) {
          menuOpts = opts.menuOpts;
        } else if (opts.menuOpts) {
          menuOpts = [opts.menuOpts];
        } else {
          menuOpts = [];
        }
        function withDefaults(item) {
          if (!item.menuId) {
            item.menuId = MenuId.EditorContext;
          }
          if (!item.title) {
            item.title = opts.label;
          }
          item.when = ContextKeyExpr.and(opts.precondition, item.when);
          return item;
        }
        if (Array.isArray(opts.contextMenuOpts)) {
          menuOpts.push(...opts.contextMenuOpts.map(withDefaults));
        } else if (opts.contextMenuOpts) {
          menuOpts.push(withDefaults(opts.contextMenuOpts));
        }
        opts.menuOpts = menuOpts;
        return opts;
      }
      constructor(opts) {
        super(_EditorAction.convertOptions(opts));
        this.label = opts.label;
        this.alias = opts.alias;
      }
      runEditorCommand(accessor, editor, args) {
        this.reportTelemetry(accessor, editor);
        return this.run(accessor, editor, args || {});
      }
      reportTelemetry(accessor, editor) {
        accessor.get(ITelemetryService).publicLog2("editorActionInvoked", { name: this.label, id: this.id });
      }
    };
    MultiEditorAction = class extends EditorAction {
      constructor() {
        super(...arguments);
        this._implementations = [];
      }
      /**
       * A higher priority gets to be looked at first
       */
      addImplementation(priority, implementation) {
        this._implementations.push([priority, implementation]);
        this._implementations.sort((a, b) => b[0] - a[0]);
        return {
          dispose: () => {
            for (let i = 0; i < this._implementations.length; i++) {
              if (this._implementations[i][1] === implementation) {
                this._implementations.splice(i, 1);
                return;
              }
            }
          }
        };
      }
      run(accessor, editor, args) {
        for (const impl of this._implementations) {
          const result = impl[1](accessor, editor, args);
          if (result) {
            if (typeof result === "boolean") {
              return;
            }
            return result;
          }
        }
      }
    };
    EditorAction2 = class extends Action2 {
      run(accessor, ...args) {
        const codeEditorService = accessor.get(ICodeEditorService);
        const editor = codeEditorService.getFocusedCodeEditor() || codeEditorService.getActiveCodeEditor();
        if (!editor) {
          return;
        }
        return editor.invokeWithinContext((editorAccessor) => {
          var _a2, _b2;
          const kbService = editorAccessor.get(IContextKeyService);
          const logService = editorAccessor.get(ILogService);
          const enabled = kbService.contextMatchesRules((_a2 = this.desc.precondition) !== null && _a2 !== void 0 ? _a2 : void 0);
          if (!enabled) {
            logService.debug(`[EditorAction2] NOT running command because its precondition is FALSE`, this.desc.id, (_b2 = this.desc.precondition) === null || _b2 === void 0 ? void 0 : _b2.serialize());
            return;
          }
          return this.runEditorCommand(editorAccessor, editor, ...args);
        });
      }
    };
    (function(EditorExtensionsRegistry2) {
      function getEditorCommand(commandId) {
        return EditorContributionRegistry.INSTANCE.getEditorCommand(commandId);
      }
      EditorExtensionsRegistry2.getEditorCommand = getEditorCommand;
      function getEditorActions() {
        return EditorContributionRegistry.INSTANCE.getEditorActions();
      }
      EditorExtensionsRegistry2.getEditorActions = getEditorActions;
      function getEditorContributions() {
        return EditorContributionRegistry.INSTANCE.getEditorContributions();
      }
      EditorExtensionsRegistry2.getEditorContributions = getEditorContributions;
      function getSomeEditorContributions(ids) {
        return EditorContributionRegistry.INSTANCE.getEditorContributions().filter((c) => ids.indexOf(c.id) >= 0);
      }
      EditorExtensionsRegistry2.getSomeEditorContributions = getSomeEditorContributions;
      function getDiffEditorContributions() {
        return EditorContributionRegistry.INSTANCE.getDiffEditorContributions();
      }
      EditorExtensionsRegistry2.getDiffEditorContributions = getDiffEditorContributions;
    })(EditorExtensionsRegistry || (EditorExtensionsRegistry = {}));
    Extensions7 = {
      EditorCommonContributions: "editor.contributions"
    };
    EditorContributionRegistry = class {
      constructor() {
        this.editorContributions = [];
        this.diffEditorContributions = [];
        this.editorActions = [];
        this.editorCommands = /* @__PURE__ */ Object.create(null);
      }
      registerEditorContribution(id, ctor, instantiation) {
        this.editorContributions.push({ id, ctor, instantiation });
      }
      getEditorContributions() {
        return this.editorContributions.slice(0);
      }
      getDiffEditorContributions() {
        return this.diffEditorContributions.slice(0);
      }
      registerEditorAction(action) {
        action.register();
        this.editorActions.push(action);
      }
      getEditorActions() {
        return this.editorActions;
      }
      registerEditorCommand(editorCommand) {
        editorCommand.register();
        this.editorCommands[editorCommand.id] = editorCommand;
      }
      getEditorCommand(commandId) {
        return this.editorCommands[commandId] || null;
      }
    };
    EditorContributionRegistry.INSTANCE = new EditorContributionRegistry();
    Registry.add(Extensions7.EditorCommonContributions, EditorContributionRegistry.INSTANCE);
    UndoCommand = registerCommand(new MultiCommand({
      id: "undo",
      precondition: void 0,
      kbOpts: {
        weight: 0,
        primary: 2048 | 56
        /* KeyCode.KeyZ */
      },
      menuOpts: [{
        menuId: MenuId.MenubarEditMenu,
        group: "1_do",
        title: localize({ key: "miUndo", comment: ["&& denotes a mnemonic"] }, "&&Undo"),
        order: 1
      }, {
        menuId: MenuId.CommandPalette,
        group: "",
        title: localize("undo", "Undo"),
        order: 1
      }]
    }));
    registerCommand(new ProxyCommand(UndoCommand, { id: "default:undo", precondition: void 0 }));
    RedoCommand = registerCommand(new MultiCommand({
      id: "redo",
      precondition: void 0,
      kbOpts: {
        weight: 0,
        primary: 2048 | 55,
        secondary: [
          2048 | 1024 | 56
          /* KeyCode.KeyZ */
        ],
        mac: {
          primary: 2048 | 1024 | 56
          /* KeyCode.KeyZ */
        }
      },
      menuOpts: [{
        menuId: MenuId.MenubarEditMenu,
        group: "1_do",
        title: localize({ key: "miRedo", comment: ["&& denotes a mnemonic"] }, "&&Redo"),
        order: 2
      }, {
        menuId: MenuId.CommandPalette,
        group: "",
        title: localize("redo", "Redo"),
        order: 1
      }]
    }));
    registerCommand(new ProxyCommand(RedoCommand, { id: "default:redo", precondition: void 0 }));
    SelectAllCommand = registerCommand(new MultiCommand({
      id: "editor.action.selectAll",
      precondition: void 0,
      kbOpts: {
        weight: 0,
        kbExpr: null,
        primary: 2048 | 31
        /* KeyCode.KeyA */
      },
      menuOpts: [{
        menuId: MenuId.MenubarSelectionMenu,
        group: "1_basic",
        title: localize({ key: "miSelectAll", comment: ["&& denotes a mnemonic"] }, "&&Select All"),
        order: 1
      }, {
        menuId: MenuId.CommandPalette,
        group: "",
        title: localize("selectAll", "Select All"),
        order: 1
      }]
    }));
  }
});

// node_modules/monaco-editor/esm/vs/editor/standalone/common/standaloneTheme.js
var IStandaloneThemeService;
var init_standaloneTheme = __esm({
  "node_modules/monaco-editor/esm/vs/editor/standalone/common/standaloneTheme.js"() {
    init_instantiation();
    IStandaloneThemeService = createDecorator("themeService");
  }
});

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
init_languageConfigurationRegistry();

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneCodeEditorService.js
init_dom();
init_network();

// node_modules/monaco-editor/esm/vs/editor/browser/services/abstractCodeEditorService.js
init_event();
init_lifecycle();
init_linkedList();
init_themeService();
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var AbstractCodeEditorService = class AbstractCodeEditorService2 extends Disposable {
  constructor(_themeService) {
    super();
    this._themeService = _themeService;
    this._onWillCreateCodeEditor = this._register(new Emitter());
    this._onCodeEditorAdd = this._register(new Emitter());
    this.onCodeEditorAdd = this._onCodeEditorAdd.event;
    this._onCodeEditorRemove = this._register(new Emitter());
    this.onCodeEditorRemove = this._onCodeEditorRemove.event;
    this._onWillCreateDiffEditor = this._register(new Emitter());
    this._onDiffEditorAdd = this._register(new Emitter());
    this.onDiffEditorAdd = this._onDiffEditorAdd.event;
    this._onDiffEditorRemove = this._register(new Emitter());
    this.onDiffEditorRemove = this._onDiffEditorRemove.event;
    this._decorationOptionProviders = /* @__PURE__ */ new Map();
    this._codeEditorOpenHandlers = new LinkedList();
    this._modelProperties = /* @__PURE__ */ new Map();
    this._codeEditors = /* @__PURE__ */ Object.create(null);
    this._diffEditors = /* @__PURE__ */ Object.create(null);
    this._globalStyleSheet = null;
  }
  willCreateCodeEditor() {
    this._onWillCreateCodeEditor.fire();
  }
  addCodeEditor(editor) {
    this._codeEditors[editor.getId()] = editor;
    this._onCodeEditorAdd.fire(editor);
  }
  removeCodeEditor(editor) {
    if (delete this._codeEditors[editor.getId()]) {
      this._onCodeEditorRemove.fire(editor);
    }
  }
  listCodeEditors() {
    return Object.keys(this._codeEditors).map((id) => this._codeEditors[id]);
  }
  willCreateDiffEditor() {
    this._onWillCreateDiffEditor.fire();
  }
  addDiffEditor(editor) {
    this._diffEditors[editor.getId()] = editor;
    this._onDiffEditorAdd.fire(editor);
  }
  listDiffEditors() {
    return Object.keys(this._diffEditors).map((id) => this._diffEditors[id]);
  }
  getFocusedCodeEditor() {
    let editorWithWidgetFocus = null;
    const editors = this.listCodeEditors();
    for (const editor of editors) {
      if (editor.hasTextFocus()) {
        return editor;
      }
      if (editor.hasWidgetFocus()) {
        editorWithWidgetFocus = editor;
      }
    }
    return editorWithWidgetFocus;
  }
  removeDecorationType(key) {
    const provider = this._decorationOptionProviders.get(key);
    if (provider) {
      provider.refCount--;
      if (provider.refCount <= 0) {
        this._decorationOptionProviders.delete(key);
        provider.dispose();
        this.listCodeEditors().forEach((ed) => ed.removeDecorationsByType(key));
      }
    }
  }
  setModelProperty(resource, key, value) {
    const key1 = resource.toString();
    let dest;
    if (this._modelProperties.has(key1)) {
      dest = this._modelProperties.get(key1);
    } else {
      dest = /* @__PURE__ */ new Map();
      this._modelProperties.set(key1, dest);
    }
    dest.set(key, value);
  }
  getModelProperty(resource, key) {
    const key1 = resource.toString();
    if (this._modelProperties.has(key1)) {
      const innerMap = this._modelProperties.get(key1);
      return innerMap.get(key);
    }
    return void 0;
  }
  async openCodeEditor(input, source, sideBySide) {
    for (const handler of this._codeEditorOpenHandlers) {
      const candidate = await handler(input, source, sideBySide);
      if (candidate !== null) {
        return candidate;
      }
    }
    return null;
  }
  registerCodeEditorOpenHandler(handler) {
    const rm = this._codeEditorOpenHandlers.unshift(handler);
    return toDisposable(rm);
  }
};
AbstractCodeEditorService = __decorate2([
  __param2(0, IThemeService)
], AbstractCodeEditorService);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneCodeEditorService.js
init_codeEditorService();
init_contextkey();
init_extensions();
init_themeService();
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneCodeEditorService = class StandaloneCodeEditorService2 extends AbstractCodeEditorService {
  constructor(contextKeyService, themeService) {
    super(themeService);
    this._register(this.onCodeEditorAdd(() => this._checkContextKey()));
    this._register(this.onCodeEditorRemove(() => this._checkContextKey()));
    this._editorIsOpen = contextKeyService.createKey("editorIsOpen", false);
    this._activeCodeEditor = null;
    this._register(this.registerCodeEditorOpenHandler(async (input, source, sideBySide) => {
      if (!source) {
        return null;
      }
      return this.doOpenEditor(source, input);
    }));
  }
  _checkContextKey() {
    let hasCodeEditor = false;
    for (const editor of this.listCodeEditors()) {
      if (!editor.isSimpleWidget) {
        hasCodeEditor = true;
        break;
      }
    }
    this._editorIsOpen.set(hasCodeEditor);
  }
  setActiveCodeEditor(activeCodeEditor) {
    this._activeCodeEditor = activeCodeEditor;
  }
  getActiveCodeEditor() {
    return this._activeCodeEditor;
  }
  doOpenEditor(editor, input) {
    const model = this.findModel(editor, input.resource);
    if (!model) {
      if (input.resource) {
        const schema = input.resource.scheme;
        if (schema === Schemas.http || schema === Schemas.https) {
          windowOpenNoOpener(input.resource.toString());
          return editor;
        }
      }
      return null;
    }
    const selection = input.options ? input.options.selection : null;
    if (selection) {
      if (typeof selection.endLineNumber === "number" && typeof selection.endColumn === "number") {
        editor.setSelection(selection);
        editor.revealRangeInCenter(
          selection,
          1
          /* ScrollType.Immediate */
        );
      } else {
        const pos = {
          lineNumber: selection.startLineNumber,
          column: selection.startColumn
        };
        editor.setPosition(pos);
        editor.revealPositionInCenter(
          pos,
          1
          /* ScrollType.Immediate */
        );
      }
    }
    return editor;
  }
  findModel(editor, resource) {
    const model = editor.getModel();
    if (model && model.uri.toString() !== resource.toString()) {
      return null;
    }
    return model;
  }
};
StandaloneCodeEditorService = __decorate3([
  __param3(0, IContextKeyService),
  __param3(1, IThemeService)
], StandaloneCodeEditorService);
registerSingleton(
  ICodeEditorService,
  StandaloneCodeEditorService,
  0
  /* InstantiationType.Eager */
);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneLayoutService.js
init_dom();
init_window();
init_arrays();
init_event();
init_codeEditorService();
init_extensions();
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param4 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneLayoutService = class StandaloneLayoutService2 {
  get mainContainer() {
    var _a2, _b2;
    return (_b2 = (_a2 = firstOrDefault(this._codeEditorService.listCodeEditors())) === null || _a2 === void 0 ? void 0 : _a2.getContainerDomNode()) !== null && _b2 !== void 0 ? _b2 : mainWindow.document.body;
  }
  get activeContainer() {
    var _a2, _b2;
    const activeCodeEditor = (_a2 = this._codeEditorService.getFocusedCodeEditor()) !== null && _a2 !== void 0 ? _a2 : this._codeEditorService.getActiveCodeEditor();
    return (_b2 = activeCodeEditor === null || activeCodeEditor === void 0 ? void 0 : activeCodeEditor.getContainerDomNode()) !== null && _b2 !== void 0 ? _b2 : this.mainContainer;
  }
  get mainContainerDimension() {
    return getClientArea(this.mainContainer);
  }
  get activeContainerDimension() {
    return getClientArea(this.activeContainer);
  }
  get containers() {
    return coalesce(this._codeEditorService.listCodeEditors().map((codeEditor) => codeEditor.getContainerDomNode()));
  }
  getContainer() {
    return this.activeContainer;
  }
  focus() {
    var _a2;
    (_a2 = this._codeEditorService.getFocusedCodeEditor()) === null || _a2 === void 0 ? void 0 : _a2.focus();
  }
  constructor(_codeEditorService) {
    this._codeEditorService = _codeEditorService;
    this.onDidLayoutMainContainer = Event.None;
    this.onDidLayoutActiveContainer = Event.None;
    this.onDidLayoutContainer = Event.None;
    this.onDidChangeActiveContainer = Event.None;
    this.onDidAddContainer = Event.None;
    this.whenActiveContainerStylesLoaded = Promise.resolve();
    this.mainContainerOffset = { top: 0, quickPickTop: 0 };
    this.activeContainerOffset = { top: 0, quickPickTop: 0 };
  }
};
StandaloneLayoutService = __decorate4([
  __param4(0, ICodeEditorService)
], StandaloneLayoutService);
var EditorScopedLayoutService = class EditorScopedLayoutService2 extends StandaloneLayoutService {
  get mainContainer() {
    return this._container;
  }
  constructor(_container, codeEditorService) {
    super(codeEditorService);
    this._container = _container;
  }
};
EditorScopedLayoutService = __decorate4([
  __param4(1, ICodeEditorService)
], EditorScopedLayoutService);
registerSingleton(
  ILayoutService,
  StandaloneLayoutService,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedoService.js
init_errors();
init_lifecycle();
init_network();

// node_modules/monaco-editor/esm/vs/base/common/severity.js
init_strings();
var Severity;
(function(Severity3) {
  Severity3[Severity3["Ignore"] = 0] = "Ignore";
  Severity3[Severity3["Info"] = 1] = "Info";
  Severity3[Severity3["Warning"] = 2] = "Warning";
  Severity3[Severity3["Error"] = 3] = "Error";
})(Severity || (Severity = {}));
(function(Severity3) {
  const _error = "error";
  const _warning = "warning";
  const _warn = "warn";
  const _info = "info";
  const _ignore = "ignore";
  function fromValue(value) {
    if (!value) {
      return Severity3.Ignore;
    }
    if (equalsIgnoreCase(_error, value)) {
      return Severity3.Error;
    }
    if (equalsIgnoreCase(_warning, value) || equalsIgnoreCase(_warn, value)) {
      return Severity3.Warning;
    }
    if (equalsIgnoreCase(_info, value)) {
      return Severity3.Info;
    }
    return Severity3.Ignore;
  }
  Severity3.fromValue = fromValue;
  function toString(severity) {
    switch (severity) {
      case Severity3.Error:
        return _error;
      case Severity3.Warning:
        return _warning;
      case Severity3.Info:
        return _info;
      default:
        return _ignore;
    }
  }
  Severity3.toString = toString;
})(Severity || (Severity = {}));
var severity_default = Severity;

// node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedoService.js
init_nls();

// node_modules/monaco-editor/esm/vs/platform/dialogs/common/dialogs.js
init_instantiation();
var IDialogService = createDecorator("dialogService");

// node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedoService.js
init_extensions();

// node_modules/monaco-editor/esm/vs/platform/notification/common/notification.js
init_instantiation();
var Severity2 = severity_default;
var INotificationService = createDecorator("notificationService");
var NoOpNotification = class {
};

// node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedoService.js
init_undoRedo();
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param5 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DEBUG = false;
function getResourceLabel(resource) {
  return resource.scheme === Schemas.file ? resource.fsPath : resource.path;
}
var stackElementCounter = 0;
var ResourceStackElement = class {
  constructor(actual, resourceLabel, strResource, groupId, groupOrder, sourceId, sourceOrder) {
    this.id = ++stackElementCounter;
    this.type = 0;
    this.actual = actual;
    this.label = actual.label;
    this.confirmBeforeUndo = actual.confirmBeforeUndo || false;
    this.resourceLabel = resourceLabel;
    this.strResource = strResource;
    this.resourceLabels = [this.resourceLabel];
    this.strResources = [this.strResource];
    this.groupId = groupId;
    this.groupOrder = groupOrder;
    this.sourceId = sourceId;
    this.sourceOrder = sourceOrder;
    this.isValid = true;
  }
  setValid(isValid) {
    this.isValid = isValid;
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? "  VALID" : "INVALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
};
var ResourceReasonPair = class {
  constructor(resourceLabel, reason) {
    this.resourceLabel = resourceLabel;
    this.reason = reason;
  }
};
var RemovedResources = class {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  createMessage() {
    const externalRemoval = [];
    const noParallelUniverses = [];
    for (const [, element] of this.elements) {
      const dest = element.reason === 0 ? externalRemoval : noParallelUniverses;
      dest.push(element.resourceLabel);
    }
    const messages = [];
    if (externalRemoval.length > 0) {
      messages.push(localize({ key: "externalRemoval", comment: ["{0} is a list of filenames"] }, "The following files have been closed and modified on disk: {0}.", externalRemoval.join(", ")));
    }
    if (noParallelUniverses.length > 0) {
      messages.push(localize({ key: "noParallelUniverses", comment: ["{0} is a list of filenames"] }, "The following files have been modified in an incompatible way: {0}.", noParallelUniverses.join(", ")));
    }
    return messages.join("\n");
  }
  get size() {
    return this.elements.size;
  }
  has(strResource) {
    return this.elements.has(strResource);
  }
  set(strResource, value) {
    this.elements.set(strResource, value);
  }
  delete(strResource) {
    return this.elements.delete(strResource);
  }
};
var WorkspaceStackElement = class {
  constructor(actual, resourceLabels, strResources, groupId, groupOrder, sourceId, sourceOrder) {
    this.id = ++stackElementCounter;
    this.type = 1;
    this.actual = actual;
    this.label = actual.label;
    this.confirmBeforeUndo = actual.confirmBeforeUndo || false;
    this.resourceLabels = resourceLabels;
    this.strResources = strResources;
    this.groupId = groupId;
    this.groupOrder = groupOrder;
    this.sourceId = sourceId;
    this.sourceOrder = sourceOrder;
    this.removedResources = null;
    this.invalidatedResources = null;
  }
  canSplit() {
    return typeof this.actual.split === "function";
  }
  removeResource(resourceLabel, strResource, reason) {
    if (!this.removedResources) {
      this.removedResources = new RemovedResources();
    }
    if (!this.removedResources.has(strResource)) {
      this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));
    }
  }
  setValid(resourceLabel, strResource, isValid) {
    if (isValid) {
      if (this.invalidatedResources) {
        this.invalidatedResources.delete(strResource);
        if (this.invalidatedResources.size === 0) {
          this.invalidatedResources = null;
        }
      }
    } else {
      if (!this.invalidatedResources) {
        this.invalidatedResources = new RemovedResources();
      }
      if (!this.invalidatedResources.has(strResource)) {
        this.invalidatedResources.set(strResource, new ResourceReasonPair(
          resourceLabel,
          0
          /* RemovedResourceReason.ExternalRemoval */
        ));
      }
    }
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? "INVALID" : "  VALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
};
var ResourceEditStack = class {
  constructor(resourceLabel, strResource) {
    this.resourceLabel = resourceLabel;
    this.strResource = strResource;
    this._past = [];
    this._future = [];
    this.locked = false;
    this.versionId = 1;
  }
  dispose() {
    for (const element of this._past) {
      if (element.type === 1) {
        element.removeResource(
          this.resourceLabel,
          this.strResource,
          0
          /* RemovedResourceReason.ExternalRemoval */
        );
      }
    }
    for (const element of this._future) {
      if (element.type === 1) {
        element.removeResource(
          this.resourceLabel,
          this.strResource,
          0
          /* RemovedResourceReason.ExternalRemoval */
        );
      }
    }
    this.versionId++;
  }
  toString() {
    const result = [];
    result.push(`* ${this.strResource}:`);
    for (let i = 0; i < this._past.length; i++) {
      result.push(`   * [UNDO] ${this._past[i]}`);
    }
    for (let i = this._future.length - 1; i >= 0; i--) {
      result.push(`   * [REDO] ${this._future[i]}`);
    }
    return result.join("\n");
  }
  flushAllElements() {
    this._past = [];
    this._future = [];
    this.versionId++;
  }
  _setElementValidFlag(element, isValid) {
    if (element.type === 1) {
      element.setValid(this.resourceLabel, this.strResource, isValid);
    } else {
      element.setValid(isValid);
    }
  }
  setElementsValidFlag(isValid, filter) {
    for (const element of this._past) {
      if (filter(element.actual)) {
        this._setElementValidFlag(element, isValid);
      }
    }
    for (const element of this._future) {
      if (filter(element.actual)) {
        this._setElementValidFlag(element, isValid);
      }
    }
  }
  pushElement(element) {
    for (const futureElement of this._future) {
      if (futureElement.type === 1) {
        futureElement.removeResource(
          this.resourceLabel,
          this.strResource,
          1
          /* RemovedResourceReason.NoParallelUniverses */
        );
      }
    }
    this._future = [];
    this._past.push(element);
    this.versionId++;
  }
  createSnapshot(resource) {
    const elements = [];
    for (let i = 0, len = this._past.length; i < len; i++) {
      elements.push(this._past[i].id);
    }
    for (let i = this._future.length - 1; i >= 0; i--) {
      elements.push(this._future[i].id);
    }
    return new ResourceEditStackSnapshot(resource, elements);
  }
  restoreSnapshot(snapshot) {
    const snapshotLength = snapshot.elements.length;
    let isOK = true;
    let snapshotIndex = 0;
    let removePastAfter = -1;
    for (let i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {
      const element = this._past[i];
      if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {
        isOK = false;
        removePastAfter = 0;
      }
      if (!isOK && element.type === 1) {
        element.removeResource(
          this.resourceLabel,
          this.strResource,
          0
          /* RemovedResourceReason.ExternalRemoval */
        );
      }
    }
    let removeFutureBefore = -1;
    for (let i = this._future.length - 1; i >= 0; i--, snapshotIndex++) {
      const element = this._future[i];
      if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {
        isOK = false;
        removeFutureBefore = i;
      }
      if (!isOK && element.type === 1) {
        element.removeResource(
          this.resourceLabel,
          this.strResource,
          0
          /* RemovedResourceReason.ExternalRemoval */
        );
      }
    }
    if (removePastAfter !== -1) {
      this._past = this._past.slice(0, removePastAfter);
    }
    if (removeFutureBefore !== -1) {
      this._future = this._future.slice(removeFutureBefore + 1);
    }
    this.versionId++;
  }
  getElements() {
    const past = [];
    const future = [];
    for (const element of this._past) {
      past.push(element.actual);
    }
    for (const element of this._future) {
      future.push(element.actual);
    }
    return { past, future };
  }
  getClosestPastElement() {
    if (this._past.length === 0) {
      return null;
    }
    return this._past[this._past.length - 1];
  }
  getSecondClosestPastElement() {
    if (this._past.length < 2) {
      return null;
    }
    return this._past[this._past.length - 2];
  }
  getClosestFutureElement() {
    if (this._future.length === 0) {
      return null;
    }
    return this._future[this._future.length - 1];
  }
  hasPastElements() {
    return this._past.length > 0;
  }
  hasFutureElements() {
    return this._future.length > 0;
  }
  splitPastWorkspaceElement(toRemove, individualMap) {
    for (let j = this._past.length - 1; j >= 0; j--) {
      if (this._past[j] === toRemove) {
        if (individualMap.has(this.strResource)) {
          this._past[j] = individualMap.get(this.strResource);
        } else {
          this._past.splice(j, 1);
        }
        break;
      }
    }
    this.versionId++;
  }
  splitFutureWorkspaceElement(toRemove, individualMap) {
    for (let j = this._future.length - 1; j >= 0; j--) {
      if (this._future[j] === toRemove) {
        if (individualMap.has(this.strResource)) {
          this._future[j] = individualMap.get(this.strResource);
        } else {
          this._future.splice(j, 1);
        }
        break;
      }
    }
    this.versionId++;
  }
  moveBackward(element) {
    this._past.pop();
    this._future.push(element);
    this.versionId++;
  }
  moveForward(element) {
    this._future.pop();
    this._past.push(element);
    this.versionId++;
  }
};
var EditStackSnapshot = class {
  constructor(editStacks) {
    this.editStacks = editStacks;
    this._versionIds = [];
    for (let i = 0, len = this.editStacks.length; i < len; i++) {
      this._versionIds[i] = this.editStacks[i].versionId;
    }
  }
  isValid() {
    for (let i = 0, len = this.editStacks.length; i < len; i++) {
      if (this._versionIds[i] !== this.editStacks[i].versionId) {
        return false;
      }
    }
    return true;
  }
};
var missingEditStack = new ResourceEditStack("", "");
missingEditStack.locked = true;
var UndoRedoService = class UndoRedoService2 {
  constructor(_dialogService, _notificationService) {
    this._dialogService = _dialogService;
    this._notificationService = _notificationService;
    this._editStacks = /* @__PURE__ */ new Map();
    this._uriComparisonKeyComputers = [];
  }
  getUriComparisonKey(resource) {
    for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {
      if (uriComparisonKeyComputer[0] === resource.scheme) {
        return uriComparisonKeyComputer[1].getComparisonKey(resource);
      }
    }
    return resource.toString();
  }
  _print(label) {
    console.log(`------------------------------------`);
    console.log(`AFTER ${label}: `);
    const str = [];
    for (const element of this._editStacks) {
      str.push(element[1].toString());
    }
    console.log(str.join("\n"));
  }
  pushElement(element, group = UndoRedoGroup.None, source = UndoRedoSource.None) {
    if (element.type === 0) {
      const resourceLabel = getResourceLabel(element.resource);
      const strResource = this.getUriComparisonKey(element.resource);
      this._pushElement(new ResourceStackElement(element, resourceLabel, strResource, group.id, group.nextOrder(), source.id, source.nextOrder()));
    } else {
      const seen = /* @__PURE__ */ new Set();
      const resourceLabels = [];
      const strResources = [];
      for (const resource of element.resources) {
        const resourceLabel = getResourceLabel(resource);
        const strResource = this.getUriComparisonKey(resource);
        if (seen.has(strResource)) {
          continue;
        }
        seen.add(strResource);
        resourceLabels.push(resourceLabel);
        strResources.push(strResource);
      }
      if (resourceLabels.length === 1) {
        this._pushElement(new ResourceStackElement(element, resourceLabels[0], strResources[0], group.id, group.nextOrder(), source.id, source.nextOrder()));
      } else {
        this._pushElement(new WorkspaceStackElement(element, resourceLabels, strResources, group.id, group.nextOrder(), source.id, source.nextOrder()));
      }
    }
    if (DEBUG) {
      this._print("pushElement");
    }
  }
  _pushElement(element) {
    for (let i = 0, len = element.strResources.length; i < len; i++) {
      const resourceLabel = element.resourceLabels[i];
      const strResource = element.strResources[i];
      let editStack;
      if (this._editStacks.has(strResource)) {
        editStack = this._editStacks.get(strResource);
      } else {
        editStack = new ResourceEditStack(resourceLabel, strResource);
        this._editStacks.set(strResource, editStack);
      }
      editStack.pushElement(element);
    }
  }
  getLastElement(resource) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      if (editStack.hasFutureElements()) {
        return null;
      }
      const closestPastElement = editStack.getClosestPastElement();
      return closestPastElement ? closestPastElement.actual : null;
    }
    return null;
  }
  _splitPastWorkspaceElement(toRemove, ignoreResources) {
    const individualArr = toRemove.actual.split();
    const individualMap = /* @__PURE__ */ new Map();
    for (const _element of individualArr) {
      const resourceLabel = getResourceLabel(_element.resource);
      const strResource = this.getUriComparisonKey(_element.resource);
      const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);
      individualMap.set(element.strResource, element);
    }
    for (const strResource of toRemove.strResources) {
      if (ignoreResources && ignoreResources.has(strResource)) {
        continue;
      }
      const editStack = this._editStacks.get(strResource);
      editStack.splitPastWorkspaceElement(toRemove, individualMap);
    }
  }
  _splitFutureWorkspaceElement(toRemove, ignoreResources) {
    const individualArr = toRemove.actual.split();
    const individualMap = /* @__PURE__ */ new Map();
    for (const _element of individualArr) {
      const resourceLabel = getResourceLabel(_element.resource);
      const strResource = this.getUriComparisonKey(_element.resource);
      const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);
      individualMap.set(element.strResource, element);
    }
    for (const strResource of toRemove.strResources) {
      if (ignoreResources && ignoreResources.has(strResource)) {
        continue;
      }
      const editStack = this._editStacks.get(strResource);
      editStack.splitFutureWorkspaceElement(toRemove, individualMap);
    }
  }
  removeElements(resource) {
    const strResource = typeof resource === "string" ? resource : this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      editStack.dispose();
      this._editStacks.delete(strResource);
    }
    if (DEBUG) {
      this._print("removeElements");
    }
  }
  setElementsValidFlag(resource, isValid, filter) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      editStack.setElementsValidFlag(isValid, filter);
    }
    if (DEBUG) {
      this._print("setElementsValidFlag");
    }
  }
  createSnapshot(resource) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      return editStack.createSnapshot(resource);
    }
    return new ResourceEditStackSnapshot(resource, []);
  }
  restoreSnapshot(snapshot) {
    const strResource = this.getUriComparisonKey(snapshot.resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      editStack.restoreSnapshot(snapshot);
      if (!editStack.hasPastElements() && !editStack.hasFutureElements()) {
        editStack.dispose();
        this._editStacks.delete(strResource);
      }
    }
    if (DEBUG) {
      this._print("restoreSnapshot");
    }
  }
  getElements(resource) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      return editStack.getElements();
    }
    return { past: [], future: [] };
  }
  _findClosestUndoElementWithSource(sourceId) {
    if (!sourceId) {
      return [null, null];
    }
    let matchedElement = null;
    let matchedStrResource = null;
    for (const [strResource, editStack] of this._editStacks) {
      const candidate = editStack.getClosestPastElement();
      if (!candidate) {
        continue;
      }
      if (candidate.sourceId === sourceId) {
        if (!matchedElement || candidate.sourceOrder > matchedElement.sourceOrder) {
          matchedElement = candidate;
          matchedStrResource = strResource;
        }
      }
    }
    return [matchedElement, matchedStrResource];
  }
  canUndo(resourceOrSource) {
    if (resourceOrSource instanceof UndoRedoSource) {
      const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);
      return matchedStrResource ? true : false;
    }
    const strResource = this.getUriComparisonKey(resourceOrSource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      return editStack.hasPastElements();
    }
    return false;
  }
  _onError(err, element) {
    onUnexpectedError(err);
    for (const strResource of element.strResources) {
      this.removeElements(strResource);
    }
    this._notificationService.error(err);
  }
  _acquireLocks(editStackSnapshot) {
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.locked) {
        throw new Error("Cannot acquire edit stack lock");
      }
    }
    for (const editStack of editStackSnapshot.editStacks) {
      editStack.locked = true;
    }
    return () => {
      for (const editStack of editStackSnapshot.editStacks) {
        editStack.locked = false;
      }
    };
  }
  _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup, continuation) {
    const releaseLocks = this._acquireLocks(editStackSnapshot);
    let result;
    try {
      result = invoke();
    } catch (err) {
      releaseLocks();
      cleanup.dispose();
      return this._onError(err, element);
    }
    if (result) {
      return result.then(() => {
        releaseLocks();
        cleanup.dispose();
        return continuation();
      }, (err) => {
        releaseLocks();
        cleanup.dispose();
        return this._onError(err, element);
      });
    } else {
      releaseLocks();
      cleanup.dispose();
      return continuation();
    }
  }
  async _invokeWorkspacePrepare(element) {
    if (typeof element.actual.prepareUndoRedo === "undefined") {
      return Disposable.None;
    }
    const result = element.actual.prepareUndoRedo();
    if (typeof result === "undefined") {
      return Disposable.None;
    }
    return result;
  }
  _invokeResourcePrepare(element, callback) {
    if (element.actual.type !== 1 || typeof element.actual.prepareUndoRedo === "undefined") {
      return callback(Disposable.None);
    }
    const r = element.actual.prepareUndoRedo();
    if (!r) {
      return callback(Disposable.None);
    }
    if (isDisposable(r)) {
      return callback(r);
    }
    return r.then((disposable) => {
      return callback(disposable);
    });
  }
  _getAffectedEditStacks(element) {
    const affectedEditStacks = [];
    for (const strResource of element.strResources) {
      affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);
    }
    return new EditStackSnapshot(affectedEditStacks);
  }
  _tryToSplitAndUndo(strResource, element, ignoreResources, message) {
    if (element.canSplit()) {
      this._splitPastWorkspaceElement(element, ignoreResources);
      this._notificationService.warn(message);
      return new WorkspaceVerificationError(this._undo(strResource, 0, true));
    } else {
      for (const strResource2 of element.strResources) {
        this.removeElements(strResource2);
      }
      this._notificationService.warn(message);
      return new WorkspaceVerificationError();
    }
  }
  _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {
    if (element.removedResources) {
      return this._tryToSplitAndUndo(strResource, element, element.removedResources, localize({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", element.label, element.removedResources.createMessage()));
    }
    if (checkInvalidatedResources && element.invalidatedResources) {
      return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, localize({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", element.label, element.invalidatedResources.createMessage()));
    }
    const cannotUndoDueToResources = [];
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.getClosestPastElement() !== element) {
        cannotUndoDueToResources.push(editStack.resourceLabel);
      }
    }
    if (cannotUndoDueToResources.length > 0) {
      return this._tryToSplitAndUndo(strResource, element, null, localize({ key: "cannotWorkspaceUndoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because changes were made to {1}", element.label, cannotUndoDueToResources.join(", ")));
    }
    const cannotLockDueToResources = [];
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.locked) {
        cannotLockDueToResources.push(editStack.resourceLabel);
      }
    }
    if (cannotLockDueToResources.length > 0) {
      return this._tryToSplitAndUndo(strResource, element, null, localize({ key: "cannotWorkspaceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}", element.label, cannotLockDueToResources.join(", ")));
    }
    if (!editStackSnapshot.isValid()) {
      return this._tryToSplitAndUndo(strResource, element, null, localize({ key: "cannotWorkspaceUndoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime", element.label));
    }
    return null;
  }
  _workspaceUndo(strResource, element, undoConfirmed) {
    const affectedEditStacks = this._getAffectedEditStacks(element);
    const verificationError = this._checkWorkspaceUndo(
      strResource,
      element,
      affectedEditStacks,
      /*invalidated resources will be checked after the prepare call*/
      false
    );
    if (verificationError) {
      return verificationError.returnValue;
    }
    return this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks, undoConfirmed);
  }
  _isPartOfUndoGroup(element) {
    if (!element.groupId) {
      return false;
    }
    for (const [, editStack] of this._editStacks) {
      const pastElement = editStack.getClosestPastElement();
      if (!pastElement) {
        continue;
      }
      if (pastElement === element) {
        const secondPastElement = editStack.getSecondClosestPastElement();
        if (secondPastElement && secondPastElement.groupId === element.groupId) {
          return true;
        }
      }
      if (pastElement.groupId === element.groupId) {
        return true;
      }
    }
    return false;
  }
  async _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {
    if (element.canSplit() && !this._isPartOfUndoGroup(element)) {
      let UndoChoice;
      (function(UndoChoice2) {
        UndoChoice2[UndoChoice2["All"] = 0] = "All";
        UndoChoice2[UndoChoice2["This"] = 1] = "This";
        UndoChoice2[UndoChoice2["Cancel"] = 2] = "Cancel";
      })(UndoChoice || (UndoChoice = {}));
      const { result } = await this._dialogService.prompt({
        type: severity_default.Info,
        message: localize("confirmWorkspace", "Would you like to undo '{0}' across all files?", element.label),
        buttons: [
          {
            label: localize({ key: "ok", comment: ["{0} denotes a number that is > 1, && denotes a mnemonic"] }, "&&Undo in {0} Files", editStackSnapshot.editStacks.length),
            run: () => UndoChoice.All
          },
          {
            label: localize({ key: "nok", comment: ["&& denotes a mnemonic"] }, "Undo this &&File"),
            run: () => UndoChoice.This
          }
        ],
        cancelButton: {
          run: () => UndoChoice.Cancel
        }
      });
      if (result === UndoChoice.Cancel) {
        return;
      }
      if (result === UndoChoice.This) {
        this._splitPastWorkspaceElement(element, null);
        return this._undo(strResource, 0, true);
      }
      const verificationError1 = this._checkWorkspaceUndo(
        strResource,
        element,
        editStackSnapshot,
        /*invalidated resources will be checked after the prepare call*/
        false
      );
      if (verificationError1) {
        return verificationError1.returnValue;
      }
      undoConfirmed = true;
    }
    let cleanup;
    try {
      cleanup = await this._invokeWorkspacePrepare(element);
    } catch (err) {
      return this._onError(err, element);
    }
    const verificationError2 = this._checkWorkspaceUndo(
      strResource,
      element,
      editStackSnapshot,
      /*now also check that there are no more invalidated resources*/
      true
    );
    if (verificationError2) {
      cleanup.dispose();
      return verificationError2.returnValue;
    }
    for (const editStack of editStackSnapshot.editStacks) {
      editStack.moveBackward(element);
    }
    return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));
  }
  _resourceUndo(editStack, element, undoConfirmed) {
    if (!element.isValid) {
      editStack.flushAllElements();
      return;
    }
    if (editStack.locked) {
      const message = localize({ key: "cannotResourceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not undo '{0}' because there is already an undo or redo operation running.", element.label);
      this._notificationService.warn(message);
      return;
    }
    return this._invokeResourcePrepare(element, (cleanup) => {
      editStack.moveBackward(element);
      return this._safeInvokeWithLocks(element, () => element.actual.undo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));
    });
  }
  _findClosestUndoElementInGroup(groupId) {
    if (!groupId) {
      return [null, null];
    }
    let matchedElement = null;
    let matchedStrResource = null;
    for (const [strResource, editStack] of this._editStacks) {
      const candidate = editStack.getClosestPastElement();
      if (!candidate) {
        continue;
      }
      if (candidate.groupId === groupId) {
        if (!matchedElement || candidate.groupOrder > matchedElement.groupOrder) {
          matchedElement = candidate;
          matchedStrResource = strResource;
        }
      }
    }
    return [matchedElement, matchedStrResource];
  }
  _continueUndoInGroup(groupId, undoConfirmed) {
    if (!groupId) {
      return;
    }
    const [, matchedStrResource] = this._findClosestUndoElementInGroup(groupId);
    if (matchedStrResource) {
      return this._undo(matchedStrResource, 0, undoConfirmed);
    }
  }
  undo(resourceOrSource) {
    if (resourceOrSource instanceof UndoRedoSource) {
      const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);
      return matchedStrResource ? this._undo(matchedStrResource, resourceOrSource.id, false) : void 0;
    }
    if (typeof resourceOrSource === "string") {
      return this._undo(resourceOrSource, 0, false);
    }
    return this._undo(this.getUriComparisonKey(resourceOrSource), 0, false);
  }
  _undo(strResource, sourceId = 0, undoConfirmed) {
    if (!this._editStacks.has(strResource)) {
      return;
    }
    const editStack = this._editStacks.get(strResource);
    const element = editStack.getClosestPastElement();
    if (!element) {
      return;
    }
    if (element.groupId) {
      const [matchedElement, matchedStrResource] = this._findClosestUndoElementInGroup(element.groupId);
      if (element !== matchedElement && matchedStrResource) {
        return this._undo(matchedStrResource, sourceId, undoConfirmed);
      }
    }
    const shouldPromptForConfirmation = element.sourceId !== sourceId || element.confirmBeforeUndo;
    if (shouldPromptForConfirmation && !undoConfirmed) {
      return this._confirmAndContinueUndo(strResource, sourceId, element);
    }
    try {
      if (element.type === 1) {
        return this._workspaceUndo(strResource, element, undoConfirmed);
      } else {
        return this._resourceUndo(editStack, element, undoConfirmed);
      }
    } finally {
      if (DEBUG) {
        this._print("undo");
      }
    }
  }
  async _confirmAndContinueUndo(strResource, sourceId, element) {
    const result = await this._dialogService.confirm({
      message: localize("confirmDifferentSource", "Would you like to undo '{0}'?", element.label),
      primaryButton: localize({ key: "confirmDifferentSource.yes", comment: ["&& denotes a mnemonic"] }, "&&Yes"),
      cancelButton: localize("confirmDifferentSource.no", "No")
    });
    if (!result.confirmed) {
      return;
    }
    return this._undo(strResource, sourceId, true);
  }
  _findClosestRedoElementWithSource(sourceId) {
    if (!sourceId) {
      return [null, null];
    }
    let matchedElement = null;
    let matchedStrResource = null;
    for (const [strResource, editStack] of this._editStacks) {
      const candidate = editStack.getClosestFutureElement();
      if (!candidate) {
        continue;
      }
      if (candidate.sourceId === sourceId) {
        if (!matchedElement || candidate.sourceOrder < matchedElement.sourceOrder) {
          matchedElement = candidate;
          matchedStrResource = strResource;
        }
      }
    }
    return [matchedElement, matchedStrResource];
  }
  canRedo(resourceOrSource) {
    if (resourceOrSource instanceof UndoRedoSource) {
      const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);
      return matchedStrResource ? true : false;
    }
    const strResource = this.getUriComparisonKey(resourceOrSource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      return editStack.hasFutureElements();
    }
    return false;
  }
  _tryToSplitAndRedo(strResource, element, ignoreResources, message) {
    if (element.canSplit()) {
      this._splitFutureWorkspaceElement(element, ignoreResources);
      this._notificationService.warn(message);
      return new WorkspaceVerificationError(this._redo(strResource));
    } else {
      for (const strResource2 of element.strResources) {
        this.removeElements(strResource2);
      }
      this._notificationService.warn(message);
      return new WorkspaceVerificationError();
    }
  }
  _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {
    if (element.removedResources) {
      return this._tryToSplitAndRedo(strResource, element, element.removedResources, localize({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", element.label, element.removedResources.createMessage()));
    }
    if (checkInvalidatedResources && element.invalidatedResources) {
      return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, localize({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", element.label, element.invalidatedResources.createMessage()));
    }
    const cannotRedoDueToResources = [];
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.getClosestFutureElement() !== element) {
        cannotRedoDueToResources.push(editStack.resourceLabel);
      }
    }
    if (cannotRedoDueToResources.length > 0) {
      return this._tryToSplitAndRedo(strResource, element, null, localize({ key: "cannotWorkspaceRedoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because changes were made to {1}", element.label, cannotRedoDueToResources.join(", ")));
    }
    const cannotLockDueToResources = [];
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.locked) {
        cannotLockDueToResources.push(editStack.resourceLabel);
      }
    }
    if (cannotLockDueToResources.length > 0) {
      return this._tryToSplitAndRedo(strResource, element, null, localize({ key: "cannotWorkspaceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}", element.label, cannotLockDueToResources.join(", ")));
    }
    if (!editStackSnapshot.isValid()) {
      return this._tryToSplitAndRedo(strResource, element, null, localize({ key: "cannotWorkspaceRedoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime", element.label));
    }
    return null;
  }
  _workspaceRedo(strResource, element) {
    const affectedEditStacks = this._getAffectedEditStacks(element);
    const verificationError = this._checkWorkspaceRedo(
      strResource,
      element,
      affectedEditStacks,
      /*invalidated resources will be checked after the prepare call*/
      false
    );
    if (verificationError) {
      return verificationError.returnValue;
    }
    return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);
  }
  async _executeWorkspaceRedo(strResource, element, editStackSnapshot) {
    let cleanup;
    try {
      cleanup = await this._invokeWorkspacePrepare(element);
    } catch (err) {
      return this._onError(err, element);
    }
    const verificationError = this._checkWorkspaceRedo(
      strResource,
      element,
      editStackSnapshot,
      /*now also check that there are no more invalidated resources*/
      true
    );
    if (verificationError) {
      cleanup.dispose();
      return verificationError.returnValue;
    }
    for (const editStack of editStackSnapshot.editStacks) {
      editStack.moveForward(element);
    }
    return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));
  }
  _resourceRedo(editStack, element) {
    if (!element.isValid) {
      editStack.flushAllElements();
      return;
    }
    if (editStack.locked) {
      const message = localize({ key: "cannotResourceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not redo '{0}' because there is already an undo or redo operation running.", element.label);
      this._notificationService.warn(message);
      return;
    }
    return this._invokeResourcePrepare(element, (cleanup) => {
      editStack.moveForward(element);
      return this._safeInvokeWithLocks(element, () => element.actual.redo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueRedoInGroup(element.groupId));
    });
  }
  _findClosestRedoElementInGroup(groupId) {
    if (!groupId) {
      return [null, null];
    }
    let matchedElement = null;
    let matchedStrResource = null;
    for (const [strResource, editStack] of this._editStacks) {
      const candidate = editStack.getClosestFutureElement();
      if (!candidate) {
        continue;
      }
      if (candidate.groupId === groupId) {
        if (!matchedElement || candidate.groupOrder < matchedElement.groupOrder) {
          matchedElement = candidate;
          matchedStrResource = strResource;
        }
      }
    }
    return [matchedElement, matchedStrResource];
  }
  _continueRedoInGroup(groupId) {
    if (!groupId) {
      return;
    }
    const [, matchedStrResource] = this._findClosestRedoElementInGroup(groupId);
    if (matchedStrResource) {
      return this._redo(matchedStrResource);
    }
  }
  redo(resourceOrSource) {
    if (resourceOrSource instanceof UndoRedoSource) {
      const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);
      return matchedStrResource ? this._redo(matchedStrResource) : void 0;
    }
    if (typeof resourceOrSource === "string") {
      return this._redo(resourceOrSource);
    }
    return this._redo(this.getUriComparisonKey(resourceOrSource));
  }
  _redo(strResource) {
    if (!this._editStacks.has(strResource)) {
      return;
    }
    const editStack = this._editStacks.get(strResource);
    const element = editStack.getClosestFutureElement();
    if (!element) {
      return;
    }
    if (element.groupId) {
      const [matchedElement, matchedStrResource] = this._findClosestRedoElementInGroup(element.groupId);
      if (element !== matchedElement && matchedStrResource) {
        return this._redo(matchedStrResource);
      }
    }
    try {
      if (element.type === 1) {
        return this._workspaceRedo(strResource, element);
      } else {
        return this._resourceRedo(editStack, element);
      }
    } finally {
      if (DEBUG) {
        this._print("redo");
      }
    }
  }
};
UndoRedoService = __decorate5([
  __param5(0, IDialogService),
  __param5(1, INotificationService)
], UndoRedoService);
var WorkspaceVerificationError = class {
  constructor(returnValue) {
    this.returnValue = returnValue;
  }
};
registerSingleton(
  IUndoRedoService,
  UndoRedoService,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
init_languageFeatureDebounce();

// node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensStylingService.js
init_lifecycle();
init_language();
init_themeService();
init_log();

// node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js
init_encodedTokenAttributes();
init_themeService();
init_log();

// node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseMultilineTokens.js
init_position();
init_range();
init_eolCounter();
var SparseMultilineTokens = class _SparseMultilineTokens {
  static create(startLineNumber, tokens) {
    return new _SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));
  }
  /**
   * (Inclusive) start line number for these tokens.
   */
  get startLineNumber() {
    return this._startLineNumber;
  }
  /**
   * (Inclusive) end line number for these tokens.
   */
  get endLineNumber() {
    return this._endLineNumber;
  }
  constructor(startLineNumber, tokens) {
    this._startLineNumber = startLineNumber;
    this._tokens = tokens;
    this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();
  }
  toString() {
    return this._tokens.toString(this._startLineNumber);
  }
  _updateEndLineNumber() {
    this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();
  }
  isEmpty() {
    return this._tokens.isEmpty();
  }
  getLineTokens(lineNumber) {
    if (this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber) {
      return this._tokens.getLineTokens(lineNumber - this._startLineNumber);
    }
    return null;
  }
  getRange() {
    const deltaRange = this._tokens.getRange();
    if (!deltaRange) {
      return deltaRange;
    }
    return new Range2(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);
  }
  removeTokens(range2) {
    const startLineIndex = range2.startLineNumber - this._startLineNumber;
    const endLineIndex = range2.endLineNumber - this._startLineNumber;
    this._startLineNumber += this._tokens.removeTokens(startLineIndex, range2.startColumn - 1, endLineIndex, range2.endColumn - 1);
    this._updateEndLineNumber();
  }
  split(range2) {
    const startLineIndex = range2.startLineNumber - this._startLineNumber;
    const endLineIndex = range2.endLineNumber - this._startLineNumber;
    const [a, b, bDeltaLine] = this._tokens.split(startLineIndex, range2.startColumn - 1, endLineIndex, range2.endColumn - 1);
    return [new _SparseMultilineTokens(this._startLineNumber, a), new _SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];
  }
  applyEdit(range2, text) {
    const [eolCount, firstLineLength, lastLineLength] = countEOL(text);
    this.acceptEdit(
      range2,
      eolCount,
      firstLineLength,
      lastLineLength,
      text.length > 0 ? text.charCodeAt(0) : 0
      /* CharCode.Null */
    );
  }
  acceptEdit(range2, eolCount, firstLineLength, lastLineLength, firstCharCode) {
    this._acceptDeleteRange(range2);
    this._acceptInsertText(new Position(range2.startLineNumber, range2.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);
    this._updateEndLineNumber();
  }
  _acceptDeleteRange(range2) {
    if (range2.startLineNumber === range2.endLineNumber && range2.startColumn === range2.endColumn) {
      return;
    }
    const firstLineIndex = range2.startLineNumber - this._startLineNumber;
    const lastLineIndex = range2.endLineNumber - this._startLineNumber;
    if (lastLineIndex < 0) {
      const deletedLinesCount = lastLineIndex - firstLineIndex;
      this._startLineNumber -= deletedLinesCount;
      return;
    }
    const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();
    if (firstLineIndex >= tokenMaxDeltaLine + 1) {
      return;
    }
    if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {
      this._startLineNumber = 0;
      this._tokens.clear();
      return;
    }
    if (firstLineIndex < 0) {
      const deletedBefore = -firstLineIndex;
      this._startLineNumber -= deletedBefore;
      this._tokens.acceptDeleteRange(range2.startColumn - 1, 0, 0, lastLineIndex, range2.endColumn - 1);
    } else {
      this._tokens.acceptDeleteRange(0, firstLineIndex, range2.startColumn - 1, lastLineIndex, range2.endColumn - 1);
    }
  }
  _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {
    if (eolCount === 0 && firstLineLength === 0) {
      return;
    }
    const lineIndex = position.lineNumber - this._startLineNumber;
    if (lineIndex < 0) {
      this._startLineNumber += eolCount;
      return;
    }
    const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();
    if (lineIndex >= tokenMaxDeltaLine + 1) {
      return;
    }
    this._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);
  }
};
var SparseMultilineTokensStorage = class _SparseMultilineTokensStorage {
  constructor(tokens) {
    this._tokens = tokens;
    this._tokenCount = tokens.length / 4;
  }
  toString(startLineNumber) {
    const pieces = [];
    for (let i = 0; i < this._tokenCount; i++) {
      pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);
    }
    return `[${pieces.join(",")}]`;
  }
  getMaxDeltaLine() {
    const tokenCount = this._getTokenCount();
    if (tokenCount === 0) {
      return -1;
    }
    return this._getDeltaLine(tokenCount - 1);
  }
  getRange() {
    const tokenCount = this._getTokenCount();
    if (tokenCount === 0) {
      return null;
    }
    const startChar = this._getStartCharacter(0);
    const maxDeltaLine = this._getDeltaLine(tokenCount - 1);
    const endChar = this._getEndCharacter(tokenCount - 1);
    return new Range2(0, startChar + 1, maxDeltaLine, endChar + 1);
  }
  _getTokenCount() {
    return this._tokenCount;
  }
  _getDeltaLine(tokenIndex) {
    return this._tokens[4 * tokenIndex];
  }
  _getStartCharacter(tokenIndex) {
    return this._tokens[4 * tokenIndex + 1];
  }
  _getEndCharacter(tokenIndex) {
    return this._tokens[4 * tokenIndex + 2];
  }
  isEmpty() {
    return this._getTokenCount() === 0;
  }
  getLineTokens(deltaLine) {
    let low = 0;
    let high = this._getTokenCount() - 1;
    while (low < high) {
      const mid = low + Math.floor((high - low) / 2);
      const midDeltaLine = this._getDeltaLine(mid);
      if (midDeltaLine < deltaLine) {
        low = mid + 1;
      } else if (midDeltaLine > deltaLine) {
        high = mid - 1;
      } else {
        let min = mid;
        while (min > low && this._getDeltaLine(min - 1) === deltaLine) {
          min--;
        }
        let max = mid;
        while (max < high && this._getDeltaLine(max + 1) === deltaLine) {
          max++;
        }
        return new SparseLineTokens(this._tokens.subarray(4 * min, 4 * max + 4));
      }
    }
    if (this._getDeltaLine(low) === deltaLine) {
      return new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4));
    }
    return null;
  }
  clear() {
    this._tokenCount = 0;
  }
  removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {
    const tokens = this._tokens;
    const tokenCount = this._tokenCount;
    let newTokenCount = 0;
    let hasDeletedTokens = false;
    let firstDeltaLine = 0;
    for (let i = 0; i < tokenCount; i++) {
      const srcOffset = 4 * i;
      const tokenDeltaLine = tokens[srcOffset];
      const tokenStartCharacter = tokens[srcOffset + 1];
      const tokenEndCharacter = tokens[srcOffset + 2];
      const tokenMetadata = tokens[srcOffset + 3];
      if ((tokenDeltaLine > startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar) && (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar)) {
        hasDeletedTokens = true;
      } else {
        if (newTokenCount === 0) {
          firstDeltaLine = tokenDeltaLine;
        }
        if (hasDeletedTokens) {
          const destOffset = 4 * newTokenCount;
          tokens[destOffset] = tokenDeltaLine - firstDeltaLine;
          tokens[destOffset + 1] = tokenStartCharacter;
          tokens[destOffset + 2] = tokenEndCharacter;
          tokens[destOffset + 3] = tokenMetadata;
        }
        newTokenCount++;
      }
    }
    this._tokenCount = newTokenCount;
    return firstDeltaLine;
  }
  split(startDeltaLine, startChar, endDeltaLine, endChar) {
    const tokens = this._tokens;
    const tokenCount = this._tokenCount;
    const aTokens = [];
    const bTokens = [];
    let destTokens = aTokens;
    let destOffset = 0;
    let destFirstDeltaLine = 0;
    for (let i = 0; i < tokenCount; i++) {
      const srcOffset = 4 * i;
      const tokenDeltaLine = tokens[srcOffset];
      const tokenStartCharacter = tokens[srcOffset + 1];
      const tokenEndCharacter = tokens[srcOffset + 2];
      const tokenMetadata = tokens[srcOffset + 3];
      if (tokenDeltaLine > startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar) {
        if (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar) {
          continue;
        } else {
          if (destTokens !== bTokens) {
            destTokens = bTokens;
            destOffset = 0;
            destFirstDeltaLine = tokenDeltaLine;
          }
        }
      }
      destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;
      destTokens[destOffset++] = tokenStartCharacter;
      destTokens[destOffset++] = tokenEndCharacter;
      destTokens[destOffset++] = tokenMetadata;
    }
    return [new _SparseMultilineTokensStorage(new Uint32Array(aTokens)), new _SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];
  }
  acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {
    const tokens = this._tokens;
    const tokenCount = this._tokenCount;
    const deletedLineCount = endDeltaLine - startDeltaLine;
    let newTokenCount = 0;
    let hasDeletedTokens = false;
    for (let i = 0; i < tokenCount; i++) {
      const srcOffset = 4 * i;
      let tokenDeltaLine = tokens[srcOffset];
      let tokenStartCharacter = tokens[srcOffset + 1];
      let tokenEndCharacter = tokens[srcOffset + 2];
      const tokenMetadata = tokens[srcOffset + 3];
      if (tokenDeltaLine < startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter) {
        newTokenCount++;
        continue;
      } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {
        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {
          tokenEndCharacter -= endCharacter - startCharacter;
        } else {
          tokenEndCharacter = startCharacter;
        }
      } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {
        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {
          tokenEndCharacter -= endCharacter - startCharacter;
        } else {
          hasDeletedTokens = true;
          continue;
        }
      } else if (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter) {
        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {
          tokenDeltaLine = startDeltaLine;
          tokenStartCharacter = startCharacter;
          tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);
        } else {
          hasDeletedTokens = true;
          continue;
        }
      } else if (tokenDeltaLine > endDeltaLine) {
        if (deletedLineCount === 0 && !hasDeletedTokens) {
          newTokenCount = tokenCount;
          break;
        }
        tokenDeltaLine -= deletedLineCount;
      } else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {
        if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {
          tokenStartCharacter += horizontalShiftForFirstLineTokens;
          tokenEndCharacter += horizontalShiftForFirstLineTokens;
        }
        tokenDeltaLine -= deletedLineCount;
        tokenStartCharacter -= endCharacter - startCharacter;
        tokenEndCharacter -= endCharacter - startCharacter;
      } else {
        throw new Error(`Not possible!`);
      }
      const destOffset = 4 * newTokenCount;
      tokens[destOffset] = tokenDeltaLine;
      tokens[destOffset + 1] = tokenStartCharacter;
      tokens[destOffset + 2] = tokenEndCharacter;
      tokens[destOffset + 3] = tokenMetadata;
      newTokenCount++;
    }
    this._tokenCount = newTokenCount;
  }
  acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {
    const isInsertingPreciselyOneWordCharacter = eolCount === 0 && firstLineLength === 1 && (firstCharCode >= 48 && firstCharCode <= 57 || firstCharCode >= 65 && firstCharCode <= 90 || firstCharCode >= 97 && firstCharCode <= 122);
    const tokens = this._tokens;
    const tokenCount = this._tokenCount;
    for (let i = 0; i < tokenCount; i++) {
      const offset = 4 * i;
      let tokenDeltaLine = tokens[offset];
      let tokenStartCharacter = tokens[offset + 1];
      let tokenEndCharacter = tokens[offset + 2];
      if (tokenDeltaLine < deltaLine || tokenDeltaLine === deltaLine && tokenEndCharacter < character) {
        continue;
      } else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {
        if (isInsertingPreciselyOneWordCharacter) {
          tokenEndCharacter += 1;
        } else {
          continue;
        }
      } else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {
        if (eolCount === 0) {
          tokenEndCharacter += firstLineLength;
        } else {
          tokenEndCharacter = character;
        }
      } else {
        if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {
          if (isInsertingPreciselyOneWordCharacter) {
            continue;
          }
        }
        if (tokenDeltaLine === deltaLine) {
          tokenDeltaLine += eolCount;
          if (eolCount === 0) {
            tokenStartCharacter += firstLineLength;
            tokenEndCharacter += firstLineLength;
          } else {
            const tokenLength = tokenEndCharacter - tokenStartCharacter;
            tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);
            tokenEndCharacter = tokenStartCharacter + tokenLength;
          }
        } else {
          tokenDeltaLine += eolCount;
        }
      }
      tokens[offset] = tokenDeltaLine;
      tokens[offset + 1] = tokenStartCharacter;
      tokens[offset + 2] = tokenEndCharacter;
    }
  }
};
var SparseLineTokens = class {
  constructor(tokens) {
    this._tokens = tokens;
  }
  getCount() {
    return this._tokens.length / 4;
  }
  getStartCharacter(tokenIndex) {
    return this._tokens[4 * tokenIndex + 1];
  }
  getEndCharacter(tokenIndex) {
    return this._tokens[4 * tokenIndex + 2];
  }
  getMetadata(tokenIndex) {
    return this._tokens[4 * tokenIndex + 3];
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js
init_language();
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param7 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SemanticTokensProviderStyling = class SemanticTokensProviderStyling2 {
  constructor(_legend, _themeService, _languageService, _logService) {
    this._legend = _legend;
    this._themeService = _themeService;
    this._languageService = _languageService;
    this._logService = _logService;
    this._hasWarnedOverlappingTokens = false;
    this._hasWarnedInvalidLengthTokens = false;
    this._hasWarnedInvalidEditStart = false;
    this._hashTable = new HashTable();
  }
  getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {
    const encodedLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);
    const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, encodedLanguageId);
    let metadata;
    if (entry) {
      metadata = entry.metadata;
      if (this._logService.getLevel() === LogLevel.Trace) {
        this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);
      }
    } else {
      let tokenType = this._legend.tokenTypes[tokenTypeIndex];
      const tokenModifiers = [];
      if (tokenType) {
        let modifierSet = tokenModifierSet;
        for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {
          if (modifierSet & 1) {
            tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);
          }
          modifierSet = modifierSet >> 1;
        }
        if (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {
          this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);
          tokenModifiers.push("not-in-legend");
        }
        const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId);
        if (typeof tokenStyle === "undefined") {
          metadata = 2147483647;
        } else {
          metadata = 0;
          if (typeof tokenStyle.italic !== "undefined") {
            const italicBit = (tokenStyle.italic ? 1 : 0) << 11;
            metadata |= italicBit | 1;
          }
          if (typeof tokenStyle.bold !== "undefined") {
            const boldBit = (tokenStyle.bold ? 2 : 0) << 11;
            metadata |= boldBit | 2;
          }
          if (typeof tokenStyle.underline !== "undefined") {
            const underlineBit = (tokenStyle.underline ? 4 : 0) << 11;
            metadata |= underlineBit | 4;
          }
          if (typeof tokenStyle.strikethrough !== "undefined") {
            const strikethroughBit = (tokenStyle.strikethrough ? 8 : 0) << 11;
            metadata |= strikethroughBit | 8;
          }
          if (tokenStyle.foreground) {
            const foregroundBits = tokenStyle.foreground << 15;
            metadata |= foregroundBits | 16;
          }
          if (metadata === 0) {
            metadata = 2147483647;
          }
        }
      } else {
        if (this._logService.getLevel() === LogLevel.Trace) {
          this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);
        }
        metadata = 2147483647;
        tokenType = "not-in-legend";
      }
      this._hashTable.add(tokenTypeIndex, tokenModifierSet, encodedLanguageId, metadata);
      if (this._logService.getLevel() === LogLevel.Trace) {
        this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(" ")}): foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);
      }
    }
    return metadata;
  }
  warnOverlappingSemanticTokens(lineNumber, startColumn) {
    if (!this._hasWarnedOverlappingTokens) {
      this._hasWarnedOverlappingTokens = true;
      this._logService.warn(`Overlapping semantic tokens detected at lineNumber ${lineNumber}, column ${startColumn}`);
    }
  }
  warnInvalidLengthSemanticTokens(lineNumber, startColumn) {
    if (!this._hasWarnedInvalidLengthTokens) {
      this._hasWarnedInvalidLengthTokens = true;
      this._logService.warn(`Semantic token with invalid length detected at lineNumber ${lineNumber}, column ${startColumn}`);
    }
  }
  warnInvalidEditStart(previousResultId, resultId, editIndex, editStart, maxExpectedStart) {
    if (!this._hasWarnedInvalidEditStart) {
      this._hasWarnedInvalidEditStart = true;
      this._logService.warn(`Invalid semantic tokens edit detected (previousResultId: ${previousResultId}, resultId: ${resultId}) at edit #${editIndex}: The provided start offset ${editStart} is outside the previous data (length ${maxExpectedStart}).`);
    }
  }
};
SemanticTokensProviderStyling = __decorate7([
  __param7(1, IThemeService),
  __param7(2, ILanguageService),
  __param7(3, ILogService)
], SemanticTokensProviderStyling);
function toMultilineTokens2(tokens, styling, languageId) {
  const srcData = tokens.data;
  const tokenCount = tokens.data.length / 5 | 0;
  const tokensPerArea = Math.max(
    Math.ceil(
      tokenCount / 1024
      /* SemanticColoringConstants.DesiredMaxAreas */
    ),
    400
    /* SemanticColoringConstants.DesiredTokensPerArea */
  );
  const result = [];
  let tokenIndex = 0;
  let lastLineNumber = 1;
  let lastStartCharacter = 0;
  while (tokenIndex < tokenCount) {
    const tokenStartIndex = tokenIndex;
    let tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);
    if (tokenEndIndex < tokenCount) {
      let smallTokenEndIndex = tokenEndIndex;
      while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {
        smallTokenEndIndex--;
      }
      if (smallTokenEndIndex - 1 === tokenStartIndex) {
        let bigTokenEndIndex = tokenEndIndex;
        while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {
          bigTokenEndIndex++;
        }
        tokenEndIndex = bigTokenEndIndex;
      } else {
        tokenEndIndex = smallTokenEndIndex;
      }
    }
    let destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);
    let destOffset = 0;
    let areaLine = 0;
    let prevLineNumber = 0;
    let prevEndCharacter = 0;
    while (tokenIndex < tokenEndIndex) {
      const srcOffset = 5 * tokenIndex;
      const deltaLine = srcData[srcOffset];
      const deltaCharacter = srcData[srcOffset + 1];
      const lineNumber = lastLineNumber + deltaLine | 0;
      const startCharacter = deltaLine === 0 ? lastStartCharacter + deltaCharacter | 0 : deltaCharacter;
      const length = srcData[srcOffset + 2];
      const endCharacter = startCharacter + length | 0;
      const tokenTypeIndex = srcData[srcOffset + 3];
      const tokenModifierSet = srcData[srcOffset + 4];
      if (endCharacter <= startCharacter) {
        styling.warnInvalidLengthSemanticTokens(lineNumber, startCharacter + 1);
      } else if (prevLineNumber === lineNumber && prevEndCharacter > startCharacter) {
        styling.warnOverlappingSemanticTokens(lineNumber, startCharacter + 1);
      } else {
        const metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);
        if (metadata !== 2147483647) {
          if (areaLine === 0) {
            areaLine = lineNumber;
          }
          destData[destOffset] = lineNumber - areaLine;
          destData[destOffset + 1] = startCharacter;
          destData[destOffset + 2] = endCharacter;
          destData[destOffset + 3] = metadata;
          destOffset += 4;
          prevLineNumber = lineNumber;
          prevEndCharacter = endCharacter;
        }
      }
      lastLineNumber = lineNumber;
      lastStartCharacter = startCharacter;
      tokenIndex++;
    }
    if (destOffset !== destData.length) {
      destData = destData.subarray(0, destOffset);
    }
    const tokens2 = SparseMultilineTokens.create(areaLine, destData);
    result.push(tokens2);
  }
  return result;
}
var HashTableEntry = class {
  constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {
    this.tokenTypeIndex = tokenTypeIndex;
    this.tokenModifierSet = tokenModifierSet;
    this.languageId = languageId;
    this.metadata = metadata;
    this.next = null;
  }
};
var HashTable = class _HashTable {
  constructor() {
    this._elementsCount = 0;
    this._currentLengthIndex = 0;
    this._currentLength = _HashTable._SIZES[this._currentLengthIndex];
    this._growCount = Math.round(this._currentLengthIndex + 1 < _HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);
    this._elements = [];
    _HashTable._nullOutEntries(this._elements, this._currentLength);
  }
  static _nullOutEntries(entries, length) {
    for (let i = 0; i < length; i++) {
      entries[i] = null;
    }
  }
  _hash2(n1, n2) {
    return (n1 << 5) - n1 + n2 | 0;
  }
  _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {
    return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;
  }
  get(tokenTypeIndex, tokenModifierSet, languageId) {
    const hash2 = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);
    let p = this._elements[hash2];
    while (p) {
      if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {
        return p;
      }
      p = p.next;
    }
    return null;
  }
  add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {
    this._elementsCount++;
    if (this._growCount !== 0 && this._elementsCount >= this._growCount) {
      const oldElements = this._elements;
      this._currentLengthIndex++;
      this._currentLength = _HashTable._SIZES[this._currentLengthIndex];
      this._growCount = Math.round(this._currentLengthIndex + 1 < _HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);
      this._elements = [];
      _HashTable._nullOutEntries(this._elements, this._currentLength);
      for (const first of oldElements) {
        let p = first;
        while (p) {
          const oldNext = p.next;
          p.next = null;
          this._add(p);
          p = oldNext;
        }
      }
    }
    this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));
  }
  _add(element) {
    const hash2 = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);
    element.next = this._elements[hash2];
    this._elements[hash2] = element;
  }
};
HashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];

// node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensStyling.js
init_instantiation();
var ISemanticTokensStylingService = createDecorator("semanticTokensStylingService");

// node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensStylingService.js
init_extensions();
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param8 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SemanticTokensStylingService = class SemanticTokensStylingService2 extends Disposable {
  constructor(_themeService, _logService, _languageService) {
    super();
    this._themeService = _themeService;
    this._logService = _logService;
    this._languageService = _languageService;
    this._caches = /* @__PURE__ */ new WeakMap();
    this._register(this._themeService.onDidColorThemeChange(() => {
      this._caches = /* @__PURE__ */ new WeakMap();
    }));
  }
  getStyling(provider) {
    if (!this._caches.has(provider)) {
      this._caches.set(provider, new SemanticTokensProviderStyling(provider.getLegend(), this._themeService, this._languageService, this._logService));
    }
    return this._caches.get(provider);
  }
};
SemanticTokensStylingService = __decorate8([
  __param8(0, IThemeService),
  __param8(1, ILogService),
  __param8(2, ILanguageService)
], SemanticTokensStylingService);
registerSingleton(
  ISemanticTokensStylingService,
  SemanticTokensStylingService,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/editor/common/languageFeatureRegistry.js
init_event();
init_lifecycle();
init_model();

// node_modules/monaco-editor/esm/vs/base/common/glob.js
init_async();
init_extpath();
init_map();
init_path();
init_platform();
init_strings();
var GLOBSTAR = "**";
var GLOB_SPLIT = "/";
var PATH_REGEX = "[/\\\\]";
var NO_PATH_REGEX = "[^/\\\\]";
var ALL_FORWARD_SLASHES = /\//g;
function starsToRegExp(starCount, isLastPattern) {
  switch (starCount) {
    case 0:
      return "";
    case 1:
      return `${NO_PATH_REGEX}*?`;
    default:
      return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ""})*?`;
  }
}
function splitGlobAware(pattern, splitChar) {
  if (!pattern) {
    return [];
  }
  const segments = [];
  let inBraces = false;
  let inBrackets = false;
  let curVal = "";
  for (const char of pattern) {
    switch (char) {
      case splitChar:
        if (!inBraces && !inBrackets) {
          segments.push(curVal);
          curVal = "";
          continue;
        }
        break;
      case "{":
        inBraces = true;
        break;
      case "}":
        inBraces = false;
        break;
      case "[":
        inBrackets = true;
        break;
      case "]":
        inBrackets = false;
        break;
    }
    curVal += char;
  }
  if (curVal) {
    segments.push(curVal);
  }
  return segments;
}
function parseRegExp(pattern) {
  if (!pattern) {
    return "";
  }
  let regEx = "";
  const segments = splitGlobAware(pattern, GLOB_SPLIT);
  if (segments.every((segment) => segment === GLOBSTAR)) {
    regEx = ".*";
  } else {
    let previousSegmentWasGlobStar = false;
    segments.forEach((segment, index) => {
      if (segment === GLOBSTAR) {
        if (previousSegmentWasGlobStar) {
          return;
        }
        regEx += starsToRegExp(2, index === segments.length - 1);
      } else {
        let inBraces = false;
        let braceVal = "";
        let inBrackets = false;
        let bracketVal = "";
        for (const char of segment) {
          if (char !== "}" && inBraces) {
            braceVal += char;
            continue;
          }
          if (inBrackets && (char !== "]" || !bracketVal)) {
            let res;
            if (char === "-") {
              res = char;
            } else if ((char === "^" || char === "!") && !bracketVal) {
              res = "^";
            } else if (char === GLOB_SPLIT) {
              res = "";
            } else {
              res = escapeRegExpCharacters(char);
            }
            bracketVal += res;
            continue;
          }
          switch (char) {
            case "{":
              inBraces = true;
              continue;
            case "[":
              inBrackets = true;
              continue;
            case "}": {
              const choices = splitGlobAware(braceVal, ",");
              const braceRegExp = `(?:${choices.map((choice) => parseRegExp(choice)).join("|")})`;
              regEx += braceRegExp;
              inBraces = false;
              braceVal = "";
              break;
            }
            case "]": {
              regEx += "[" + bracketVal + "]";
              inBrackets = false;
              bracketVal = "";
              break;
            }
            case "?":
              regEx += NO_PATH_REGEX;
              continue;
            case "*":
              regEx += starsToRegExp(1);
              continue;
            default:
              regEx += escapeRegExpCharacters(char);
          }
        }
        if (index < segments.length - 1 && // more segments to come after this
        (segments[index + 1] !== GLOBSTAR || // next segment is not **, or...
        index + 2 < segments.length)) {
          regEx += PATH_REGEX;
        }
      }
      previousSegmentWasGlobStar = segment === GLOBSTAR;
    });
  }
  return regEx;
}
var T1 = /^\*\*\/\*\.[\w\.-]+$/;
var T2 = /^\*\*\/([\w\.-]+)\/?$/;
var T3 = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/;
var T3_2 = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/;
var T4 = /^\*\*((\/[\w\.-]+)+)\/?$/;
var T5 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/;
var CACHE = new LRUCache(1e4);
var FALSE = function() {
  return false;
};
var NULL = function() {
  return null;
};
function parsePattern(arg1, options2) {
  if (!arg1) {
    return NULL;
  }
  let pattern;
  if (typeof arg1 !== "string") {
    pattern = arg1.pattern;
  } else {
    pattern = arg1;
  }
  pattern = pattern.trim();
  const patternKey = `${pattern}_${!!options2.trimForExclusions}`;
  let parsedPattern = CACHE.get(patternKey);
  if (parsedPattern) {
    return wrapRelativePattern(parsedPattern, arg1);
  }
  let match2;
  if (T1.test(pattern)) {
    parsedPattern = trivia1(pattern.substr(4), pattern);
  } else if (match2 = T2.exec(trimForExclusions(pattern, options2))) {
    parsedPattern = trivia2(match2[1], pattern);
  } else if ((options2.trimForExclusions ? T3_2 : T3).test(pattern)) {
    parsedPattern = trivia3(pattern, options2);
  } else if (match2 = T4.exec(trimForExclusions(pattern, options2))) {
    parsedPattern = trivia4and5(match2[1].substr(1), pattern, true);
  } else if (match2 = T5.exec(trimForExclusions(pattern, options2))) {
    parsedPattern = trivia4and5(match2[1], pattern, false);
  } else {
    parsedPattern = toRegExp(pattern);
  }
  CACHE.set(patternKey, parsedPattern);
  return wrapRelativePattern(parsedPattern, arg1);
}
function wrapRelativePattern(parsedPattern, arg2) {
  if (typeof arg2 === "string") {
    return parsedPattern;
  }
  const wrappedPattern = function(path, basename3) {
    if (!isEqualOrParent(path, arg2.base, !isLinux)) {
      return null;
    }
    return parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename3);
  };
  wrappedPattern.allBasenames = parsedPattern.allBasenames;
  wrappedPattern.allPaths = parsedPattern.allPaths;
  wrappedPattern.basenames = parsedPattern.basenames;
  wrappedPattern.patterns = parsedPattern.patterns;
  return wrappedPattern;
}
function trimForExclusions(pattern, options2) {
  return options2.trimForExclusions && pattern.endsWith("/**") ? pattern.substr(0, pattern.length - 2) : pattern;
}
function trivia1(base, pattern) {
  return function(path, basename3) {
    return typeof path === "string" && path.endsWith(base) ? pattern : null;
  };
}
function trivia2(base, pattern) {
  const slashBase = `/${base}`;
  const backslashBase = `\\${base}`;
  const parsedPattern = function(path, basename3) {
    if (typeof path !== "string") {
      return null;
    }
    if (basename3) {
      return basename3 === base ? pattern : null;
    }
    return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;
  };
  const basenames = [base];
  parsedPattern.basenames = basenames;
  parsedPattern.patterns = [pattern];
  parsedPattern.allBasenames = basenames;
  return parsedPattern;
}
function trivia3(pattern, options2) {
  const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(",").map((pattern2) => parsePattern(pattern2, options2)).filter((pattern2) => pattern2 !== NULL), pattern);
  const patternsLength = parsedPatterns.length;
  if (!patternsLength) {
    return NULL;
  }
  if (patternsLength === 1) {
    return parsedPatterns[0];
  }
  const parsedPattern = function(path, basename3) {
    for (let i = 0, n = parsedPatterns.length; i < n; i++) {
      if (parsedPatterns[i](path, basename3)) {
        return pattern;
      }
    }
    return null;
  };
  const withBasenames = parsedPatterns.find((pattern2) => !!pattern2.allBasenames);
  if (withBasenames) {
    parsedPattern.allBasenames = withBasenames.allBasenames;
  }
  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
  if (allPaths.length) {
    parsedPattern.allPaths = allPaths;
  }
  return parsedPattern;
}
function trivia4and5(targetPath, pattern, matchPathEnds) {
  const usingPosixSep = sep === posix.sep;
  const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);
  const nativePathEnd = sep + nativePath;
  const targetPathEnd = posix.sep + targetPath;
  let parsedPattern;
  if (matchPathEnds) {
    parsedPattern = function(path, basename3) {
      return typeof path === "string" && (path === nativePath || path.endsWith(nativePathEnd) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;
    };
  } else {
    parsedPattern = function(path, basename3) {
      return typeof path === "string" && (path === nativePath || !usingPosixSep && path === targetPath) ? pattern : null;
    };
  }
  parsedPattern.allPaths = [(matchPathEnds ? "*/" : "./") + targetPath];
  return parsedPattern;
}
function toRegExp(pattern) {
  try {
    const regExp = new RegExp(`^${parseRegExp(pattern)}$`);
    return function(path) {
      regExp.lastIndex = 0;
      return typeof path === "string" && regExp.test(path) ? pattern : null;
    };
  } catch (error) {
    return NULL;
  }
}
function match(arg1, path, hasSibling) {
  if (!arg1 || typeof path !== "string") {
    return false;
  }
  return parse(arg1)(path, void 0, hasSibling);
}
function parse(arg1, options2 = {}) {
  if (!arg1) {
    return FALSE;
  }
  if (typeof arg1 === "string" || isRelativePattern(arg1)) {
    const parsedPattern = parsePattern(arg1, options2);
    if (parsedPattern === NULL) {
      return FALSE;
    }
    const resultPattern = function(path, basename3) {
      return !!parsedPattern(path, basename3);
    };
    if (parsedPattern.allBasenames) {
      resultPattern.allBasenames = parsedPattern.allBasenames;
    }
    if (parsedPattern.allPaths) {
      resultPattern.allPaths = parsedPattern.allPaths;
    }
    return resultPattern;
  }
  return parsedExpression(arg1, options2);
}
function isRelativePattern(obj) {
  const rp = obj;
  if (!rp) {
    return false;
  }
  return typeof rp.base === "string" && typeof rp.pattern === "string";
}
function parsedExpression(expression, options2) {
  const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map((pattern) => parseExpressionPattern(pattern, expression[pattern], options2)).filter((pattern) => pattern !== NULL));
  const patternsLength = parsedPatterns.length;
  if (!patternsLength) {
    return NULL;
  }
  if (!parsedPatterns.some((parsedPattern) => !!parsedPattern.requiresSiblings)) {
    if (patternsLength === 1) {
      return parsedPatterns[0];
    }
    const resultExpression2 = function(path, basename3) {
      let resultPromises = void 0;
      for (let i = 0, n = parsedPatterns.length; i < n; i++) {
        const result = parsedPatterns[i](path, basename3);
        if (typeof result === "string") {
          return result;
        }
        if (isThenable(result)) {
          if (!resultPromises) {
            resultPromises = [];
          }
          resultPromises.push(result);
        }
      }
      if (resultPromises) {
        return (async () => {
          for (const resultPromise of resultPromises) {
            const result = await resultPromise;
            if (typeof result === "string") {
              return result;
            }
          }
          return null;
        })();
      }
      return null;
    };
    const withBasenames2 = parsedPatterns.find((pattern) => !!pattern.allBasenames);
    if (withBasenames2) {
      resultExpression2.allBasenames = withBasenames2.allBasenames;
    }
    const allPaths2 = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
    if (allPaths2.length) {
      resultExpression2.allPaths = allPaths2;
    }
    return resultExpression2;
  }
  const resultExpression = function(path, base, hasSibling) {
    let name = void 0;
    let resultPromises = void 0;
    for (let i = 0, n = parsedPatterns.length; i < n; i++) {
      const parsedPattern = parsedPatterns[i];
      if (parsedPattern.requiresSiblings && hasSibling) {
        if (!base) {
          base = basename(path);
        }
        if (!name) {
          name = base.substr(0, base.length - extname(path).length);
        }
      }
      const result = parsedPattern(path, base, name, hasSibling);
      if (typeof result === "string") {
        return result;
      }
      if (isThenable(result)) {
        if (!resultPromises) {
          resultPromises = [];
        }
        resultPromises.push(result);
      }
    }
    if (resultPromises) {
      return (async () => {
        for (const resultPromise of resultPromises) {
          const result = await resultPromise;
          if (typeof result === "string") {
            return result;
          }
        }
        return null;
      })();
    }
    return null;
  };
  const withBasenames = parsedPatterns.find((pattern) => !!pattern.allBasenames);
  if (withBasenames) {
    resultExpression.allBasenames = withBasenames.allBasenames;
  }
  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
  if (allPaths.length) {
    resultExpression.allPaths = allPaths;
  }
  return resultExpression;
}
function parseExpressionPattern(pattern, value, options2) {
  if (value === false) {
    return NULL;
  }
  const parsedPattern = parsePattern(pattern, options2);
  if (parsedPattern === NULL) {
    return NULL;
  }
  if (typeof value === "boolean") {
    return parsedPattern;
  }
  if (value) {
    const when = value.when;
    if (typeof when === "string") {
      const result = (path, basename3, name, hasSibling) => {
        if (!hasSibling || !parsedPattern(path, basename3)) {
          return null;
        }
        const clausePattern = when.replace("$(basename)", () => name);
        const matched = hasSibling(clausePattern);
        return isThenable(matched) ? matched.then((match2) => match2 ? pattern : null) : matched ? pattern : null;
      };
      result.requiresSiblings = true;
      return result;
    }
  }
  return parsedPattern;
}
function aggregateBasenameMatches(parsedPatterns, result) {
  const basenamePatterns = parsedPatterns.filter((parsedPattern) => !!parsedPattern.basenames);
  if (basenamePatterns.length < 2) {
    return parsedPatterns;
  }
  const basenames = basenamePatterns.reduce((all, current) => {
    const basenames2 = current.basenames;
    return basenames2 ? all.concat(basenames2) : all;
  }, []);
  let patterns;
  if (result) {
    patterns = [];
    for (let i = 0, n = basenames.length; i < n; i++) {
      patterns.push(result);
    }
  } else {
    patterns = basenamePatterns.reduce((all, current) => {
      const patterns2 = current.patterns;
      return patterns2 ? all.concat(patterns2) : all;
    }, []);
  }
  const aggregate = function(path, basename3) {
    if (typeof path !== "string") {
      return null;
    }
    if (!basename3) {
      let i;
      for (i = path.length; i > 0; i--) {
        const ch = path.charCodeAt(i - 1);
        if (ch === 47 || ch === 92) {
          break;
        }
      }
      basename3 = path.substr(i);
    }
    const index = basenames.indexOf(basename3);
    return index !== -1 ? patterns[index] : null;
  };
  aggregate.basenames = basenames;
  aggregate.patterns = patterns;
  aggregate.allBasenames = basenames;
  const aggregatedPatterns = parsedPatterns.filter((parsedPattern) => !parsedPattern.basenames);
  aggregatedPatterns.push(aggregate);
  return aggregatedPatterns;
}

// node_modules/monaco-editor/esm/vs/editor/common/languageSelector.js
init_path();
function score(selector, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType) {
  if (Array.isArray(selector)) {
    let ret = 0;
    for (const filter of selector) {
      const value = score(filter, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType);
      if (value === 10) {
        return value;
      }
      if (value > ret) {
        ret = value;
      }
    }
    return ret;
  } else if (typeof selector === "string") {
    if (!candidateIsSynchronized) {
      return 0;
    }
    if (selector === "*") {
      return 5;
    } else if (selector === candidateLanguage) {
      return 10;
    } else {
      return 0;
    }
  } else if (selector) {
    const { language, pattern, scheme, hasAccessToAllModels, notebookType } = selector;
    if (!candidateIsSynchronized && !hasAccessToAllModels) {
      return 0;
    }
    if (notebookType && candidateNotebookUri) {
      candidateUri = candidateNotebookUri;
    }
    let ret = 0;
    if (scheme) {
      if (scheme === candidateUri.scheme) {
        ret = 10;
      } else if (scheme === "*") {
        ret = 5;
      } else {
        return 0;
      }
    }
    if (language) {
      if (language === candidateLanguage) {
        ret = 10;
      } else if (language === "*") {
        ret = Math.max(ret, 5);
      } else {
        return 0;
      }
    }
    if (notebookType) {
      if (notebookType === candidateNotebookType) {
        ret = 10;
      } else if (notebookType === "*" && candidateNotebookType !== void 0) {
        ret = Math.max(ret, 5);
      } else {
        return 0;
      }
    }
    if (pattern) {
      let normalizedPattern;
      if (typeof pattern === "string") {
        normalizedPattern = pattern;
      } else {
        normalizedPattern = { ...pattern, base: normalize(pattern.base) };
      }
      if (normalizedPattern === candidateUri.fsPath || match(normalizedPattern, candidateUri.fsPath)) {
        ret = 10;
      } else {
        return 0;
      }
    }
    return ret;
  } else {
    return 0;
  }
}

// node_modules/monaco-editor/esm/vs/editor/common/languageFeatureRegistry.js
function isExclusive(selector) {
  if (typeof selector === "string") {
    return false;
  } else if (Array.isArray(selector)) {
    return selector.every(isExclusive);
  } else {
    return !!selector.exclusive;
  }
}
var MatchCandidate = class {
  constructor(uri, languageId, notebookUri, notebookType) {
    this.uri = uri;
    this.languageId = languageId;
    this.notebookUri = notebookUri;
    this.notebookType = notebookType;
  }
  equals(other) {
    var _a2, _b2;
    return this.notebookType === other.notebookType && this.languageId === other.languageId && this.uri.toString() === other.uri.toString() && ((_a2 = this.notebookUri) === null || _a2 === void 0 ? void 0 : _a2.toString()) === ((_b2 = other.notebookUri) === null || _b2 === void 0 ? void 0 : _b2.toString());
  }
};
var LanguageFeatureRegistry = class _LanguageFeatureRegistry {
  constructor(_notebookInfoResolver) {
    this._notebookInfoResolver = _notebookInfoResolver;
    this._clock = 0;
    this._entries = [];
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
  }
  register(selector, provider) {
    let entry = {
      selector,
      provider,
      _score: -1,
      _time: this._clock++
    };
    this._entries.push(entry);
    this._lastCandidate = void 0;
    this._onDidChange.fire(this._entries.length);
    return toDisposable(() => {
      if (entry) {
        const idx = this._entries.indexOf(entry);
        if (idx >= 0) {
          this._entries.splice(idx, 1);
          this._lastCandidate = void 0;
          this._onDidChange.fire(this._entries.length);
          entry = void 0;
        }
      }
    });
  }
  has(model) {
    return this.all(model).length > 0;
  }
  all(model) {
    if (!model) {
      return [];
    }
    this._updateScores(model);
    const result = [];
    for (const entry of this._entries) {
      if (entry._score > 0) {
        result.push(entry.provider);
      }
    }
    return result;
  }
  ordered(model) {
    const result = [];
    this._orderedForEach(model, (entry) => result.push(entry.provider));
    return result;
  }
  orderedGroups(model) {
    const result = [];
    let lastBucket;
    let lastBucketScore;
    this._orderedForEach(model, (entry) => {
      if (lastBucket && lastBucketScore === entry._score) {
        lastBucket.push(entry.provider);
      } else {
        lastBucketScore = entry._score;
        lastBucket = [entry.provider];
        result.push(lastBucket);
      }
    });
    return result;
  }
  _orderedForEach(model, callback) {
    this._updateScores(model);
    for (const entry of this._entries) {
      if (entry._score > 0) {
        callback(entry);
      }
    }
  }
  _updateScores(model) {
    var _a2, _b2;
    const notebookInfo = (_a2 = this._notebookInfoResolver) === null || _a2 === void 0 ? void 0 : _a2.call(this, model.uri);
    const candidate = notebookInfo ? new MatchCandidate(model.uri, model.getLanguageId(), notebookInfo.uri, notebookInfo.type) : new MatchCandidate(model.uri, model.getLanguageId(), void 0, void 0);
    if ((_b2 = this._lastCandidate) === null || _b2 === void 0 ? void 0 : _b2.equals(candidate)) {
      return;
    }
    this._lastCandidate = candidate;
    for (const entry of this._entries) {
      entry._score = score(entry.selector, candidate.uri, candidate.languageId, shouldSynchronizeModel(model), candidate.notebookUri, candidate.notebookType);
      if (isExclusive(entry.selector) && entry._score > 0) {
        for (const entry2 of this._entries) {
          entry2._score = 0;
        }
        entry._score = 1e3;
        break;
      }
    }
    this._entries.sort(_LanguageFeatureRegistry._compareByScoreAndTime);
  }
  static _compareByScoreAndTime(a, b) {
    if (a._score < b._score) {
      return 1;
    } else if (a._score > b._score) {
      return -1;
    }
    if (isBuiltinSelector(a.selector) && !isBuiltinSelector(b.selector)) {
      return 1;
    } else if (!isBuiltinSelector(a.selector) && isBuiltinSelector(b.selector)) {
      return -1;
    }
    if (a._time < b._time) {
      return 1;
    } else if (a._time > b._time) {
      return -1;
    } else {
      return 0;
    }
  }
};
function isBuiltinSelector(selector) {
  if (typeof selector === "string") {
    return false;
  }
  if (Array.isArray(selector)) {
    return selector.some(isBuiltinSelector);
  }
  return Boolean(selector.isBuiltin);
}

// node_modules/monaco-editor/esm/vs/editor/common/services/languageFeaturesService.js
init_languageFeatures();
init_extensions();
var LanguageFeaturesService = class {
  constructor() {
    this.referenceProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.renameProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.newSymbolNamesProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.codeActionProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.definitionProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.typeDefinitionProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.declarationProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.implementationProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.documentSymbolProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.inlayHintsProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.colorProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.codeLensProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.documentFormattingEditProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.documentRangeFormattingEditProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.onTypeFormattingEditProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.signatureHelpProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.hoverProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.documentHighlightProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.multiDocumentHighlightProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.selectionRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.foldingRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.linkProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.inlineCompletionsProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.inlineEditProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.completionProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.linkedEditingRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.documentRangeSemanticTokensProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.documentSemanticTokensProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.documentOnDropEditProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.documentPasteEditProvider = new LanguageFeatureRegistry(this._score.bind(this));
  }
  _score(uri) {
    var _a2;
    return (_a2 = this._notebookTypeResolver) === null || _a2 === void 0 ? void 0 : _a2.call(this, uri);
  }
};
registerSingleton(
  ILanguageFeaturesService,
  LanguageFeaturesService,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/editor/browser/services/hoverService.js
init_extensions();
init_themeService();
init_colorRegistry();

// node_modules/monaco-editor/esm/vs/platform/hover/browser/hover.js
init_instantiation();
init_lifecycle();
init_configuration();
init_dom();
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param9 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var IHoverService = createDecorator("hoverService");
var WorkbenchHoverDelegate = class WorkbenchHoverDelegate2 extends Disposable {
  get delay() {
    if (this.instantHover && Date.now() - this.lastHoverHideTime < this.timeLimit) {
      return 0;
    }
    return this._delay;
  }
  constructor(placement, instantHover, overrideOptions = {}, configurationService, hoverService) {
    super();
    this.placement = placement;
    this.instantHover = instantHover;
    this.overrideOptions = overrideOptions;
    this.configurationService = configurationService;
    this.hoverService = hoverService;
    this.lastHoverHideTime = Number.MAX_VALUE;
    this.timeLimit = 200;
    this.hoverDisposables = this._register(new DisposableStore());
    this._delay = this.configurationService.getValue("workbench.hover.delay");
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("workbench.hover.delay")) {
        this._delay = this.configurationService.getValue("workbench.hover.delay");
      }
    }));
  }
  showHover(options2, focus) {
    const overrideOptions = typeof this.overrideOptions === "function" ? this.overrideOptions(options2, focus) : this.overrideOptions;
    this.hoverDisposables.clear();
    const targets = options2.target instanceof HTMLElement ? [options2.target] : options2.target.targetElements;
    for (const target of targets) {
      this.hoverDisposables.add(addStandardDisposableListener(target, "keydown", (e) => {
        if (e.equals(
          9
          /* KeyCode.Escape */
        )) {
          this.hoverService.hideHover();
        }
      }));
    }
    return this.hoverService.showHover({
      ...options2,
      persistence: {
        hideOnHover: true
      },
      ...overrideOptions
    }, focus);
  }
  onDidHideHover() {
    this.hoverDisposables.clear();
    if (this.instantHover) {
      this.lastHoverHideTime = Date.now();
    }
  }
};
WorkbenchHoverDelegate = __decorate9([
  __param9(3, IConfigurationService),
  __param9(4, IHoverService)
], WorkbenchHoverDelegate);

// node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextView.js
init_instantiation();
var IContextViewService = createDecorator("contextViewService");
var IContextMenuService = createDecorator("contextMenuService");

// node_modules/monaco-editor/esm/vs/editor/browser/services/hoverService.js
init_instantiation();

// node_modules/monaco-editor/esm/vs/editor/browser/widget/hoverWidget/hoverWidget.js
init_lifecycle();
init_event();
init_dom();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/editor/browser/widget/hoverWidget/hover.css";

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybinding.js
init_instantiation();
var IKeybindingService = createDecorator("keybindingService");

// node_modules/monaco-editor/esm/vs/editor/browser/widget/hoverWidget/hoverWidget.js
init_configuration();

// node_modules/monaco-editor/esm/vs/editor/common/config/editorOptions.js
init_arrays();
init_objects();
init_platform();
init_textModelDefaults();
init_wordHelper();
init_nls();
var MINIMAP_GUTTER_WIDTH = 8;
var ConfigurationChangedEvent = class {
  /**
   * @internal
   */
  constructor(values) {
    this._values = values;
  }
  hasChanged(id) {
    return this._values[id];
  }
};
var ComputeOptionsMemory = class {
  constructor() {
    this.stableMinimapLayoutInput = null;
    this.stableFitMaxMinimapScale = 0;
    this.stableFitRemainingWidth = 0;
  }
};
var BaseEditorOption = class {
  constructor(id, name, defaultValue, schema) {
    this.id = id;
    this.name = name;
    this.defaultValue = defaultValue;
    this.schema = schema;
  }
  applyUpdate(value, update) {
    return applyUpdate(value, update);
  }
  compute(env, options2, value) {
    return value;
  }
};
var ApplyUpdateResult = class {
  constructor(newValue, didChange) {
    this.newValue = newValue;
    this.didChange = didChange;
  }
};
function applyUpdate(value, update) {
  if (typeof value !== "object" || typeof update !== "object" || !value || !update) {
    return new ApplyUpdateResult(update, value !== update);
  }
  if (Array.isArray(value) || Array.isArray(update)) {
    const arrayEquals = Array.isArray(value) && Array.isArray(update) && equals(value, update);
    return new ApplyUpdateResult(update, !arrayEquals);
  }
  let didChange = false;
  for (const key in update) {
    if (update.hasOwnProperty(key)) {
      const result = applyUpdate(value[key], update[key]);
      if (result.didChange) {
        value[key] = result.newValue;
        didChange = true;
      }
    }
  }
  return new ApplyUpdateResult(value, didChange);
}
var ComputedEditorOption = class {
  constructor(id) {
    this.schema = void 0;
    this.id = id;
    this.name = "_never_";
    this.defaultValue = void 0;
  }
  applyUpdate(value, update) {
    return applyUpdate(value, update);
  }
  validate(input) {
    return this.defaultValue;
  }
};
var SimpleEditorOption = class {
  constructor(id, name, defaultValue, schema) {
    this.id = id;
    this.name = name;
    this.defaultValue = defaultValue;
    this.schema = schema;
  }
  applyUpdate(value, update) {
    return applyUpdate(value, update);
  }
  validate(input) {
    if (typeof input === "undefined") {
      return this.defaultValue;
    }
    return input;
  }
  compute(env, options2, value) {
    return value;
  }
};
function boolean(value, defaultValue) {
  if (typeof value === "undefined") {
    return defaultValue;
  }
  if (value === "false") {
    return false;
  }
  return Boolean(value);
}
var EditorBooleanOption = class extends SimpleEditorOption {
  constructor(id, name, defaultValue, schema = void 0) {
    if (typeof schema !== "undefined") {
      schema.type = "boolean";
      schema.default = defaultValue;
    }
    super(id, name, defaultValue, schema);
  }
  validate(input) {
    return boolean(input, this.defaultValue);
  }
};
function clampedInt(value, defaultValue, minimum, maximum) {
  if (typeof value === "undefined") {
    return defaultValue;
  }
  let r = parseInt(value, 10);
  if (isNaN(r)) {
    return defaultValue;
  }
  r = Math.max(minimum, r);
  r = Math.min(maximum, r);
  return r | 0;
}
var EditorIntOption = class _EditorIntOption extends SimpleEditorOption {
  static clampedInt(value, defaultValue, minimum, maximum) {
    return clampedInt(value, defaultValue, minimum, maximum);
  }
  constructor(id, name, defaultValue, minimum, maximum, schema = void 0) {
    if (typeof schema !== "undefined") {
      schema.type = "integer";
      schema.default = defaultValue;
      schema.minimum = minimum;
      schema.maximum = maximum;
    }
    super(id, name, defaultValue, schema);
    this.minimum = minimum;
    this.maximum = maximum;
  }
  validate(input) {
    return _EditorIntOption.clampedInt(input, this.defaultValue, this.minimum, this.maximum);
  }
};
function clampedFloat(value, defaultValue, minimum, maximum) {
  if (typeof value === "undefined") {
    return defaultValue;
  }
  const r = EditorFloatOption.float(value, defaultValue);
  return EditorFloatOption.clamp(r, minimum, maximum);
}
var EditorFloatOption = class _EditorFloatOption extends SimpleEditorOption {
  static clamp(n, min, max) {
    if (n < min) {
      return min;
    }
    if (n > max) {
      return max;
    }
    return n;
  }
  static float(value, defaultValue) {
    if (typeof value === "number") {
      return value;
    }
    if (typeof value === "undefined") {
      return defaultValue;
    }
    const r = parseFloat(value);
    return isNaN(r) ? defaultValue : r;
  }
  constructor(id, name, defaultValue, validationFn, schema) {
    if (typeof schema !== "undefined") {
      schema.type = "number";
      schema.default = defaultValue;
    }
    super(id, name, defaultValue, schema);
    this.validationFn = validationFn;
  }
  validate(input) {
    return this.validationFn(_EditorFloatOption.float(input, this.defaultValue));
  }
};
var EditorStringOption = class _EditorStringOption extends SimpleEditorOption {
  static string(value, defaultValue) {
    if (typeof value !== "string") {
      return defaultValue;
    }
    return value;
  }
  constructor(id, name, defaultValue, schema = void 0) {
    if (typeof schema !== "undefined") {
      schema.type = "string";
      schema.default = defaultValue;
    }
    super(id, name, defaultValue, schema);
  }
  validate(input) {
    return _EditorStringOption.string(input, this.defaultValue);
  }
};
function stringSet(value, defaultValue, allowedValues, renamedValues) {
  if (typeof value !== "string") {
    return defaultValue;
  }
  if (renamedValues && value in renamedValues) {
    return renamedValues[value];
  }
  if (allowedValues.indexOf(value) === -1) {
    return defaultValue;
  }
  return value;
}
var EditorStringEnumOption = class extends SimpleEditorOption {
  constructor(id, name, defaultValue, allowedValues, schema = void 0) {
    if (typeof schema !== "undefined") {
      schema.type = "string";
      schema.enum = allowedValues;
      schema.default = defaultValue;
    }
    super(id, name, defaultValue, schema);
    this._allowedValues = allowedValues;
  }
  validate(input) {
    return stringSet(input, this.defaultValue, this._allowedValues);
  }
};
var EditorEnumOption = class extends BaseEditorOption {
  constructor(id, name, defaultValue, defaultStringValue, allowedValues, convert, schema = void 0) {
    if (typeof schema !== "undefined") {
      schema.type = "string";
      schema.enum = allowedValues;
      schema.default = defaultStringValue;
    }
    super(id, name, defaultValue, schema);
    this._allowedValues = allowedValues;
    this._convert = convert;
  }
  validate(input) {
    if (typeof input !== "string") {
      return this.defaultValue;
    }
    if (this._allowedValues.indexOf(input) === -1) {
      return this.defaultValue;
    }
    return this._convert(input);
  }
};
function _autoIndentFromString(autoIndent) {
  switch (autoIndent) {
    case "none":
      return 0;
    case "keep":
      return 1;
    case "brackets":
      return 2;
    case "advanced":
      return 3;
    case "full":
      return 4;
  }
}
var EditorAccessibilitySupport = class extends BaseEditorOption {
  constructor() {
    super(2, "accessibilitySupport", 0, {
      type: "string",
      enum: ["auto", "on", "off"],
      enumDescriptions: [
        localize("accessibilitySupport.auto", "Use platform APIs to detect when a Screen Reader is attached."),
        localize("accessibilitySupport.on", "Optimize for usage with a Screen Reader."),
        localize("accessibilitySupport.off", "Assume a screen reader is not attached.")
      ],
      default: "auto",
      tags: ["accessibility"],
      description: localize("accessibilitySupport", "Controls if the UI should run in a mode where it is optimized for screen readers.")
    });
  }
  validate(input) {
    switch (input) {
      case "auto":
        return 0;
      case "off":
        return 1;
      case "on":
        return 2;
    }
    return this.defaultValue;
  }
  compute(env, options2, value) {
    if (value === 0) {
      return env.accessibilitySupport;
    }
    return value;
  }
};
var EditorComments = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      insertSpace: true,
      ignoreEmptyLines: true
    };
    super(23, "comments", defaults, {
      "editor.comments.insertSpace": {
        type: "boolean",
        default: defaults.insertSpace,
        description: localize("comments.insertSpace", "Controls whether a space character is inserted when commenting.")
      },
      "editor.comments.ignoreEmptyLines": {
        type: "boolean",
        default: defaults.ignoreEmptyLines,
        description: localize("comments.ignoreEmptyLines", "Controls if empty lines should be ignored with toggle, add or remove actions for line comments.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      insertSpace: boolean(input.insertSpace, this.defaultValue.insertSpace),
      ignoreEmptyLines: boolean(input.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines)
    };
  }
};
function _cursorBlinkingStyleFromString(cursorBlinkingStyle) {
  switch (cursorBlinkingStyle) {
    case "blink":
      return 1;
    case "smooth":
      return 2;
    case "phase":
      return 3;
    case "expand":
      return 4;
    case "solid":
      return 5;
  }
}
var TextEditorCursorStyle;
(function(TextEditorCursorStyle3) {
  TextEditorCursorStyle3[TextEditorCursorStyle3["Line"] = 1] = "Line";
  TextEditorCursorStyle3[TextEditorCursorStyle3["Block"] = 2] = "Block";
  TextEditorCursorStyle3[TextEditorCursorStyle3["Underline"] = 3] = "Underline";
  TextEditorCursorStyle3[TextEditorCursorStyle3["LineThin"] = 4] = "LineThin";
  TextEditorCursorStyle3[TextEditorCursorStyle3["BlockOutline"] = 5] = "BlockOutline";
  TextEditorCursorStyle3[TextEditorCursorStyle3["UnderlineThin"] = 6] = "UnderlineThin";
})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
function _cursorStyleFromString(cursorStyle) {
  switch (cursorStyle) {
    case "line":
      return TextEditorCursorStyle.Line;
    case "block":
      return TextEditorCursorStyle.Block;
    case "underline":
      return TextEditorCursorStyle.Underline;
    case "line-thin":
      return TextEditorCursorStyle.LineThin;
    case "block-outline":
      return TextEditorCursorStyle.BlockOutline;
    case "underline-thin":
      return TextEditorCursorStyle.UnderlineThin;
  }
}
var EditorClassName = class extends ComputedEditorOption {
  constructor() {
    super(
      141
      /* EditorOption.editorClassName */
    );
  }
  compute(env, options2, _) {
    const classNames = ["monaco-editor"];
    if (options2.get(
      39
      /* EditorOption.extraEditorClassName */
    )) {
      classNames.push(options2.get(
        39
        /* EditorOption.extraEditorClassName */
      ));
    }
    if (env.extraEditorClassName) {
      classNames.push(env.extraEditorClassName);
    }
    if (options2.get(
      74
      /* EditorOption.mouseStyle */
    ) === "default") {
      classNames.push("mouse-default");
    } else if (options2.get(
      74
      /* EditorOption.mouseStyle */
    ) === "copy") {
      classNames.push("mouse-copy");
    }
    if (options2.get(
      111
      /* EditorOption.showUnused */
    )) {
      classNames.push("showUnused");
    }
    if (options2.get(
      139
      /* EditorOption.showDeprecated */
    )) {
      classNames.push("showDeprecated");
    }
    return classNames.join(" ");
  }
};
var EditorEmptySelectionClipboard = class extends EditorBooleanOption {
  constructor() {
    super(37, "emptySelectionClipboard", true, { description: localize("emptySelectionClipboard", "Controls whether copying without a selection copies the current line.") });
  }
  compute(env, options2, value) {
    return value && env.emptySelectionClipboard;
  }
};
var EditorFind = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      cursorMoveOnType: true,
      seedSearchStringFromSelection: "always",
      autoFindInSelection: "never",
      globalFindClipboard: false,
      addExtraSpaceOnTop: true,
      loop: true
    };
    super(41, "find", defaults, {
      "editor.find.cursorMoveOnType": {
        type: "boolean",
        default: defaults.cursorMoveOnType,
        description: localize("find.cursorMoveOnType", "Controls whether the cursor should jump to find matches while typing.")
      },
      "editor.find.seedSearchStringFromSelection": {
        type: "string",
        enum: ["never", "always", "selection"],
        default: defaults.seedSearchStringFromSelection,
        enumDescriptions: [
          localize("editor.find.seedSearchStringFromSelection.never", "Never seed search string from the editor selection."),
          localize("editor.find.seedSearchStringFromSelection.always", "Always seed search string from the editor selection, including word at cursor position."),
          localize("editor.find.seedSearchStringFromSelection.selection", "Only seed search string from the editor selection.")
        ],
        description: localize("find.seedSearchStringFromSelection", "Controls whether the search string in the Find Widget is seeded from the editor selection.")
      },
      "editor.find.autoFindInSelection": {
        type: "string",
        enum: ["never", "always", "multiline"],
        default: defaults.autoFindInSelection,
        enumDescriptions: [
          localize("editor.find.autoFindInSelection.never", "Never turn on Find in Selection automatically (default)."),
          localize("editor.find.autoFindInSelection.always", "Always turn on Find in Selection automatically."),
          localize("editor.find.autoFindInSelection.multiline", "Turn on Find in Selection automatically when multiple lines of content are selected.")
        ],
        description: localize("find.autoFindInSelection", "Controls the condition for turning on Find in Selection automatically.")
      },
      "editor.find.globalFindClipboard": {
        type: "boolean",
        default: defaults.globalFindClipboard,
        description: localize("find.globalFindClipboard", "Controls whether the Find Widget should read or modify the shared find clipboard on macOS."),
        included: isMacintosh
      },
      "editor.find.addExtraSpaceOnTop": {
        type: "boolean",
        default: defaults.addExtraSpaceOnTop,
        description: localize("find.addExtraSpaceOnTop", "Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.")
      },
      "editor.find.loop": {
        type: "boolean",
        default: defaults.loop,
        description: localize("find.loop", "Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      cursorMoveOnType: boolean(input.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
      seedSearchStringFromSelection: typeof _input.seedSearchStringFromSelection === "boolean" ? _input.seedSearchStringFromSelection ? "always" : "never" : stringSet(input.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, ["never", "always", "selection"]),
      autoFindInSelection: typeof _input.autoFindInSelection === "boolean" ? _input.autoFindInSelection ? "always" : "never" : stringSet(input.autoFindInSelection, this.defaultValue.autoFindInSelection, ["never", "always", "multiline"]),
      globalFindClipboard: boolean(input.globalFindClipboard, this.defaultValue.globalFindClipboard),
      addExtraSpaceOnTop: boolean(input.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
      loop: boolean(input.loop, this.defaultValue.loop)
    };
  }
};
var EditorFontLigatures = class _EditorFontLigatures extends BaseEditorOption {
  constructor() {
    super(51, "fontLigatures", _EditorFontLigatures.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: localize("fontLigatures", "Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.")
        },
        {
          type: "string",
          description: localize("fontFeatureSettings", "Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.")
        }
      ],
      description: localize("fontLigaturesGeneral", "Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property."),
      default: false
    });
  }
  validate(input) {
    if (typeof input === "undefined") {
      return this.defaultValue;
    }
    if (typeof input === "string") {
      if (input === "false" || input.length === 0) {
        return _EditorFontLigatures.OFF;
      }
      if (input === "true") {
        return _EditorFontLigatures.ON;
      }
      return input;
    }
    if (Boolean(input)) {
      return _EditorFontLigatures.ON;
    }
    return _EditorFontLigatures.OFF;
  }
};
EditorFontLigatures.OFF = '"liga" off, "calt" off';
EditorFontLigatures.ON = '"liga" on, "calt" on';
var EditorFontVariations = class _EditorFontVariations extends BaseEditorOption {
  constructor() {
    super(54, "fontVariations", _EditorFontVariations.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: localize("fontVariations", "Enables/Disables the translation from font-weight to font-variation-settings. Change this to a string for fine-grained control of the 'font-variation-settings' CSS property.")
        },
        {
          type: "string",
          description: localize("fontVariationSettings", "Explicit 'font-variation-settings' CSS property. A boolean can be passed instead if one only needs to translate font-weight to font-variation-settings.")
        }
      ],
      description: localize("fontVariationsGeneral", "Configures font variations. Can be either a boolean to enable/disable the translation from font-weight to font-variation-settings or a string for the value of the CSS 'font-variation-settings' property."),
      default: false
    });
  }
  validate(input) {
    if (typeof input === "undefined") {
      return this.defaultValue;
    }
    if (typeof input === "string") {
      if (input === "false") {
        return _EditorFontVariations.OFF;
      }
      if (input === "true") {
        return _EditorFontVariations.TRANSLATE;
      }
      return input;
    }
    if (Boolean(input)) {
      return _EditorFontVariations.TRANSLATE;
    }
    return _EditorFontVariations.OFF;
  }
  compute(env, options2, value) {
    return env.fontInfo.fontVariationSettings;
  }
};
EditorFontVariations.OFF = "normal";
EditorFontVariations.TRANSLATE = "translate";
var EditorFontInfo = class extends ComputedEditorOption {
  constructor() {
    super(
      50
      /* EditorOption.fontInfo */
    );
  }
  compute(env, options2, _) {
    return env.fontInfo;
  }
};
var EditorFontSize = class extends SimpleEditorOption {
  constructor() {
    super(52, "fontSize", EDITOR_FONT_DEFAULTS.fontSize, {
      type: "number",
      minimum: 6,
      maximum: 100,
      default: EDITOR_FONT_DEFAULTS.fontSize,
      description: localize("fontSize", "Controls the font size in pixels.")
    });
  }
  validate(input) {
    const r = EditorFloatOption.float(input, this.defaultValue);
    if (r === 0) {
      return EDITOR_FONT_DEFAULTS.fontSize;
    }
    return EditorFloatOption.clamp(r, 6, 100);
  }
  compute(env, options2, value) {
    return env.fontInfo.fontSize;
  }
};
var EditorFontWeight = class _EditorFontWeight extends BaseEditorOption {
  constructor() {
    super(53, "fontWeight", EDITOR_FONT_DEFAULTS.fontWeight, {
      anyOf: [
        {
          type: "number",
          minimum: _EditorFontWeight.MINIMUM_VALUE,
          maximum: _EditorFontWeight.MAXIMUM_VALUE,
          errorMessage: localize("fontWeightErrorMessage", 'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.')
        },
        {
          type: "string",
          pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
        },
        {
          enum: _EditorFontWeight.SUGGESTION_VALUES
        }
      ],
      default: EDITOR_FONT_DEFAULTS.fontWeight,
      description: localize("fontWeight", 'Controls the font weight. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.')
    });
  }
  validate(input) {
    if (input === "normal" || input === "bold") {
      return input;
    }
    return String(EditorIntOption.clampedInt(input, EDITOR_FONT_DEFAULTS.fontWeight, _EditorFontWeight.MINIMUM_VALUE, _EditorFontWeight.MAXIMUM_VALUE));
  }
};
EditorFontWeight.SUGGESTION_VALUES = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
EditorFontWeight.MINIMUM_VALUE = 1;
EditorFontWeight.MAXIMUM_VALUE = 1e3;
var EditorGoToLocation = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      multiple: "peek",
      multipleDefinitions: "peek",
      multipleTypeDefinitions: "peek",
      multipleDeclarations: "peek",
      multipleImplementations: "peek",
      multipleReferences: "peek",
      alternativeDefinitionCommand: "editor.action.goToReferences",
      alternativeTypeDefinitionCommand: "editor.action.goToReferences",
      alternativeDeclarationCommand: "editor.action.goToReferences",
      alternativeImplementationCommand: "",
      alternativeReferenceCommand: ""
    };
    const jsonSubset = {
      type: "string",
      enum: ["peek", "gotoAndPeek", "goto"],
      default: defaults.multiple,
      enumDescriptions: [
        localize("editor.gotoLocation.multiple.peek", "Show Peek view of the results (default)"),
        localize("editor.gotoLocation.multiple.gotoAndPeek", "Go to the primary result and show a Peek view"),
        localize("editor.gotoLocation.multiple.goto", "Go to the primary result and enable Peek-less navigation to others")
      ]
    };
    const alternativeCommandOptions = ["", "editor.action.referenceSearch.trigger", "editor.action.goToReferences", "editor.action.peekImplementation", "editor.action.goToImplementation", "editor.action.peekTypeDefinition", "editor.action.goToTypeDefinition", "editor.action.peekDeclaration", "editor.action.revealDeclaration", "editor.action.peekDefinition", "editor.action.revealDefinitionAside", "editor.action.revealDefinition"];
    super(58, "gotoLocation", defaults, {
      "editor.gotoLocation.multiple": {
        deprecationMessage: localize("editor.gotoLocation.multiple.deprecated", "This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.")
      },
      "editor.gotoLocation.multipleDefinitions": {
        description: localize("editor.editor.gotoLocation.multipleDefinitions", "Controls the behavior the 'Go to Definition'-command when multiple target locations exist."),
        ...jsonSubset
      },
      "editor.gotoLocation.multipleTypeDefinitions": {
        description: localize("editor.editor.gotoLocation.multipleTypeDefinitions", "Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist."),
        ...jsonSubset
      },
      "editor.gotoLocation.multipleDeclarations": {
        description: localize("editor.editor.gotoLocation.multipleDeclarations", "Controls the behavior the 'Go to Declaration'-command when multiple target locations exist."),
        ...jsonSubset
      },
      "editor.gotoLocation.multipleImplementations": {
        description: localize("editor.editor.gotoLocation.multipleImplemenattions", "Controls the behavior the 'Go to Implementations'-command when multiple target locations exist."),
        ...jsonSubset
      },
      "editor.gotoLocation.multipleReferences": {
        description: localize("editor.editor.gotoLocation.multipleReferences", "Controls the behavior the 'Go to References'-command when multiple target locations exist."),
        ...jsonSubset
      },
      "editor.gotoLocation.alternativeDefinitionCommand": {
        type: "string",
        default: defaults.alternativeDefinitionCommand,
        enum: alternativeCommandOptions,
        description: localize("alternativeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeTypeDefinitionCommand": {
        type: "string",
        default: defaults.alternativeTypeDefinitionCommand,
        enum: alternativeCommandOptions,
        description: localize("alternativeTypeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeDeclarationCommand": {
        type: "string",
        default: defaults.alternativeDeclarationCommand,
        enum: alternativeCommandOptions,
        description: localize("alternativeDeclarationCommand", "Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.")
      },
      "editor.gotoLocation.alternativeImplementationCommand": {
        type: "string",
        default: defaults.alternativeImplementationCommand,
        enum: alternativeCommandOptions,
        description: localize("alternativeImplementationCommand", "Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.")
      },
      "editor.gotoLocation.alternativeReferenceCommand": {
        type: "string",
        default: defaults.alternativeReferenceCommand,
        enum: alternativeCommandOptions,
        description: localize("alternativeReferenceCommand", "Alternative command id that is being executed when the result of 'Go to Reference' is the current location.")
      }
    });
  }
  validate(_input) {
    var _a2, _b2, _c, _d, _e;
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      multiple: stringSet(input.multiple, this.defaultValue.multiple, ["peek", "gotoAndPeek", "goto"]),
      multipleDefinitions: (_a2 = input.multipleDefinitions) !== null && _a2 !== void 0 ? _a2 : stringSet(input.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleTypeDefinitions: (_b2 = input.multipleTypeDefinitions) !== null && _b2 !== void 0 ? _b2 : stringSet(input.multipleTypeDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleDeclarations: (_c = input.multipleDeclarations) !== null && _c !== void 0 ? _c : stringSet(input.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleImplementations: (_d = input.multipleImplementations) !== null && _d !== void 0 ? _d : stringSet(input.multipleImplementations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleReferences: (_e = input.multipleReferences) !== null && _e !== void 0 ? _e : stringSet(input.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
      alternativeDefinitionCommand: EditorStringOption.string(input.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
      alternativeTypeDefinitionCommand: EditorStringOption.string(input.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
      alternativeDeclarationCommand: EditorStringOption.string(input.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
      alternativeImplementationCommand: EditorStringOption.string(input.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),
      alternativeReferenceCommand: EditorStringOption.string(input.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand)
    };
  }
};
var EditorHover = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      enabled: true,
      delay: 300,
      hidingDelay: 300,
      sticky: true,
      above: true
    };
    super(60, "hover", defaults, {
      "editor.hover.enabled": {
        type: "boolean",
        default: defaults.enabled,
        description: localize("hover.enabled", "Controls whether the hover is shown.")
      },
      "editor.hover.delay": {
        type: "number",
        default: defaults.delay,
        minimum: 0,
        maximum: 1e4,
        description: localize("hover.delay", "Controls the delay in milliseconds after which the hover is shown.")
      },
      "editor.hover.sticky": {
        type: "boolean",
        default: defaults.sticky,
        description: localize("hover.sticky", "Controls whether the hover should remain visible when mouse is moved over it.")
      },
      "editor.hover.hidingDelay": {
        type: "integer",
        minimum: 0,
        default: defaults.hidingDelay,
        description: localize("hover.hidingDelay", "Controls the delay in milliseconds after which the hover is hidden. Requires `editor.hover.sticky` to be enabled.")
      },
      "editor.hover.above": {
        type: "boolean",
        default: defaults.above,
        description: localize("hover.above", "Prefer showing hovers above the line, if there's space.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: boolean(input.enabled, this.defaultValue.enabled),
      delay: EditorIntOption.clampedInt(input.delay, this.defaultValue.delay, 0, 1e4),
      sticky: boolean(input.sticky, this.defaultValue.sticky),
      hidingDelay: EditorIntOption.clampedInt(input.hidingDelay, this.defaultValue.hidingDelay, 0, 6e5),
      above: boolean(input.above, this.defaultValue.above)
    };
  }
};
var EditorLayoutInfoComputer = class _EditorLayoutInfoComputer extends ComputedEditorOption {
  constructor() {
    super(
      144
      /* EditorOption.layoutInfo */
    );
  }
  compute(env, options2, _) {
    return _EditorLayoutInfoComputer.computeLayout(options2, {
      memory: env.memory,
      outerWidth: env.outerWidth,
      outerHeight: env.outerHeight,
      isDominatedByLongLines: env.isDominatedByLongLines,
      lineHeight: env.fontInfo.lineHeight,
      viewLineCount: env.viewLineCount,
      lineNumbersDigitCount: env.lineNumbersDigitCount,
      typicalHalfwidthCharacterWidth: env.fontInfo.typicalHalfwidthCharacterWidth,
      maxDigitWidth: env.fontInfo.maxDigitWidth,
      pixelRatio: env.pixelRatio,
      glyphMarginDecorationLaneCount: env.glyphMarginDecorationLaneCount
    });
  }
  static computeContainedMinimapLineCount(input) {
    const typicalViewportLineCount = input.height / input.lineHeight;
    const extraLinesBeforeFirstLine = Math.floor(input.paddingTop / input.lineHeight);
    let extraLinesBeyondLastLine = Math.floor(input.paddingBottom / input.lineHeight);
    if (input.scrollBeyondLastLine) {
      extraLinesBeyondLastLine = Math.max(extraLinesBeyondLastLine, typicalViewportLineCount - 1);
    }
    const desiredRatio = (extraLinesBeforeFirstLine + input.viewLineCount + extraLinesBeyondLastLine) / (input.pixelRatio * input.height);
    const minimapLineCount = Math.floor(input.viewLineCount / desiredRatio);
    return { typicalViewportLineCount, extraLinesBeforeFirstLine, extraLinesBeyondLastLine, desiredRatio, minimapLineCount };
  }
  static _computeMinimapLayout(input, memory) {
    const outerWidth = input.outerWidth;
    const outerHeight = input.outerHeight;
    const pixelRatio = input.pixelRatio;
    if (!input.minimap.enabled) {
      return {
        renderMinimap: 0,
        minimapLeft: 0,
        minimapWidth: 0,
        minimapHeightIsEditorHeight: false,
        minimapIsSampling: false,
        minimapScale: 1,
        minimapLineHeight: 1,
        minimapCanvasInnerWidth: 0,
        minimapCanvasInnerHeight: Math.floor(pixelRatio * outerHeight),
        minimapCanvasOuterWidth: 0,
        minimapCanvasOuterHeight: outerHeight
      };
    }
    const stableMinimapLayoutInput = memory.stableMinimapLayoutInput;
    const couldUseMemory = stableMinimapLayoutInput && input.outerHeight === stableMinimapLayoutInput.outerHeight && input.lineHeight === stableMinimapLayoutInput.lineHeight && input.typicalHalfwidthCharacterWidth === stableMinimapLayoutInput.typicalHalfwidthCharacterWidth && input.pixelRatio === stableMinimapLayoutInput.pixelRatio && input.scrollBeyondLastLine === stableMinimapLayoutInput.scrollBeyondLastLine && input.paddingTop === stableMinimapLayoutInput.paddingTop && input.paddingBottom === stableMinimapLayoutInput.paddingBottom && input.minimap.enabled === stableMinimapLayoutInput.minimap.enabled && input.minimap.side === stableMinimapLayoutInput.minimap.side && input.minimap.size === stableMinimapLayoutInput.minimap.size && input.minimap.showSlider === stableMinimapLayoutInput.minimap.showSlider && input.minimap.renderCharacters === stableMinimapLayoutInput.minimap.renderCharacters && input.minimap.maxColumn === stableMinimapLayoutInput.minimap.maxColumn && input.minimap.scale === stableMinimapLayoutInput.minimap.scale && input.verticalScrollbarWidth === stableMinimapLayoutInput.verticalScrollbarWidth && input.isViewportWrapping === stableMinimapLayoutInput.isViewportWrapping;
    const lineHeight = input.lineHeight;
    const typicalHalfwidthCharacterWidth = input.typicalHalfwidthCharacterWidth;
    const scrollBeyondLastLine = input.scrollBeyondLastLine;
    const minimapRenderCharacters = input.minimap.renderCharacters;
    let minimapScale = pixelRatio >= 2 ? Math.round(input.minimap.scale * 2) : input.minimap.scale;
    const minimapMaxColumn = input.minimap.maxColumn;
    const minimapSize = input.minimap.size;
    const minimapSide = input.minimap.side;
    const verticalScrollbarWidth = input.verticalScrollbarWidth;
    const viewLineCount = input.viewLineCount;
    const remainingWidth = input.remainingWidth;
    const isViewportWrapping = input.isViewportWrapping;
    const baseCharHeight = minimapRenderCharacters ? 2 : 3;
    let minimapCanvasInnerHeight = Math.floor(pixelRatio * outerHeight);
    const minimapCanvasOuterHeight = minimapCanvasInnerHeight / pixelRatio;
    let minimapHeightIsEditorHeight = false;
    let minimapIsSampling = false;
    let minimapLineHeight = baseCharHeight * minimapScale;
    let minimapCharWidth = minimapScale / pixelRatio;
    let minimapWidthMultiplier = 1;
    if (minimapSize === "fill" || minimapSize === "fit") {
      const { typicalViewportLineCount, extraLinesBeforeFirstLine, extraLinesBeyondLastLine, desiredRatio, minimapLineCount } = _EditorLayoutInfoComputer.computeContainedMinimapLineCount({
        viewLineCount,
        scrollBeyondLastLine,
        paddingTop: input.paddingTop,
        paddingBottom: input.paddingBottom,
        height: outerHeight,
        lineHeight,
        pixelRatio
      });
      const ratio = viewLineCount / minimapLineCount;
      if (ratio > 1) {
        minimapHeightIsEditorHeight = true;
        minimapIsSampling = true;
        minimapScale = 1;
        minimapLineHeight = 1;
        minimapCharWidth = minimapScale / pixelRatio;
      } else {
        let fitBecomesFill = false;
        let maxMinimapScale = minimapScale + 1;
        if (minimapSize === "fit") {
          const effectiveMinimapHeight = Math.ceil((extraLinesBeforeFirstLine + viewLineCount + extraLinesBeyondLastLine) * minimapLineHeight);
          if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {
            fitBecomesFill = true;
            maxMinimapScale = memory.stableFitMaxMinimapScale;
          } else {
            fitBecomesFill = effectiveMinimapHeight > minimapCanvasInnerHeight;
          }
        }
        if (minimapSize === "fill" || fitBecomesFill) {
          minimapHeightIsEditorHeight = true;
          const configuredMinimapScale = minimapScale;
          minimapLineHeight = Math.min(lineHeight * pixelRatio, Math.max(1, Math.floor(1 / desiredRatio)));
          if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {
            maxMinimapScale = memory.stableFitMaxMinimapScale;
          }
          minimapScale = Math.min(maxMinimapScale, Math.max(1, Math.floor(minimapLineHeight / baseCharHeight)));
          if (minimapScale > configuredMinimapScale) {
            minimapWidthMultiplier = Math.min(2, minimapScale / configuredMinimapScale);
          }
          minimapCharWidth = minimapScale / pixelRatio / minimapWidthMultiplier;
          minimapCanvasInnerHeight = Math.ceil(Math.max(typicalViewportLineCount, extraLinesBeforeFirstLine + viewLineCount + extraLinesBeyondLastLine) * minimapLineHeight);
          if (isViewportWrapping) {
            memory.stableMinimapLayoutInput = input;
            memory.stableFitRemainingWidth = remainingWidth;
            memory.stableFitMaxMinimapScale = minimapScale;
          } else {
            memory.stableMinimapLayoutInput = null;
            memory.stableFitRemainingWidth = 0;
          }
        }
      }
    }
    const minimapMaxWidth = Math.floor(minimapMaxColumn * minimapCharWidth);
    const minimapWidth = Math.min(minimapMaxWidth, Math.max(0, Math.floor((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth / (typicalHalfwidthCharacterWidth + minimapCharWidth))) + MINIMAP_GUTTER_WIDTH);
    let minimapCanvasInnerWidth = Math.floor(pixelRatio * minimapWidth);
    const minimapCanvasOuterWidth = minimapCanvasInnerWidth / pixelRatio;
    minimapCanvasInnerWidth = Math.floor(minimapCanvasInnerWidth * minimapWidthMultiplier);
    const renderMinimap = minimapRenderCharacters ? 1 : 2;
    const minimapLeft = minimapSide === "left" ? 0 : outerWidth - minimapWidth - verticalScrollbarWidth;
    return {
      renderMinimap,
      minimapLeft,
      minimapWidth,
      minimapHeightIsEditorHeight,
      minimapIsSampling,
      minimapScale,
      minimapLineHeight,
      minimapCanvasInnerWidth,
      minimapCanvasInnerHeight,
      minimapCanvasOuterWidth,
      minimapCanvasOuterHeight
    };
  }
  static computeLayout(options2, env) {
    const outerWidth = env.outerWidth | 0;
    const outerHeight = env.outerHeight | 0;
    const lineHeight = env.lineHeight | 0;
    const lineNumbersDigitCount = env.lineNumbersDigitCount | 0;
    const typicalHalfwidthCharacterWidth = env.typicalHalfwidthCharacterWidth;
    const maxDigitWidth = env.maxDigitWidth;
    const pixelRatio = env.pixelRatio;
    const viewLineCount = env.viewLineCount;
    const wordWrapOverride2 = options2.get(
      136
      /* EditorOption.wordWrapOverride2 */
    );
    const wordWrapOverride1 = wordWrapOverride2 === "inherit" ? options2.get(
      135
      /* EditorOption.wordWrapOverride1 */
    ) : wordWrapOverride2;
    const wordWrap = wordWrapOverride1 === "inherit" ? options2.get(
      131
      /* EditorOption.wordWrap */
    ) : wordWrapOverride1;
    const wordWrapColumn = options2.get(
      134
      /* EditorOption.wordWrapColumn */
    );
    const isDominatedByLongLines = env.isDominatedByLongLines;
    const showGlyphMargin = options2.get(
      57
      /* EditorOption.glyphMargin */
    );
    const showLineNumbers = options2.get(
      68
      /* EditorOption.lineNumbers */
    ).renderType !== 0;
    const lineNumbersMinChars = options2.get(
      69
      /* EditorOption.lineNumbersMinChars */
    );
    const scrollBeyondLastLine = options2.get(
      105
      /* EditorOption.scrollBeyondLastLine */
    );
    const padding = options2.get(
      84
      /* EditorOption.padding */
    );
    const minimap = options2.get(
      73
      /* EditorOption.minimap */
    );
    const scrollbar = options2.get(
      103
      /* EditorOption.scrollbar */
    );
    const verticalScrollbarWidth = scrollbar.verticalScrollbarSize;
    const verticalScrollbarHasArrows = scrollbar.verticalHasArrows;
    const scrollbarArrowSize = scrollbar.arrowSize;
    const horizontalScrollbarHeight = scrollbar.horizontalScrollbarSize;
    const folding = options2.get(
      43
      /* EditorOption.folding */
    );
    const showFoldingDecoration = options2.get(
      110
      /* EditorOption.showFoldingControls */
    ) !== "never";
    let lineDecorationsWidth = options2.get(
      66
      /* EditorOption.lineDecorationsWidth */
    );
    if (folding && showFoldingDecoration) {
      lineDecorationsWidth += 16;
    }
    let lineNumbersWidth = 0;
    if (showLineNumbers) {
      const digitCount = Math.max(lineNumbersDigitCount, lineNumbersMinChars);
      lineNumbersWidth = Math.round(digitCount * maxDigitWidth);
    }
    let glyphMarginWidth = 0;
    if (showGlyphMargin) {
      glyphMarginWidth = lineHeight * env.glyphMarginDecorationLaneCount;
    }
    let glyphMarginLeft = 0;
    let lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;
    let decorationsLeft = lineNumbersLeft + lineNumbersWidth;
    let contentLeft = decorationsLeft + lineDecorationsWidth;
    const remainingWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;
    let isWordWrapMinified = false;
    let isViewportWrapping = false;
    let wrappingColumn = -1;
    if (wordWrapOverride1 === "inherit" && isDominatedByLongLines) {
      isWordWrapMinified = true;
      isViewportWrapping = true;
    } else if (wordWrap === "on" || wordWrap === "bounded") {
      isViewportWrapping = true;
    } else if (wordWrap === "wordWrapColumn") {
      wrappingColumn = wordWrapColumn;
    }
    const minimapLayout = _EditorLayoutInfoComputer._computeMinimapLayout({
      outerWidth,
      outerHeight,
      lineHeight,
      typicalHalfwidthCharacterWidth,
      pixelRatio,
      scrollBeyondLastLine,
      paddingTop: padding.top,
      paddingBottom: padding.bottom,
      minimap,
      verticalScrollbarWidth,
      viewLineCount,
      remainingWidth,
      isViewportWrapping
    }, env.memory || new ComputeOptionsMemory());
    if (minimapLayout.renderMinimap !== 0 && minimapLayout.minimapLeft === 0) {
      glyphMarginLeft += minimapLayout.minimapWidth;
      lineNumbersLeft += minimapLayout.minimapWidth;
      decorationsLeft += minimapLayout.minimapWidth;
      contentLeft += minimapLayout.minimapWidth;
    }
    const contentWidth = remainingWidth - minimapLayout.minimapWidth;
    const viewportColumn = Math.max(1, Math.floor((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth));
    const verticalArrowSize = verticalScrollbarHasArrows ? scrollbarArrowSize : 0;
    if (isViewportWrapping) {
      wrappingColumn = Math.max(1, viewportColumn);
      if (wordWrap === "bounded") {
        wrappingColumn = Math.min(wrappingColumn, wordWrapColumn);
      }
    }
    return {
      width: outerWidth,
      height: outerHeight,
      glyphMarginLeft,
      glyphMarginWidth,
      glyphMarginDecorationLaneCount: env.glyphMarginDecorationLaneCount,
      lineNumbersLeft,
      lineNumbersWidth,
      decorationsLeft,
      decorationsWidth: lineDecorationsWidth,
      contentLeft,
      contentWidth,
      minimap: minimapLayout,
      viewportColumn,
      isWordWrapMinified,
      isViewportWrapping,
      wrappingColumn,
      verticalScrollbarWidth,
      horizontalScrollbarHeight,
      overviewRuler: {
        top: verticalArrowSize,
        width: verticalScrollbarWidth,
        height: outerHeight - 2 * verticalArrowSize,
        right: 0
      }
    };
  }
};
var WrappingStrategy = class extends BaseEditorOption {
  constructor() {
    super(138, "wrappingStrategy", "simple", {
      "editor.wrappingStrategy": {
        enumDescriptions: [
          localize("wrappingStrategy.simple", "Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width."),
          localize("wrappingStrategy.advanced", "Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.")
        ],
        type: "string",
        enum: ["simple", "advanced"],
        default: "simple",
        description: localize("wrappingStrategy", "Controls the algorithm that computes wrapping points. Note that when in accessibility mode, advanced will be used for the best experience.")
      }
    });
  }
  validate(input) {
    return stringSet(input, "simple", ["simple", "advanced"]);
  }
  compute(env, options2, value) {
    const accessibilitySupport = options2.get(
      2
      /* EditorOption.accessibilitySupport */
    );
    if (accessibilitySupport === 2) {
      return "advanced";
    }
    return value;
  }
};
var ShowLightbulbIconMode;
(function(ShowLightbulbIconMode3) {
  ShowLightbulbIconMode3["Off"] = "off";
  ShowLightbulbIconMode3["OnCode"] = "onCode";
  ShowLightbulbIconMode3["On"] = "on";
})(ShowLightbulbIconMode || (ShowLightbulbIconMode = {}));
var EditorLightbulb = class extends BaseEditorOption {
  constructor() {
    const defaults = { enabled: ShowLightbulbIconMode.OnCode };
    super(65, "lightbulb", defaults, {
      "editor.lightbulb.enabled": {
        type: "string",
        tags: ["experimental"],
        enum: [ShowLightbulbIconMode.Off, ShowLightbulbIconMode.OnCode, ShowLightbulbIconMode.On],
        default: defaults.enabled,
        enumDescriptions: [
          localize("editor.lightbulb.enabled.off", "Disable the code action menu."),
          localize("editor.lightbulb.enabled.onCode", "Show the code action menu when the cursor is on lines with code."),
          localize("editor.lightbulb.enabled.on", "Show the code action menu when the cursor is on lines with code or on empty lines.")
        ],
        description: localize("enabled", "Enables the Code Action lightbulb in the editor.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: stringSet(input.enabled, this.defaultValue.enabled, [ShowLightbulbIconMode.Off, ShowLightbulbIconMode.OnCode, ShowLightbulbIconMode.On])
    };
  }
};
var EditorStickyScroll = class extends BaseEditorOption {
  constructor() {
    const defaults = { enabled: true, maxLineCount: 5, defaultModel: "outlineModel", scrollWithEditor: true };
    super(115, "stickyScroll", defaults, {
      "editor.stickyScroll.enabled": {
        type: "boolean",
        default: defaults.enabled,
        description: localize("editor.stickyScroll.enabled", "Shows the nested current scopes during the scroll at the top of the editor."),
        tags: ["experimental"]
      },
      "editor.stickyScroll.maxLineCount": {
        type: "number",
        default: defaults.maxLineCount,
        minimum: 1,
        maximum: 20,
        description: localize("editor.stickyScroll.maxLineCount", "Defines the maximum number of sticky lines to show.")
      },
      "editor.stickyScroll.defaultModel": {
        type: "string",
        enum: ["outlineModel", "foldingProviderModel", "indentationModel"],
        default: defaults.defaultModel,
        description: localize("editor.stickyScroll.defaultModel", "Defines the model to use for determining which lines to stick. If the outline model does not exist, it will fall back on the folding provider model which falls back on the indentation model. This order is respected in all three cases.")
      },
      "editor.stickyScroll.scrollWithEditor": {
        type: "boolean",
        default: defaults.scrollWithEditor,
        description: localize("editor.stickyScroll.scrollWithEditor", "Enable scrolling of Sticky Scroll with the editor's horizontal scrollbar.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: boolean(input.enabled, this.defaultValue.enabled),
      maxLineCount: EditorIntOption.clampedInt(input.maxLineCount, this.defaultValue.maxLineCount, 1, 20),
      defaultModel: stringSet(input.defaultModel, this.defaultValue.defaultModel, ["outlineModel", "foldingProviderModel", "indentationModel"]),
      scrollWithEditor: boolean(input.scrollWithEditor, this.defaultValue.scrollWithEditor)
    };
  }
};
var EditorInlayHints = class extends BaseEditorOption {
  constructor() {
    const defaults = { enabled: "on", fontSize: 0, fontFamily: "", padding: false };
    super(140, "inlayHints", defaults, {
      "editor.inlayHints.enabled": {
        type: "string",
        default: defaults.enabled,
        description: localize("inlayHints.enable", "Enables the inlay hints in the editor."),
        enum: ["on", "onUnlessPressed", "offUnlessPressed", "off"],
        markdownEnumDescriptions: [
          localize("editor.inlayHints.on", "Inlay hints are enabled"),
          localize("editor.inlayHints.onUnlessPressed", "Inlay hints are showing by default and hide when holding {0}", isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`),
          localize("editor.inlayHints.offUnlessPressed", "Inlay hints are hidden by default and show when holding {0}", isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`),
          localize("editor.inlayHints.off", "Inlay hints are disabled")
        ]
      },
      "editor.inlayHints.fontSize": {
        type: "number",
        default: defaults.fontSize,
        markdownDescription: localize("inlayHints.fontSize", "Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.", "`#editor.fontSize#`", "`5`")
      },
      "editor.inlayHints.fontFamily": {
        type: "string",
        default: defaults.fontFamily,
        markdownDescription: localize("inlayHints.fontFamily", "Controls font family of inlay hints in the editor. When set to empty, the {0} is used.", "`#editor.fontFamily#`")
      },
      "editor.inlayHints.padding": {
        type: "boolean",
        default: defaults.padding,
        description: localize("inlayHints.padding", "Enables the padding around the inlay hints in the editor.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    if (typeof input.enabled === "boolean") {
      input.enabled = input.enabled ? "on" : "off";
    }
    return {
      enabled: stringSet(input.enabled, this.defaultValue.enabled, ["on", "off", "offUnlessPressed", "onUnlessPressed"]),
      fontSize: EditorIntOption.clampedInt(input.fontSize, this.defaultValue.fontSize, 0, 100),
      fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily),
      padding: boolean(input.padding, this.defaultValue.padding)
    };
  }
};
var EditorLineDecorationsWidth = class extends BaseEditorOption {
  constructor() {
    super(66, "lineDecorationsWidth", 10);
  }
  validate(input) {
    if (typeof input === "string" && /^\d+(\.\d+)?ch$/.test(input)) {
      const multiple = parseFloat(input.substring(0, input.length - 2));
      return -multiple;
    } else {
      return EditorIntOption.clampedInt(input, this.defaultValue, 0, 1e3);
    }
  }
  compute(env, options2, value) {
    if (value < 0) {
      return EditorIntOption.clampedInt(-value * env.fontInfo.typicalHalfwidthCharacterWidth, this.defaultValue, 0, 1e3);
    } else {
      return value;
    }
  }
};
var EditorLineHeight = class extends EditorFloatOption {
  constructor() {
    super(67, "lineHeight", EDITOR_FONT_DEFAULTS.lineHeight, (x) => EditorFloatOption.clamp(x, 0, 150), { markdownDescription: localize("lineHeight", "Controls the line height. \n - Use 0 to automatically compute the line height from the font size.\n - Values between 0 and 8 will be used as a multiplier with the font size.\n - Values greater than or equal to 8 will be used as effective values.") });
  }
  compute(env, options2, value) {
    return env.fontInfo.lineHeight;
  }
};
var EditorMinimap = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      enabled: true,
      size: "proportional",
      side: "right",
      showSlider: "mouseover",
      autohide: false,
      renderCharacters: true,
      maxColumn: 120,
      scale: 1
    };
    super(73, "minimap", defaults, {
      "editor.minimap.enabled": {
        type: "boolean",
        default: defaults.enabled,
        description: localize("minimap.enabled", "Controls whether the minimap is shown.")
      },
      "editor.minimap.autohide": {
        type: "boolean",
        default: defaults.autohide,
        description: localize("minimap.autohide", "Controls whether the minimap is hidden automatically.")
      },
      "editor.minimap.size": {
        type: "string",
        enum: ["proportional", "fill", "fit"],
        enumDescriptions: [
          localize("minimap.size.proportional", "The minimap has the same size as the editor contents (and might scroll)."),
          localize("minimap.size.fill", "The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling)."),
          localize("minimap.size.fit", "The minimap will shrink as necessary to never be larger than the editor (no scrolling).")
        ],
        default: defaults.size,
        description: localize("minimap.size", "Controls the size of the minimap.")
      },
      "editor.minimap.side": {
        type: "string",
        enum: ["left", "right"],
        default: defaults.side,
        description: localize("minimap.side", "Controls the side where to render the minimap.")
      },
      "editor.minimap.showSlider": {
        type: "string",
        enum: ["always", "mouseover"],
        default: defaults.showSlider,
        description: localize("minimap.showSlider", "Controls when the minimap slider is shown.")
      },
      "editor.minimap.scale": {
        type: "number",
        default: defaults.scale,
        minimum: 1,
        maximum: 3,
        enum: [1, 2, 3],
        description: localize("minimap.scale", "Scale of content drawn in the minimap: 1, 2 or 3.")
      },
      "editor.minimap.renderCharacters": {
        type: "boolean",
        default: defaults.renderCharacters,
        description: localize("minimap.renderCharacters", "Render the actual characters on a line as opposed to color blocks.")
      },
      "editor.minimap.maxColumn": {
        type: "number",
        default: defaults.maxColumn,
        description: localize("minimap.maxColumn", "Limit the width of the minimap to render at most a certain number of columns.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: boolean(input.enabled, this.defaultValue.enabled),
      autohide: boolean(input.autohide, this.defaultValue.autohide),
      size: stringSet(input.size, this.defaultValue.size, ["proportional", "fill", "fit"]),
      side: stringSet(input.side, this.defaultValue.side, ["right", "left"]),
      showSlider: stringSet(input.showSlider, this.defaultValue.showSlider, ["always", "mouseover"]),
      renderCharacters: boolean(input.renderCharacters, this.defaultValue.renderCharacters),
      scale: EditorIntOption.clampedInt(input.scale, 1, 1, 3),
      maxColumn: EditorIntOption.clampedInt(input.maxColumn, this.defaultValue.maxColumn, 1, 1e4)
    };
  }
};
function _multiCursorModifierFromString(multiCursorModifier) {
  if (multiCursorModifier === "ctrlCmd") {
    return isMacintosh ? "metaKey" : "ctrlKey";
  }
  return "altKey";
}
var EditorPadding = class extends BaseEditorOption {
  constructor() {
    super(84, "padding", { top: 0, bottom: 0 }, {
      "editor.padding.top": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: localize("padding.top", "Controls the amount of space between the top edge of the editor and the first line.")
      },
      "editor.padding.bottom": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: localize("padding.bottom", "Controls the amount of space between the bottom edge of the editor and the last line.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      top: EditorIntOption.clampedInt(input.top, 0, 0, 1e3),
      bottom: EditorIntOption.clampedInt(input.bottom, 0, 0, 1e3)
    };
  }
};
var EditorParameterHints = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      enabled: true,
      cycle: true
    };
    super(86, "parameterHints", defaults, {
      "editor.parameterHints.enabled": {
        type: "boolean",
        default: defaults.enabled,
        description: localize("parameterHints.enabled", "Enables a pop-up that shows parameter documentation and type information as you type.")
      },
      "editor.parameterHints.cycle": {
        type: "boolean",
        default: defaults.cycle,
        description: localize("parameterHints.cycle", "Controls whether the parameter hints menu cycles or closes when reaching the end of the list.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: boolean(input.enabled, this.defaultValue.enabled),
      cycle: boolean(input.cycle, this.defaultValue.cycle)
    };
  }
};
var EditorPixelRatio = class extends ComputedEditorOption {
  constructor() {
    super(
      142
      /* EditorOption.pixelRatio */
    );
  }
  compute(env, options2, _) {
    return env.pixelRatio;
  }
};
var EditorQuickSuggestions = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      other: "on",
      comments: "off",
      strings: "off"
    };
    const types = [
      { type: "boolean" },
      {
        type: "string",
        enum: ["on", "inline", "off"],
        enumDescriptions: [localize("on", "Quick suggestions show inside the suggest widget"), localize("inline", "Quick suggestions show as ghost text"), localize("off", "Quick suggestions are disabled")]
      }
    ];
    super(89, "quickSuggestions", defaults, {
      type: "object",
      additionalProperties: false,
      properties: {
        strings: {
          anyOf: types,
          default: defaults.strings,
          description: localize("quickSuggestions.strings", "Enable quick suggestions inside strings.")
        },
        comments: {
          anyOf: types,
          default: defaults.comments,
          description: localize("quickSuggestions.comments", "Enable quick suggestions inside comments.")
        },
        other: {
          anyOf: types,
          default: defaults.other,
          description: localize("quickSuggestions.other", "Enable quick suggestions outside of strings and comments.")
        }
      },
      default: defaults,
      markdownDescription: localize("quickSuggestions", "Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the '{0}'-setting which controls if suggestions are triggered by special characters.", `#editor.suggestOnTriggerCharacters#`)
    });
    this.defaultValue = defaults;
  }
  validate(input) {
    if (typeof input === "boolean") {
      const value = input ? "on" : "off";
      return { comments: value, strings: value, other: value };
    }
    if (!input || typeof input !== "object") {
      return this.defaultValue;
    }
    const { other, comments, strings } = input;
    const allowedValues = ["on", "inline", "off"];
    let validatedOther;
    let validatedComments;
    let validatedStrings;
    if (typeof other === "boolean") {
      validatedOther = other ? "on" : "off";
    } else {
      validatedOther = stringSet(other, this.defaultValue.other, allowedValues);
    }
    if (typeof comments === "boolean") {
      validatedComments = comments ? "on" : "off";
    } else {
      validatedComments = stringSet(comments, this.defaultValue.comments, allowedValues);
    }
    if (typeof strings === "boolean") {
      validatedStrings = strings ? "on" : "off";
    } else {
      validatedStrings = stringSet(strings, this.defaultValue.strings, allowedValues);
    }
    return {
      other: validatedOther,
      comments: validatedComments,
      strings: validatedStrings
    };
  }
};
var EditorRenderLineNumbersOption = class extends BaseEditorOption {
  constructor() {
    super(68, "lineNumbers", { renderType: 1, renderFn: null }, {
      type: "string",
      enum: ["off", "on", "relative", "interval"],
      enumDescriptions: [
        localize("lineNumbers.off", "Line numbers are not rendered."),
        localize("lineNumbers.on", "Line numbers are rendered as absolute number."),
        localize("lineNumbers.relative", "Line numbers are rendered as distance in lines to cursor position."),
        localize("lineNumbers.interval", "Line numbers are rendered every 10 lines.")
      ],
      default: "on",
      description: localize("lineNumbers", "Controls the display of line numbers.")
    });
  }
  validate(lineNumbers) {
    let renderType = this.defaultValue.renderType;
    let renderFn = this.defaultValue.renderFn;
    if (typeof lineNumbers !== "undefined") {
      if (typeof lineNumbers === "function") {
        renderType = 4;
        renderFn = lineNumbers;
      } else if (lineNumbers === "interval") {
        renderType = 3;
      } else if (lineNumbers === "relative") {
        renderType = 2;
      } else if (lineNumbers === "on") {
        renderType = 1;
      } else {
        renderType = 0;
      }
    }
    return {
      renderType,
      renderFn
    };
  }
};
function filterValidationDecorations(options2) {
  const renderValidationDecorations = options2.get(
    98
    /* EditorOption.renderValidationDecorations */
  );
  if (renderValidationDecorations === "editable") {
    return options2.get(
      91
      /* EditorOption.readOnly */
    );
  }
  return renderValidationDecorations === "on" ? false : true;
}
var EditorRulers = class extends BaseEditorOption {
  constructor() {
    const defaults = [];
    const columnSchema = { type: "number", description: localize("rulers.size", "Number of monospace characters at which this editor ruler will render.") };
    super(102, "rulers", defaults, {
      type: "array",
      items: {
        anyOf: [
          columnSchema,
          {
            type: [
              "object"
            ],
            properties: {
              column: columnSchema,
              color: {
                type: "string",
                description: localize("rulers.color", "Color of this editor ruler."),
                format: "color-hex"
              }
            }
          }
        ]
      },
      default: defaults,
      description: localize("rulers", "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.")
    });
  }
  validate(input) {
    if (Array.isArray(input)) {
      const rulers = [];
      for (const _element of input) {
        if (typeof _element === "number") {
          rulers.push({
            column: EditorIntOption.clampedInt(_element, 0, 0, 1e4),
            color: null
          });
        } else if (_element && typeof _element === "object") {
          const element = _element;
          rulers.push({
            column: EditorIntOption.clampedInt(element.column, 0, 0, 1e4),
            color: element.color
          });
        }
      }
      rulers.sort((a, b) => a.column - b.column);
      return rulers;
    }
    return this.defaultValue;
  }
};
var ReadonlyMessage = class extends BaseEditorOption {
  constructor() {
    const defaults = void 0;
    super(92, "readOnlyMessage", defaults);
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    return _input;
  }
};
function _scrollbarVisibilityFromString(visibility, defaultValue) {
  if (typeof visibility !== "string") {
    return defaultValue;
  }
  switch (visibility) {
    case "hidden":
      return 2;
    case "visible":
      return 3;
    default:
      return 1;
  }
}
var EditorScrollbar = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      vertical: 1,
      horizontal: 1,
      arrowSize: 11,
      useShadows: true,
      verticalHasArrows: false,
      horizontalHasArrows: false,
      horizontalScrollbarSize: 12,
      horizontalSliderSize: 12,
      verticalScrollbarSize: 14,
      verticalSliderSize: 14,
      handleMouseWheel: true,
      alwaysConsumeMouseWheel: true,
      scrollByPage: false,
      ignoreHorizontalScrollbarInContentHeight: false
    };
    super(103, "scrollbar", defaults, {
      "editor.scrollbar.vertical": {
        type: "string",
        enum: ["auto", "visible", "hidden"],
        enumDescriptions: [
          localize("scrollbar.vertical.auto", "The vertical scrollbar will be visible only when necessary."),
          localize("scrollbar.vertical.visible", "The vertical scrollbar will always be visible."),
          localize("scrollbar.vertical.fit", "The vertical scrollbar will always be hidden.")
        ],
        default: "auto",
        description: localize("scrollbar.vertical", "Controls the visibility of the vertical scrollbar.")
      },
      "editor.scrollbar.horizontal": {
        type: "string",
        enum: ["auto", "visible", "hidden"],
        enumDescriptions: [
          localize("scrollbar.horizontal.auto", "The horizontal scrollbar will be visible only when necessary."),
          localize("scrollbar.horizontal.visible", "The horizontal scrollbar will always be visible."),
          localize("scrollbar.horizontal.fit", "The horizontal scrollbar will always be hidden.")
        ],
        default: "auto",
        description: localize("scrollbar.horizontal", "Controls the visibility of the horizontal scrollbar.")
      },
      "editor.scrollbar.verticalScrollbarSize": {
        type: "number",
        default: defaults.verticalScrollbarSize,
        description: localize("scrollbar.verticalScrollbarSize", "The width of the vertical scrollbar.")
      },
      "editor.scrollbar.horizontalScrollbarSize": {
        type: "number",
        default: defaults.horizontalScrollbarSize,
        description: localize("scrollbar.horizontalScrollbarSize", "The height of the horizontal scrollbar.")
      },
      "editor.scrollbar.scrollByPage": {
        type: "boolean",
        default: defaults.scrollByPage,
        description: localize("scrollbar.scrollByPage", "Controls whether clicks scroll by page or jump to click position.")
      },
      "editor.scrollbar.ignoreHorizontalScrollbarInContentHeight": {
        type: "boolean",
        default: defaults.ignoreHorizontalScrollbarInContentHeight,
        description: localize("scrollbar.ignoreHorizontalScrollbarInContentHeight", "When set, the horizontal scrollbar will not increase the size of the editor's content.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    const horizontalScrollbarSize = EditorIntOption.clampedInt(input.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3);
    const verticalScrollbarSize = EditorIntOption.clampedInt(input.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3);
    return {
      arrowSize: EditorIntOption.clampedInt(input.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
      vertical: _scrollbarVisibilityFromString(input.vertical, this.defaultValue.vertical),
      horizontal: _scrollbarVisibilityFromString(input.horizontal, this.defaultValue.horizontal),
      useShadows: boolean(input.useShadows, this.defaultValue.useShadows),
      verticalHasArrows: boolean(input.verticalHasArrows, this.defaultValue.verticalHasArrows),
      horizontalHasArrows: boolean(input.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
      handleMouseWheel: boolean(input.handleMouseWheel, this.defaultValue.handleMouseWheel),
      alwaysConsumeMouseWheel: boolean(input.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
      horizontalScrollbarSize,
      horizontalSliderSize: EditorIntOption.clampedInt(input.horizontalSliderSize, horizontalScrollbarSize, 0, 1e3),
      verticalScrollbarSize,
      verticalSliderSize: EditorIntOption.clampedInt(input.verticalSliderSize, verticalScrollbarSize, 0, 1e3),
      scrollByPage: boolean(input.scrollByPage, this.defaultValue.scrollByPage),
      ignoreHorizontalScrollbarInContentHeight: boolean(input.ignoreHorizontalScrollbarInContentHeight, this.defaultValue.ignoreHorizontalScrollbarInContentHeight)
    };
  }
};
var inUntrustedWorkspace = "inUntrustedWorkspace";
var unicodeHighlightConfigKeys = {
  allowedCharacters: "editor.unicodeHighlight.allowedCharacters",
  invisibleCharacters: "editor.unicodeHighlight.invisibleCharacters",
  nonBasicASCII: "editor.unicodeHighlight.nonBasicASCII",
  ambiguousCharacters: "editor.unicodeHighlight.ambiguousCharacters",
  includeComments: "editor.unicodeHighlight.includeComments",
  includeStrings: "editor.unicodeHighlight.includeStrings",
  allowedLocales: "editor.unicodeHighlight.allowedLocales"
};
var UnicodeHighlight = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      nonBasicASCII: inUntrustedWorkspace,
      invisibleCharacters: true,
      ambiguousCharacters: true,
      includeComments: inUntrustedWorkspace,
      includeStrings: true,
      allowedCharacters: {},
      allowedLocales: { _os: true, _vscode: true }
    };
    super(125, "unicodeHighlight", defaults, {
      [unicodeHighlightConfigKeys.nonBasicASCII]: {
        restricted: true,
        type: ["boolean", "string"],
        enum: [true, false, inUntrustedWorkspace],
        default: defaults.nonBasicASCII,
        description: localize("unicodeHighlight.nonBasicASCII", "Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.")
      },
      [unicodeHighlightConfigKeys.invisibleCharacters]: {
        restricted: true,
        type: "boolean",
        default: defaults.invisibleCharacters,
        description: localize("unicodeHighlight.invisibleCharacters", "Controls whether characters that just reserve space or have no width at all are highlighted.")
      },
      [unicodeHighlightConfigKeys.ambiguousCharacters]: {
        restricted: true,
        type: "boolean",
        default: defaults.ambiguousCharacters,
        description: localize("unicodeHighlight.ambiguousCharacters", "Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.")
      },
      [unicodeHighlightConfigKeys.includeComments]: {
        restricted: true,
        type: ["boolean", "string"],
        enum: [true, false, inUntrustedWorkspace],
        default: defaults.includeComments,
        description: localize("unicodeHighlight.includeComments", "Controls whether characters in comments should also be subject to Unicode highlighting.")
      },
      [unicodeHighlightConfigKeys.includeStrings]: {
        restricted: true,
        type: ["boolean", "string"],
        enum: [true, false, inUntrustedWorkspace],
        default: defaults.includeStrings,
        description: localize("unicodeHighlight.includeStrings", "Controls whether characters in strings should also be subject to Unicode highlighting.")
      },
      [unicodeHighlightConfigKeys.allowedCharacters]: {
        restricted: true,
        type: "object",
        default: defaults.allowedCharacters,
        description: localize("unicodeHighlight.allowedCharacters", "Defines allowed characters that are not being highlighted."),
        additionalProperties: {
          type: "boolean"
        }
      },
      [unicodeHighlightConfigKeys.allowedLocales]: {
        restricted: true,
        type: "object",
        additionalProperties: {
          type: "boolean"
        },
        default: defaults.allowedLocales,
        description: localize("unicodeHighlight.allowedLocales", "Unicode characters that are common in allowed locales are not being highlighted.")
      }
    });
  }
  applyUpdate(value, update) {
    let didChange = false;
    if (update.allowedCharacters && value) {
      if (!equals2(value.allowedCharacters, update.allowedCharacters)) {
        value = { ...value, allowedCharacters: update.allowedCharacters };
        didChange = true;
      }
    }
    if (update.allowedLocales && value) {
      if (!equals2(value.allowedLocales, update.allowedLocales)) {
        value = { ...value, allowedLocales: update.allowedLocales };
        didChange = true;
      }
    }
    const result = super.applyUpdate(value, update);
    if (didChange) {
      return new ApplyUpdateResult(result.newValue, true);
    }
    return result;
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      nonBasicASCII: primitiveSet(input.nonBasicASCII, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),
      invisibleCharacters: boolean(input.invisibleCharacters, this.defaultValue.invisibleCharacters),
      ambiguousCharacters: boolean(input.ambiguousCharacters, this.defaultValue.ambiguousCharacters),
      includeComments: primitiveSet(input.includeComments, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),
      includeStrings: primitiveSet(input.includeStrings, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),
      allowedCharacters: this.validateBooleanMap(_input.allowedCharacters, this.defaultValue.allowedCharacters),
      allowedLocales: this.validateBooleanMap(_input.allowedLocales, this.defaultValue.allowedLocales)
    };
  }
  validateBooleanMap(map, defaultValue) {
    if (typeof map !== "object" || !map) {
      return defaultValue;
    }
    const result = {};
    for (const [key, value] of Object.entries(map)) {
      if (value === true) {
        result[key] = true;
      }
    }
    return result;
  }
};
var InlineEditorSuggest = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      enabled: true,
      mode: "subwordSmart",
      showToolbar: "onHover",
      suppressSuggestions: false,
      keepOnBlur: false,
      fontFamily: "default"
    };
    super(62, "inlineSuggest", defaults, {
      "editor.inlineSuggest.enabled": {
        type: "boolean",
        default: defaults.enabled,
        description: localize("inlineSuggest.enabled", "Controls whether to automatically show inline suggestions in the editor.")
      },
      "editor.inlineSuggest.showToolbar": {
        type: "string",
        default: defaults.showToolbar,
        enum: ["always", "onHover", "never"],
        enumDescriptions: [
          localize("inlineSuggest.showToolbar.always", "Show the inline suggestion toolbar whenever an inline suggestion is shown."),
          localize("inlineSuggest.showToolbar.onHover", "Show the inline suggestion toolbar when hovering over an inline suggestion."),
          localize("inlineSuggest.showToolbar.never", "Never show the inline suggestion toolbar.")
        ],
        description: localize("inlineSuggest.showToolbar", "Controls when to show the inline suggestion toolbar.")
      },
      "editor.inlineSuggest.suppressSuggestions": {
        type: "boolean",
        default: defaults.suppressSuggestions,
        description: localize("inlineSuggest.suppressSuggestions", "Controls how inline suggestions interact with the suggest widget. If enabled, the suggest widget is not shown automatically when inline suggestions are available.")
      },
      "editor.inlineSuggest.fontFamily": {
        type: "string",
        default: defaults.fontFamily,
        description: localize("inlineSuggest.fontFamily", "Controls the font family of the inline suggestions.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: boolean(input.enabled, this.defaultValue.enabled),
      mode: stringSet(input.mode, this.defaultValue.mode, ["prefix", "subword", "subwordSmart"]),
      showToolbar: stringSet(input.showToolbar, this.defaultValue.showToolbar, ["always", "onHover", "never"]),
      suppressSuggestions: boolean(input.suppressSuggestions, this.defaultValue.suppressSuggestions),
      keepOnBlur: boolean(input.keepOnBlur, this.defaultValue.keepOnBlur),
      fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily)
    };
  }
};
var InlineEditorEdit = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      enabled: false,
      showToolbar: "onHover",
      fontFamily: "default",
      keepOnBlur: false,
      backgroundColoring: false
    };
    super(63, "experimentalInlineEdit", defaults, {
      "editor.experimentalInlineEdit.enabled": {
        type: "boolean",
        default: defaults.enabled,
        description: localize("inlineEdit.enabled", "Controls whether to show inline edits in the editor.")
      },
      "editor.experimentalInlineEdit.showToolbar": {
        type: "string",
        default: defaults.showToolbar,
        enum: ["always", "onHover", "never"],
        enumDescriptions: [
          localize("inlineEdit.showToolbar.always", "Show the inline edit toolbar whenever an inline suggestion is shown."),
          localize("inlineEdit.showToolbar.onHover", "Show the inline edit toolbar when hovering over an inline suggestion."),
          localize("inlineEdit.showToolbar.never", "Never show the inline edit toolbar.")
        ],
        description: localize("inlineEdit.showToolbar", "Controls when to show the inline edit toolbar.")
      },
      "editor.experimentalInlineEdit.fontFamily": {
        type: "string",
        default: defaults.fontFamily,
        description: localize("inlineEdit.fontFamily", "Controls the font family of the inline edit.")
      },
      "editor.experimentalInlineEdit.backgroundColoring": {
        type: "boolean",
        default: defaults.backgroundColoring,
        description: localize("inlineEdit.backgroundColoring", "Controls whether to color the background of inline edits.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: boolean(input.enabled, this.defaultValue.enabled),
      showToolbar: stringSet(input.showToolbar, this.defaultValue.showToolbar, ["always", "onHover", "never"]),
      fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily),
      keepOnBlur: boolean(input.keepOnBlur, this.defaultValue.keepOnBlur),
      backgroundColoring: boolean(input.backgroundColoring, this.defaultValue.backgroundColoring)
    };
  }
};
var BracketPairColorization = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      enabled: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions.enabled,
      independentColorPoolPerBracketType: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions.independentColorPoolPerBracketType
    };
    super(15, "bracketPairColorization", defaults, {
      "editor.bracketPairColorization.enabled": {
        type: "boolean",
        default: defaults.enabled,
        markdownDescription: localize("bracketPairColorization.enabled", "Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.", "`#workbench.colorCustomizations#`")
      },
      "editor.bracketPairColorization.independentColorPoolPerBracketType": {
        type: "boolean",
        default: defaults.independentColorPoolPerBracketType,
        description: localize("bracketPairColorization.independentColorPoolPerBracketType", "Controls whether each bracket type has its own independent color pool.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: boolean(input.enabled, this.defaultValue.enabled),
      independentColorPoolPerBracketType: boolean(input.independentColorPoolPerBracketType, this.defaultValue.independentColorPoolPerBracketType)
    };
  }
};
var GuideOptions = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      bracketPairs: false,
      bracketPairsHorizontal: "active",
      highlightActiveBracketPair: true,
      indentation: true,
      highlightActiveIndentation: true
    };
    super(16, "guides", defaults, {
      "editor.guides.bracketPairs": {
        type: ["boolean", "string"],
        enum: [true, "active", false],
        enumDescriptions: [
          localize("editor.guides.bracketPairs.true", "Enables bracket pair guides."),
          localize("editor.guides.bracketPairs.active", "Enables bracket pair guides only for the active bracket pair."),
          localize("editor.guides.bracketPairs.false", "Disables bracket pair guides.")
        ],
        default: defaults.bracketPairs,
        description: localize("editor.guides.bracketPairs", "Controls whether bracket pair guides are enabled or not.")
      },
      "editor.guides.bracketPairsHorizontal": {
        type: ["boolean", "string"],
        enum: [true, "active", false],
        enumDescriptions: [
          localize("editor.guides.bracketPairsHorizontal.true", "Enables horizontal guides as addition to vertical bracket pair guides."),
          localize("editor.guides.bracketPairsHorizontal.active", "Enables horizontal guides only for the active bracket pair."),
          localize("editor.guides.bracketPairsHorizontal.false", "Disables horizontal bracket pair guides.")
        ],
        default: defaults.bracketPairsHorizontal,
        description: localize("editor.guides.bracketPairsHorizontal", "Controls whether horizontal bracket pair guides are enabled or not.")
      },
      "editor.guides.highlightActiveBracketPair": {
        type: "boolean",
        default: defaults.highlightActiveBracketPair,
        description: localize("editor.guides.highlightActiveBracketPair", "Controls whether the editor should highlight the active bracket pair.")
      },
      "editor.guides.indentation": {
        type: "boolean",
        default: defaults.indentation,
        description: localize("editor.guides.indentation", "Controls whether the editor should render indent guides.")
      },
      "editor.guides.highlightActiveIndentation": {
        type: ["boolean", "string"],
        enum: [true, "always", false],
        enumDescriptions: [
          localize("editor.guides.highlightActiveIndentation.true", "Highlights the active indent guide."),
          localize("editor.guides.highlightActiveIndentation.always", "Highlights the active indent guide even if bracket guides are highlighted."),
          localize("editor.guides.highlightActiveIndentation.false", "Do not highlight the active indent guide.")
        ],
        default: defaults.highlightActiveIndentation,
        description: localize("editor.guides.highlightActiveIndentation", "Controls whether the editor should highlight the active indent guide.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      bracketPairs: primitiveSet(input.bracketPairs, this.defaultValue.bracketPairs, [true, false, "active"]),
      bracketPairsHorizontal: primitiveSet(input.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [true, false, "active"]),
      highlightActiveBracketPair: boolean(input.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),
      indentation: boolean(input.indentation, this.defaultValue.indentation),
      highlightActiveIndentation: primitiveSet(input.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation, [true, false, "always"])
    };
  }
};
function primitiveSet(value, defaultValue, allowedValues) {
  const idx = allowedValues.indexOf(value);
  if (idx === -1) {
    return defaultValue;
  }
  return allowedValues[idx];
}
var EditorSuggest = class extends BaseEditorOption {
  constructor() {
    const defaults = {
      insertMode: "insert",
      filterGraceful: true,
      snippetsPreventQuickSuggestions: false,
      localityBonus: false,
      shareSuggestSelections: false,
      selectionMode: "always",
      showIcons: true,
      showStatusBar: false,
      preview: false,
      previewMode: "subwordSmart",
      showInlineDetails: true,
      showMethods: true,
      showFunctions: true,
      showConstructors: true,
      showDeprecated: true,
      matchOnWordStartOnly: true,
      showFields: true,
      showVariables: true,
      showClasses: true,
      showStructs: true,
      showInterfaces: true,
      showModules: true,
      showProperties: true,
      showEvents: true,
      showOperators: true,
      showUnits: true,
      showValues: true,
      showConstants: true,
      showEnums: true,
      showEnumMembers: true,
      showKeywords: true,
      showWords: true,
      showColors: true,
      showFiles: true,
      showReferences: true,
      showFolders: true,
      showTypeParameters: true,
      showSnippets: true,
      showUsers: true,
      showIssues: true
    };
    super(118, "suggest", defaults, {
      "editor.suggest.insertMode": {
        type: "string",
        enum: ["insert", "replace"],
        enumDescriptions: [
          localize("suggest.insertMode.insert", "Insert suggestion without overwriting text right of the cursor."),
          localize("suggest.insertMode.replace", "Insert suggestion and overwrite text right of the cursor.")
        ],
        default: defaults.insertMode,
        description: localize("suggest.insertMode", "Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.")
      },
      "editor.suggest.filterGraceful": {
        type: "boolean",
        default: defaults.filterGraceful,
        description: localize("suggest.filterGraceful", "Controls whether filtering and sorting suggestions accounts for small typos.")
      },
      "editor.suggest.localityBonus": {
        type: "boolean",
        default: defaults.localityBonus,
        description: localize("suggest.localityBonus", "Controls whether sorting favors words that appear close to the cursor.")
      },
      "editor.suggest.shareSuggestSelections": {
        type: "boolean",
        default: defaults.shareSuggestSelections,
        markdownDescription: localize("suggest.shareSuggestSelections", "Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).")
      },
      "editor.suggest.selectionMode": {
        type: "string",
        enum: ["always", "never", "whenTriggerCharacter", "whenQuickSuggestion"],
        enumDescriptions: [
          localize("suggest.insertMode.always", "Always select a suggestion when automatically triggering IntelliSense."),
          localize("suggest.insertMode.never", "Never select a suggestion when automatically triggering IntelliSense."),
          localize("suggest.insertMode.whenTriggerCharacter", "Select a suggestion only when triggering IntelliSense from a trigger character."),
          localize("suggest.insertMode.whenQuickSuggestion", "Select a suggestion only when triggering IntelliSense as you type.")
        ],
        default: defaults.selectionMode,
        markdownDescription: localize("suggest.selectionMode", "Controls whether a suggestion is selected when the widget shows. Note that this only applies to automatically triggered suggestions (`#editor.quickSuggestions#` and `#editor.suggestOnTriggerCharacters#`) and that a suggestion is always selected when explicitly invoked, e.g via `Ctrl+Space`.")
      },
      "editor.suggest.snippetsPreventQuickSuggestions": {
        type: "boolean",
        default: defaults.snippetsPreventQuickSuggestions,
        description: localize("suggest.snippetsPreventQuickSuggestions", "Controls whether an active snippet prevents quick suggestions.")
      },
      "editor.suggest.showIcons": {
        type: "boolean",
        default: defaults.showIcons,
        description: localize("suggest.showIcons", "Controls whether to show or hide icons in suggestions.")
      },
      "editor.suggest.showStatusBar": {
        type: "boolean",
        default: defaults.showStatusBar,
        description: localize("suggest.showStatusBar", "Controls the visibility of the status bar at the bottom of the suggest widget.")
      },
      "editor.suggest.preview": {
        type: "boolean",
        default: defaults.preview,
        description: localize("suggest.preview", "Controls whether to preview the suggestion outcome in the editor.")
      },
      "editor.suggest.showInlineDetails": {
        type: "boolean",
        default: defaults.showInlineDetails,
        description: localize("suggest.showInlineDetails", "Controls whether suggest details show inline with the label or only in the details widget.")
      },
      "editor.suggest.maxVisibleSuggestions": {
        type: "number",
        deprecationMessage: localize("suggest.maxVisibleSuggestions.dep", "This setting is deprecated. The suggest widget can now be resized.")
      },
      "editor.suggest.filteredTypes": {
        type: "object",
        deprecationMessage: localize("deprecated", "This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.")
      },
      "editor.suggest.showMethods": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showMethods", "When enabled IntelliSense shows `method`-suggestions.")
      },
      "editor.suggest.showFunctions": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showFunctions", "When enabled IntelliSense shows `function`-suggestions.")
      },
      "editor.suggest.showConstructors": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showConstructors", "When enabled IntelliSense shows `constructor`-suggestions.")
      },
      "editor.suggest.showDeprecated": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showDeprecated", "When enabled IntelliSense shows `deprecated`-suggestions.")
      },
      "editor.suggest.matchOnWordStartOnly": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.matchOnWordStartOnly", "When enabled IntelliSense filtering requires that the first character matches on a word start. For example, `c` on `Console` or `WebContext` but _not_ on `description`. When disabled IntelliSense will show more results but still sorts them by match quality.")
      },
      "editor.suggest.showFields": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showFields", "When enabled IntelliSense shows `field`-suggestions.")
      },
      "editor.suggest.showVariables": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showVariables", "When enabled IntelliSense shows `variable`-suggestions.")
      },
      "editor.suggest.showClasses": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showClasss", "When enabled IntelliSense shows `class`-suggestions.")
      },
      "editor.suggest.showStructs": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showStructs", "When enabled IntelliSense shows `struct`-suggestions.")
      },
      "editor.suggest.showInterfaces": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showInterfaces", "When enabled IntelliSense shows `interface`-suggestions.")
      },
      "editor.suggest.showModules": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showModules", "When enabled IntelliSense shows `module`-suggestions.")
      },
      "editor.suggest.showProperties": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showPropertys", "When enabled IntelliSense shows `property`-suggestions.")
      },
      "editor.suggest.showEvents": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showEvents", "When enabled IntelliSense shows `event`-suggestions.")
      },
      "editor.suggest.showOperators": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showOperators", "When enabled IntelliSense shows `operator`-suggestions.")
      },
      "editor.suggest.showUnits": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showUnits", "When enabled IntelliSense shows `unit`-suggestions.")
      },
      "editor.suggest.showValues": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showValues", "When enabled IntelliSense shows `value`-suggestions.")
      },
      "editor.suggest.showConstants": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showConstants", "When enabled IntelliSense shows `constant`-suggestions.")
      },
      "editor.suggest.showEnums": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showEnums", "When enabled IntelliSense shows `enum`-suggestions.")
      },
      "editor.suggest.showEnumMembers": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showEnumMembers", "When enabled IntelliSense shows `enumMember`-suggestions.")
      },
      "editor.suggest.showKeywords": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showKeywords", "When enabled IntelliSense shows `keyword`-suggestions.")
      },
      "editor.suggest.showWords": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showTexts", "When enabled IntelliSense shows `text`-suggestions.")
      },
      "editor.suggest.showColors": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showColors", "When enabled IntelliSense shows `color`-suggestions.")
      },
      "editor.suggest.showFiles": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showFiles", "When enabled IntelliSense shows `file`-suggestions.")
      },
      "editor.suggest.showReferences": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showReferences", "When enabled IntelliSense shows `reference`-suggestions.")
      },
      "editor.suggest.showCustomcolors": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showCustomcolors", "When enabled IntelliSense shows `customcolor`-suggestions.")
      },
      "editor.suggest.showFolders": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showFolders", "When enabled IntelliSense shows `folder`-suggestions.")
      },
      "editor.suggest.showTypeParameters": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showTypeParameters", "When enabled IntelliSense shows `typeParameter`-suggestions.")
      },
      "editor.suggest.showSnippets": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showSnippets", "When enabled IntelliSense shows `snippet`-suggestions.")
      },
      "editor.suggest.showUsers": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showUsers", "When enabled IntelliSense shows `user`-suggestions.")
      },
      "editor.suggest.showIssues": {
        type: "boolean",
        default: true,
        markdownDescription: localize("editor.suggest.showIssues", "When enabled IntelliSense shows `issues`-suggestions.")
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      insertMode: stringSet(input.insertMode, this.defaultValue.insertMode, ["insert", "replace"]),
      filterGraceful: boolean(input.filterGraceful, this.defaultValue.filterGraceful),
      snippetsPreventQuickSuggestions: boolean(input.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),
      localityBonus: boolean(input.localityBonus, this.defaultValue.localityBonus),
      shareSuggestSelections: boolean(input.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
      selectionMode: stringSet(input.selectionMode, this.defaultValue.selectionMode, ["always", "never", "whenQuickSuggestion", "whenTriggerCharacter"]),
      showIcons: boolean(input.showIcons, this.defaultValue.showIcons),
      showStatusBar: boolean(input.showStatusBar, this.defaultValue.showStatusBar),
      preview: boolean(input.preview, this.defaultValue.preview),
      previewMode: stringSet(input.previewMode, this.defaultValue.previewMode, ["prefix", "subword", "subwordSmart"]),
      showInlineDetails: boolean(input.showInlineDetails, this.defaultValue.showInlineDetails),
      showMethods: boolean(input.showMethods, this.defaultValue.showMethods),
      showFunctions: boolean(input.showFunctions, this.defaultValue.showFunctions),
      showConstructors: boolean(input.showConstructors, this.defaultValue.showConstructors),
      showDeprecated: boolean(input.showDeprecated, this.defaultValue.showDeprecated),
      matchOnWordStartOnly: boolean(input.matchOnWordStartOnly, this.defaultValue.matchOnWordStartOnly),
      showFields: boolean(input.showFields, this.defaultValue.showFields),
      showVariables: boolean(input.showVariables, this.defaultValue.showVariables),
      showClasses: boolean(input.showClasses, this.defaultValue.showClasses),
      showStructs: boolean(input.showStructs, this.defaultValue.showStructs),
      showInterfaces: boolean(input.showInterfaces, this.defaultValue.showInterfaces),
      showModules: boolean(input.showModules, this.defaultValue.showModules),
      showProperties: boolean(input.showProperties, this.defaultValue.showProperties),
      showEvents: boolean(input.showEvents, this.defaultValue.showEvents),
      showOperators: boolean(input.showOperators, this.defaultValue.showOperators),
      showUnits: boolean(input.showUnits, this.defaultValue.showUnits),
      showValues: boolean(input.showValues, this.defaultValue.showValues),
      showConstants: boolean(input.showConstants, this.defaultValue.showConstants),
      showEnums: boolean(input.showEnums, this.defaultValue.showEnums),
      showEnumMembers: boolean(input.showEnumMembers, this.defaultValue.showEnumMembers),
      showKeywords: boolean(input.showKeywords, this.defaultValue.showKeywords),
      showWords: boolean(input.showWords, this.defaultValue.showWords),
      showColors: boolean(input.showColors, this.defaultValue.showColors),
      showFiles: boolean(input.showFiles, this.defaultValue.showFiles),
      showReferences: boolean(input.showReferences, this.defaultValue.showReferences),
      showFolders: boolean(input.showFolders, this.defaultValue.showFolders),
      showTypeParameters: boolean(input.showTypeParameters, this.defaultValue.showTypeParameters),
      showSnippets: boolean(input.showSnippets, this.defaultValue.showSnippets),
      showUsers: boolean(input.showUsers, this.defaultValue.showUsers),
      showIssues: boolean(input.showIssues, this.defaultValue.showIssues)
    };
  }
};
var SmartSelect = class extends BaseEditorOption {
  constructor() {
    super(113, "smartSelect", {
      selectLeadingAndTrailingWhitespace: true,
      selectSubwords: true
    }, {
      "editor.smartSelect.selectLeadingAndTrailingWhitespace": {
        description: localize("selectLeadingAndTrailingWhitespace", "Whether leading and trailing whitespace should always be selected."),
        default: true,
        type: "boolean"
      },
      "editor.smartSelect.selectSubwords": {
        description: localize("selectSubwords", "Whether subwords (like 'foo' in 'fooBar' or 'foo_bar') should be selected."),
        default: true,
        type: "boolean"
      }
    });
  }
  validate(input) {
    if (!input || typeof input !== "object") {
      return this.defaultValue;
    }
    return {
      selectLeadingAndTrailingWhitespace: boolean(input.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace),
      selectSubwords: boolean(input.selectSubwords, this.defaultValue.selectSubwords)
    };
  }
};
var WrappingIndentOption = class extends BaseEditorOption {
  constructor() {
    super(137, "wrappingIndent", 1, {
      "editor.wrappingIndent": {
        type: "string",
        enum: ["none", "same", "indent", "deepIndent"],
        enumDescriptions: [
          localize("wrappingIndent.none", "No indentation. Wrapped lines begin at column 1."),
          localize("wrappingIndent.same", "Wrapped lines get the same indentation as the parent."),
          localize("wrappingIndent.indent", "Wrapped lines get +1 indentation toward the parent."),
          localize("wrappingIndent.deepIndent", "Wrapped lines get +2 indentation toward the parent.")
        ],
        description: localize("wrappingIndent", "Controls the indentation of wrapped lines."),
        default: "same"
      }
    });
  }
  validate(input) {
    switch (input) {
      case "none":
        return 0;
      case "same":
        return 1;
      case "indent":
        return 2;
      case "deepIndent":
        return 3;
    }
    return 1;
  }
  compute(env, options2, value) {
    const accessibilitySupport = options2.get(
      2
      /* EditorOption.accessibilitySupport */
    );
    if (accessibilitySupport === 2) {
      return 0;
    }
    return value;
  }
};
var EditorWrappingInfoComputer = class extends ComputedEditorOption {
  constructor() {
    super(
      145
      /* EditorOption.wrappingInfo */
    );
  }
  compute(env, options2, _) {
    const layoutInfo = options2.get(
      144
      /* EditorOption.layoutInfo */
    );
    return {
      isDominatedByLongLines: env.isDominatedByLongLines,
      isWordWrapMinified: layoutInfo.isWordWrapMinified,
      isViewportWrapping: layoutInfo.isViewportWrapping,
      wrappingColumn: layoutInfo.wrappingColumn
    };
  }
};
var EditorDropIntoEditor = class extends BaseEditorOption {
  constructor() {
    const defaults = { enabled: true, showDropSelector: "afterDrop" };
    super(36, "dropIntoEditor", defaults, {
      "editor.dropIntoEditor.enabled": {
        type: "boolean",
        default: defaults.enabled,
        markdownDescription: localize("dropIntoEditor.enabled", "Controls whether you can drag and drop a file into a text editor by holding down the `Shift` key (instead of opening the file in an editor).")
      },
      "editor.dropIntoEditor.showDropSelector": {
        type: "string",
        markdownDescription: localize("dropIntoEditor.showDropSelector", "Controls if a widget is shown when dropping files into the editor. This widget lets you control how the file is dropped."),
        enum: [
          "afterDrop",
          "never"
        ],
        enumDescriptions: [
          localize("dropIntoEditor.showDropSelector.afterDrop", "Show the drop selector widget after a file is dropped into the editor."),
          localize("dropIntoEditor.showDropSelector.never", "Never show the drop selector widget. Instead the default drop provider is always used.")
        ],
        default: "afterDrop"
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: boolean(input.enabled, this.defaultValue.enabled),
      showDropSelector: stringSet(input.showDropSelector, this.defaultValue.showDropSelector, ["afterDrop", "never"])
    };
  }
};
var EditorPasteAs = class extends BaseEditorOption {
  constructor() {
    const defaults = { enabled: true, showPasteSelector: "afterPaste" };
    super(85, "pasteAs", defaults, {
      "editor.pasteAs.enabled": {
        type: "boolean",
        default: defaults.enabled,
        markdownDescription: localize("pasteAs.enabled", "Controls whether you can paste content in different ways.")
      },
      "editor.pasteAs.showPasteSelector": {
        type: "string",
        markdownDescription: localize("pasteAs.showPasteSelector", "Controls if a widget is shown when pasting content in to the editor. This widget lets you control how the file is pasted."),
        enum: [
          "afterPaste",
          "never"
        ],
        enumDescriptions: [
          localize("pasteAs.showPasteSelector.afterPaste", "Show the paste selector widget after content is pasted into the editor."),
          localize("pasteAs.showPasteSelector.never", "Never show the paste selector widget. Instead the default pasting behavior is always used.")
        ],
        default: "afterPaste"
      }
    });
  }
  validate(_input) {
    if (!_input || typeof _input !== "object") {
      return this.defaultValue;
    }
    const input = _input;
    return {
      enabled: boolean(input.enabled, this.defaultValue.enabled),
      showPasteSelector: stringSet(input.showPasteSelector, this.defaultValue.showPasteSelector, ["afterPaste", "never"])
    };
  }
};
var DEFAULT_WINDOWS_FONT_FAMILY = "Consolas, 'Courier New', monospace";
var DEFAULT_MAC_FONT_FAMILY = "Menlo, Monaco, 'Courier New', monospace";
var DEFAULT_LINUX_FONT_FAMILY = "'Droid Sans Mono', 'monospace', monospace";
var EDITOR_FONT_DEFAULTS = {
  fontFamily: isMacintosh ? DEFAULT_MAC_FONT_FAMILY : isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY,
  fontWeight: "normal",
  fontSize: isMacintosh ? 12 : 14,
  lineHeight: 0,
  letterSpacing: 0
};
var editorOptionsRegistry = [];
function register(option) {
  editorOptionsRegistry[option.id] = option;
  return option;
}
var EditorOptions = {
  acceptSuggestionOnCommitCharacter: register(new EditorBooleanOption(0, "acceptSuggestionOnCommitCharacter", true, { markdownDescription: localize("acceptSuggestionOnCommitCharacter", "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.") })),
  acceptSuggestionOnEnter: register(new EditorStringEnumOption(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
    markdownEnumDescriptions: [
      "",
      localize("acceptSuggestionOnEnterSmart", "Only accept a suggestion with `Enter` when it makes a textual change."),
      ""
    ],
    markdownDescription: localize("acceptSuggestionOnEnter", "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.")
  })),
  accessibilitySupport: register(new EditorAccessibilitySupport()),
  accessibilityPageSize: register(new EditorIntOption(3, "accessibilityPageSize", 10, 1, 1073741824, {
    description: localize("accessibilityPageSize", "Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default."),
    tags: ["accessibility"]
  })),
  ariaLabel: register(new EditorStringOption(4, "ariaLabel", localize("editorViewAccessibleLabel", "Editor content"))),
  ariaRequired: register(new EditorBooleanOption(5, "ariaRequired", false, void 0)),
  screenReaderAnnounceInlineSuggestion: register(new EditorBooleanOption(8, "screenReaderAnnounceInlineSuggestion", true, {
    description: localize("screenReaderAnnounceInlineSuggestion", "Control whether inline suggestions are announced by a screen reader."),
    tags: ["accessibility"]
  })),
  autoClosingBrackets: register(new EditorStringEnumOption(6, "autoClosingBrackets", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      localize("editor.autoClosingBrackets.languageDefined", "Use language configurations to determine when to autoclose brackets."),
      localize("editor.autoClosingBrackets.beforeWhitespace", "Autoclose brackets only when the cursor is to the left of whitespace."),
      ""
    ],
    description: localize("autoClosingBrackets", "Controls whether the editor should automatically close brackets after the user adds an opening bracket.")
  })),
  autoClosingComments: register(new EditorStringEnumOption(7, "autoClosingComments", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      localize("editor.autoClosingComments.languageDefined", "Use language configurations to determine when to autoclose comments."),
      localize("editor.autoClosingComments.beforeWhitespace", "Autoclose comments only when the cursor is to the left of whitespace."),
      ""
    ],
    description: localize("autoClosingComments", "Controls whether the editor should automatically close comments after the user adds an opening comment.")
  })),
  autoClosingDelete: register(new EditorStringEnumOption(9, "autoClosingDelete", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      localize("editor.autoClosingDelete.auto", "Remove adjacent closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: localize("autoClosingDelete", "Controls whether the editor should remove adjacent closing quotes or brackets when deleting.")
  })),
  autoClosingOvertype: register(new EditorStringEnumOption(10, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      localize("editor.autoClosingOvertype.auto", "Type over closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: localize("autoClosingOvertype", "Controls whether the editor should type over closing quotes or brackets.")
  })),
  autoClosingQuotes: register(new EditorStringEnumOption(11, "autoClosingQuotes", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      localize("editor.autoClosingQuotes.languageDefined", "Use language configurations to determine when to autoclose quotes."),
      localize("editor.autoClosingQuotes.beforeWhitespace", "Autoclose quotes only when the cursor is to the left of whitespace."),
      ""
    ],
    description: localize("autoClosingQuotes", "Controls whether the editor should automatically close quotes after the user adds an opening quote.")
  })),
  autoIndent: register(new EditorEnumOption(12, "autoIndent", 4, "full", ["none", "keep", "brackets", "advanced", "full"], _autoIndentFromString, {
    enumDescriptions: [
      localize("editor.autoIndent.none", "The editor will not insert indentation automatically."),
      localize("editor.autoIndent.keep", "The editor will keep the current line's indentation."),
      localize("editor.autoIndent.brackets", "The editor will keep the current line's indentation and honor language defined brackets."),
      localize("editor.autoIndent.advanced", "The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages."),
      localize("editor.autoIndent.full", "The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.")
    ],
    description: localize("autoIndent", "Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.")
  })),
  automaticLayout: register(new EditorBooleanOption(13, "automaticLayout", false)),
  autoSurround: register(new EditorStringEnumOption(14, "autoSurround", "languageDefined", ["languageDefined", "quotes", "brackets", "never"], {
    enumDescriptions: [
      localize("editor.autoSurround.languageDefined", "Use language configurations to determine when to automatically surround selections."),
      localize("editor.autoSurround.quotes", "Surround with quotes but not brackets."),
      localize("editor.autoSurround.brackets", "Surround with brackets but not quotes."),
      ""
    ],
    description: localize("autoSurround", "Controls whether the editor should automatically surround selections when typing quotes or brackets.")
  })),
  bracketPairColorization: register(new BracketPairColorization()),
  bracketPairGuides: register(new GuideOptions()),
  stickyTabStops: register(new EditorBooleanOption(116, "stickyTabStops", false, { description: localize("stickyTabStops", "Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.") })),
  codeLens: register(new EditorBooleanOption(17, "codeLens", true, { description: localize("codeLens", "Controls whether the editor shows CodeLens.") })),
  codeLensFontFamily: register(new EditorStringOption(18, "codeLensFontFamily", "", { description: localize("codeLensFontFamily", "Controls the font family for CodeLens.") })),
  codeLensFontSize: register(new EditorIntOption(19, "codeLensFontSize", 0, 0, 100, {
    type: "number",
    default: 0,
    minimum: 0,
    maximum: 100,
    markdownDescription: localize("codeLensFontSize", "Controls the font size in pixels for CodeLens. When set to 0, 90% of `#editor.fontSize#` is used.")
  })),
  colorDecorators: register(new EditorBooleanOption(20, "colorDecorators", true, { description: localize("colorDecorators", "Controls whether the editor should render the inline color decorators and color picker.") })),
  colorDecoratorActivatedOn: register(new EditorStringEnumOption(147, "colorDecoratorsActivatedOn", "clickAndHover", ["clickAndHover", "hover", "click"], {
    enumDescriptions: [
      localize("editor.colorDecoratorActivatedOn.clickAndHover", "Make the color picker appear both on click and hover of the color decorator"),
      localize("editor.colorDecoratorActivatedOn.hover", "Make the color picker appear on hover of the color decorator"),
      localize("editor.colorDecoratorActivatedOn.click", "Make the color picker appear on click of the color decorator")
    ],
    description: localize("colorDecoratorActivatedOn", "Controls the condition to make a color picker appear from a color decorator")
  })),
  colorDecoratorsLimit: register(new EditorIntOption(21, "colorDecoratorsLimit", 500, 1, 1e6, {
    markdownDescription: localize("colorDecoratorsLimit", "Controls the max number of color decorators that can be rendered in an editor at once.")
  })),
  columnSelection: register(new EditorBooleanOption(22, "columnSelection", false, { description: localize("columnSelection", "Enable that the selection with the mouse and keys is doing column selection.") })),
  comments: register(new EditorComments()),
  contextmenu: register(new EditorBooleanOption(24, "contextmenu", true)),
  copyWithSyntaxHighlighting: register(new EditorBooleanOption(25, "copyWithSyntaxHighlighting", true, { description: localize("copyWithSyntaxHighlighting", "Controls whether syntax highlighting should be copied into the clipboard.") })),
  cursorBlinking: register(new EditorEnumOption(26, "cursorBlinking", 1, "blink", ["blink", "smooth", "phase", "expand", "solid"], _cursorBlinkingStyleFromString, { description: localize("cursorBlinking", "Control the cursor animation style.") })),
  cursorSmoothCaretAnimation: register(new EditorStringEnumOption(27, "cursorSmoothCaretAnimation", "off", ["off", "explicit", "on"], {
    enumDescriptions: [
      localize("cursorSmoothCaretAnimation.off", "Smooth caret animation is disabled."),
      localize("cursorSmoothCaretAnimation.explicit", "Smooth caret animation is enabled only when the user moves the cursor with an explicit gesture."),
      localize("cursorSmoothCaretAnimation.on", "Smooth caret animation is always enabled.")
    ],
    description: localize("cursorSmoothCaretAnimation", "Controls whether the smooth caret animation should be enabled.")
  })),
  cursorStyle: register(new EditorEnumOption(28, "cursorStyle", TextEditorCursorStyle.Line, "line", ["line", "block", "underline", "line-thin", "block-outline", "underline-thin"], _cursorStyleFromString, { description: localize("cursorStyle", "Controls the cursor style.") })),
  cursorSurroundingLines: register(new EditorIntOption(29, "cursorSurroundingLines", 0, 0, 1073741824, { description: localize("cursorSurroundingLines", "Controls the minimal number of visible leading lines (minimum 0) and trailing lines (minimum 1) surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.") })),
  cursorSurroundingLinesStyle: register(new EditorStringEnumOption(30, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
    enumDescriptions: [
      localize("cursorSurroundingLinesStyle.default", "`cursorSurroundingLines` is enforced only when triggered via the keyboard or API."),
      localize("cursorSurroundingLinesStyle.all", "`cursorSurroundingLines` is enforced always.")
    ],
    markdownDescription: localize("cursorSurroundingLinesStyle", "Controls when `#cursorSurroundingLines#` should be enforced.")
  })),
  cursorWidth: register(new EditorIntOption(31, "cursorWidth", 0, 0, 1073741824, { markdownDescription: localize("cursorWidth", "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.") })),
  disableLayerHinting: register(new EditorBooleanOption(32, "disableLayerHinting", false)),
  disableMonospaceOptimizations: register(new EditorBooleanOption(33, "disableMonospaceOptimizations", false)),
  domReadOnly: register(new EditorBooleanOption(34, "domReadOnly", false)),
  dragAndDrop: register(new EditorBooleanOption(35, "dragAndDrop", true, { description: localize("dragAndDrop", "Controls whether the editor should allow moving selections via drag and drop.") })),
  emptySelectionClipboard: register(new EditorEmptySelectionClipboard()),
  dropIntoEditor: register(new EditorDropIntoEditor()),
  stickyScroll: register(new EditorStickyScroll()),
  experimentalWhitespaceRendering: register(new EditorStringEnumOption(38, "experimentalWhitespaceRendering", "svg", ["svg", "font", "off"], {
    enumDescriptions: [
      localize("experimentalWhitespaceRendering.svg", "Use a new rendering method with svgs."),
      localize("experimentalWhitespaceRendering.font", "Use a new rendering method with font characters."),
      localize("experimentalWhitespaceRendering.off", "Use the stable rendering method.")
    ],
    description: localize("experimentalWhitespaceRendering", "Controls whether whitespace is rendered with a new, experimental method.")
  })),
  extraEditorClassName: register(new EditorStringOption(39, "extraEditorClassName", "")),
  fastScrollSensitivity: register(new EditorFloatOption(40, "fastScrollSensitivity", 5, (x) => x <= 0 ? 5 : x, { markdownDescription: localize("fastScrollSensitivity", "Scrolling speed multiplier when pressing `Alt`.") })),
  find: register(new EditorFind()),
  fixedOverflowWidgets: register(new EditorBooleanOption(42, "fixedOverflowWidgets", false)),
  folding: register(new EditorBooleanOption(43, "folding", true, { description: localize("folding", "Controls whether the editor has code folding enabled.") })),
  foldingStrategy: register(new EditorStringEnumOption(44, "foldingStrategy", "auto", ["auto", "indentation"], {
    enumDescriptions: [
      localize("foldingStrategy.auto", "Use a language-specific folding strategy if available, else the indentation-based one."),
      localize("foldingStrategy.indentation", "Use the indentation-based folding strategy.")
    ],
    description: localize("foldingStrategy", "Controls the strategy for computing folding ranges.")
  })),
  foldingHighlight: register(new EditorBooleanOption(45, "foldingHighlight", true, { description: localize("foldingHighlight", "Controls whether the editor should highlight folded ranges.") })),
  foldingImportsByDefault: register(new EditorBooleanOption(46, "foldingImportsByDefault", false, { description: localize("foldingImportsByDefault", "Controls whether the editor automatically collapses import ranges.") })),
  foldingMaximumRegions: register(new EditorIntOption(
    47,
    "foldingMaximumRegions",
    5e3,
    10,
    65e3,
    // limit must be less than foldingRanges MAX_FOLDING_REGIONS
    { description: localize("foldingMaximumRegions", "The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.") }
  )),
  unfoldOnClickAfterEndOfLine: register(new EditorBooleanOption(48, "unfoldOnClickAfterEndOfLine", false, { description: localize("unfoldOnClickAfterEndOfLine", "Controls whether clicking on the empty content after a folded line will unfold the line.") })),
  fontFamily: register(new EditorStringOption(49, "fontFamily", EDITOR_FONT_DEFAULTS.fontFamily, { description: localize("fontFamily", "Controls the font family.") })),
  fontInfo: register(new EditorFontInfo()),
  fontLigatures2: register(new EditorFontLigatures()),
  fontSize: register(new EditorFontSize()),
  fontWeight: register(new EditorFontWeight()),
  fontVariations: register(new EditorFontVariations()),
  formatOnPaste: register(new EditorBooleanOption(55, "formatOnPaste", false, { description: localize("formatOnPaste", "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.") })),
  formatOnType: register(new EditorBooleanOption(56, "formatOnType", false, { description: localize("formatOnType", "Controls whether the editor should automatically format the line after typing.") })),
  glyphMargin: register(new EditorBooleanOption(57, "glyphMargin", true, { description: localize("glyphMargin", "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.") })),
  gotoLocation: register(new EditorGoToLocation()),
  hideCursorInOverviewRuler: register(new EditorBooleanOption(59, "hideCursorInOverviewRuler", false, { description: localize("hideCursorInOverviewRuler", "Controls whether the cursor should be hidden in the overview ruler.") })),
  hover: register(new EditorHover()),
  inDiffEditor: register(new EditorBooleanOption(61, "inDiffEditor", false)),
  letterSpacing: register(new EditorFloatOption(64, "letterSpacing", EDITOR_FONT_DEFAULTS.letterSpacing, (x) => EditorFloatOption.clamp(x, -5, 20), { description: localize("letterSpacing", "Controls the letter spacing in pixels.") })),
  lightbulb: register(new EditorLightbulb()),
  lineDecorationsWidth: register(new EditorLineDecorationsWidth()),
  lineHeight: register(new EditorLineHeight()),
  lineNumbers: register(new EditorRenderLineNumbersOption()),
  lineNumbersMinChars: register(new EditorIntOption(69, "lineNumbersMinChars", 5, 1, 300)),
  linkedEditing: register(new EditorBooleanOption(70, "linkedEditing", false, { description: localize("linkedEditing", "Controls whether the editor has linked editing enabled. Depending on the language, related symbols such as HTML tags, are updated while editing.") })),
  links: register(new EditorBooleanOption(71, "links", true, { description: localize("links", "Controls whether the editor should detect links and make them clickable.") })),
  matchBrackets: register(new EditorStringEnumOption(72, "matchBrackets", "always", ["always", "near", "never"], { description: localize("matchBrackets", "Highlight matching brackets.") })),
  minimap: register(new EditorMinimap()),
  mouseStyle: register(new EditorStringEnumOption(74, "mouseStyle", "text", ["text", "default", "copy"])),
  mouseWheelScrollSensitivity: register(new EditorFloatOption(75, "mouseWheelScrollSensitivity", 1, (x) => x === 0 ? 1 : x, { markdownDescription: localize("mouseWheelScrollSensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.") })),
  mouseWheelZoom: register(new EditorBooleanOption(76, "mouseWheelZoom", false, {
    markdownDescription: isMacintosh ? localize("mouseWheelZoom.mac", "Zoom the font of the editor when using mouse wheel and holding `Cmd`.") : localize("mouseWheelZoom", "Zoom the font of the editor when using mouse wheel and holding `Ctrl`.")
  })),
  multiCursorMergeOverlapping: register(new EditorBooleanOption(77, "multiCursorMergeOverlapping", true, { description: localize("multiCursorMergeOverlapping", "Merge multiple cursors when they are overlapping.") })),
  multiCursorModifier: register(new EditorEnumOption(78, "multiCursorModifier", "altKey", "alt", ["ctrlCmd", "alt"], _multiCursorModifierFromString, {
    markdownEnumDescriptions: [
      localize("multiCursorModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
      localize("multiCursorModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
    ],
    markdownDescription: localize({
      key: "multiCursorModifier",
      comment: [
        "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
        "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
      ]
    }, "The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the [multicursor modifier](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).")
  })),
  multiCursorPaste: register(new EditorStringEnumOption(79, "multiCursorPaste", "spread", ["spread", "full"], {
    markdownEnumDescriptions: [
      localize("multiCursorPaste.spread", "Each cursor pastes a single line of the text."),
      localize("multiCursorPaste.full", "Each cursor pastes the full text.")
    ],
    markdownDescription: localize("multiCursorPaste", "Controls pasting when the line count of the pasted text matches the cursor count.")
  })),
  multiCursorLimit: register(new EditorIntOption(80, "multiCursorLimit", 1e4, 1, 1e5, {
    markdownDescription: localize("multiCursorLimit", "Controls the max number of cursors that can be in an active editor at once.")
  })),
  occurrencesHighlight: register(new EditorStringEnumOption(81, "occurrencesHighlight", "singleFile", ["off", "singleFile", "multiFile"], {
    markdownEnumDescriptions: [
      localize("occurrencesHighlight.off", "Does not highlight occurrences."),
      localize("occurrencesHighlight.singleFile", "Highlights occurrences only in the current file."),
      localize("occurrencesHighlight.multiFile", "Experimental: Highlights occurrences across all valid open files.")
    ],
    markdownDescription: localize("occurrencesHighlight", "Controls whether occurrences should be highlighted across open files.")
  })),
  overviewRulerBorder: register(new EditorBooleanOption(82, "overviewRulerBorder", true, { description: localize("overviewRulerBorder", "Controls whether a border should be drawn around the overview ruler.") })),
  overviewRulerLanes: register(new EditorIntOption(83, "overviewRulerLanes", 3, 0, 3)),
  padding: register(new EditorPadding()),
  pasteAs: register(new EditorPasteAs()),
  parameterHints: register(new EditorParameterHints()),
  peekWidgetDefaultFocus: register(new EditorStringEnumOption(87, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
    enumDescriptions: [
      localize("peekWidgetDefaultFocus.tree", "Focus the tree when opening peek"),
      localize("peekWidgetDefaultFocus.editor", "Focus the editor when opening peek")
    ],
    description: localize("peekWidgetDefaultFocus", "Controls whether to focus the inline editor or the tree in the peek widget.")
  })),
  definitionLinkOpensInPeek: register(new EditorBooleanOption(88, "definitionLinkOpensInPeek", false, { description: localize("definitionLinkOpensInPeek", "Controls whether the Go to Definition mouse gesture always opens the peek widget.") })),
  quickSuggestions: register(new EditorQuickSuggestions()),
  quickSuggestionsDelay: register(new EditorIntOption(90, "quickSuggestionsDelay", 10, 0, 1073741824, { description: localize("quickSuggestionsDelay", "Controls the delay in milliseconds after which quick suggestions will show up.") })),
  readOnly: register(new EditorBooleanOption(91, "readOnly", false)),
  readOnlyMessage: register(new ReadonlyMessage()),
  renameOnType: register(new EditorBooleanOption(93, "renameOnType", false, { description: localize("renameOnType", "Controls whether the editor auto renames on type."), markdownDeprecationMessage: localize("renameOnTypeDeprecate", "Deprecated, use `editor.linkedEditing` instead.") })),
  renderControlCharacters: register(new EditorBooleanOption(94, "renderControlCharacters", true, { description: localize("renderControlCharacters", "Controls whether the editor should render control characters."), restricted: true })),
  renderFinalNewline: register(new EditorStringEnumOption(95, "renderFinalNewline", isLinux ? "dimmed" : "on", ["off", "on", "dimmed"], { description: localize("renderFinalNewline", "Render last line number when the file ends with a newline.") })),
  renderLineHighlight: register(new EditorStringEnumOption(96, "renderLineHighlight", "line", ["none", "gutter", "line", "all"], {
    enumDescriptions: [
      "",
      "",
      "",
      localize("renderLineHighlight.all", "Highlights both the gutter and the current line.")
    ],
    description: localize("renderLineHighlight", "Controls how the editor should render the current line highlight.")
  })),
  renderLineHighlightOnlyWhenFocus: register(new EditorBooleanOption(97, "renderLineHighlightOnlyWhenFocus", false, { description: localize("renderLineHighlightOnlyWhenFocus", "Controls if the editor should render the current line highlight only when the editor is focused.") })),
  renderValidationDecorations: register(new EditorStringEnumOption(98, "renderValidationDecorations", "editable", ["editable", "on", "off"])),
  renderWhitespace: register(new EditorStringEnumOption(99, "renderWhitespace", "selection", ["none", "boundary", "selection", "trailing", "all"], {
    enumDescriptions: [
      "",
      localize("renderWhitespace.boundary", "Render whitespace characters except for single spaces between words."),
      localize("renderWhitespace.selection", "Render whitespace characters only on selected text."),
      localize("renderWhitespace.trailing", "Render only trailing whitespace characters."),
      ""
    ],
    description: localize("renderWhitespace", "Controls how the editor should render whitespace characters.")
  })),
  revealHorizontalRightPadding: register(new EditorIntOption(100, "revealHorizontalRightPadding", 15, 0, 1e3)),
  roundedSelection: register(new EditorBooleanOption(101, "roundedSelection", true, { description: localize("roundedSelection", "Controls whether selections should have rounded corners.") })),
  rulers: register(new EditorRulers()),
  scrollbar: register(new EditorScrollbar()),
  scrollBeyondLastColumn: register(new EditorIntOption(104, "scrollBeyondLastColumn", 4, 0, 1073741824, { description: localize("scrollBeyondLastColumn", "Controls the number of extra characters beyond which the editor will scroll horizontally.") })),
  scrollBeyondLastLine: register(new EditorBooleanOption(105, "scrollBeyondLastLine", true, { description: localize("scrollBeyondLastLine", "Controls whether the editor will scroll beyond the last line.") })),
  scrollPredominantAxis: register(new EditorBooleanOption(106, "scrollPredominantAxis", true, { description: localize("scrollPredominantAxis", "Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.") })),
  selectionClipboard: register(new EditorBooleanOption(107, "selectionClipboard", true, {
    description: localize("selectionClipboard", "Controls whether the Linux primary clipboard should be supported."),
    included: isLinux
  })),
  selectionHighlight: register(new EditorBooleanOption(108, "selectionHighlight", true, { description: localize("selectionHighlight", "Controls whether the editor should highlight matches similar to the selection.") })),
  selectOnLineNumbers: register(new EditorBooleanOption(109, "selectOnLineNumbers", true)),
  showFoldingControls: register(new EditorStringEnumOption(110, "showFoldingControls", "mouseover", ["always", "never", "mouseover"], {
    enumDescriptions: [
      localize("showFoldingControls.always", "Always show the folding controls."),
      localize("showFoldingControls.never", "Never show the folding controls and reduce the gutter size."),
      localize("showFoldingControls.mouseover", "Only show the folding controls when the mouse is over the gutter.")
    ],
    description: localize("showFoldingControls", "Controls when the folding controls on the gutter are shown.")
  })),
  showUnused: register(new EditorBooleanOption(111, "showUnused", true, { description: localize("showUnused", "Controls fading out of unused code.") })),
  showDeprecated: register(new EditorBooleanOption(139, "showDeprecated", true, { description: localize("showDeprecated", "Controls strikethrough deprecated variables.") })),
  inlayHints: register(new EditorInlayHints()),
  snippetSuggestions: register(new EditorStringEnumOption(112, "snippetSuggestions", "inline", ["top", "bottom", "inline", "none"], {
    enumDescriptions: [
      localize("snippetSuggestions.top", "Show snippet suggestions on top of other suggestions."),
      localize("snippetSuggestions.bottom", "Show snippet suggestions below other suggestions."),
      localize("snippetSuggestions.inline", "Show snippets suggestions with other suggestions."),
      localize("snippetSuggestions.none", "Do not show snippet suggestions.")
    ],
    description: localize("snippetSuggestions", "Controls whether snippets are shown with other suggestions and how they are sorted.")
  })),
  smartSelect: register(new SmartSelect()),
  smoothScrolling: register(new EditorBooleanOption(114, "smoothScrolling", false, { description: localize("smoothScrolling", "Controls whether the editor will scroll using an animation.") })),
  stopRenderingLineAfter: register(new EditorIntOption(
    117,
    "stopRenderingLineAfter",
    1e4,
    -1,
    1073741824
    /* Constants.MAX_SAFE_SMALL_INTEGER */
  )),
  suggest: register(new EditorSuggest()),
  inlineSuggest: register(new InlineEditorSuggest()),
  inlineEdit: register(new InlineEditorEdit()),
  inlineCompletionsAccessibilityVerbose: register(new EditorBooleanOption(148, "inlineCompletionsAccessibilityVerbose", false, { description: localize("inlineCompletionsAccessibilityVerbose", "Controls whether the accessibility hint should be provided to screen reader users when an inline completion is shown.") })),
  suggestFontSize: register(new EditorIntOption(119, "suggestFontSize", 0, 0, 1e3, { markdownDescription: localize("suggestFontSize", "Font size for the suggest widget. When set to {0}, the value of {1} is used.", "`0`", "`#editor.fontSize#`") })),
  suggestLineHeight: register(new EditorIntOption(120, "suggestLineHeight", 0, 0, 1e3, { markdownDescription: localize("suggestLineHeight", "Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.", "`0`", "`#editor.lineHeight#`") })),
  suggestOnTriggerCharacters: register(new EditorBooleanOption(121, "suggestOnTriggerCharacters", true, { description: localize("suggestOnTriggerCharacters", "Controls whether suggestions should automatically show up when typing trigger characters.") })),
  suggestSelection: register(new EditorStringEnumOption(122, "suggestSelection", "first", ["first", "recentlyUsed", "recentlyUsedByPrefix"], {
    markdownEnumDescriptions: [
      localize("suggestSelection.first", "Always select the first suggestion."),
      localize("suggestSelection.recentlyUsed", "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."),
      localize("suggestSelection.recentlyUsedByPrefix", "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.")
    ],
    description: localize("suggestSelection", "Controls how suggestions are pre-selected when showing the suggest list.")
  })),
  tabCompletion: register(new EditorStringEnumOption(123, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
    enumDescriptions: [
      localize("tabCompletion.on", "Tab complete will insert the best matching suggestion when pressing tab."),
      localize("tabCompletion.off", "Disable tab completions."),
      localize("tabCompletion.onlySnippets", "Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.")
    ],
    description: localize("tabCompletion", "Enables tab completions.")
  })),
  tabIndex: register(new EditorIntOption(
    124,
    "tabIndex",
    0,
    -1,
    1073741824
    /* Constants.MAX_SAFE_SMALL_INTEGER */
  )),
  unicodeHighlight: register(new UnicodeHighlight()),
  unusualLineTerminators: register(new EditorStringEnumOption(126, "unusualLineTerminators", "prompt", ["auto", "off", "prompt"], {
    enumDescriptions: [
      localize("unusualLineTerminators.auto", "Unusual line terminators are automatically removed."),
      localize("unusualLineTerminators.off", "Unusual line terminators are ignored."),
      localize("unusualLineTerminators.prompt", "Unusual line terminators prompt to be removed.")
    ],
    description: localize("unusualLineTerminators", "Remove unusual line terminators that might cause problems.")
  })),
  useShadowDOM: register(new EditorBooleanOption(127, "useShadowDOM", true)),
  useTabStops: register(new EditorBooleanOption(128, "useTabStops", true, { description: localize("useTabStops", "Inserting and deleting whitespace follows tab stops.") })),
  wordBreak: register(new EditorStringEnumOption(129, "wordBreak", "normal", ["normal", "keepAll"], {
    markdownEnumDescriptions: [
      localize("wordBreak.normal", "Use the default line break rule."),
      localize("wordBreak.keepAll", "Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal.")
    ],
    description: localize("wordBreak", "Controls the word break rules used for Chinese/Japanese/Korean (CJK) text.")
  })),
  wordSeparators: register(new EditorStringOption(130, "wordSeparators", USUAL_WORD_SEPARATORS, { description: localize("wordSeparators", "Characters that will be used as word separators when doing word related navigations or operations.") })),
  wordWrap: register(new EditorStringEnumOption(131, "wordWrap", "off", ["off", "on", "wordWrapColumn", "bounded"], {
    markdownEnumDescriptions: [
      localize("wordWrap.off", "Lines will never wrap."),
      localize("wordWrap.on", "Lines will wrap at the viewport width."),
      localize({
        key: "wordWrap.wordWrapColumn",
        comment: [
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at `#editor.wordWrapColumn#`."),
      localize({
        key: "wordWrap.bounded",
        comment: [
          "- viewport means the edge of the visible window size.",
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.")
    ],
    description: localize({
      key: "wordWrap",
      comment: [
        "- 'off', 'on', 'wordWrapColumn' and 'bounded' refer to values the setting can take and should not be localized.",
        "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
      ]
    }, "Controls how lines should wrap.")
  })),
  wordWrapBreakAfterCharacters: register(new EditorStringOption(
    132,
    "wordWrapBreakAfterCharacters",
    // allow-any-unicode-next-line
    " 	})]?|/&.,;"
  )),
  wordWrapBreakBeforeCharacters: register(new EditorStringOption(
    133,
    "wordWrapBreakBeforeCharacters",
    // allow-any-unicode-next-line
    "([{+"
  )),
  wordWrapColumn: register(new EditorIntOption(134, "wordWrapColumn", 80, 1, 1073741824, {
    markdownDescription: localize({
      key: "wordWrapColumn",
      comment: [
        "- `editor.wordWrap` refers to a different setting and should not be localized.",
        "- 'wordWrapColumn' and 'bounded' refer to values the different setting can take and should not be localized."
      ]
    }, "Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.")
  })),
  wordWrapOverride1: register(new EditorStringEnumOption(135, "wordWrapOverride1", "inherit", ["off", "on", "inherit"])),
  wordWrapOverride2: register(new EditorStringEnumOption(136, "wordWrapOverride2", "inherit", ["off", "on", "inherit"])),
  // Leave these at the end (because they have dependencies!)
  editorClassName: register(new EditorClassName()),
  defaultColorDecorators: register(new EditorBooleanOption(146, "defaultColorDecorators", false, { markdownDescription: localize("defaultColorDecorators", "Controls whether inline color decorations should be shown using the default document color provider") })),
  pixelRatio: register(new EditorPixelRatio()),
  tabFocusMode: register(new EditorBooleanOption(143, "tabFocusMode", false, { markdownDescription: localize("tabFocusMode", "Controls whether the editor receives tabs or defers them to the workbench for navigation.") })),
  layoutInfo: register(new EditorLayoutInfoComputer()),
  wrappingInfo: register(new EditorWrappingInfoComputer()),
  wrappingIndent: register(new WrappingIndentOption()),
  wrappingStrategy: register(new WrappingStrategy())
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hoverWidget.js
init_dom();
init_keyboardEvent();

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollableElement.js
init_browser();
init_dom();

// node_modules/monaco-editor/esm/vs/base/browser/fastDomNode.js
var FastDomNode = class {
  constructor(domNode) {
    this.domNode = domNode;
    this._maxWidth = "";
    this._width = "";
    this._height = "";
    this._top = "";
    this._left = "";
    this._bottom = "";
    this._right = "";
    this._paddingLeft = "";
    this._fontFamily = "";
    this._fontWeight = "";
    this._fontSize = "";
    this._fontStyle = "";
    this._fontFeatureSettings = "";
    this._fontVariationSettings = "";
    this._textDecoration = "";
    this._lineHeight = "";
    this._letterSpacing = "";
    this._className = "";
    this._display = "";
    this._position = "";
    this._visibility = "";
    this._color = "";
    this._backgroundColor = "";
    this._layerHint = false;
    this._contain = "none";
    this._boxShadow = "";
  }
  setMaxWidth(_maxWidth) {
    const maxWidth = numberAsPixels(_maxWidth);
    if (this._maxWidth === maxWidth) {
      return;
    }
    this._maxWidth = maxWidth;
    this.domNode.style.maxWidth = this._maxWidth;
  }
  setWidth(_width) {
    const width = numberAsPixels(_width);
    if (this._width === width) {
      return;
    }
    this._width = width;
    this.domNode.style.width = this._width;
  }
  setHeight(_height) {
    const height = numberAsPixels(_height);
    if (this._height === height) {
      return;
    }
    this._height = height;
    this.domNode.style.height = this._height;
  }
  setTop(_top) {
    const top = numberAsPixels(_top);
    if (this._top === top) {
      return;
    }
    this._top = top;
    this.domNode.style.top = this._top;
  }
  setLeft(_left) {
    const left = numberAsPixels(_left);
    if (this._left === left) {
      return;
    }
    this._left = left;
    this.domNode.style.left = this._left;
  }
  setBottom(_bottom) {
    const bottom = numberAsPixels(_bottom);
    if (this._bottom === bottom) {
      return;
    }
    this._bottom = bottom;
    this.domNode.style.bottom = this._bottom;
  }
  setRight(_right) {
    const right = numberAsPixels(_right);
    if (this._right === right) {
      return;
    }
    this._right = right;
    this.domNode.style.right = this._right;
  }
  setPaddingLeft(_paddingLeft) {
    const paddingLeft = numberAsPixels(_paddingLeft);
    if (this._paddingLeft === paddingLeft) {
      return;
    }
    this._paddingLeft = paddingLeft;
    this.domNode.style.paddingLeft = this._paddingLeft;
  }
  setFontFamily(fontFamily) {
    if (this._fontFamily === fontFamily) {
      return;
    }
    this._fontFamily = fontFamily;
    this.domNode.style.fontFamily = this._fontFamily;
  }
  setFontWeight(fontWeight) {
    if (this._fontWeight === fontWeight) {
      return;
    }
    this._fontWeight = fontWeight;
    this.domNode.style.fontWeight = this._fontWeight;
  }
  setFontSize(_fontSize) {
    const fontSize = numberAsPixels(_fontSize);
    if (this._fontSize === fontSize) {
      return;
    }
    this._fontSize = fontSize;
    this.domNode.style.fontSize = this._fontSize;
  }
  setFontStyle(fontStyle) {
    if (this._fontStyle === fontStyle) {
      return;
    }
    this._fontStyle = fontStyle;
    this.domNode.style.fontStyle = this._fontStyle;
  }
  setFontFeatureSettings(fontFeatureSettings) {
    if (this._fontFeatureSettings === fontFeatureSettings) {
      return;
    }
    this._fontFeatureSettings = fontFeatureSettings;
    this.domNode.style.fontFeatureSettings = this._fontFeatureSettings;
  }
  setFontVariationSettings(fontVariationSettings) {
    if (this._fontVariationSettings === fontVariationSettings) {
      return;
    }
    this._fontVariationSettings = fontVariationSettings;
    this.domNode.style.fontVariationSettings = this._fontVariationSettings;
  }
  setTextDecoration(textDecoration) {
    if (this._textDecoration === textDecoration) {
      return;
    }
    this._textDecoration = textDecoration;
    this.domNode.style.textDecoration = this._textDecoration;
  }
  setLineHeight(_lineHeight) {
    const lineHeight = numberAsPixels(_lineHeight);
    if (this._lineHeight === lineHeight) {
      return;
    }
    this._lineHeight = lineHeight;
    this.domNode.style.lineHeight = this._lineHeight;
  }
  setLetterSpacing(_letterSpacing) {
    const letterSpacing = numberAsPixels(_letterSpacing);
    if (this._letterSpacing === letterSpacing) {
      return;
    }
    this._letterSpacing = letterSpacing;
    this.domNode.style.letterSpacing = this._letterSpacing;
  }
  setClassName(className) {
    if (this._className === className) {
      return;
    }
    this._className = className;
    this.domNode.className = this._className;
  }
  toggleClassName(className, shouldHaveIt) {
    this.domNode.classList.toggle(className, shouldHaveIt);
    this._className = this.domNode.className;
  }
  setDisplay(display) {
    if (this._display === display) {
      return;
    }
    this._display = display;
    this.domNode.style.display = this._display;
  }
  setPosition(position) {
    if (this._position === position) {
      return;
    }
    this._position = position;
    this.domNode.style.position = this._position;
  }
  setVisibility(visibility) {
    if (this._visibility === visibility) {
      return;
    }
    this._visibility = visibility;
    this.domNode.style.visibility = this._visibility;
  }
  setColor(color) {
    if (this._color === color) {
      return;
    }
    this._color = color;
    this.domNode.style.color = this._color;
  }
  setBackgroundColor(backgroundColor) {
    if (this._backgroundColor === backgroundColor) {
      return;
    }
    this._backgroundColor = backgroundColor;
    this.domNode.style.backgroundColor = this._backgroundColor;
  }
  setLayerHinting(layerHint) {
    if (this._layerHint === layerHint) {
      return;
    }
    this._layerHint = layerHint;
    this.domNode.style.transform = this._layerHint ? "translate3d(0px, 0px, 0px)" : "";
  }
  setBoxShadow(boxShadow) {
    if (this._boxShadow === boxShadow) {
      return;
    }
    this._boxShadow = boxShadow;
    this.domNode.style.boxShadow = boxShadow;
  }
  setContain(contain) {
    if (this._contain === contain) {
      return;
    }
    this._contain = contain;
    this.domNode.style.contain = this._contain;
  }
  setAttribute(name, value) {
    this.domNode.setAttribute(name, value);
  }
  removeAttribute(name) {
    this.domNode.removeAttribute(name);
  }
  appendChild(child) {
    this.domNode.appendChild(child.domNode);
  }
  removeChild(child) {
    this.domNode.removeChild(child.domNode);
  }
};
function numberAsPixels(value) {
  return typeof value === "number" ? `${value}px` : value;
}
function createFastDomNode(domNode) {
  return new FastDomNode(domNode);
}

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollableElement.js
init_mouseEvent();

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/horizontalScrollbar.js
init_mouseEvent();

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/abstractScrollbar.js
init_dom();

// node_modules/monaco-editor/esm/vs/base/browser/globalPointerMoveMonitor.js
init_dom();
init_lifecycle();
var GlobalPointerMoveMonitor = class {
  constructor() {
    this._hooks = new DisposableStore();
    this._pointerMoveCallback = null;
    this._onStopCallback = null;
  }
  dispose() {
    this.stopMonitoring(false);
    this._hooks.dispose();
  }
  stopMonitoring(invokeStopCallback, browserEvent) {
    if (!this.isMonitoring()) {
      return;
    }
    this._hooks.clear();
    this._pointerMoveCallback = null;
    const onStopCallback = this._onStopCallback;
    this._onStopCallback = null;
    if (invokeStopCallback && onStopCallback) {
      onStopCallback(browserEvent);
    }
  }
  isMonitoring() {
    return !!this._pointerMoveCallback;
  }
  startMonitoring(initialElement, pointerId, initialButtons, pointerMoveCallback, onStopCallback) {
    if (this.isMonitoring()) {
      this.stopMonitoring(false);
    }
    this._pointerMoveCallback = pointerMoveCallback;
    this._onStopCallback = onStopCallback;
    let eventSource = initialElement;
    try {
      initialElement.setPointerCapture(pointerId);
      this._hooks.add(toDisposable(() => {
        try {
          initialElement.releasePointerCapture(pointerId);
        } catch (err) {
        }
      }));
    } catch (err) {
      eventSource = getWindow(initialElement);
    }
    this._hooks.add(addDisposableListener(eventSource, EventType.POINTER_MOVE, (e) => {
      if (e.buttons !== initialButtons) {
        this.stopMonitoring(true);
        return;
      }
      e.preventDefault();
      this._pointerMoveCallback(e);
    }));
    this._hooks.add(addDisposableListener(eventSource, EventType.POINTER_UP, (e) => this.stopMonitoring(true)));
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/widget.js
init_dom();
init_keyboardEvent();
init_mouseEvent();

// node_modules/monaco-editor/esm/vs/base/browser/touch.js
init_dom();
init_window();
init_arrays();

// node_modules/monaco-editor/esm/vs/base/common/decorators.js
function memoize(_target, key, descriptor) {
  let fnKey = null;
  let fn = null;
  if (typeof descriptor.value === "function") {
    fnKey = "value";
    fn = descriptor.value;
    if (fn.length !== 0) {
      console.warn("Memoize should only be used in functions with zero parameters");
    }
  } else if (typeof descriptor.get === "function") {
    fnKey = "get";
    fn = descriptor.get;
  }
  if (!fn) {
    throw new Error("not supported");
  }
  const memoizeKey = `$memoize$${key}`;
  descriptor[fnKey] = function(...args) {
    if (!this.hasOwnProperty(memoizeKey)) {
      Object.defineProperty(this, memoizeKey, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: fn.apply(this, args)
      });
    }
    return this[memoizeKey];
  };
}

// node_modules/monaco-editor/esm/vs/base/browser/touch.js
init_event();
init_lifecycle();
init_linkedList();
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EventType2;
(function(EventType3) {
  EventType3.Tap = "-monaco-gesturetap";
  EventType3.Change = "-monaco-gesturechange";
  EventType3.Start = "-monaco-gesturestart";
  EventType3.End = "-monaco-gesturesend";
  EventType3.Contextmenu = "-monaco-gesturecontextmenu";
})(EventType2 || (EventType2 = {}));
var Gesture = class _Gesture extends Disposable {
  constructor() {
    super();
    this.dispatched = false;
    this.targets = new LinkedList();
    this.ignoreTargets = new LinkedList();
    this.activeTouches = {};
    this.handle = null;
    this._lastSetTapCountTime = 0;
    this._register(Event.runAndSubscribe(onDidRegisterWindow, ({ window, disposables }) => {
      disposables.add(addDisposableListener(window.document, "touchstart", (e) => this.onTouchStart(e), { passive: false }));
      disposables.add(addDisposableListener(window.document, "touchend", (e) => this.onTouchEnd(window, e)));
      disposables.add(addDisposableListener(window.document, "touchmove", (e) => this.onTouchMove(e), { passive: false }));
    }, { window: mainWindow, disposables: this._store }));
  }
  static addTarget(element) {
    if (!_Gesture.isTouchDevice()) {
      return Disposable.None;
    }
    if (!_Gesture.INSTANCE) {
      _Gesture.INSTANCE = markAsSingleton(new _Gesture());
    }
    const remove = _Gesture.INSTANCE.targets.push(element);
    return toDisposable(remove);
  }
  static ignoreTarget(element) {
    if (!_Gesture.isTouchDevice()) {
      return Disposable.None;
    }
    if (!_Gesture.INSTANCE) {
      _Gesture.INSTANCE = markAsSingleton(new _Gesture());
    }
    const remove = _Gesture.INSTANCE.ignoreTargets.push(element);
    return toDisposable(remove);
  }
  static isTouchDevice() {
    return "ontouchstart" in mainWindow || navigator.maxTouchPoints > 0;
  }
  dispose() {
    if (this.handle) {
      this.handle.dispose();
      this.handle = null;
    }
    super.dispose();
  }
  onTouchStart(e) {
    const timestamp = Date.now();
    if (this.handle) {
      this.handle.dispose();
      this.handle = null;
    }
    for (let i = 0, len = e.targetTouches.length; i < len; i++) {
      const touch = e.targetTouches.item(i);
      this.activeTouches[touch.identifier] = {
        id: touch.identifier,
        initialTarget: touch.target,
        initialTimeStamp: timestamp,
        initialPageX: touch.pageX,
        initialPageY: touch.pageY,
        rollingTimestamps: [timestamp],
        rollingPageX: [touch.pageX],
        rollingPageY: [touch.pageY]
      };
      const evt = this.newGestureEvent(EventType2.Start, touch.target);
      evt.pageX = touch.pageX;
      evt.pageY = touch.pageY;
      this.dispatchEvent(evt);
    }
    if (this.dispatched) {
      e.preventDefault();
      e.stopPropagation();
      this.dispatched = false;
    }
  }
  onTouchEnd(targetWindow, e) {
    const timestamp = Date.now();
    const activeTouchCount = Object.keys(this.activeTouches).length;
    for (let i = 0, len = e.changedTouches.length; i < len; i++) {
      const touch = e.changedTouches.item(i);
      if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {
        console.warn("move of an UNKNOWN touch", touch);
        continue;
      }
      const data = this.activeTouches[touch.identifier], holdTime = Date.now() - data.initialTimeStamp;
      if (holdTime < _Gesture.HOLD_DELAY && Math.abs(data.initialPageX - tail(data.rollingPageX)) < 30 && Math.abs(data.initialPageY - tail(data.rollingPageY)) < 30) {
        const evt = this.newGestureEvent(EventType2.Tap, data.initialTarget);
        evt.pageX = tail(data.rollingPageX);
        evt.pageY = tail(data.rollingPageY);
        this.dispatchEvent(evt);
      } else if (holdTime >= _Gesture.HOLD_DELAY && Math.abs(data.initialPageX - tail(data.rollingPageX)) < 30 && Math.abs(data.initialPageY - tail(data.rollingPageY)) < 30) {
        const evt = this.newGestureEvent(EventType2.Contextmenu, data.initialTarget);
        evt.pageX = tail(data.rollingPageX);
        evt.pageY = tail(data.rollingPageY);
        this.dispatchEvent(evt);
      } else if (activeTouchCount === 1) {
        const finalX = tail(data.rollingPageX);
        const finalY = tail(data.rollingPageY);
        const deltaT = tail(data.rollingTimestamps) - data.rollingTimestamps[0];
        const deltaX = finalX - data.rollingPageX[0];
        const deltaY = finalY - data.rollingPageY[0];
        const dispatchTo = [...this.targets].filter((t) => data.initialTarget instanceof Node && t.contains(data.initialTarget));
        this.inertia(
          targetWindow,
          dispatchTo,
          timestamp,
          // time now
          Math.abs(deltaX) / deltaT,
          // speed
          deltaX > 0 ? 1 : -1,
          // x direction
          finalX,
          // x now
          Math.abs(deltaY) / deltaT,
          // y speed
          deltaY > 0 ? 1 : -1,
          // y direction
          finalY
          // y now
        );
      }
      this.dispatchEvent(this.newGestureEvent(EventType2.End, data.initialTarget));
      delete this.activeTouches[touch.identifier];
    }
    if (this.dispatched) {
      e.preventDefault();
      e.stopPropagation();
      this.dispatched = false;
    }
  }
  newGestureEvent(type, initialTarget) {
    const event = document.createEvent("CustomEvent");
    event.initEvent(type, false, true);
    event.initialTarget = initialTarget;
    event.tapCount = 0;
    return event;
  }
  dispatchEvent(event) {
    if (event.type === EventType2.Tap) {
      const currentTime = (/* @__PURE__ */ new Date()).getTime();
      let setTapCount = 0;
      if (currentTime - this._lastSetTapCountTime > _Gesture.CLEAR_TAP_COUNT_TIME) {
        setTapCount = 1;
      } else {
        setTapCount = 2;
      }
      this._lastSetTapCountTime = currentTime;
      event.tapCount = setTapCount;
    } else if (event.type === EventType2.Change || event.type === EventType2.Contextmenu) {
      this._lastSetTapCountTime = 0;
    }
    if (event.initialTarget instanceof Node) {
      for (const ignoreTarget of this.ignoreTargets) {
        if (ignoreTarget.contains(event.initialTarget)) {
          return;
        }
      }
      for (const target of this.targets) {
        if (target.contains(event.initialTarget)) {
          target.dispatchEvent(event);
          this.dispatched = true;
        }
      }
    }
  }
  inertia(targetWindow, dispatchTo, t1, vX, dirX, x, vY, dirY, y) {
    this.handle = scheduleAtNextAnimationFrame(targetWindow, () => {
      const now = Date.now();
      const deltaT = now - t1;
      let delta_pos_x = 0, delta_pos_y = 0;
      let stopped = true;
      vX += _Gesture.SCROLL_FRICTION * deltaT;
      vY += _Gesture.SCROLL_FRICTION * deltaT;
      if (vX > 0) {
        stopped = false;
        delta_pos_x = dirX * vX * deltaT;
      }
      if (vY > 0) {
        stopped = false;
        delta_pos_y = dirY * vY * deltaT;
      }
      const evt = this.newGestureEvent(EventType2.Change);
      evt.translationX = delta_pos_x;
      evt.translationY = delta_pos_y;
      dispatchTo.forEach((d) => d.dispatchEvent(evt));
      if (!stopped) {
        this.inertia(targetWindow, dispatchTo, now, vX, dirX, x + delta_pos_x, vY, dirY, y + delta_pos_y);
      }
    });
  }
  onTouchMove(e) {
    const timestamp = Date.now();
    for (let i = 0, len = e.changedTouches.length; i < len; i++) {
      const touch = e.changedTouches.item(i);
      if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {
        console.warn("end of an UNKNOWN touch", touch);
        continue;
      }
      const data = this.activeTouches[touch.identifier];
      const evt = this.newGestureEvent(EventType2.Change, data.initialTarget);
      evt.translationX = touch.pageX - tail(data.rollingPageX);
      evt.translationY = touch.pageY - tail(data.rollingPageY);
      evt.pageX = touch.pageX;
      evt.pageY = touch.pageY;
      this.dispatchEvent(evt);
      if (data.rollingPageX.length > 3) {
        data.rollingPageX.shift();
        data.rollingPageY.shift();
        data.rollingTimestamps.shift();
      }
      data.rollingPageX.push(touch.pageX);
      data.rollingPageY.push(touch.pageY);
      data.rollingTimestamps.push(timestamp);
    }
    if (this.dispatched) {
      e.preventDefault();
      e.stopPropagation();
      this.dispatched = false;
    }
  }
};
Gesture.SCROLL_FRICTION = -5e-3;
Gesture.HOLD_DELAY = 700;
Gesture.CLEAR_TAP_COUNT_TIME = 400;
__decorate10([
  memoize
], Gesture, "isTouchDevice", null);

// node_modules/monaco-editor/esm/vs/base/browser/ui/widget.js
init_lifecycle();
var Widget = class extends Disposable {
  onclick(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.CLICK, (e) => listener(new StandardMouseEvent(getWindow(domNode), e))));
  }
  onmousedown(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.MOUSE_DOWN, (e) => listener(new StandardMouseEvent(getWindow(domNode), e))));
  }
  onmouseover(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.MOUSE_OVER, (e) => listener(new StandardMouseEvent(getWindow(domNode), e))));
  }
  onmouseleave(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.MOUSE_LEAVE, (e) => listener(new StandardMouseEvent(getWindow(domNode), e))));
  }
  onkeydown(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.KEY_DOWN, (e) => listener(new StandardKeyboardEvent(e))));
  }
  onkeyup(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.KEY_UP, (e) => listener(new StandardKeyboardEvent(e))));
  }
  oninput(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.INPUT, listener));
  }
  onblur(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.BLUR, listener));
  }
  onfocus(domNode, listener) {
    this._register(addDisposableListener(domNode, EventType.FOCUS, listener));
  }
  ignoreGesture(domNode) {
    return Gesture.ignoreTarget(domNode);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollbarArrow.js
init_async();
init_themables();
init_dom();
var ARROW_IMG_SIZE = 11;
var ScrollbarArrow = class extends Widget {
  constructor(opts) {
    super();
    this._onActivate = opts.onActivate;
    this.bgDomNode = document.createElement("div");
    this.bgDomNode.className = "arrow-background";
    this.bgDomNode.style.position = "absolute";
    this.bgDomNode.style.width = opts.bgWidth + "px";
    this.bgDomNode.style.height = opts.bgHeight + "px";
    if (typeof opts.top !== "undefined") {
      this.bgDomNode.style.top = "0px";
    }
    if (typeof opts.left !== "undefined") {
      this.bgDomNode.style.left = "0px";
    }
    if (typeof opts.bottom !== "undefined") {
      this.bgDomNode.style.bottom = "0px";
    }
    if (typeof opts.right !== "undefined") {
      this.bgDomNode.style.right = "0px";
    }
    this.domNode = document.createElement("div");
    this.domNode.className = opts.className;
    this.domNode.classList.add(...ThemeIcon.asClassNameArray(opts.icon));
    this.domNode.style.position = "absolute";
    this.domNode.style.width = ARROW_IMG_SIZE + "px";
    this.domNode.style.height = ARROW_IMG_SIZE + "px";
    if (typeof opts.top !== "undefined") {
      this.domNode.style.top = opts.top + "px";
    }
    if (typeof opts.left !== "undefined") {
      this.domNode.style.left = opts.left + "px";
    }
    if (typeof opts.bottom !== "undefined") {
      this.domNode.style.bottom = opts.bottom + "px";
    }
    if (typeof opts.right !== "undefined") {
      this.domNode.style.right = opts.right + "px";
    }
    this._pointerMoveMonitor = this._register(new GlobalPointerMoveMonitor());
    this._register(addStandardDisposableListener(this.bgDomNode, EventType.POINTER_DOWN, (e) => this._arrowPointerDown(e)));
    this._register(addStandardDisposableListener(this.domNode, EventType.POINTER_DOWN, (e) => this._arrowPointerDown(e)));
    this._pointerdownRepeatTimer = this._register(new WindowIntervalTimer());
    this._pointerdownScheduleRepeatTimer = this._register(new TimeoutTimer());
  }
  _arrowPointerDown(e) {
    if (!e.target || !(e.target instanceof Element)) {
      return;
    }
    const scheduleRepeater = () => {
      this._pointerdownRepeatTimer.cancelAndSet(() => this._onActivate(), 1e3 / 24, getWindow(e));
    };
    this._onActivate();
    this._pointerdownRepeatTimer.cancel();
    this._pointerdownScheduleRepeatTimer.cancelAndSet(scheduleRepeater, 200);
    this._pointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (pointerMoveData) => {
    }, () => {
      this._pointerdownRepeatTimer.cancel();
      this._pointerdownScheduleRepeatTimer.cancel();
    });
    e.preventDefault();
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollbarVisibilityController.js
init_async();
init_lifecycle();
var ScrollbarVisibilityController = class extends Disposable {
  constructor(visibility, visibleClassName, invisibleClassName) {
    super();
    this._visibility = visibility;
    this._visibleClassName = visibleClassName;
    this._invisibleClassName = invisibleClassName;
    this._domNode = null;
    this._isVisible = false;
    this._isNeeded = false;
    this._rawShouldBeVisible = false;
    this._shouldBeVisible = false;
    this._revealTimer = this._register(new TimeoutTimer());
  }
  setVisibility(visibility) {
    if (this._visibility !== visibility) {
      this._visibility = visibility;
      this._updateShouldBeVisible();
    }
  }
  // ----------------- Hide / Reveal
  setShouldBeVisible(rawShouldBeVisible) {
    this._rawShouldBeVisible = rawShouldBeVisible;
    this._updateShouldBeVisible();
  }
  _applyVisibilitySetting() {
    if (this._visibility === 2) {
      return false;
    }
    if (this._visibility === 3) {
      return true;
    }
    return this._rawShouldBeVisible;
  }
  _updateShouldBeVisible() {
    const shouldBeVisible = this._applyVisibilitySetting();
    if (this._shouldBeVisible !== shouldBeVisible) {
      this._shouldBeVisible = shouldBeVisible;
      this.ensureVisibility();
    }
  }
  setIsNeeded(isNeeded) {
    if (this._isNeeded !== isNeeded) {
      this._isNeeded = isNeeded;
      this.ensureVisibility();
    }
  }
  setDomNode(domNode) {
    this._domNode = domNode;
    this._domNode.setClassName(this._invisibleClassName);
    this.setShouldBeVisible(false);
  }
  ensureVisibility() {
    if (!this._isNeeded) {
      this._hide(false);
      return;
    }
    if (this._shouldBeVisible) {
      this._reveal();
    } else {
      this._hide(true);
    }
  }
  _reveal() {
    if (this._isVisible) {
      return;
    }
    this._isVisible = true;
    this._revealTimer.setIfNotSet(() => {
      var _a2;
      (_a2 = this._domNode) === null || _a2 === void 0 ? void 0 : _a2.setClassName(this._visibleClassName);
    }, 0);
  }
  _hide(withFadeAway) {
    var _a2;
    this._revealTimer.cancel();
    if (!this._isVisible) {
      return;
    }
    this._isVisible = false;
    (_a2 = this._domNode) === null || _a2 === void 0 ? void 0 : _a2.setClassName(this._invisibleClassName + (withFadeAway ? " fade" : ""));
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/abstractScrollbar.js
init_platform();
var POINTER_DRAG_RESET_DISTANCE = 140;
var AbstractScrollbar = class extends Widget {
  constructor(opts) {
    super();
    this._lazyRender = opts.lazyRender;
    this._host = opts.host;
    this._scrollable = opts.scrollable;
    this._scrollByPage = opts.scrollByPage;
    this._scrollbarState = opts.scrollbarState;
    this._visibilityController = this._register(new ScrollbarVisibilityController(opts.visibility, "visible scrollbar " + opts.extraScrollbarClassName, "invisible scrollbar " + opts.extraScrollbarClassName));
    this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
    this._pointerMoveMonitor = this._register(new GlobalPointerMoveMonitor());
    this._shouldRender = true;
    this.domNode = createFastDomNode(document.createElement("div"));
    this.domNode.setAttribute("role", "presentation");
    this.domNode.setAttribute("aria-hidden", "true");
    this._visibilityController.setDomNode(this.domNode);
    this.domNode.setPosition("absolute");
    this._register(addDisposableListener(this.domNode.domNode, EventType.POINTER_DOWN, (e) => this._domNodePointerDown(e)));
  }
  // ----------------- creation
  /**
   * Creates the dom node for an arrow & adds it to the container
   */
  _createArrow(opts) {
    const arrow = this._register(new ScrollbarArrow(opts));
    this.domNode.domNode.appendChild(arrow.bgDomNode);
    this.domNode.domNode.appendChild(arrow.domNode);
  }
  /**
   * Creates the slider dom node, adds it to the container & hooks up the events
   */
  _createSlider(top, left, width, height) {
    this.slider = createFastDomNode(document.createElement("div"));
    this.slider.setClassName("slider");
    this.slider.setPosition("absolute");
    this.slider.setTop(top);
    this.slider.setLeft(left);
    if (typeof width === "number") {
      this.slider.setWidth(width);
    }
    if (typeof height === "number") {
      this.slider.setHeight(height);
    }
    this.slider.setLayerHinting(true);
    this.slider.setContain("strict");
    this.domNode.domNode.appendChild(this.slider.domNode);
    this._register(addDisposableListener(this.slider.domNode, EventType.POINTER_DOWN, (e) => {
      if (e.button === 0) {
        e.preventDefault();
        this._sliderPointerDown(e);
      }
    }));
    this.onclick(this.slider.domNode, (e) => {
      if (e.leftButton) {
        e.stopPropagation();
      }
    });
  }
  // ----------------- Update state
  _onElementSize(visibleSize) {
    if (this._scrollbarState.setVisibleSize(visibleSize)) {
      this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
      this._shouldRender = true;
      if (!this._lazyRender) {
        this.render();
      }
    }
    return this._shouldRender;
  }
  _onElementScrollSize(elementScrollSize) {
    if (this._scrollbarState.setScrollSize(elementScrollSize)) {
      this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
      this._shouldRender = true;
      if (!this._lazyRender) {
        this.render();
      }
    }
    return this._shouldRender;
  }
  _onElementScrollPosition(elementScrollPosition) {
    if (this._scrollbarState.setScrollPosition(elementScrollPosition)) {
      this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
      this._shouldRender = true;
      if (!this._lazyRender) {
        this.render();
      }
    }
    return this._shouldRender;
  }
  // ----------------- rendering
  beginReveal() {
    this._visibilityController.setShouldBeVisible(true);
  }
  beginHide() {
    this._visibilityController.setShouldBeVisible(false);
  }
  render() {
    if (!this._shouldRender) {
      return;
    }
    this._shouldRender = false;
    this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize());
    this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition());
  }
  // ----------------- DOM events
  _domNodePointerDown(e) {
    if (e.target !== this.domNode.domNode) {
      return;
    }
    this._onPointerDown(e);
  }
  delegatePointerDown(e) {
    const domTop = this.domNode.domNode.getClientRects()[0].top;
    const sliderStart = domTop + this._scrollbarState.getSliderPosition();
    const sliderStop = domTop + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize();
    const pointerPos = this._sliderPointerPosition(e);
    if (sliderStart <= pointerPos && pointerPos <= sliderStop) {
      if (e.button === 0) {
        e.preventDefault();
        this._sliderPointerDown(e);
      }
    } else {
      this._onPointerDown(e);
    }
  }
  _onPointerDown(e) {
    let offsetX;
    let offsetY;
    if (e.target === this.domNode.domNode && typeof e.offsetX === "number" && typeof e.offsetY === "number") {
      offsetX = e.offsetX;
      offsetY = e.offsetY;
    } else {
      const domNodePosition = getDomNodePagePosition(this.domNode.domNode);
      offsetX = e.pageX - domNodePosition.left;
      offsetY = e.pageY - domNodePosition.top;
    }
    const offset = this._pointerDownRelativePosition(offsetX, offsetY);
    this._setDesiredScrollPositionNow(this._scrollByPage ? this._scrollbarState.getDesiredScrollPositionFromOffsetPaged(offset) : this._scrollbarState.getDesiredScrollPositionFromOffset(offset));
    if (e.button === 0) {
      e.preventDefault();
      this._sliderPointerDown(e);
    }
  }
  _sliderPointerDown(e) {
    if (!e.target || !(e.target instanceof Element)) {
      return;
    }
    const initialPointerPosition = this._sliderPointerPosition(e);
    const initialPointerOrthogonalPosition = this._sliderOrthogonalPointerPosition(e);
    const initialScrollbarState = this._scrollbarState.clone();
    this.slider.toggleClassName("active", true);
    this._pointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (pointerMoveData) => {
      const pointerOrthogonalPosition = this._sliderOrthogonalPointerPosition(pointerMoveData);
      const pointerOrthogonalDelta = Math.abs(pointerOrthogonalPosition - initialPointerOrthogonalPosition);
      if (isWindows && pointerOrthogonalDelta > POINTER_DRAG_RESET_DISTANCE) {
        this._setDesiredScrollPositionNow(initialScrollbarState.getScrollPosition());
        return;
      }
      const pointerPosition = this._sliderPointerPosition(pointerMoveData);
      const pointerDelta = pointerPosition - initialPointerPosition;
      this._setDesiredScrollPositionNow(initialScrollbarState.getDesiredScrollPositionFromDelta(pointerDelta));
    }, () => {
      this.slider.toggleClassName("active", false);
      this._host.onDragEnd();
    });
    this._host.onDragStart();
  }
  _setDesiredScrollPositionNow(_desiredScrollPosition) {
    const desiredScrollPosition = {};
    this.writeScrollPosition(desiredScrollPosition, _desiredScrollPosition);
    this._scrollable.setScrollPositionNow(desiredScrollPosition);
  }
  updateScrollbarSize(scrollbarSize) {
    this._updateScrollbarSize(scrollbarSize);
    this._scrollbarState.setScrollbarSize(scrollbarSize);
    this._shouldRender = true;
    if (!this._lazyRender) {
      this.render();
    }
  }
  isNeeded() {
    return this._scrollbarState.isNeeded();
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollbarState.js
var MINIMUM_SLIDER_SIZE = 20;
var ScrollbarState = class _ScrollbarState {
  constructor(arrowSize, scrollbarSize, oppositeScrollbarSize, visibleSize, scrollSize, scrollPosition) {
    this._scrollbarSize = Math.round(scrollbarSize);
    this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);
    this._arrowSize = Math.round(arrowSize);
    this._visibleSize = visibleSize;
    this._scrollSize = scrollSize;
    this._scrollPosition = scrollPosition;
    this._computedAvailableSize = 0;
    this._computedIsNeeded = false;
    this._computedSliderSize = 0;
    this._computedSliderRatio = 0;
    this._computedSliderPosition = 0;
    this._refreshComputedValues();
  }
  clone() {
    return new _ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);
  }
  setVisibleSize(visibleSize) {
    const iVisibleSize = Math.round(visibleSize);
    if (this._visibleSize !== iVisibleSize) {
      this._visibleSize = iVisibleSize;
      this._refreshComputedValues();
      return true;
    }
    return false;
  }
  setScrollSize(scrollSize) {
    const iScrollSize = Math.round(scrollSize);
    if (this._scrollSize !== iScrollSize) {
      this._scrollSize = iScrollSize;
      this._refreshComputedValues();
      return true;
    }
    return false;
  }
  setScrollPosition(scrollPosition) {
    const iScrollPosition = Math.round(scrollPosition);
    if (this._scrollPosition !== iScrollPosition) {
      this._scrollPosition = iScrollPosition;
      this._refreshComputedValues();
      return true;
    }
    return false;
  }
  setScrollbarSize(scrollbarSize) {
    this._scrollbarSize = Math.round(scrollbarSize);
  }
  setOppositeScrollbarSize(oppositeScrollbarSize) {
    this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);
  }
  static _computeValues(oppositeScrollbarSize, arrowSize, visibleSize, scrollSize, scrollPosition) {
    const computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);
    const computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);
    const computedIsNeeded = scrollSize > 0 && scrollSize > visibleSize;
    if (!computedIsNeeded) {
      return {
        computedAvailableSize: Math.round(computedAvailableSize),
        computedIsNeeded,
        computedSliderSize: Math.round(computedRepresentableSize),
        computedSliderRatio: 0,
        computedSliderPosition: 0
      };
    }
    const computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize)));
    const computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);
    const computedSliderPosition = scrollPosition * computedSliderRatio;
    return {
      computedAvailableSize: Math.round(computedAvailableSize),
      computedIsNeeded,
      computedSliderSize: Math.round(computedSliderSize),
      computedSliderRatio,
      computedSliderPosition: Math.round(computedSliderPosition)
    };
  }
  _refreshComputedValues() {
    const r = _ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);
    this._computedAvailableSize = r.computedAvailableSize;
    this._computedIsNeeded = r.computedIsNeeded;
    this._computedSliderSize = r.computedSliderSize;
    this._computedSliderRatio = r.computedSliderRatio;
    this._computedSliderPosition = r.computedSliderPosition;
  }
  getArrowSize() {
    return this._arrowSize;
  }
  getScrollPosition() {
    return this._scrollPosition;
  }
  getRectangleLargeSize() {
    return this._computedAvailableSize;
  }
  getRectangleSmallSize() {
    return this._scrollbarSize;
  }
  isNeeded() {
    return this._computedIsNeeded;
  }
  getSliderSize() {
    return this._computedSliderSize;
  }
  getSliderPosition() {
    return this._computedSliderPosition;
  }
  /**
   * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.
   * `offset` is based on the same coordinate system as the `sliderPosition`.
   */
  getDesiredScrollPositionFromOffset(offset) {
    if (!this._computedIsNeeded) {
      return 0;
    }
    const desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;
    return Math.round(desiredSliderPosition / this._computedSliderRatio);
  }
  /**
   * Compute a desired `scrollPosition` from if offset is before or after the slider position.
   * If offset is before slider, treat as a page up (or left).  If after, page down (or right).
   * `offset` and `_computedSliderPosition` are based on the same coordinate system.
   * `_visibleSize` corresponds to a "page" of lines in the returned coordinate system.
   */
  getDesiredScrollPositionFromOffsetPaged(offset) {
    if (!this._computedIsNeeded) {
      return 0;
    }
    const correctedOffset = offset - this._arrowSize;
    let desiredScrollPosition = this._scrollPosition;
    if (correctedOffset < this._computedSliderPosition) {
      desiredScrollPosition -= this._visibleSize;
    } else {
      desiredScrollPosition += this._visibleSize;
    }
    return desiredScrollPosition;
  }
  /**
   * Compute a desired `scrollPosition` such that the slider moves by `delta`.
   */
  getDesiredScrollPositionFromDelta(delta) {
    if (!this._computedIsNeeded) {
      return 0;
    }
    const desiredSliderPosition = this._computedSliderPosition + delta;
    return Math.round(desiredSliderPosition / this._computedSliderRatio);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/horizontalScrollbar.js
init_codicons();
var HorizontalScrollbar = class extends AbstractScrollbar {
  constructor(scrollable, options2, host) {
    const scrollDimensions = scrollable.getScrollDimensions();
    const scrollPosition = scrollable.getCurrentScrollPosition();
    super({
      lazyRender: options2.lazyRender,
      host,
      scrollbarState: new ScrollbarState(options2.horizontalHasArrows ? options2.arrowSize : 0, options2.horizontal === 2 ? 0 : options2.horizontalScrollbarSize, options2.vertical === 2 ? 0 : options2.verticalScrollbarSize, scrollDimensions.width, scrollDimensions.scrollWidth, scrollPosition.scrollLeft),
      visibility: options2.horizontal,
      extraScrollbarClassName: "horizontal",
      scrollable,
      scrollByPage: options2.scrollByPage
    });
    if (options2.horizontalHasArrows) {
      const arrowDelta = (options2.arrowSize - ARROW_IMG_SIZE) / 2;
      const scrollbarDelta = (options2.horizontalScrollbarSize - ARROW_IMG_SIZE) / 2;
      this._createArrow({
        className: "scra",
        icon: Codicon.scrollbarButtonLeft,
        top: scrollbarDelta,
        left: arrowDelta,
        bottom: void 0,
        right: void 0,
        bgWidth: options2.arrowSize,
        bgHeight: options2.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, 1, 0))
      });
      this._createArrow({
        className: "scra",
        icon: Codicon.scrollbarButtonRight,
        top: scrollbarDelta,
        left: void 0,
        bottom: void 0,
        right: arrowDelta,
        bgWidth: options2.arrowSize,
        bgHeight: options2.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, -1, 0))
      });
    }
    this._createSlider(Math.floor((options2.horizontalScrollbarSize - options2.horizontalSliderSize) / 2), 0, void 0, options2.horizontalSliderSize);
  }
  _updateSlider(sliderSize, sliderPosition) {
    this.slider.setWidth(sliderSize);
    this.slider.setLeft(sliderPosition);
  }
  _renderDomNode(largeSize, smallSize) {
    this.domNode.setWidth(largeSize);
    this.domNode.setHeight(smallSize);
    this.domNode.setLeft(0);
    this.domNode.setBottom(0);
  }
  onDidScroll(e) {
    this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender;
    this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender;
    this._shouldRender = this._onElementSize(e.width) || this._shouldRender;
    return this._shouldRender;
  }
  _pointerDownRelativePosition(offsetX, offsetY) {
    return offsetX;
  }
  _sliderPointerPosition(e) {
    return e.pageX;
  }
  _sliderOrthogonalPointerPosition(e) {
    return e.pageY;
  }
  _updateScrollbarSize(size) {
    this.slider.setHeight(size);
  }
  writeScrollPosition(target, scrollPosition) {
    target.scrollLeft = scrollPosition;
  }
  updateOptions(options2) {
    this.updateScrollbarSize(options2.horizontal === 2 ? 0 : options2.horizontalScrollbarSize);
    this._scrollbarState.setOppositeScrollbarSize(options2.vertical === 2 ? 0 : options2.verticalScrollbarSize);
    this._visibilityController.setVisibility(options2.horizontal);
    this._scrollByPage = options2.scrollByPage;
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/verticalScrollbar.js
init_mouseEvent();
init_codicons();
var VerticalScrollbar = class extends AbstractScrollbar {
  constructor(scrollable, options2, host) {
    const scrollDimensions = scrollable.getScrollDimensions();
    const scrollPosition = scrollable.getCurrentScrollPosition();
    super({
      lazyRender: options2.lazyRender,
      host,
      scrollbarState: new ScrollbarState(
        options2.verticalHasArrows ? options2.arrowSize : 0,
        options2.vertical === 2 ? 0 : options2.verticalScrollbarSize,
        // give priority to vertical scroll bar over horizontal and let it scroll all the way to the bottom
        0,
        scrollDimensions.height,
        scrollDimensions.scrollHeight,
        scrollPosition.scrollTop
      ),
      visibility: options2.vertical,
      extraScrollbarClassName: "vertical",
      scrollable,
      scrollByPage: options2.scrollByPage
    });
    if (options2.verticalHasArrows) {
      const arrowDelta = (options2.arrowSize - ARROW_IMG_SIZE) / 2;
      const scrollbarDelta = (options2.verticalScrollbarSize - ARROW_IMG_SIZE) / 2;
      this._createArrow({
        className: "scra",
        icon: Codicon.scrollbarButtonUp,
        top: arrowDelta,
        left: scrollbarDelta,
        bottom: void 0,
        right: void 0,
        bgWidth: options2.verticalScrollbarSize,
        bgHeight: options2.arrowSize,
        onActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, 0, 1))
      });
      this._createArrow({
        className: "scra",
        icon: Codicon.scrollbarButtonDown,
        top: void 0,
        left: scrollbarDelta,
        bottom: arrowDelta,
        right: void 0,
        bgWidth: options2.verticalScrollbarSize,
        bgHeight: options2.arrowSize,
        onActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, 0, -1))
      });
    }
    this._createSlider(0, Math.floor((options2.verticalScrollbarSize - options2.verticalSliderSize) / 2), options2.verticalSliderSize, void 0);
  }
  _updateSlider(sliderSize, sliderPosition) {
    this.slider.setHeight(sliderSize);
    this.slider.setTop(sliderPosition);
  }
  _renderDomNode(largeSize, smallSize) {
    this.domNode.setWidth(smallSize);
    this.domNode.setHeight(largeSize);
    this.domNode.setRight(0);
    this.domNode.setTop(0);
  }
  onDidScroll(e) {
    this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender;
    this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender;
    this._shouldRender = this._onElementSize(e.height) || this._shouldRender;
    return this._shouldRender;
  }
  _pointerDownRelativePosition(offsetX, offsetY) {
    return offsetY;
  }
  _sliderPointerPosition(e) {
    return e.pageY;
  }
  _sliderOrthogonalPointerPosition(e) {
    return e.pageX;
  }
  _updateScrollbarSize(size) {
    this.slider.setWidth(size);
  }
  writeScrollPosition(target, scrollPosition) {
    target.scrollTop = scrollPosition;
  }
  updateOptions(options2) {
    this.updateScrollbarSize(options2.vertical === 2 ? 0 : options2.verticalScrollbarSize);
    this._scrollbarState.setOppositeScrollbarSize(0);
    this._visibilityController.setVisibility(options2.vertical);
    this._scrollByPage = options2.scrollByPage;
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollableElement.js
init_async();
init_event();
init_lifecycle();
init_platform();

// node_modules/monaco-editor/esm/vs/base/common/scrollable.js
init_event();
init_lifecycle();
var ScrollState = class _ScrollState {
  constructor(_forceIntegerValues, width, scrollWidth, scrollLeft, height, scrollHeight, scrollTop) {
    this._forceIntegerValues = _forceIntegerValues;
    this._scrollStateBrand = void 0;
    if (this._forceIntegerValues) {
      width = width | 0;
      scrollWidth = scrollWidth | 0;
      scrollLeft = scrollLeft | 0;
      height = height | 0;
      scrollHeight = scrollHeight | 0;
      scrollTop = scrollTop | 0;
    }
    this.rawScrollLeft = scrollLeft;
    this.rawScrollTop = scrollTop;
    if (width < 0) {
      width = 0;
    }
    if (scrollLeft + width > scrollWidth) {
      scrollLeft = scrollWidth - width;
    }
    if (scrollLeft < 0) {
      scrollLeft = 0;
    }
    if (height < 0) {
      height = 0;
    }
    if (scrollTop + height > scrollHeight) {
      scrollTop = scrollHeight - height;
    }
    if (scrollTop < 0) {
      scrollTop = 0;
    }
    this.width = width;
    this.scrollWidth = scrollWidth;
    this.scrollLeft = scrollLeft;
    this.height = height;
    this.scrollHeight = scrollHeight;
    this.scrollTop = scrollTop;
  }
  equals(other) {
    return this.rawScrollLeft === other.rawScrollLeft && this.rawScrollTop === other.rawScrollTop && this.width === other.width && this.scrollWidth === other.scrollWidth && this.scrollLeft === other.scrollLeft && this.height === other.height && this.scrollHeight === other.scrollHeight && this.scrollTop === other.scrollTop;
  }
  withScrollDimensions(update, useRawScrollPositions) {
    return new _ScrollState(this._forceIntegerValues, typeof update.width !== "undefined" ? update.width : this.width, typeof update.scrollWidth !== "undefined" ? update.scrollWidth : this.scrollWidth, useRawScrollPositions ? this.rawScrollLeft : this.scrollLeft, typeof update.height !== "undefined" ? update.height : this.height, typeof update.scrollHeight !== "undefined" ? update.scrollHeight : this.scrollHeight, useRawScrollPositions ? this.rawScrollTop : this.scrollTop);
  }
  withScrollPosition(update) {
    return new _ScrollState(this._forceIntegerValues, this.width, this.scrollWidth, typeof update.scrollLeft !== "undefined" ? update.scrollLeft : this.rawScrollLeft, this.height, this.scrollHeight, typeof update.scrollTop !== "undefined" ? update.scrollTop : this.rawScrollTop);
  }
  createScrollEvent(previous, inSmoothScrolling) {
    const widthChanged = this.width !== previous.width;
    const scrollWidthChanged = this.scrollWidth !== previous.scrollWidth;
    const scrollLeftChanged = this.scrollLeft !== previous.scrollLeft;
    const heightChanged = this.height !== previous.height;
    const scrollHeightChanged = this.scrollHeight !== previous.scrollHeight;
    const scrollTopChanged = this.scrollTop !== previous.scrollTop;
    return {
      inSmoothScrolling,
      oldWidth: previous.width,
      oldScrollWidth: previous.scrollWidth,
      oldScrollLeft: previous.scrollLeft,
      width: this.width,
      scrollWidth: this.scrollWidth,
      scrollLeft: this.scrollLeft,
      oldHeight: previous.height,
      oldScrollHeight: previous.scrollHeight,
      oldScrollTop: previous.scrollTop,
      height: this.height,
      scrollHeight: this.scrollHeight,
      scrollTop: this.scrollTop,
      widthChanged,
      scrollWidthChanged,
      scrollLeftChanged,
      heightChanged,
      scrollHeightChanged,
      scrollTopChanged
    };
  }
};
var Scrollable = class extends Disposable {
  constructor(options2) {
    super();
    this._scrollableBrand = void 0;
    this._onScroll = this._register(new Emitter());
    this.onScroll = this._onScroll.event;
    this._smoothScrollDuration = options2.smoothScrollDuration;
    this._scheduleAtNextAnimationFrame = options2.scheduleAtNextAnimationFrame;
    this._state = new ScrollState(options2.forceIntegerValues, 0, 0, 0, 0, 0, 0);
    this._smoothScrolling = null;
  }
  dispose() {
    if (this._smoothScrolling) {
      this._smoothScrolling.dispose();
      this._smoothScrolling = null;
    }
    super.dispose();
  }
  setSmoothScrollDuration(smoothScrollDuration) {
    this._smoothScrollDuration = smoothScrollDuration;
  }
  validateScrollPosition(scrollPosition) {
    return this._state.withScrollPosition(scrollPosition);
  }
  getScrollDimensions() {
    return this._state;
  }
  setScrollDimensions(dimensions, useRawScrollPositions) {
    var _a2;
    const newState = this._state.withScrollDimensions(dimensions, useRawScrollPositions);
    this._setState(newState, Boolean(this._smoothScrolling));
    (_a2 = this._smoothScrolling) === null || _a2 === void 0 ? void 0 : _a2.acceptScrollDimensions(this._state);
  }
  /**
   * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.
   * If no scroll animation is occurring, it will return the current scroll position instead.
   */
  getFutureScrollPosition() {
    if (this._smoothScrolling) {
      return this._smoothScrolling.to;
    }
    return this._state;
  }
  /**
   * Returns the current scroll position.
   * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.
   */
  getCurrentScrollPosition() {
    return this._state;
  }
  setScrollPositionNow(update) {
    const newState = this._state.withScrollPosition(update);
    if (this._smoothScrolling) {
      this._smoothScrolling.dispose();
      this._smoothScrolling = null;
    }
    this._setState(newState, false);
  }
  setScrollPositionSmooth(update, reuseAnimation) {
    if (this._smoothScrollDuration === 0) {
      return this.setScrollPositionNow(update);
    }
    if (this._smoothScrolling) {
      update = {
        scrollLeft: typeof update.scrollLeft === "undefined" ? this._smoothScrolling.to.scrollLeft : update.scrollLeft,
        scrollTop: typeof update.scrollTop === "undefined" ? this._smoothScrolling.to.scrollTop : update.scrollTop
      };
      const validTarget = this._state.withScrollPosition(update);
      if (this._smoothScrolling.to.scrollLeft === validTarget.scrollLeft && this._smoothScrolling.to.scrollTop === validTarget.scrollTop) {
        return;
      }
      let newSmoothScrolling;
      if (reuseAnimation) {
        newSmoothScrolling = new SmoothScrollingOperation(this._smoothScrolling.from, validTarget, this._smoothScrolling.startTime, this._smoothScrolling.duration);
      } else {
        newSmoothScrolling = this._smoothScrolling.combine(this._state, validTarget, this._smoothScrollDuration);
      }
      this._smoothScrolling.dispose();
      this._smoothScrolling = newSmoothScrolling;
    } else {
      const validTarget = this._state.withScrollPosition(update);
      this._smoothScrolling = SmoothScrollingOperation.start(this._state, validTarget, this._smoothScrollDuration);
    }
    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
      if (!this._smoothScrolling) {
        return;
      }
      this._smoothScrolling.animationFrameDisposable = null;
      this._performSmoothScrolling();
    });
  }
  hasPendingScrollAnimation() {
    return Boolean(this._smoothScrolling);
  }
  _performSmoothScrolling() {
    if (!this._smoothScrolling) {
      return;
    }
    const update = this._smoothScrolling.tick();
    const newState = this._state.withScrollPosition(update);
    this._setState(newState, true);
    if (!this._smoothScrolling) {
      return;
    }
    if (update.isDone) {
      this._smoothScrolling.dispose();
      this._smoothScrolling = null;
      return;
    }
    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
      if (!this._smoothScrolling) {
        return;
      }
      this._smoothScrolling.animationFrameDisposable = null;
      this._performSmoothScrolling();
    });
  }
  _setState(newState, inSmoothScrolling) {
    const oldState = this._state;
    if (oldState.equals(newState)) {
      return;
    }
    this._state = newState;
    this._onScroll.fire(this._state.createScrollEvent(oldState, inSmoothScrolling));
  }
};
var SmoothScrollingUpdate = class {
  constructor(scrollLeft, scrollTop, isDone) {
    this.scrollLeft = scrollLeft;
    this.scrollTop = scrollTop;
    this.isDone = isDone;
  }
};
function createEaseOutCubic(from, to) {
  const delta = to - from;
  return function(completion) {
    return from + delta * easeOutCubic(completion);
  };
}
function createComposed(a, b, cut) {
  return function(completion) {
    if (completion < cut) {
      return a(completion / cut);
    }
    return b((completion - cut) / (1 - cut));
  };
}
var SmoothScrollingOperation = class _SmoothScrollingOperation {
  constructor(from, to, startTime, duration) {
    this.from = from;
    this.to = to;
    this.duration = duration;
    this.startTime = startTime;
    this.animationFrameDisposable = null;
    this._initAnimations();
  }
  _initAnimations() {
    this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width);
    this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
  }
  _initAnimation(from, to, viewportSize) {
    const delta = Math.abs(from - to);
    if (delta > 2.5 * viewportSize) {
      let stop1, stop2;
      if (from < to) {
        stop1 = from + 0.75 * viewportSize;
        stop2 = to - 0.75 * viewportSize;
      } else {
        stop1 = from - 0.75 * viewportSize;
        stop2 = to + 0.75 * viewportSize;
      }
      return createComposed(createEaseOutCubic(from, stop1), createEaseOutCubic(stop2, to), 0.33);
    }
    return createEaseOutCubic(from, to);
  }
  dispose() {
    if (this.animationFrameDisposable !== null) {
      this.animationFrameDisposable.dispose();
      this.animationFrameDisposable = null;
    }
  }
  acceptScrollDimensions(state) {
    this.to = state.withScrollPosition(this.to);
    this._initAnimations();
  }
  tick() {
    return this._tick(Date.now());
  }
  _tick(now) {
    const completion = (now - this.startTime) / this.duration;
    if (completion < 1) {
      const newScrollLeft = this.scrollLeft(completion);
      const newScrollTop = this.scrollTop(completion);
      return new SmoothScrollingUpdate(newScrollLeft, newScrollTop, false);
    }
    return new SmoothScrollingUpdate(this.to.scrollLeft, this.to.scrollTop, true);
  }
  combine(from, to, duration) {
    return _SmoothScrollingOperation.start(from, to, duration);
  }
  static start(from, to, duration) {
    duration = duration + 10;
    const startTime = Date.now() - 10;
    return new _SmoothScrollingOperation(from, to, startTime, duration);
  }
};
function easeInCubic(t) {
  return Math.pow(t, 3);
}
function easeOutCubic(t) {
  return 1 - easeInCubic(1 - t);
}

// node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollableElement.js
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/media/scrollbars.css";
var HIDE_TIMEOUT = 500;
var SCROLL_WHEEL_SENSITIVITY = 50;
var SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED = true;
var MouseWheelClassifierItem = class {
  constructor(timestamp, deltaX, deltaY) {
    this.timestamp = timestamp;
    this.deltaX = deltaX;
    this.deltaY = deltaY;
    this.score = 0;
  }
};
var MouseWheelClassifier = class {
  constructor() {
    this._capacity = 5;
    this._memory = [];
    this._front = -1;
    this._rear = -1;
  }
  isPhysicalMouseWheel() {
    if (this._front === -1 && this._rear === -1) {
      return false;
    }
    let remainingInfluence = 1;
    let score3 = 0;
    let iteration = 1;
    let index = this._rear;
    do {
      const influence = index === this._front ? remainingInfluence : Math.pow(2, -iteration);
      remainingInfluence -= influence;
      score3 += this._memory[index].score * influence;
      if (index === this._front) {
        break;
      }
      index = (this._capacity + index - 1) % this._capacity;
      iteration++;
    } while (true);
    return score3 <= 0.5;
  }
  acceptStandardWheelEvent(e) {
    if (isChrome2) {
      const targetWindow = getWindow(e.browserEvent);
      const pageZoomFactor = getZoomFactor(targetWindow);
      this.accept(Date.now(), e.deltaX * pageZoomFactor, e.deltaY * pageZoomFactor);
    } else {
      this.accept(Date.now(), e.deltaX, e.deltaY);
    }
  }
  accept(timestamp, deltaX, deltaY) {
    const item = new MouseWheelClassifierItem(timestamp, deltaX, deltaY);
    item.score = this._computeScore(item);
    if (this._front === -1 && this._rear === -1) {
      this._memory[0] = item;
      this._front = 0;
      this._rear = 0;
    } else {
      this._rear = (this._rear + 1) % this._capacity;
      if (this._rear === this._front) {
        this._front = (this._front + 1) % this._capacity;
      }
      this._memory[this._rear] = item;
    }
  }
  /**
   * A score between 0 and 1 for `item`.
   *  - a score towards 0 indicates that the source appears to be a physical mouse wheel
   *  - a score towards 1 indicates that the source appears to be a touchpad or magic mouse, etc.
   */
  _computeScore(item) {
    if (Math.abs(item.deltaX) > 0 && Math.abs(item.deltaY) > 0) {
      return 1;
    }
    let score3 = 0.5;
    const prev = this._front === -1 && this._rear === -1 ? null : this._memory[this._rear];
    if (prev) {
    }
    if (!this._isAlmostInt(item.deltaX) || !this._isAlmostInt(item.deltaY)) {
      score3 += 0.25;
    }
    return Math.min(Math.max(score3, 0), 1);
  }
  _isAlmostInt(value) {
    const delta = Math.abs(Math.round(value) - value);
    return delta < 0.01;
  }
};
MouseWheelClassifier.INSTANCE = new MouseWheelClassifier();
var AbstractScrollableElement = class extends Widget {
  get options() {
    return this._options;
  }
  constructor(element, options2, scrollable) {
    super();
    this._onScroll = this._register(new Emitter());
    this.onScroll = this._onScroll.event;
    this._onWillScroll = this._register(new Emitter());
    element.style.overflow = "hidden";
    this._options = resolveOptions(options2);
    this._scrollable = scrollable;
    this._register(this._scrollable.onScroll((e) => {
      this._onWillScroll.fire(e);
      this._onDidScroll(e);
      this._onScroll.fire(e);
    }));
    const scrollbarHost = {
      onMouseWheel: (mouseWheelEvent) => this._onMouseWheel(mouseWheelEvent),
      onDragStart: () => this._onDragStart(),
      onDragEnd: () => this._onDragEnd()
    };
    this._verticalScrollbar = this._register(new VerticalScrollbar(this._scrollable, this._options, scrollbarHost));
    this._horizontalScrollbar = this._register(new HorizontalScrollbar(this._scrollable, this._options, scrollbarHost));
    this._domNode = document.createElement("div");
    this._domNode.className = "monaco-scrollable-element " + this._options.className;
    this._domNode.setAttribute("role", "presentation");
    this._domNode.style.position = "relative";
    this._domNode.style.overflow = "hidden";
    this._domNode.appendChild(element);
    this._domNode.appendChild(this._horizontalScrollbar.domNode.domNode);
    this._domNode.appendChild(this._verticalScrollbar.domNode.domNode);
    if (this._options.useShadows) {
      this._leftShadowDomNode = createFastDomNode(document.createElement("div"));
      this._leftShadowDomNode.setClassName("shadow");
      this._domNode.appendChild(this._leftShadowDomNode.domNode);
      this._topShadowDomNode = createFastDomNode(document.createElement("div"));
      this._topShadowDomNode.setClassName("shadow");
      this._domNode.appendChild(this._topShadowDomNode.domNode);
      this._topLeftShadowDomNode = createFastDomNode(document.createElement("div"));
      this._topLeftShadowDomNode.setClassName("shadow");
      this._domNode.appendChild(this._topLeftShadowDomNode.domNode);
    } else {
      this._leftShadowDomNode = null;
      this._topShadowDomNode = null;
      this._topLeftShadowDomNode = null;
    }
    this._listenOnDomNode = this._options.listenOnDomNode || this._domNode;
    this._mouseWheelToDispose = [];
    this._setListeningToMouseWheel(this._options.handleMouseWheel);
    this.onmouseover(this._listenOnDomNode, (e) => this._onMouseOver(e));
    this.onmouseleave(this._listenOnDomNode, (e) => this._onMouseLeave(e));
    this._hideTimeout = this._register(new TimeoutTimer());
    this._isDragging = false;
    this._mouseIsOver = false;
    this._shouldRender = true;
    this._revealOnScroll = true;
  }
  dispose() {
    this._mouseWheelToDispose = dispose(this._mouseWheelToDispose);
    super.dispose();
  }
  /**
   * Get the generated 'scrollable' dom node
   */
  getDomNode() {
    return this._domNode;
  }
  getOverviewRulerLayoutInfo() {
    return {
      parent: this._domNode,
      insertBefore: this._verticalScrollbar.domNode.domNode
    };
  }
  /**
   * Delegate a pointer down event to the vertical scrollbar.
   * This is to help with clicking somewhere else and having the scrollbar react.
   */
  delegateVerticalScrollbarPointerDown(browserEvent) {
    this._verticalScrollbar.delegatePointerDown(browserEvent);
  }
  getScrollDimensions() {
    return this._scrollable.getScrollDimensions();
  }
  setScrollDimensions(dimensions) {
    this._scrollable.setScrollDimensions(dimensions, false);
  }
  /**
   * Update the class name of the scrollable element.
   */
  updateClassName(newClassName) {
    this._options.className = newClassName;
    if (isMacintosh) {
      this._options.className += " mac";
    }
    this._domNode.className = "monaco-scrollable-element " + this._options.className;
  }
  /**
   * Update configuration options for the scrollbar.
   */
  updateOptions(newOptions) {
    if (typeof newOptions.handleMouseWheel !== "undefined") {
      this._options.handleMouseWheel = newOptions.handleMouseWheel;
      this._setListeningToMouseWheel(this._options.handleMouseWheel);
    }
    if (typeof newOptions.mouseWheelScrollSensitivity !== "undefined") {
      this._options.mouseWheelScrollSensitivity = newOptions.mouseWheelScrollSensitivity;
    }
    if (typeof newOptions.fastScrollSensitivity !== "undefined") {
      this._options.fastScrollSensitivity = newOptions.fastScrollSensitivity;
    }
    if (typeof newOptions.scrollPredominantAxis !== "undefined") {
      this._options.scrollPredominantAxis = newOptions.scrollPredominantAxis;
    }
    if (typeof newOptions.horizontal !== "undefined") {
      this._options.horizontal = newOptions.horizontal;
    }
    if (typeof newOptions.vertical !== "undefined") {
      this._options.vertical = newOptions.vertical;
    }
    if (typeof newOptions.horizontalScrollbarSize !== "undefined") {
      this._options.horizontalScrollbarSize = newOptions.horizontalScrollbarSize;
    }
    if (typeof newOptions.verticalScrollbarSize !== "undefined") {
      this._options.verticalScrollbarSize = newOptions.verticalScrollbarSize;
    }
    if (typeof newOptions.scrollByPage !== "undefined") {
      this._options.scrollByPage = newOptions.scrollByPage;
    }
    this._horizontalScrollbar.updateOptions(this._options);
    this._verticalScrollbar.updateOptions(this._options);
    if (!this._options.lazyRender) {
      this._render();
    }
  }
  delegateScrollFromMouseWheelEvent(browserEvent) {
    this._onMouseWheel(new StandardWheelEvent(browserEvent));
  }
  // -------------------- mouse wheel scrolling --------------------
  _setListeningToMouseWheel(shouldListen) {
    const isListening = this._mouseWheelToDispose.length > 0;
    if (isListening === shouldListen) {
      return;
    }
    this._mouseWheelToDispose = dispose(this._mouseWheelToDispose);
    if (shouldListen) {
      const onMouseWheel = (browserEvent) => {
        this._onMouseWheel(new StandardWheelEvent(browserEvent));
      };
      this._mouseWheelToDispose.push(addDisposableListener(this._listenOnDomNode, EventType.MOUSE_WHEEL, onMouseWheel, { passive: false }));
    }
  }
  _onMouseWheel(e) {
    var _a2;
    if ((_a2 = e.browserEvent) === null || _a2 === void 0 ? void 0 : _a2.defaultPrevented) {
      return;
    }
    const classifier = MouseWheelClassifier.INSTANCE;
    if (SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED) {
      classifier.acceptStandardWheelEvent(e);
    }
    let didScroll = false;
    if (e.deltaY || e.deltaX) {
      let deltaY = e.deltaY * this._options.mouseWheelScrollSensitivity;
      let deltaX = e.deltaX * this._options.mouseWheelScrollSensitivity;
      if (this._options.scrollPredominantAxis) {
        if (this._options.scrollYToX && deltaX + deltaY === 0) {
          deltaX = deltaY = 0;
        } else if (Math.abs(deltaY) >= Math.abs(deltaX)) {
          deltaX = 0;
        } else {
          deltaY = 0;
        }
      }
      if (this._options.flipAxes) {
        [deltaY, deltaX] = [deltaX, deltaY];
      }
      const shiftConvert = !isMacintosh && e.browserEvent && e.browserEvent.shiftKey;
      if ((this._options.scrollYToX || shiftConvert) && !deltaX) {
        deltaX = deltaY;
        deltaY = 0;
      }
      if (e.browserEvent && e.browserEvent.altKey) {
        deltaX = deltaX * this._options.fastScrollSensitivity;
        deltaY = deltaY * this._options.fastScrollSensitivity;
      }
      const futureScrollPosition = this._scrollable.getFutureScrollPosition();
      let desiredScrollPosition = {};
      if (deltaY) {
        const deltaScrollTop = SCROLL_WHEEL_SENSITIVITY * deltaY;
        const desiredScrollTop = futureScrollPosition.scrollTop - (deltaScrollTop < 0 ? Math.floor(deltaScrollTop) : Math.ceil(deltaScrollTop));
        this._verticalScrollbar.writeScrollPosition(desiredScrollPosition, desiredScrollTop);
      }
      if (deltaX) {
        const deltaScrollLeft = SCROLL_WHEEL_SENSITIVITY * deltaX;
        const desiredScrollLeft = futureScrollPosition.scrollLeft - (deltaScrollLeft < 0 ? Math.floor(deltaScrollLeft) : Math.ceil(deltaScrollLeft));
        this._horizontalScrollbar.writeScrollPosition(desiredScrollPosition, desiredScrollLeft);
      }
      desiredScrollPosition = this._scrollable.validateScrollPosition(desiredScrollPosition);
      if (futureScrollPosition.scrollLeft !== desiredScrollPosition.scrollLeft || futureScrollPosition.scrollTop !== desiredScrollPosition.scrollTop) {
        const canPerformSmoothScroll = SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED && this._options.mouseWheelSmoothScroll && classifier.isPhysicalMouseWheel();
        if (canPerformSmoothScroll) {
          this._scrollable.setScrollPositionSmooth(desiredScrollPosition);
        } else {
          this._scrollable.setScrollPositionNow(desiredScrollPosition);
        }
        didScroll = true;
      }
    }
    let consumeMouseWheel = didScroll;
    if (!consumeMouseWheel && this._options.alwaysConsumeMouseWheel) {
      consumeMouseWheel = true;
    }
    if (!consumeMouseWheel && this._options.consumeMouseWheelIfScrollbarIsNeeded && (this._verticalScrollbar.isNeeded() || this._horizontalScrollbar.isNeeded())) {
      consumeMouseWheel = true;
    }
    if (consumeMouseWheel) {
      e.preventDefault();
      e.stopPropagation();
    }
  }
  _onDidScroll(e) {
    this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender;
    this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender;
    if (this._options.useShadows) {
      this._shouldRender = true;
    }
    if (this._revealOnScroll) {
      this._reveal();
    }
    if (!this._options.lazyRender) {
      this._render();
    }
  }
  /**
   * Render / mutate the DOM now.
   * Should be used together with the ctor option `lazyRender`.
   */
  renderNow() {
    if (!this._options.lazyRender) {
      throw new Error("Please use `lazyRender` together with `renderNow`!");
    }
    this._render();
  }
  _render() {
    if (!this._shouldRender) {
      return;
    }
    this._shouldRender = false;
    this._horizontalScrollbar.render();
    this._verticalScrollbar.render();
    if (this._options.useShadows) {
      const scrollState = this._scrollable.getCurrentScrollPosition();
      const enableTop = scrollState.scrollTop > 0;
      const enableLeft = scrollState.scrollLeft > 0;
      const leftClassName = enableLeft ? " left" : "";
      const topClassName = enableTop ? " top" : "";
      const topLeftClassName = enableLeft || enableTop ? " top-left-corner" : "";
      this._leftShadowDomNode.setClassName(`shadow${leftClassName}`);
      this._topShadowDomNode.setClassName(`shadow${topClassName}`);
      this._topLeftShadowDomNode.setClassName(`shadow${topLeftClassName}${topClassName}${leftClassName}`);
    }
  }
  // -------------------- fade in / fade out --------------------
  _onDragStart() {
    this._isDragging = true;
    this._reveal();
  }
  _onDragEnd() {
    this._isDragging = false;
    this._hide();
  }
  _onMouseLeave(e) {
    this._mouseIsOver = false;
    this._hide();
  }
  _onMouseOver(e) {
    this._mouseIsOver = true;
    this._reveal();
  }
  _reveal() {
    this._verticalScrollbar.beginReveal();
    this._horizontalScrollbar.beginReveal();
    this._scheduleHide();
  }
  _hide() {
    if (!this._mouseIsOver && !this._isDragging) {
      this._verticalScrollbar.beginHide();
      this._horizontalScrollbar.beginHide();
    }
  }
  _scheduleHide() {
    if (!this._mouseIsOver && !this._isDragging) {
      this._hideTimeout.cancelAndSet(() => this._hide(), HIDE_TIMEOUT);
    }
  }
};
var ScrollableElement = class extends AbstractScrollableElement {
  constructor(element, options2) {
    options2 = options2 || {};
    options2.mouseWheelSmoothScroll = false;
    const scrollable = new Scrollable({
      forceIntegerValues: true,
      smoothScrollDuration: 0,
      scheduleAtNextAnimationFrame: (callback) => scheduleAtNextAnimationFrame(getWindow(element), callback)
    });
    super(element, options2, scrollable);
    this._register(scrollable);
  }
  setScrollPosition(update) {
    this._scrollable.setScrollPositionNow(update);
  }
};
var SmoothScrollableElement = class extends AbstractScrollableElement {
  constructor(element, options2, scrollable) {
    super(element, options2, scrollable);
  }
  setScrollPosition(update) {
    if (update.reuseAnimation) {
      this._scrollable.setScrollPositionSmooth(update, update.reuseAnimation);
    } else {
      this._scrollable.setScrollPositionNow(update);
    }
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
};
var DomScrollableElement = class extends AbstractScrollableElement {
  constructor(element, options2) {
    options2 = options2 || {};
    options2.mouseWheelSmoothScroll = false;
    const scrollable = new Scrollable({
      forceIntegerValues: false,
      // See https://github.com/microsoft/vscode/issues/139877
      smoothScrollDuration: 0,
      scheduleAtNextAnimationFrame: (callback) => scheduleAtNextAnimationFrame(getWindow(element), callback)
    });
    super(element, options2, scrollable);
    this._register(scrollable);
    this._element = element;
    this._register(this.onScroll((e) => {
      if (e.scrollTopChanged) {
        this._element.scrollTop = e.scrollTop;
      }
      if (e.scrollLeftChanged) {
        this._element.scrollLeft = e.scrollLeft;
      }
    }));
    this.scanDomNode();
  }
  setScrollPosition(update) {
    this._scrollable.setScrollPositionNow(update);
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
  scanDomNode() {
    this.setScrollDimensions({
      width: this._element.clientWidth,
      scrollWidth: this._element.scrollWidth,
      height: this._element.clientHeight,
      scrollHeight: this._element.scrollHeight
    });
    this.setScrollPosition({
      scrollLeft: this._element.scrollLeft,
      scrollTop: this._element.scrollTop
    });
  }
};
function resolveOptions(opts) {
  const result = {
    lazyRender: typeof opts.lazyRender !== "undefined" ? opts.lazyRender : false,
    className: typeof opts.className !== "undefined" ? opts.className : "",
    useShadows: typeof opts.useShadows !== "undefined" ? opts.useShadows : true,
    handleMouseWheel: typeof opts.handleMouseWheel !== "undefined" ? opts.handleMouseWheel : true,
    flipAxes: typeof opts.flipAxes !== "undefined" ? opts.flipAxes : false,
    consumeMouseWheelIfScrollbarIsNeeded: typeof opts.consumeMouseWheelIfScrollbarIsNeeded !== "undefined" ? opts.consumeMouseWheelIfScrollbarIsNeeded : false,
    alwaysConsumeMouseWheel: typeof opts.alwaysConsumeMouseWheel !== "undefined" ? opts.alwaysConsumeMouseWheel : false,
    scrollYToX: typeof opts.scrollYToX !== "undefined" ? opts.scrollYToX : false,
    mouseWheelScrollSensitivity: typeof opts.mouseWheelScrollSensitivity !== "undefined" ? opts.mouseWheelScrollSensitivity : 1,
    fastScrollSensitivity: typeof opts.fastScrollSensitivity !== "undefined" ? opts.fastScrollSensitivity : 5,
    scrollPredominantAxis: typeof opts.scrollPredominantAxis !== "undefined" ? opts.scrollPredominantAxis : true,
    mouseWheelSmoothScroll: typeof opts.mouseWheelSmoothScroll !== "undefined" ? opts.mouseWheelSmoothScroll : true,
    arrowSize: typeof opts.arrowSize !== "undefined" ? opts.arrowSize : 11,
    listenOnDomNode: typeof opts.listenOnDomNode !== "undefined" ? opts.listenOnDomNode : null,
    horizontal: typeof opts.horizontal !== "undefined" ? opts.horizontal : 1,
    horizontalScrollbarSize: typeof opts.horizontalScrollbarSize !== "undefined" ? opts.horizontalScrollbarSize : 10,
    horizontalSliderSize: typeof opts.horizontalSliderSize !== "undefined" ? opts.horizontalSliderSize : 0,
    horizontalHasArrows: typeof opts.horizontalHasArrows !== "undefined" ? opts.horizontalHasArrows : false,
    vertical: typeof opts.vertical !== "undefined" ? opts.vertical : 1,
    verticalScrollbarSize: typeof opts.verticalScrollbarSize !== "undefined" ? opts.verticalScrollbarSize : 10,
    verticalHasArrows: typeof opts.verticalHasArrows !== "undefined" ? opts.verticalHasArrows : false,
    verticalSliderSize: typeof opts.verticalSliderSize !== "undefined" ? opts.verticalSliderSize : 0,
    scrollByPage: typeof opts.scrollByPage !== "undefined" ? opts.scrollByPage : false
  };
  result.horizontalSliderSize = typeof opts.horizontalSliderSize !== "undefined" ? opts.horizontalSliderSize : result.horizontalScrollbarSize;
  result.verticalSliderSize = typeof opts.verticalSliderSize !== "undefined" ? opts.verticalSliderSize : result.verticalScrollbarSize;
  if (isMacintosh) {
    result.className += " mac";
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hoverWidget.js
init_lifecycle();
init_nls();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hover.css";
var $2 = $;
var HoverWidget = class extends Disposable {
  constructor() {
    super();
    this.containerDomNode = document.createElement("div");
    this.containerDomNode.className = "monaco-hover";
    this.containerDomNode.tabIndex = 0;
    this.containerDomNode.setAttribute("role", "tooltip");
    this.contentsDomNode = document.createElement("div");
    this.contentsDomNode.className = "monaco-hover-content";
    this.scrollbar = this._register(new DomScrollableElement(this.contentsDomNode, {
      consumeMouseWheelIfScrollbarIsNeeded: true
    }));
    this.containerDomNode.appendChild(this.scrollbar.getDomNode());
  }
  onContentsChanged() {
    this.scrollbar.scanDomNode();
  }
};
var HoverAction = class _HoverAction extends Disposable {
  static render(parent, actionOptions, keybindingLabel) {
    return new _HoverAction(parent, actionOptions, keybindingLabel);
  }
  constructor(parent, actionOptions, keybindingLabel) {
    super();
    this.actionContainer = append(parent, $2("div.action-container"));
    this.actionContainer.setAttribute("tabindex", "0");
    this.action = append(this.actionContainer, $2("a.action"));
    this.action.setAttribute("role", "button");
    if (actionOptions.iconClass) {
      append(this.action, $2(`span.icon.${actionOptions.iconClass}`));
    }
    const label = append(this.action, $2("span"));
    label.textContent = keybindingLabel ? `${actionOptions.label} (${keybindingLabel})` : actionOptions.label;
    this._register(addDisposableListener(this.actionContainer, EventType.CLICK, (e) => {
      e.stopPropagation();
      e.preventDefault();
      actionOptions.run(this.actionContainer);
    }));
    this._register(addDisposableListener(this.actionContainer, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(
        3
        /* KeyCode.Enter */
      ) || event.equals(
        10
        /* KeyCode.Space */
      )) {
        e.stopPropagation();
        e.preventDefault();
        actionOptions.run(this.actionContainer);
      }
    }));
    this.setEnabled(true);
  }
  setEnabled(enabled) {
    if (enabled) {
      this.actionContainer.classList.remove("disabled");
      this.actionContainer.removeAttribute("aria-disabled");
    } else {
      this.actionContainer.classList.add("disabled");
      this.actionContainer.setAttribute("aria-disabled", "true");
    }
  }
};
function getHoverAccessibleViewHint(shouldHaveHint, keybinding) {
  return shouldHaveHint && keybinding ? localize("acessibleViewHint", "Inspect this in the accessible view with {0}.", keybinding) : shouldHaveHint ? localize("acessibleViewHintNoKbOpen", "Inspect this in the accessible view via the command Open Accessible View which is currently not triggerable via keybinding.") : "";
}

// node_modules/monaco-editor/esm/vs/platform/opener/common/opener.js
init_instantiation();
var IOpenerService = createDecorator("openerService");
function extractSelection(uri) {
  let selection = void 0;
  const match2 = /^L?(\d+)(?:,(\d+))?(-L?(\d+)(?:,(\d+))?)?/.exec(uri.fragment);
  if (match2) {
    selection = {
      startLineNumber: parseInt(match2[1]),
      startColumn: match2[2] ? parseInt(match2[2]) : 1,
      endLineNumber: match2[4] ? parseInt(match2[4]) : void 0,
      endColumn: match2[4] ? match2[5] ? parseInt(match2[5]) : 1 : void 0
    };
    uri = uri.with({ fragment: "" });
  }
  return { selection, uri };
}

// node_modules/monaco-editor/esm/vs/editor/browser/widget/hoverWidget/hoverWidget.js
init_instantiation();

// node_modules/monaco-editor/esm/vs/base/browser/markdownRenderer.js
init_dom();
init_dompurify();

// node_modules/monaco-editor/esm/vs/base/browser/event.js
init_event();
var DomEmitter = class {
  get event() {
    return this.emitter.event;
  }
  constructor(element, type, useCapture) {
    const fn = (e) => this.emitter.fire(e);
    this.emitter = new Emitter({
      onWillAddFirstListener: () => element.addEventListener(type, fn, useCapture),
      onDidRemoveLastListener: () => element.removeEventListener(type, fn, useCapture)
    });
  }
  dispose() {
    this.emitter.dispose();
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/formattedTextRenderer.js
init_dom();
function renderText(text, options2 = {}) {
  const element = createElement(options2);
  element.textContent = text;
  return element;
}
function renderFormattedText(formattedText, options2 = {}) {
  const element = createElement(options2);
  _renderFormattedText(element, parseFormattedText(formattedText, !!options2.renderCodeSegments), options2.actionHandler, options2.renderCodeSegments);
  return element;
}
function createElement(options2) {
  const tagName = options2.inline ? "span" : "div";
  const element = document.createElement(tagName);
  if (options2.className) {
    element.className = options2.className;
  }
  return element;
}
var StringStream = class {
  constructor(source) {
    this.source = source;
    this.index = 0;
  }
  eos() {
    return this.index >= this.source.length;
  }
  next() {
    const next = this.peek();
    this.advance();
    return next;
  }
  peek() {
    return this.source[this.index];
  }
  advance() {
    this.index++;
  }
};
function _renderFormattedText(element, treeNode, actionHandler, renderCodeSegments) {
  let child;
  if (treeNode.type === 2) {
    child = document.createTextNode(treeNode.content || "");
  } else if (treeNode.type === 3) {
    child = document.createElement("b");
  } else if (treeNode.type === 4) {
    child = document.createElement("i");
  } else if (treeNode.type === 7 && renderCodeSegments) {
    child = document.createElement("code");
  } else if (treeNode.type === 5 && actionHandler) {
    const a = document.createElement("a");
    actionHandler.disposables.add(addStandardDisposableListener(a, "click", (event) => {
      actionHandler.callback(String(treeNode.index), event);
    }));
    child = a;
  } else if (treeNode.type === 8) {
    child = document.createElement("br");
  } else if (treeNode.type === 1) {
    child = element;
  }
  if (child && element !== child) {
    element.appendChild(child);
  }
  if (child && Array.isArray(treeNode.children)) {
    treeNode.children.forEach((nodeChild) => {
      _renderFormattedText(child, nodeChild, actionHandler, renderCodeSegments);
    });
  }
}
function parseFormattedText(content, parseCodeSegments) {
  const root = {
    type: 1,
    children: []
  };
  let actionViewItemIndex = 0;
  let current = root;
  const stack = [];
  const stream = new StringStream(content);
  while (!stream.eos()) {
    let next = stream.next();
    const isEscapedFormatType = next === "\\" && formatTagType(stream.peek(), parseCodeSegments) !== 0;
    if (isEscapedFormatType) {
      next = stream.next();
    }
    if (!isEscapedFormatType && isFormatTag(next, parseCodeSegments) && next === stream.peek()) {
      stream.advance();
      if (current.type === 2) {
        current = stack.pop();
      }
      const type = formatTagType(next, parseCodeSegments);
      if (current.type === type || current.type === 5 && type === 6) {
        current = stack.pop();
      } else {
        const newCurrent = {
          type,
          children: []
        };
        if (type === 5) {
          newCurrent.index = actionViewItemIndex;
          actionViewItemIndex++;
        }
        current.children.push(newCurrent);
        stack.push(current);
        current = newCurrent;
      }
    } else if (next === "\n") {
      if (current.type === 2) {
        current = stack.pop();
      }
      current.children.push({
        type: 8
        /* FormatType.NewLine */
      });
    } else {
      if (current.type !== 2) {
        const textCurrent = {
          type: 2,
          content: next
        };
        current.children.push(textCurrent);
        stack.push(current);
        current = textCurrent;
      } else {
        current.content += next;
      }
    }
  }
  if (current.type === 2) {
    current = stack.pop();
  }
  if (stack.length) {
  }
  return root;
}
function isFormatTag(char, supportCodeSegments) {
  return formatTagType(char, supportCodeSegments) !== 0;
}
function formatTagType(char, supportCodeSegments) {
  switch (char) {
    case "*":
      return 3;
    case "_":
      return 4;
    case "[":
      return 5;
    case "]":
      return 6;
    case "`":
      return supportCodeSegments ? 7 : 0;
    default:
      return 0;
  }
}

// node_modules/monaco-editor/esm/vs/base/browser/markdownRenderer.js
init_keyboardEvent();
init_mouseEvent();
init_iconLabels();
init_errors();
init_event();
init_htmlContent();
init_iconLabels2();

// node_modules/monaco-editor/esm/vs/base/common/idGenerator.js
var IdGenerator = class {
  constructor(prefix) {
    this._prefix = prefix;
    this._lastId = 0;
  }
  nextId() {
    return this._prefix + ++this._lastId;
  }
};
var defaultGenerator = new IdGenerator("id#");

// node_modules/monaco-editor/esm/vs/base/browser/markdownRenderer.js
init_lazy();
init_lifecycle();

// node_modules/monaco-editor/esm/vs/base/common/marked/marked.js
var __marked_exports = {};
(function() {
  function define(deps, factory) {
    factory(__marked_exports);
  }
  define.amd = true;
  (function(global, factory) {
    typeof define === "function" && define.amd ? define(["exports"], factory) : typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.marked = {}));
  })(this, function(exports2) {
    "use strict";
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it)
        return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        return function() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function getDefaults2() {
      return {
        async: false,
        baseUrl: null,
        breaks: false,
        extensions: null,
        gfm: true,
        headerIds: true,
        headerPrefix: "",
        highlight: null,
        langPrefix: "language-",
        mangle: true,
        pedantic: false,
        renderer: null,
        sanitize: false,
        sanitizer: null,
        silent: false,
        smartLists: false,
        smartypants: false,
        tokenizer: null,
        walkTokens: null,
        xhtml: false
      };
    }
    exports2.defaults = getDefaults2();
    function changeDefaults(newDefaults) {
      exports2.defaults = newDefaults;
    }
    var escapeTest = /[&<>"']/;
    var escapeReplace = /[&<>"']/g;
    var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
    var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
    var escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var getEscapeReplacement = function getEscapeReplacement2(ch) {
      return escapeReplacements[ch];
    };
    function escape2(html, encode) {
      if (encode) {
        if (escapeTest.test(html)) {
          return html.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html)) {
          return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }
      return html;
    }
    var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    function unescape(html) {
      return html.replace(unescapeTest, function(_, n) {
        n = n.toLowerCase();
        if (n === "colon")
          return ":";
        if (n.charAt(0) === "#") {
          return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
        }
        return "";
      });
    }
    var caret = /(^|[^\[])\^/g;
    function edit(regex, opt) {
      regex = typeof regex === "string" ? regex : regex.source;
      opt = opt || "";
      var obj = {
        replace: function replace(name, val) {
          val = val.source || val;
          val = val.replace(caret, "$1");
          regex = regex.replace(name, val);
          return obj;
        },
        getRegex: function getRegex() {
          return new RegExp(regex, opt);
        }
      };
      return obj;
    }
    var nonWordAndColonTest = /[^\w:]/g;
    var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    function cleanUrl(sanitize2, base, href) {
      if (sanitize2) {
        var prot;
        try {
          prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();
        } catch (e) {
          return null;
        }
        if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, "%");
      } catch (e) {
        return null;
      }
      return href;
    }
    var baseUrls = {};
    var justDomain = /^[^:]+:\/*[^/]*$/;
    var protocol = /^([^:]+:)[\s\S]*$/;
    var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    function resolveUrl(base, href) {
      if (!baseUrls[" " + base]) {
        if (justDomain.test(base)) {
          baseUrls[" " + base] = base + "/";
        } else {
          baseUrls[" " + base] = rtrim2(base, "/", true);
        }
      }
      base = baseUrls[" " + base];
      var relativeBase = base.indexOf(":") === -1;
      if (href.substring(0, 2) === "//") {
        if (relativeBase) {
          return href;
        }
        return base.replace(protocol, "$1") + href;
      } else if (href.charAt(0) === "/") {
        if (relativeBase) {
          return href;
        }
        return base.replace(domain, "$1") + href;
      } else {
        return base + href;
      }
    }
    var noopTest = {
      exec: function noopTest2() {
      }
    };
    function merge(obj) {
      var i = 1, target, key;
      for (; i < arguments.length; i++) {
        target = arguments[i];
        for (key in target) {
          if (Object.prototype.hasOwnProperty.call(target, key)) {
            obj[key] = target[key];
          }
        }
      }
      return obj;
    }
    function splitCells(tableRow, count) {
      var row = tableRow.replace(/\|/g, function(match2, offset, str) {
        var escaped = false, curr = offset;
        while (--curr >= 0 && str[curr] === "\\") {
          escaped = !escaped;
        }
        if (escaped) {
          return "|";
        } else {
          return " |";
        }
      }), cells = row.split(/ \|/);
      var i = 0;
      if (!cells[0].trim()) {
        cells.shift();
      }
      if (cells.length > 0 && !cells[cells.length - 1].trim()) {
        cells.pop();
      }
      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count) {
          cells.push("");
        }
      }
      for (; i < cells.length; i++) {
        cells[i] = cells[i].trim().replace(/\\\|/g, "|");
      }
      return cells;
    }
    function rtrim2(str, c, invert) {
      var l = str.length;
      if (l === 0) {
        return "";
      }
      var suffLen = 0;
      while (suffLen < l) {
        var currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && !invert) {
          suffLen++;
        } else if (currChar !== c && invert) {
          suffLen++;
        } else {
          break;
        }
      }
      return str.slice(0, l - suffLen);
    }
    function findClosingBracket(str, b) {
      if (str.indexOf(b[1]) === -1) {
        return -1;
      }
      var l = str.length;
      var level = 0, i = 0;
      for (; i < l; i++) {
        if (str[i] === "\\") {
          i++;
        } else if (str[i] === b[0]) {
          level++;
        } else if (str[i] === b[1]) {
          level--;
          if (level < 0) {
            return i;
          }
        }
      }
      return -1;
    }
    function checkSanitizeDeprecation(opt) {
      if (opt && opt.sanitize && !opt.silent) {
        console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
      }
    }
    function repeatString(pattern, count) {
      if (count < 1) {
        return "";
      }
      var result = "";
      while (count > 1) {
        if (count & 1) {
          result += pattern;
        }
        count >>= 1;
        pattern += pattern;
      }
      return result + pattern;
    }
    function outputLink(cap, link, raw, lexer3) {
      var href = link.href;
      var title = link.title ? escape2(link.title) : null;
      var text = cap[1].replace(/\\([\[\]])/g, "$1");
      if (cap[0].charAt(0) !== "!") {
        lexer3.state.inLink = true;
        var token = {
          type: "link",
          raw,
          href,
          title,
          text,
          tokens: lexer3.inlineTokens(text)
        };
        lexer3.state.inLink = false;
        return token;
      }
      return {
        type: "image",
        raw,
        href,
        title,
        text: escape2(text)
      };
    }
    function indentCodeCompensation(raw, text) {
      var matchIndentToCode = raw.match(/^(\s+)(?:```)/);
      if (matchIndentToCode === null) {
        return text;
      }
      var indentToCode = matchIndentToCode[1];
      return text.split("\n").map(function(node) {
        var matchIndentInNode = node.match(/^\s+/);
        if (matchIndentInNode === null) {
          return node;
        }
        var indentInNode = matchIndentInNode[0];
        if (indentInNode.length >= indentToCode.length) {
          return node.slice(indentToCode.length);
        }
        return node;
      }).join("\n");
    }
    var Tokenizer2 = function() {
      function Tokenizer3(options3) {
        this.options = options3 || exports2.defaults;
      }
      var _proto = Tokenizer3.prototype;
      _proto.space = function space(src) {
        var cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
          return {
            type: "space",
            raw: cap[0]
          };
        }
      };
      _proto.code = function code(src) {
        var cap = this.rules.block.code.exec(src);
        if (cap) {
          var text = cap[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim2(text, "\n") : text
          };
        }
      };
      _proto.fences = function fences(src) {
        var cap = this.rules.block.fences.exec(src);
        if (cap) {
          var raw = cap[0];
          var text = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim() : cap[2],
            text
          };
        }
      };
      _proto.heading = function heading(src) {
        var cap = this.rules.block.heading.exec(src);
        if (cap) {
          var text = cap[2].trim();
          if (/#$/.test(text)) {
            var trimmed = rtrim2(text, "#");
            if (this.options.pedantic) {
              text = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              text = trimmed.trim();
            }
          }
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text,
            tokens: this.lexer.inline(text)
          };
        }
      };
      _proto.hr = function hr(src) {
        var cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      };
      _proto.blockquote = function blockquote(src) {
        var cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          var text = cap[0].replace(/^ *>[ \t]?/gm, "");
          return {
            type: "blockquote",
            raw: cap[0],
            tokens: this.lexer.blockTokens(text, []),
            text
          };
        }
      };
      _proto.list = function list(src) {
        var cap = this.rules.block.list.exec(src);
        if (cap) {
          var raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
          var bull = cap[1].trim();
          var isordered = bull.length > 1;
          var list2 = {
            type: "list",
            raw: "",
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          bull = isordered ? "\\d{1,9}\\" + bull.slice(-1) : "\\" + bull;
          if (this.options.pedantic) {
            bull = isordered ? bull : "[*+-]";
          }
          var itemRegex = new RegExp("^( {0,3}" + bull + ")((?:[	 ][^\\n]*)?(?:\\n|$))");
          while (src) {
            endEarly = false;
            if (!(cap = itemRegex.exec(src))) {
              break;
            }
            if (this.rules.block.hr.test(src)) {
              break;
            }
            raw = cap[0];
            src = src.substring(raw.length);
            line = cap[2].split("\n", 1)[0];
            nextLine = src.split("\n", 1)[0];
            if (this.options.pedantic) {
              indent = 2;
              itemContents = line.trimLeft();
            } else {
              indent = cap[2].search(/[^ ]/);
              indent = indent > 4 ? 1 : indent;
              itemContents = line.slice(indent);
              indent += cap[1].length;
            }
            blankLine = false;
            if (!line && /^ *$/.test(nextLine)) {
              raw += nextLine + "\n";
              src = src.substring(nextLine.length + 1);
              endEarly = true;
            }
            if (!endEarly) {
              var nextBulletRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:[*+-]|\\d{1,9}[.)])((?: [^\\n]*)?(?:\\n|$))");
              var hrRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)");
              var fencesBeginRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:```|~~~)");
              var headingBeginRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}#");
              while (src) {
                rawLine = src.split("\n", 1)[0];
                line = rawLine;
                if (this.options.pedantic) {
                  line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
                }
                if (fencesBeginRegex.test(line)) {
                  break;
                }
                if (headingBeginRegex.test(line)) {
                  break;
                }
                if (nextBulletRegex.test(line)) {
                  break;
                }
                if (hrRegex.test(src)) {
                  break;
                }
                if (line.search(/[^ ]/) >= indent || !line.trim()) {
                  itemContents += "\n" + line.slice(indent);
                } else if (!blankLine) {
                  itemContents += "\n" + line;
                } else {
                  break;
                }
                if (!blankLine && !line.trim()) {
                  blankLine = true;
                }
                raw += rawLine + "\n";
                src = src.substring(rawLine.length + 1);
              }
            }
            if (!list2.loose) {
              if (endsWithBlankLine) {
                list2.loose = true;
              } else if (/\n *\n *$/.test(raw)) {
                endsWithBlankLine = true;
              }
            }
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.exec(itemContents);
              if (istask) {
                ischecked = istask[0] !== "[ ] ";
                itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
              }
            }
            list2.items.push({
              type: "list_item",
              raw,
              task: !!istask,
              checked: ischecked,
              loose: false,
              text: itemContents
            });
            list2.raw += raw;
          }
          list2.items[list2.items.length - 1].raw = raw.trimRight();
          list2.items[list2.items.length - 1].text = itemContents.trimRight();
          list2.raw = list2.raw.trimRight();
          var l = list2.items.length;
          for (i = 0; i < l; i++) {
            this.lexer.state.top = false;
            list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
            var spacers = list2.items[i].tokens.filter(function(t) {
              return t.type === "space";
            });
            var hasMultipleLineBreaks = spacers.every(function(t) {
              var chars = t.raw.split("");
              var lineBreaks = 0;
              for (var _iterator = _createForOfIteratorHelperLoose(chars), _step; !(_step = _iterator()).done; ) {
                var _char = _step.value;
                if (_char === "\n") {
                  lineBreaks += 1;
                }
                if (lineBreaks > 1) {
                  return true;
                }
              }
              return false;
            });
            if (!list2.loose && spacers.length && hasMultipleLineBreaks) {
              list2.loose = true;
              list2.items[i].loose = true;
            }
          }
          return list2;
        }
      };
      _proto.html = function html(src) {
        var cap = this.rules.block.html.exec(src);
        if (cap) {
          var token = {
            type: "html",
            raw: cap[0],
            pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
            text: cap[0]
          };
          if (this.options.sanitize) {
            var text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape2(cap[0]);
            token.type = "paragraph";
            token.text = text;
            token.tokens = this.lexer.inline(text);
          }
          return token;
        }
      };
      _proto.def = function def(src) {
        var cap = this.rules.block.def.exec(src);
        if (cap) {
          if (cap[3])
            cap[3] = cap[3].substring(1, cap[3].length - 1);
          var tag = cap[1].toLowerCase().replace(/\s+/g, " ");
          return {
            type: "def",
            tag,
            raw: cap[0],
            href: cap[2],
            title: cap[3]
          };
        }
      };
      _proto.table = function table(src) {
        var cap = this.rules.block.table.exec(src);
        if (cap) {
          var item = {
            type: "table",
            header: splitCells(cap[1]).map(function(c) {
              return {
                text: c
              };
            }),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
          };
          if (item.header.length === item.align.length) {
            item.raw = cap[0];
            var l = item.align.length;
            var i, j, k, row;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = "left";
              } else {
                item.align[i] = null;
              }
            }
            l = item.rows.length;
            for (i = 0; i < l; i++) {
              item.rows[i] = splitCells(item.rows[i], item.header.length).map(function(c) {
                return {
                  text: c
                };
              });
            }
            l = item.header.length;
            for (j = 0; j < l; j++) {
              item.header[j].tokens = this.lexer.inline(item.header[j].text);
            }
            l = item.rows.length;
            for (j = 0; j < l; j++) {
              row = item.rows[j];
              for (k = 0; k < row.length; k++) {
                row[k].tokens = this.lexer.inline(row[k].text);
              }
            }
            return item;
          }
        }
      };
      _proto.lheading = function lheading(src) {
        var cap = this.rules.block.lheading.exec(src);
        if (cap) {
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1],
            tokens: this.lexer.inline(cap[1])
          };
        }
      };
      _proto.paragraph = function paragraph(src) {
        var cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          var text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
          return {
            type: "paragraph",
            raw: cap[0],
            text,
            tokens: this.lexer.inline(text)
          };
        }
      };
      _proto.text = function text(src) {
        var cap = this.rules.block.text.exec(src);
        if (cap) {
          return {
            type: "text",
            raw: cap[0],
            text: cap[0],
            tokens: this.lexer.inline(cap[0])
          };
        }
      };
      _proto.escape = function escape$1(src) {
        var cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: escape2(cap[1])
          };
        }
      };
      _proto.tag = function tag(src) {
        var cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
            this.lexer.state.inLink = true;
          } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
            this.lexer.state.inLink = false;
          }
          if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = true;
          } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = false;
          }
          return {
            type: this.options.sanitize ? "text" : "html",
            raw: cap[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape2(cap[0]) : cap[0]
          };
        }
      };
      _proto.link = function link(src) {
        var cap = this.rules.inline.link.exec(src);
        if (cap) {
          var trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            if (!/>$/.test(trimmedUrl)) {
              return;
            }
            var rtrimSlash = rtrim2(trimmedUrl.slice(0, -1), "\\");
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            var lastParenIndex = findClosingBracket(cap[2], "()");
            if (lastParenIndex > -1) {
              var start = cap[0].indexOf("!") === 0 ? 5 : 4;
              var linkLen = start + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = "";
            }
          }
          var href = cap[2];
          var title = "";
          if (this.options.pedantic) {
            var link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link2) {
              href = link2[1];
              title = link2[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
            title: title ? title.replace(this.rules.inline._escapes, "$1") : title
          }, cap[0], this.lexer);
        }
      };
      _proto.reflink = function reflink(src, links) {
        var cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          var link = (cap[2] || cap[1]).replace(/\s+/g, " ");
          link = links[link.toLowerCase()];
          if (!link || !link.href) {
            var text = cap[0].charAt(0);
            return {
              type: "text",
              raw: text,
              text
            };
          }
          return outputLink(cap, link, cap[0], this.lexer);
        }
      };
      _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {
        if (prevChar === void 0) {
          prevChar = "";
        }
        var match2 = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match2)
          return;
        if (match2[3] && prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/))
          return;
        var nextChar = match2[1] || match2[2] || "";
        if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
          var lLength = match2[0].length - 1;
          var rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
          var endReg = match2[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;
          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
          while ((match2 = endReg.exec(maskedSrc)) != null) {
            rDelim = match2[1] || match2[2] || match2[3] || match2[4] || match2[5] || match2[6];
            if (!rDelim)
              continue;
            rLength = rDelim.length;
            if (match2[3] || match2[4]) {
              delimTotal += rLength;
              continue;
            } else if (match2[5] || match2[6]) {
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue;
              }
            }
            delimTotal -= rLength;
            if (delimTotal > 0)
              continue;
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
            if (Math.min(lLength, rLength) % 2) {
              var _text = src.slice(1, lLength + match2.index + rLength);
              return {
                type: "em",
                raw: src.slice(0, lLength + match2.index + rLength + 1),
                text: _text,
                tokens: this.lexer.inlineTokens(_text)
              };
            }
            var text = src.slice(2, lLength + match2.index + rLength - 1);
            return {
              type: "strong",
              raw: src.slice(0, lLength + match2.index + rLength + 1),
              text,
              tokens: this.lexer.inlineTokens(text)
            };
          }
        }
      };
      _proto.codespan = function codespan(src) {
        var cap = this.rules.inline.code.exec(src);
        if (cap) {
          var text = cap[2].replace(/\n/g, " ");
          var hasNonSpaceChars = /[^ ]/.test(text);
          var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text = text.substring(1, text.length - 1);
          }
          text = escape2(text, true);
          return {
            type: "codespan",
            raw: cap[0],
            text
          };
        }
      };
      _proto.br = function br(src) {
        var cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      };
      _proto.del = function del(src) {
        var cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[2],
            tokens: this.lexer.inlineTokens(cap[2])
          };
        }
      };
      _proto.autolink = function autolink(src, mangle2) {
        var cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          var text, href;
          if (cap[2] === "@") {
            text = escape2(this.options.mangle ? mangle2(cap[1]) : cap[1]);
            href = "mailto:" + text;
          } else {
            text = escape2(cap[1]);
            href = text;
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [{
              type: "text",
              raw: text,
              text
            }]
          };
        }
      };
      _proto.url = function url(src, mangle2) {
        var cap;
        if (cap = this.rules.inline.url.exec(src)) {
          var text, href;
          if (cap[2] === "@") {
            text = escape2(this.options.mangle ? mangle2(cap[0]) : cap[0]);
            href = "mailto:" + text;
          } else {
            var prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = escape2(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + text;
            } else {
              href = text;
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [{
              type: "text",
              raw: text,
              text
            }]
          };
        }
      };
      _proto.inlineText = function inlineText(src, smartypants2) {
        var cap = this.rules.inline.text.exec(src);
        if (cap) {
          var text;
          if (this.lexer.state.inRawBlock) {
            text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape2(cap[0]) : cap[0];
          } else {
            text = escape2(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text
          };
        }
      };
      return Tokenizer3;
    }();
    var block = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
      hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
      html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
      def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
      table: noopTest,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      // regex template, placeholders will be replaced according to different paragraph
      // interruption rules of commonmark and the original markdown spec:
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
    block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
    block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
    block.normal = merge({}, block);
    block.gfm = merge({}, block.normal, {
      table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
      // Cells
    });
    block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.pedantic = merge({}, block.normal, {
      html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest,
      // fences not supported
      paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    });
    var inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      // CDATA section
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(ref)\]/,
      nolink: /^!?\[(ref)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
        //          () Skip orphan inside strong  () Consume to delim (1) #***                (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
        rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[^*]+(?=[^*])|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
        rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
        // ^- Not allowed for _
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\spunctuation])/
    };
    inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
    inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
    inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
    inline.escapedEmSt = /\\\*|\\_/g;
    inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
    inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
    inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
    inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
    inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
    inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
    inline.normal = merge({}, inline);
    inline.pedantic = merge({}, inline.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
    });
    inline.gfm = merge({}, inline.normal, {
      escape: edit(inline.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    });
    inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
    inline.breaks = merge({}, inline.gfm, {
      br: edit(inline.br).replace("{2,}", "*").getRegex(),
      text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    });
    function smartypants(text) {
      return text.replace(/---/g, "").replace(/--/g, "").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1").replace(/'/g, "").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1").replace(/"/g, "").replace(/\.{3}/g, "");
    }
    function mangle(text) {
      var out = "", i, ch;
      var l = text.length;
      for (i = 0; i < l; i++) {
        ch = text.charCodeAt(i);
        if (Math.random() > 0.5) {
          ch = "x" + ch.toString(16);
        }
        out += "&#" + ch + ";";
      }
      return out;
    }
    var Lexer2 = function() {
      function Lexer3(options3) {
        this.tokens = [];
        this.tokens.links = /* @__PURE__ */ Object.create(null);
        this.options = options3 || exports2.defaults;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer2();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
          inLink: false,
          inRawBlock: false,
          top: true
        };
        var rules = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules.block = block.pedantic;
          rules.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules.block = block.gfm;
          if (this.options.breaks) {
            rules.inline = inline.breaks;
          } else {
            rules.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }
      Lexer3.lex = function lex(src, options3) {
        var lexer3 = new Lexer3(options3);
        return lexer3.lex(src);
      };
      Lexer3.lexInline = function lexInline(src, options3) {
        var lexer3 = new Lexer3(options3);
        return lexer3.inlineTokens(src);
      };
      var _proto = Lexer3.prototype;
      _proto.lex = function lex(src) {
        src = src.replace(/\r\n|\r/g, "\n");
        this.blockTokens(src, this.tokens);
        var next;
        while (next = this.inlineQueue.shift()) {
          this.inlineTokens(next.src, next.tokens);
        }
        return this.tokens;
      };
      _proto.blockTokens = function blockTokens(src, tokens) {
        var _this = this;
        if (tokens === void 0) {
          tokens = [];
        }
        if (this.options.pedantic) {
          src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
        } else {
          src = src.replace(/^( *)(\t+)/gm, function(_, leading, tabs) {
            return leading + "    ".repeat(tabs.length);
          });
        }
        var token, lastToken, cutSrc, lastParagraphClipped;
        while (src) {
          if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function(extTokenizer) {
            if (token = extTokenizer.call({
              lexer: _this
            }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.raw.length === 1 && tokens.length > 0) {
              tokens[tokens.length - 1].raw += "\n";
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.def(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.raw;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startBlock) {
            (function() {
              var startIndex = Infinity;
              var tempSrc = src.slice(1);
              var tempStart = void 0;
              _this.options.extensions.startBlock.forEach(function(getStartIndex) {
                tempStart = getStartIndex.call({
                  lexer: this
                }, tempSrc);
                if (typeof tempStart === "number" && tempStart >= 0) {
                  startIndex = Math.min(startIndex, tempStart);
                }
              });
              if (startIndex < Infinity && startIndex >= 0) {
                cutSrc = src.substring(0, startIndex + 1);
              }
            })();
          }
          if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            lastParagraphClipped = cutSrc.length !== src.length;
            src = src.substring(token.raw.length);
            continue;
          }
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        this.state.top = true;
        return tokens;
      };
      _proto.inline = function inline2(src, tokens) {
        if (tokens === void 0) {
          tokens = [];
        }
        this.inlineQueue.push({
          src,
          tokens
        });
        return tokens;
      };
      _proto.inlineTokens = function inlineTokens(src, tokens) {
        var _this2 = this;
        if (tokens === void 0) {
          tokens = [];
        }
        var token, lastToken, cutSrc;
        var maskedSrc = src;
        var match2;
        var keepPrevChar, prevChar;
        if (this.tokens.links) {
          var links = Object.keys(this.tokens.links);
          if (links.length > 0) {
            while ((match2 = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links.includes(match2[0].slice(match2[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match2.index) + "[" + repeatString("a", match2[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match2 = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match2.index) + "[" + repeatString("a", match2[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match2 = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match2.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
        }
        while (src) {
          if (!keepPrevChar) {
            prevChar = "";
          }
          keepPrevChar = false;
          if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function(extTokenizer) {
            if (token = extTokenizer.call({
              lexer: _this2
            }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startInline) {
            (function() {
              var startIndex = Infinity;
              var tempSrc = src.slice(1);
              var tempStart = void 0;
              _this2.options.extensions.startInline.forEach(function(getStartIndex) {
                tempStart = getStartIndex.call({
                  lexer: this
                }, tempSrc);
                if (typeof tempStart === "number" && tempStart >= 0) {
                  startIndex = Math.min(startIndex, tempStart);
                }
              });
              if (startIndex < Infinity && startIndex >= 0) {
                cutSrc = src.substring(0, startIndex + 1);
              }
            })();
          }
          if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== "_") {
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      };
      _createClass(Lexer3, null, [{
        key: "rules",
        get: function get() {
          return {
            block,
            inline
          };
        }
      }]);
      return Lexer3;
    }();
    var Renderer2 = function() {
      function Renderer3(options3) {
        this.options = options3 || exports2.defaults;
      }
      var _proto = Renderer3.prototype;
      _proto.code = function code(_code, infostring, escaped) {
        var lang = (infostring || "").match(/\S*/)[0];
        if (this.options.highlight) {
          var out = this.options.highlight(_code, lang);
          if (out != null && out !== _code) {
            escaped = true;
            _code = out;
          }
        }
        _code = _code.replace(/\n$/, "") + "\n";
        if (!lang) {
          return "<pre><code>" + (escaped ? _code : escape2(_code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="' + this.options.langPrefix + escape2(lang, true) + '">' + (escaped ? _code : escape2(_code, true)) + "</code></pre>\n";
      };
      _proto.blockquote = function blockquote(quote) {
        return "<blockquote>\n" + quote + "</blockquote>\n";
      };
      _proto.html = function html(_html) {
        return _html;
      };
      _proto.heading = function heading(text, level, raw, slugger) {
        if (this.options.headerIds) {
          var id = this.options.headerPrefix + slugger.slug(raw);
          return "<h" + level + ' id="' + id + '">' + text + "</h" + level + ">\n";
        }
        return "<h" + level + ">" + text + "</h" + level + ">\n";
      };
      _proto.hr = function hr() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
      };
      _proto.list = function list(body, ordered, start) {
        var type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
        return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
      };
      _proto.listitem = function listitem(text) {
        return "<li>" + text + "</li>\n";
      };
      _proto.checkbox = function checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      };
      _proto.paragraph = function paragraph(text) {
        return "<p>" + text + "</p>\n";
      };
      _proto.table = function table(header, body) {
        if (body)
          body = "<tbody>" + body + "</tbody>";
        return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
      };
      _proto.tablerow = function tablerow(content) {
        return "<tr>\n" + content + "</tr>\n";
      };
      _proto.tablecell = function tablecell(content, flags) {
        var type = flags.header ? "th" : "td";
        var tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
        return tag + content + ("</" + type + ">\n");
      };
      _proto.strong = function strong(text) {
        return "<strong>" + text + "</strong>";
      };
      _proto.em = function em(text) {
        return "<em>" + text + "</em>";
      };
      _proto.codespan = function codespan(text) {
        return "<code>" + text + "</code>";
      };
      _proto.br = function br() {
        return this.options.xhtml ? "<br/>" : "<br>";
      };
      _proto.del = function del(text) {
        return "<del>" + text + "</del>";
      };
      _proto.link = function link(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        var out = '<a href="' + escape2(href) + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += ">" + text + "</a>";
        return out;
      };
      _proto.image = function image(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        var out = '<img src="' + href + '" alt="' + text + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += this.options.xhtml ? "/>" : ">";
        return out;
      };
      _proto.text = function text(_text) {
        return _text;
      };
      return Renderer3;
    }();
    var TextRenderer2 = function() {
      function TextRenderer3() {
      }
      var _proto = TextRenderer3.prototype;
      _proto.strong = function strong(text) {
        return text;
      };
      _proto.em = function em(text) {
        return text;
      };
      _proto.codespan = function codespan(text) {
        return text;
      };
      _proto.del = function del(text) {
        return text;
      };
      _proto.html = function html(text) {
        return text;
      };
      _proto.text = function text(_text) {
        return _text;
      };
      _proto.link = function link(href, title, text) {
        return "" + text;
      };
      _proto.image = function image(href, title, text) {
        return "" + text;
      };
      _proto.br = function br() {
        return "";
      };
      return TextRenderer3;
    }();
    var Slugger2 = function() {
      function Slugger3() {
        this.seen = {};
      }
      var _proto = Slugger3.prototype;
      _proto.serialize = function serialize(value) {
        return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      };
      _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
        var slug = originalSlug;
        var occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + "-" + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      };
      _proto.slug = function slug(value, options3) {
        if (options3 === void 0) {
          options3 = {};
        }
        var slug2 = this.serialize(value);
        return this.getNextSafeSlug(slug2, options3.dryrun);
      };
      return Slugger3;
    }();
    var Parser4 = function() {
      function Parser5(options3) {
        this.options = options3 || exports2.defaults;
        this.options.renderer = this.options.renderer || new Renderer2();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer2();
        this.slugger = new Slugger2();
      }
      Parser5.parse = function parse5(tokens, options3) {
        var parser3 = new Parser5(options3);
        return parser3.parse(tokens);
      };
      Parser5.parseInline = function parseInline3(tokens, options3) {
        var parser3 = new Parser5(options3);
        return parser3.parseInline(tokens);
      };
      var _proto = Parser5.prototype;
      _proto.parse = function parse5(tokens, top) {
        if (top === void 0) {
          top = true;
        }
        var out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
        var l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({
              parser: this
            }, token);
            if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
              continue;
            }
            case "code": {
              out += this.renderer.code(token.text, token.lang, token.escaped);
              continue;
            }
            case "table": {
              header = "";
              cell = "";
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {
                  header: true,
                  align: token.align[j]
                });
              }
              header += this.renderer.tablerow(cell);
              body = "";
              l2 = token.rows.length;
              for (j = 0; j < l2; j++) {
                row = token.rows[j];
                cell = "";
                l3 = row.length;
                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {
                    header: false,
                    align: token.align[k]
                  });
                }
                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case "blockquote": {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case "list": {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body = "";
              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;
                itemBody = "";
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                      item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }
              out += this.renderer.list(body, ordered, start);
              continue;
            }
            case "html": {
              out += this.renderer.html(token.text);
              continue;
            }
            case "paragraph": {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case "text": {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i + 1 < l && tokens[i + 1].type === "text") {
                token = tokens[++i];
                body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
            default: {
              var errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      };
      _proto.parseInline = function parseInline3(tokens, renderer) {
        renderer = renderer || this.renderer;
        var out = "", i, token, ret;
        var l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({
              parser: this
            }, token);
            if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "escape": {
              out += renderer.text(token.text);
              break;
            }
            case "html": {
              out += renderer.html(token.text);
              break;
            }
            case "link": {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case "image": {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case "strong": {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case "em": {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case "codespan": {
              out += renderer.codespan(token.text);
              break;
            }
            case "br": {
              out += renderer.br();
              break;
            }
            case "del": {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case "text": {
              out += renderer.text(token.text);
              break;
            }
            default: {
              var errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      };
      return Parser5;
    }();
    function marked2(src, opt, callback) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      if (typeof opt === "function") {
        callback = opt;
        opt = null;
      }
      opt = merge({}, marked2.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      if (callback) {
        var highlight = opt.highlight;
        var tokens;
        try {
          tokens = Lexer2.lex(src, opt);
        } catch (e) {
          return callback(e);
        }
        var done = function done2(err) {
          var out;
          if (!err) {
            try {
              if (opt.walkTokens) {
                marked2.walkTokens(tokens, opt.walkTokens);
              }
              out = Parser4.parse(tokens, opt);
            } catch (e) {
              err = e;
            }
          }
          opt.highlight = highlight;
          return err ? callback(err) : callback(null, out);
        };
        if (!highlight || highlight.length < 3) {
          return done();
        }
        delete opt.highlight;
        if (!tokens.length)
          return done();
        var pending = 0;
        marked2.walkTokens(tokens, function(token) {
          if (token.type === "code") {
            pending++;
            setTimeout(function() {
              highlight(token.text, token.lang, function(err, code) {
                if (err) {
                  return done(err);
                }
                if (code != null && code !== token.text) {
                  token.text = code;
                  token.escaped = true;
                }
                pending--;
                if (pending === 0) {
                  done();
                }
              });
            }, 0);
          }
        });
        if (pending === 0) {
          done();
        }
        return;
      }
      function onError(e) {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape2(e.message + "", true) + "</pre>";
        }
        throw e;
      }
      try {
        var _tokens = Lexer2.lex(src, opt);
        if (opt.walkTokens) {
          if (opt.async) {
            return Promise.all(marked2.walkTokens(_tokens, opt.walkTokens)).then(function() {
              return Parser4.parse(_tokens, opt);
            })["catch"](onError);
          }
          marked2.walkTokens(_tokens, opt.walkTokens);
        }
        return Parser4.parse(_tokens, opt);
      } catch (e) {
        onError(e);
      }
    }
    marked2.options = marked2.setOptions = function(opt) {
      merge(marked2.defaults, opt);
      changeDefaults(marked2.defaults);
      return marked2;
    };
    marked2.getDefaults = getDefaults2;
    marked2.defaults = exports2.defaults;
    marked2.use = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var opts = merge.apply(void 0, [{}].concat(args));
      var extensions = marked2.defaults.extensions || {
        renderers: {},
        childTokens: {}
      };
      var hasExtensions;
      args.forEach(function(pack) {
        if (pack.extensions) {
          hasExtensions = true;
          pack.extensions.forEach(function(ext) {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if (ext.renderer) {
              var prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
              if (prevRenderer) {
                extensions.renderers[ext.name] = function() {
                  for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args2[_key2] = arguments[_key2];
                  }
                  var ret = ext.renderer.apply(this, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args2);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if (ext.tokenizer) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              if (extensions[ext.level]) {
                extensions[ext.level].unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if (ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
        }
        if (pack.renderer) {
          (function() {
            var renderer = marked2.defaults.renderer || new Renderer2();
            var _loop = function _loop2(prop2) {
              var prevRenderer = renderer[prop2];
              renderer[prop2] = function() {
                for (var _len3 = arguments.length, args2 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args2[_key3] = arguments[_key3];
                }
                var ret = pack.renderer[prop2].apply(renderer, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(renderer, args2);
                }
                return ret;
              };
            };
            for (var prop in pack.renderer) {
              _loop(prop);
            }
            opts.renderer = renderer;
          })();
        }
        if (pack.tokenizer) {
          (function() {
            var tokenizer = marked2.defaults.tokenizer || new Tokenizer2();
            var _loop2 = function _loop22(prop2) {
              var prevTokenizer = tokenizer[prop2];
              tokenizer[prop2] = function() {
                for (var _len4 = arguments.length, args2 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                  args2[_key4] = arguments[_key4];
                }
                var ret = pack.tokenizer[prop2].apply(tokenizer, args2);
                if (ret === false) {
                  ret = prevTokenizer.apply(tokenizer, args2);
                }
                return ret;
              };
            };
            for (var prop in pack.tokenizer) {
              _loop2(prop);
            }
            opts.tokenizer = tokenizer;
          })();
        }
        if (pack.walkTokens) {
          var _walkTokens = marked2.defaults.walkTokens;
          opts.walkTokens = function(token) {
            var values = [];
            values.push(pack.walkTokens.call(this, token));
            if (_walkTokens) {
              values = values.concat(_walkTokens.call(this, token));
            }
            return values;
          };
        }
        if (hasExtensions) {
          opts.extensions = extensions;
        }
        marked2.setOptions(opts);
      });
    };
    marked2.walkTokens = function(tokens, callback) {
      var values = [];
      var _loop3 = function _loop32() {
        var token = _step.value;
        values = values.concat(callback.call(marked2, token));
        switch (token.type) {
          case "table": {
            for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done; ) {
              var cell = _step2.value;
              values = values.concat(marked2.walkTokens(cell.tokens, callback));
            }
            for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done; ) {
              var row = _step3.value;
              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done; ) {
                var _cell = _step4.value;
                values = values.concat(marked2.walkTokens(_cell.tokens, callback));
              }
            }
            break;
          }
          case "list": {
            values = values.concat(marked2.walkTokens(token.items, callback));
            break;
          }
          default: {
            if (marked2.defaults.extensions && marked2.defaults.extensions.childTokens && marked2.defaults.extensions.childTokens[token.type]) {
              marked2.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
                values = values.concat(marked2.walkTokens(token[childTokens], callback));
              });
            } else if (token.tokens) {
              values = values.concat(marked2.walkTokens(token.tokens, callback));
            }
          }
        }
      };
      for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done; ) {
        _loop3();
      }
      return values;
    };
    marked2.parseInline = function(src, opt) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked.parseInline(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      opt = merge({}, marked2.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      try {
        var tokens = Lexer2.lexInline(src, opt);
        if (opt.walkTokens) {
          marked2.walkTokens(tokens, opt.walkTokens);
        }
        return Parser4.parseInline(tokens, opt);
      } catch (e) {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape2(e.message + "", true) + "</pre>";
        }
        throw e;
      }
    };
    marked2.Parser = Parser4;
    marked2.parser = Parser4.parse;
    marked2.Renderer = Renderer2;
    marked2.TextRenderer = TextRenderer2;
    marked2.Lexer = Lexer2;
    marked2.lexer = Lexer2.lex;
    marked2.Tokenizer = Tokenizer2;
    marked2.Slugger = Slugger2;
    marked2.parse = marked2;
    var options2 = marked2.options;
    var setOptions2 = marked2.setOptions;
    var use2 = marked2.use;
    var walkTokens2 = marked2.walkTokens;
    var parseInline2 = marked2.parseInline;
    var parse4 = marked2;
    var parser2 = Parser4.parse;
    var lexer2 = Lexer2.lex;
    exports2.Lexer = Lexer2;
    exports2.Parser = Parser4;
    exports2.Renderer = Renderer2;
    exports2.Slugger = Slugger2;
    exports2.TextRenderer = TextRenderer2;
    exports2.Tokenizer = Tokenizer2;
    exports2.getDefaults = getDefaults2;
    exports2.lexer = lexer2;
    exports2.marked = marked2;
    exports2.options = options2;
    exports2.parse = parse4;
    exports2.parseInline = parseInline2;
    exports2.parser = parser2;
    exports2.setOptions = setOptions2;
    exports2.use = use2;
    exports2.walkTokens = walkTokens2;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
})();
var Lexer = __marked_exports.Lexer || exports.Lexer;
var Parser2 = __marked_exports.Parser || exports.Parser;
var Renderer = __marked_exports.Renderer || exports.Renderer;
var Slugger = __marked_exports.Slugger || exports.Slugger;
var TextRenderer = __marked_exports.TextRenderer || exports.TextRenderer;
var Tokenizer = __marked_exports.Tokenizer || exports.Tokenizer;
var getDefaults = __marked_exports.getDefaults || exports.getDefaults;
var lexer = __marked_exports.lexer || exports.lexer;
var marked = __marked_exports.marked || exports.marked;
var options = __marked_exports.options || exports.options;
var parse2 = __marked_exports.parse || exports.parse;
var parseInline = __marked_exports.parseInline || exports.parseInline;
var parser = __marked_exports.parser || exports.parser;
var setOptions = __marked_exports.setOptions || exports.setOptions;
var use = __marked_exports.use || exports.use;
var walkTokens = __marked_exports.walkTokens || exports.walkTokens;

// node_modules/monaco-editor/esm/vs/base/common/marshalling.js
init_buffer();
init_uri();
function stringify(obj) {
  return JSON.stringify(obj, replacer);
}
function parse3(text) {
  let data = JSON.parse(text);
  data = revive(data);
  return data;
}
function replacer(key, value) {
  if (value instanceof RegExp) {
    return {
      $mid: 2,
      source: value.source,
      flags: value.flags
    };
  }
  return value;
}
function revive(obj, depth = 0) {
  if (!obj || depth > 200) {
    return obj;
  }
  if (typeof obj === "object") {
    switch (obj.$mid) {
      case 1:
        return URI.revive(obj);
      case 2:
        return new RegExp(obj.source, obj.flags);
      case 17:
        return new Date(obj.source);
    }
    if (obj instanceof VSBuffer || obj instanceof Uint8Array) {
      return obj;
    }
    if (Array.isArray(obj)) {
      for (let i = 0; i < obj.length; ++i) {
        obj[i] = revive(obj[i], depth + 1);
      }
    } else {
      for (const key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) {
          obj[key] = revive(obj[key], depth + 1);
        }
      }
    }
  }
  return obj;
}

// node_modules/monaco-editor/esm/vs/base/browser/markdownRenderer.js
init_network();
init_objects();
init_resources();
init_strings();
init_uri();
var defaultMarkedRenderers = Object.freeze({
  image: (href, title, text) => {
    let dimensions = [];
    let attributes = [];
    if (href) {
      ({ href, dimensions } = parseHrefAndDimensions(href));
      attributes.push(`src="${escapeDoubleQuotes(href)}"`);
    }
    if (text) {
      attributes.push(`alt="${escapeDoubleQuotes(text)}"`);
    }
    if (title) {
      attributes.push(`title="${escapeDoubleQuotes(title)}"`);
    }
    if (dimensions.length) {
      attributes = attributes.concat(dimensions);
    }
    return "<img " + attributes.join(" ") + ">";
  },
  paragraph: (text) => {
    return `<p>${text}</p>`;
  },
  link: (href, title, text) => {
    if (typeof href !== "string") {
      return "";
    }
    if (href === text) {
      text = removeMarkdownEscapes(text);
    }
    title = typeof title === "string" ? escapeDoubleQuotes(removeMarkdownEscapes(title)) : "";
    href = removeMarkdownEscapes(href);
    href = href.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
    return `<a href="${href}" title="${title || href}" draggable="false">${text}</a>`;
  }
});
function renderMarkdown(markdown, options2 = {}, markedOptions = {}) {
  var _a2, _b2;
  const disposables = new DisposableStore();
  let isDisposed = false;
  const element = createElement(options2);
  const _uriMassage = function(part) {
    let data;
    try {
      data = parse3(decodeURIComponent(part));
    } catch (e) {
    }
    if (!data) {
      return part;
    }
    data = cloneAndChange(data, (value2) => {
      if (markdown.uris && markdown.uris[value2]) {
        return URI.revive(markdown.uris[value2]);
      } else {
        return void 0;
      }
    });
    return encodeURIComponent(JSON.stringify(data));
  };
  const _href = function(href, isDomUri) {
    const data = markdown.uris && markdown.uris[href];
    let uri = URI.revive(data);
    if (isDomUri) {
      if (href.startsWith(Schemas.data + ":")) {
        return href;
      }
      if (!uri) {
        uri = URI.parse(href);
      }
      return FileAccess.uriToBrowserUri(uri).toString(true);
    }
    if (!uri) {
      return href;
    }
    if (URI.parse(href).toString() === uri.toString()) {
      return href;
    }
    if (uri.query) {
      uri = uri.with({ query: _uriMassage(uri.query) });
    }
    return uri.toString();
  };
  const renderer = new marked.Renderer();
  renderer.image = defaultMarkedRenderers.image;
  renderer.link = defaultMarkedRenderers.link;
  renderer.paragraph = defaultMarkedRenderers.paragraph;
  const codeBlocks = [];
  const syncCodeBlocks = [];
  if (options2.codeBlockRendererSync) {
    renderer.code = (code, lang) => {
      const id = defaultGenerator.nextId();
      const value2 = options2.codeBlockRendererSync(postProcessCodeBlockLanguageId(lang), code);
      syncCodeBlocks.push([id, value2]);
      return `<div class="code" data-code="${id}">${escape(code)}</div>`;
    };
  } else if (options2.codeBlockRenderer) {
    renderer.code = (code, lang) => {
      const id = defaultGenerator.nextId();
      const value2 = options2.codeBlockRenderer(postProcessCodeBlockLanguageId(lang), code);
      codeBlocks.push(value2.then((element2) => [id, element2]));
      return `<div class="code" data-code="${id}">${escape(code)}</div>`;
    };
  }
  if (options2.actionHandler) {
    const _activateLink = function(event) {
      let target = event.target;
      if (target.tagName !== "A") {
        target = target.parentElement;
        if (!target || target.tagName !== "A") {
          return;
        }
      }
      try {
        let href = target.dataset["href"];
        if (href) {
          if (markdown.baseUri) {
            href = resolveWithBaseUri(URI.from(markdown.baseUri), href);
          }
          options2.actionHandler.callback(href, event);
        }
      } catch (err) {
        onUnexpectedError(err);
      } finally {
        event.preventDefault();
      }
    };
    const onClick = options2.actionHandler.disposables.add(new DomEmitter(element, "click"));
    const onAuxClick = options2.actionHandler.disposables.add(new DomEmitter(element, "auxclick"));
    options2.actionHandler.disposables.add(Event.any(onClick.event, onAuxClick.event)((e) => {
      const mouseEvent = new StandardMouseEvent(getWindow(element), e);
      if (!mouseEvent.leftButton && !mouseEvent.middleButton) {
        return;
      }
      _activateLink(mouseEvent);
    }));
    options2.actionHandler.disposables.add(addDisposableListener(element, "keydown", (e) => {
      const keyboardEvent = new StandardKeyboardEvent(e);
      if (!keyboardEvent.equals(
        10
        /* KeyCode.Space */
      ) && !keyboardEvent.equals(
        3
        /* KeyCode.Enter */
      )) {
        return;
      }
      _activateLink(keyboardEvent);
    }));
  }
  if (!markdown.supportHtml) {
    markedOptions.sanitizer = (html) => {
      const match2 = markdown.isTrusted ? html.match(/^(<span[^>]+>)|(<\/\s*span>)$/) : void 0;
      return match2 ? html : "";
    };
    markedOptions.sanitize = true;
    markedOptions.silent = true;
  }
  markedOptions.renderer = renderer;
  let value = (_a2 = markdown.value) !== null && _a2 !== void 0 ? _a2 : "";
  if (value.length > 1e5) {
    value = `${value.substr(0, 1e5)}`;
  }
  if (markdown.supportThemeIcons) {
    value = markdownEscapeEscapedIcons(value);
  }
  let renderedMarkdown;
  if (options2.fillInIncompleteTokens) {
    const opts = {
      ...marked.defaults,
      ...markedOptions
    };
    const tokens = marked.lexer(value, opts);
    const newTokens = fillInIncompleteTokens(tokens);
    renderedMarkdown = marked.parser(newTokens, opts);
  } else {
    renderedMarkdown = marked.parse(value, markedOptions);
  }
  if (markdown.supportThemeIcons) {
    const elements = renderLabelWithIcons(renderedMarkdown);
    renderedMarkdown = elements.map((e) => typeof e === "string" ? e : e.outerHTML).join("");
  }
  const htmlParser = new DOMParser();
  const markdownHtmlDoc = htmlParser.parseFromString(sanitizeRenderedMarkdown(markdown, renderedMarkdown), "text/html");
  markdownHtmlDoc.body.querySelectorAll("img").forEach((img) => {
    const src = img.getAttribute("src");
    if (src) {
      let href = src;
      try {
        if (markdown.baseUri) {
          href = resolveWithBaseUri(URI.from(markdown.baseUri), href);
        }
      } catch (err) {
      }
      img.src = _href(href, true);
    }
  });
  markdownHtmlDoc.body.querySelectorAll("a").forEach((a) => {
    const href = a.getAttribute("href");
    a.setAttribute("href", "");
    if (!href || /^data:|javascript:/i.test(href) || /^command:/i.test(href) && !markdown.isTrusted || /^command:(\/\/\/)?_workbench\.downloadResource/i.test(href)) {
      a.replaceWith(...a.childNodes);
    } else {
      let resolvedHref = _href(href, false);
      if (markdown.baseUri) {
        resolvedHref = resolveWithBaseUri(URI.from(markdown.baseUri), href);
      }
      a.dataset.href = resolvedHref;
    }
  });
  element.innerHTML = sanitizeRenderedMarkdown(markdown, markdownHtmlDoc.body.innerHTML);
  if (codeBlocks.length > 0) {
    Promise.all(codeBlocks).then((tuples) => {
      var _a3, _b3;
      if (isDisposed) {
        return;
      }
      const renderedElements = new Map(tuples);
      const placeholderElements = element.querySelectorAll(`div[data-code]`);
      for (const placeholderElement of placeholderElements) {
        const renderedElement = renderedElements.get((_a3 = placeholderElement.dataset["code"]) !== null && _a3 !== void 0 ? _a3 : "");
        if (renderedElement) {
          reset(placeholderElement, renderedElement);
        }
      }
      (_b3 = options2.asyncRenderCallback) === null || _b3 === void 0 ? void 0 : _b3.call(options2);
    });
  } else if (syncCodeBlocks.length > 0) {
    const renderedElements = new Map(syncCodeBlocks);
    const placeholderElements = element.querySelectorAll(`div[data-code]`);
    for (const placeholderElement of placeholderElements) {
      const renderedElement = renderedElements.get((_b2 = placeholderElement.dataset["code"]) !== null && _b2 !== void 0 ? _b2 : "");
      if (renderedElement) {
        reset(placeholderElement, renderedElement);
      }
    }
  }
  if (options2.asyncRenderCallback) {
    for (const img of element.getElementsByTagName("img")) {
      const listener = disposables.add(addDisposableListener(img, "load", () => {
        listener.dispose();
        options2.asyncRenderCallback();
      }));
    }
  }
  return {
    element,
    dispose: () => {
      isDisposed = true;
      disposables.dispose();
    }
  };
}
function postProcessCodeBlockLanguageId(lang) {
  if (!lang) {
    return "";
  }
  const parts = lang.split(/[\s+|:|,|\{|\?]/, 1);
  if (parts.length) {
    return parts[0];
  }
  return lang;
}
function resolveWithBaseUri(baseUri, href) {
  const hasScheme = /^\w[\w\d+.-]*:/.test(href);
  if (hasScheme) {
    return href;
  }
  if (baseUri.path.endsWith("/")) {
    return resolvePath(baseUri, href).toString();
  } else {
    return resolvePath(dirname2(baseUri), href).toString();
  }
}
function sanitizeRenderedMarkdown(options2, renderedMarkdown) {
  const { config, allowedSchemes } = getSanitizerOptions(options2);
  addHook("uponSanitizeAttribute", (element, e) => {
    var _a2;
    if (e.attrName === "style" || e.attrName === "class") {
      if (element.tagName === "SPAN") {
        if (e.attrName === "style") {
          e.keepAttr = /^(color\:(#[0-9a-fA-F]+|var\(--vscode(-[a-zA-Z]+)+\));)?(background-color\:(#[0-9a-fA-F]+|var\(--vscode(-[a-zA-Z]+)+\));)?$/.test(e.attrValue);
          return;
        } else if (e.attrName === "class") {
          e.keepAttr = /^codicon codicon-[a-z\-]+( codicon-modifier-[a-z\-]+)?$/.test(e.attrValue);
          return;
        }
      }
      e.keepAttr = false;
      return;
    } else if (element.tagName === "INPUT" && ((_a2 = element.attributes.getNamedItem("type")) === null || _a2 === void 0 ? void 0 : _a2.value) === "checkbox") {
      if (e.attrName === "type" && e.attrValue === "checkbox" || e.attrName === "disabled" || e.attrName === "checked") {
        e.keepAttr = true;
        return;
      }
      e.keepAttr = false;
    }
  });
  addHook("uponSanitizeElement", (element, e) => {
    var _a2, _b2;
    if (e.tagName === "input") {
      if (((_a2 = element.attributes.getNamedItem("type")) === null || _a2 === void 0 ? void 0 : _a2.value) === "checkbox") {
        element.setAttribute("disabled", "");
      } else {
        (_b2 = element.parentElement) === null || _b2 === void 0 ? void 0 : _b2.removeChild(element);
      }
    }
  });
  const hook = hookDomPurifyHrefAndSrcSanitizer(allowedSchemes);
  try {
    return sanitize(renderedMarkdown, { ...config, RETURN_TRUSTED_TYPE: true });
  } finally {
    removeHook("uponSanitizeAttribute");
    hook.dispose();
  }
}
var allowedMarkdownAttr = [
  "align",
  "autoplay",
  "alt",
  "checked",
  "class",
  "controls",
  "data-code",
  "data-href",
  "disabled",
  "draggable",
  "height",
  "href",
  "loop",
  "muted",
  "playsinline",
  "poster",
  "src",
  "style",
  "target",
  "title",
  "type",
  "width",
  "start"
];
function getSanitizerOptions(options2) {
  const allowedSchemes = [
    Schemas.http,
    Schemas.https,
    Schemas.mailto,
    Schemas.data,
    Schemas.file,
    Schemas.vscodeFileResource,
    Schemas.vscodeRemote,
    Schemas.vscodeRemoteResource
  ];
  if (options2.isTrusted) {
    allowedSchemes.push(Schemas.command);
  }
  return {
    config: {
      // allowedTags should included everything that markdown renders to.
      // Since we have our own sanitize function for marked, it's possible we missed some tag so let dompurify make sure.
      // HTML tags that can result from markdown are from reading https://spec.commonmark.org/0.29/
      // HTML table tags that can result from markdown are from https://github.github.com/gfm/#tables-extension-
      ALLOWED_TAGS: [...basicMarkupHtmlTags],
      ALLOWED_ATTR: allowedMarkdownAttr,
      ALLOW_UNKNOWN_PROTOCOLS: true
    },
    allowedSchemes
  };
}
function renderStringAsPlaintext(string) {
  return typeof string === "string" ? string : renderMarkdownAsPlaintext(string);
}
function renderMarkdownAsPlaintext(markdown) {
  var _a2;
  let value = (_a2 = markdown.value) !== null && _a2 !== void 0 ? _a2 : "";
  if (value.length > 1e5) {
    value = `${value.substr(0, 1e5)}`;
  }
  const html = marked.parse(value, { renderer: plainTextRenderer.value }).replace(/&(#\d+|[a-zA-Z]+);/g, (m) => {
    var _a3;
    return (_a3 = unescapeInfo.get(m)) !== null && _a3 !== void 0 ? _a3 : m;
  });
  return sanitizeRenderedMarkdown({ isTrusted: false }, html).toString();
}
var unescapeInfo = /* @__PURE__ */ new Map([
  ["&quot;", '"'],
  ["&nbsp;", " "],
  ["&amp;", "&"],
  ["&#39;", "'"],
  ["&lt;", "<"],
  ["&gt;", ">"]
]);
var plainTextRenderer = new Lazy(() => {
  const renderer = new marked.Renderer();
  renderer.code = (code) => {
    return code;
  };
  renderer.blockquote = (quote) => {
    return quote;
  };
  renderer.html = (_html) => {
    return "";
  };
  renderer.heading = (text, _level, _raw) => {
    return text + "\n";
  };
  renderer.hr = () => {
    return "";
  };
  renderer.list = (body, _ordered) => {
    return body;
  };
  renderer.listitem = (text) => {
    return text + "\n";
  };
  renderer.paragraph = (text) => {
    return text + "\n";
  };
  renderer.table = (header, body) => {
    return header + body + "\n";
  };
  renderer.tablerow = (content) => {
    return content;
  };
  renderer.tablecell = (content, _flags) => {
    return content + " ";
  };
  renderer.strong = (text) => {
    return text;
  };
  renderer.em = (text) => {
    return text;
  };
  renderer.codespan = (code) => {
    return code;
  };
  renderer.br = () => {
    return "\n";
  };
  renderer.del = (text) => {
    return text;
  };
  renderer.image = (_href, _title, _text) => {
    return "";
  };
  renderer.text = (text) => {
    return text;
  };
  renderer.link = (_href, _title, text) => {
    return text;
  };
  return renderer;
});
function mergeRawTokenText(tokens) {
  let mergedTokenText = "";
  tokens.forEach((token) => {
    mergedTokenText += token.raw;
  });
  return mergedTokenText;
}
function completeSingleLinePattern(token) {
  var _a2, _b2;
  for (let i = 0; i < token.tokens.length; i++) {
    const subtoken = token.tokens[i];
    if (subtoken.type === "text") {
      const lines = subtoken.raw.split("\n");
      const lastLine = lines[lines.length - 1];
      if (lastLine.includes("`")) {
        return completeCodespan(token);
      } else if (lastLine.includes("**")) {
        return completeDoublestar(token);
      } else if (lastLine.match(/\*\w/)) {
        return completeStar(token);
      } else if (lastLine.match(/(^|\s)__\w/)) {
        return completeDoubleUnderscore(token);
      } else if (lastLine.match(/(^|\s)_\w/)) {
        return completeUnderscore(token);
      } else if (lastLine.match(/(^|\s)\[.*\]\(\w*/)) {
        const nextTwoSubTokens = token.tokens.slice(i + 1);
        if (((_a2 = nextTwoSubTokens[0]) === null || _a2 === void 0 ? void 0 : _a2.type) === "link" && ((_b2 = nextTwoSubTokens[1]) === null || _b2 === void 0 ? void 0 : _b2.type) === "text" && nextTwoSubTokens[1].raw.match(/^ *"[^"]*$/)) {
          return completeLinkTargetArg(token);
        }
        return completeLinkTarget(token);
      } else if (hasStartOfLinkTarget(lastLine)) {
        return completeLinkTarget(token);
      } else if (lastLine.match(/(^|\s)\[\w/) && !token.tokens.slice(i + 1).some((t) => hasStartOfLinkTarget(t.raw))) {
        return completeLinkText(token);
      }
    }
  }
  return void 0;
}
function hasStartOfLinkTarget(str) {
  return !!str.match(/^[^\[]*\]\([^\)]*$/);
}
function fillInIncompleteTokens(tokens) {
  let i;
  let newTokens;
  for (i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    let codeblockStart;
    if (token.type === "paragraph" && (codeblockStart = token.raw.match(/(\n|^)(````*)/))) {
      const codeblockLead = codeblockStart[2];
      newTokens = completeCodeBlock(tokens.slice(i), codeblockLead);
      break;
    }
    if (token.type === "paragraph" && token.raw.match(/(\n|^)\|/)) {
      newTokens = completeTable(tokens.slice(i));
      break;
    }
    if (i === tokens.length - 1 && token.type === "paragraph") {
      const newToken = completeSingleLinePattern(token);
      if (newToken) {
        newTokens = [newToken];
        break;
      }
    }
  }
  if (newTokens) {
    const newTokensList = [
      ...tokens.slice(0, i),
      ...newTokens
    ];
    newTokensList.links = tokens.links;
    return newTokensList;
  }
  return tokens;
}
function completeCodeBlock(tokens, leader) {
  const mergedRawText = mergeRawTokenText(tokens);
  return marked.lexer(mergedRawText + `
${leader}`);
}
function completeCodespan(token) {
  return completeWithString(token, "`");
}
function completeStar(tokens) {
  return completeWithString(tokens, "*");
}
function completeUnderscore(tokens) {
  return completeWithString(tokens, "_");
}
function completeLinkTarget(tokens) {
  return completeWithString(tokens, ")");
}
function completeLinkTargetArg(tokens) {
  return completeWithString(tokens, '")');
}
function completeLinkText(tokens) {
  return completeWithString(tokens, "](about:blank)");
}
function completeDoublestar(tokens) {
  return completeWithString(tokens, "**");
}
function completeDoubleUnderscore(tokens) {
  return completeWithString(tokens, "__");
}
function completeWithString(tokens, closingString) {
  const mergedRawText = mergeRawTokenText(Array.isArray(tokens) ? tokens : [tokens]);
  return marked.lexer(mergedRawText + closingString)[0];
}
function completeTable(tokens) {
  const mergedRawText = mergeRawTokenText(tokens);
  const lines = mergedRawText.split("\n");
  let numCols;
  let hasSeparatorRow = false;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (typeof numCols === "undefined" && line.match(/^\s*\|/)) {
      const line1Matches = line.match(/(\|[^\|]+)(?=\||$)/g);
      if (line1Matches) {
        numCols = line1Matches.length;
      }
    } else if (typeof numCols === "number") {
      if (line.match(/^\s*\|/)) {
        if (i !== lines.length - 1) {
          return void 0;
        }
        hasSeparatorRow = true;
      } else {
        return void 0;
      }
    }
  }
  if (typeof numCols === "number" && numCols > 0) {
    const prefixText = hasSeparatorRow ? lines.slice(0, -1).join("\n") : mergedRawText;
    const line1EndsInPipe = !!prefixText.match(/\|\s*$/);
    const newRawText = prefixText + (line1EndsInPipe ? "" : "|") + `
|${" --- |".repeat(numCols)}`;
    return marked.lexer(newRawText);
  }
  return void 0;
}

// node_modules/monaco-editor/esm/vs/base/browser/trustedTypes.js
init_window();
init_errors();
function createTrustedTypesPolicy(policyName, policyOptions) {
  var _a2;
  const monacoEnvironment = globalThis.MonacoEnvironment;
  if (monacoEnvironment === null || monacoEnvironment === void 0 ? void 0 : monacoEnvironment.createTrustedTypesPolicy) {
    try {
      return monacoEnvironment.createTrustedTypesPolicy(policyName, policyOptions);
    } catch (err) {
      onUnexpectedError(err);
      return void 0;
    }
  }
  try {
    return (_a2 = mainWindow.trustedTypes) === null || _a2 === void 0 ? void 0 : _a2.createPolicy(policyName, policyOptions);
  } catch (err) {
    onUnexpectedError(err);
    return void 0;
  }
}

// node_modules/monaco-editor/esm/vs/editor/browser/widget/markdownRenderer/browser/markdownRenderer.js
init_errors();
init_event();
init_lifecycle();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/editor/browser/widget/markdownRenderer/browser/renderedMarkdown.css";

// node_modules/monaco-editor/esm/vs/editor/browser/config/domFontInfo.js
function applyFontInfo(domNode, fontInfo) {
  if (domNode instanceof FastDomNode) {
    domNode.setFontFamily(fontInfo.getMassagedFontFamily());
    domNode.setFontWeight(fontInfo.fontWeight);
    domNode.setFontSize(fontInfo.fontSize);
    domNode.setFontFeatureSettings(fontInfo.fontFeatureSettings);
    domNode.setFontVariationSettings(fontInfo.fontVariationSettings);
    domNode.setLineHeight(fontInfo.lineHeight);
    domNode.setLetterSpacing(fontInfo.letterSpacing);
  } else {
    domNode.style.fontFamily = fontInfo.getMassagedFontFamily();
    domNode.style.fontWeight = fontInfo.fontWeight;
    domNode.style.fontSize = fontInfo.fontSize + "px";
    domNode.style.fontFeatureSettings = fontInfo.fontFeatureSettings;
    domNode.style.fontVariationSettings = fontInfo.fontVariationSettings;
    domNode.style.lineHeight = fontInfo.lineHeight + "px";
    domNode.style.letterSpacing = fontInfo.letterSpacing + "px";
  }
}

// node_modules/monaco-editor/esm/vs/editor/browser/widget/markdownRenderer/browser/markdownRenderer.js
init_language();
init_modesRegistry();

// node_modules/monaco-editor/esm/vs/editor/common/languages/textToHtmlTokenizer.js
init_strings();
init_lineTokens();
init_languages();
init_nullTokenize();
var fallback = {
  getInitialState: () => NullState,
  tokenizeEncoded: (buffer, hasEOL, state) => nullTokenizeEncoded(0, state)
};
async function tokenizeToString(languageService, text, languageId) {
  if (!languageId) {
    return _tokenizeToString(text, languageService.languageIdCodec, fallback);
  }
  const tokenizationSupport = await TokenizationRegistry2.getOrCreate(languageId);
  return _tokenizeToString(text, languageService.languageIdCodec, tokenizationSupport || fallback);
}
function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {
  let result = `<div>`;
  let charIndex = startOffset;
  let tabsCharDelta = 0;
  let prevIsSpace = true;
  for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {
    const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);
    if (tokenEndIndex <= startOffset) {
      continue;
    }
    let partContent = "";
    for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {
      const charCode = text.charCodeAt(charIndex);
      switch (charCode) {
        case 9: {
          let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;
          tabsCharDelta += insertSpacesCount - 1;
          while (insertSpacesCount > 0) {
            if (useNbsp && prevIsSpace) {
              partContent += "&#160;";
              prevIsSpace = false;
            } else {
              partContent += " ";
              prevIsSpace = true;
            }
            insertSpacesCount--;
          }
          break;
        }
        case 60:
          partContent += "&lt;";
          prevIsSpace = false;
          break;
        case 62:
          partContent += "&gt;";
          prevIsSpace = false;
          break;
        case 38:
          partContent += "&amp;";
          prevIsSpace = false;
          break;
        case 0:
          partContent += "&#00;";
          prevIsSpace = false;
          break;
        case 65279:
        case 8232:
        case 8233:
        case 133:
          partContent += "";
          prevIsSpace = false;
          break;
        case 13:
          partContent += "&#8203";
          prevIsSpace = false;
          break;
        case 32:
          if (useNbsp && prevIsSpace) {
            partContent += "&#160;";
            prevIsSpace = false;
          } else {
            partContent += " ";
            prevIsSpace = true;
          }
          break;
        default:
          partContent += String.fromCharCode(charCode);
          prevIsSpace = false;
      }
    }
    result += `<span style="${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}">${partContent}</span>`;
    if (tokenEndIndex > endOffset || charIndex >= endOffset) {
      break;
    }
  }
  result += `</div>`;
  return result;
}
function _tokenizeToString(text, languageIdCodec, tokenizationSupport) {
  let result = `<div class="monaco-tokenized-source">`;
  const lines = splitLines(text);
  let currentState = tokenizationSupport.getInitialState();
  for (let i = 0, len = lines.length; i < len; i++) {
    const line = lines[i];
    if (i > 0) {
      result += `<br/>`;
    }
    const tokenizationResult = tokenizationSupport.tokenizeEncoded(line, true, currentState);
    LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);
    const lineTokens = new LineTokens(tokenizationResult.tokens, line, languageIdCodec);
    const viewLineTokens = lineTokens.inflate();
    let startOffset = 0;
    for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {
      const type = viewLineTokens.getClassName(j);
      const endIndex = viewLineTokens.getEndOffset(j);
      result += `<span class="${type}">${escape(line.substring(startOffset, endIndex))}</span>`;
      startOffset = endIndex;
    }
    currentState = tokenizationResult.endState;
  }
  result += `</div>`;
  return result;
}

// node_modules/monaco-editor/esm/vs/editor/browser/widget/markdownRenderer/browser/markdownRenderer.js
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param10 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MarkdownRenderer_1;
var MarkdownRenderer = MarkdownRenderer_1 = class MarkdownRenderer2 {
  constructor(_options, _languageService, _openerService) {
    this._options = _options;
    this._languageService = _languageService;
    this._openerService = _openerService;
    this._onDidRenderAsync = new Emitter();
    this.onDidRenderAsync = this._onDidRenderAsync.event;
  }
  dispose() {
    this._onDidRenderAsync.dispose();
  }
  render(markdown, options2, markedOptions) {
    if (!markdown) {
      const element = document.createElement("span");
      return { element, dispose: () => {
      } };
    }
    const disposables = new DisposableStore();
    const rendered = disposables.add(renderMarkdown(markdown, { ...this._getRenderOptions(markdown, disposables), ...options2 }, markedOptions));
    rendered.element.classList.add("rendered-markdown");
    return {
      element: rendered.element,
      dispose: () => disposables.dispose()
    };
  }
  _getRenderOptions(markdown, disposables) {
    return {
      codeBlockRenderer: async (languageAlias, value) => {
        var _a2, _b2, _c;
        let languageId;
        if (languageAlias) {
          languageId = this._languageService.getLanguageIdByLanguageName(languageAlias);
        } else if (this._options.editor) {
          languageId = (_a2 = this._options.editor.getModel()) === null || _a2 === void 0 ? void 0 : _a2.getLanguageId();
        }
        if (!languageId) {
          languageId = PLAINTEXT_LANGUAGE_ID;
        }
        const html = await tokenizeToString(this._languageService, value, languageId);
        const element = document.createElement("span");
        element.innerHTML = (_c = (_b2 = MarkdownRenderer_1._ttpTokenizer) === null || _b2 === void 0 ? void 0 : _b2.createHTML(html)) !== null && _c !== void 0 ? _c : html;
        if (this._options.editor) {
          const fontInfo = this._options.editor.getOption(
            50
            /* EditorOption.fontInfo */
          );
          applyFontInfo(element, fontInfo);
        } else if (this._options.codeBlockFontFamily) {
          element.style.fontFamily = this._options.codeBlockFontFamily;
        }
        if (this._options.codeBlockFontSize !== void 0) {
          element.style.fontSize = this._options.codeBlockFontSize;
        }
        return element;
      },
      asyncRenderCallback: () => this._onDidRenderAsync.fire(),
      actionHandler: {
        callback: (link) => openLinkFromMarkdown(this._openerService, link, markdown.isTrusted),
        disposables
      }
    };
  }
};
MarkdownRenderer._ttpTokenizer = createTrustedTypesPolicy("tokenizeToString", {
  createHTML(html) {
    return html;
  }
});
MarkdownRenderer = MarkdownRenderer_1 = __decorate11([
  __param10(1, ILanguageService),
  __param10(2, IOpenerService)
], MarkdownRenderer);
async function openLinkFromMarkdown(openerService, link, isTrusted) {
  try {
    return await openerService.open(link, {
      fromUserGesture: true,
      allowContributedOpeners: true,
      allowCommands: toAllowCommandsOption(isTrusted)
    });
  } catch (e) {
    onUnexpectedError(e);
    return false;
  }
}
function toAllowCommandsOption(isTrusted) {
  if (isTrusted === true) {
    return true;
  }
  if (isTrusted && Array.isArray(isTrusted.enabledCommands)) {
    return isTrusted.enabledCommands;
  }
  return false;
}

// node_modules/monaco-editor/esm/vs/editor/browser/widget/hoverWidget/hoverWidget.js
init_htmlContent();
init_nls();
init_platform();

// node_modules/monaco-editor/esm/vs/platform/accessibility/common/accessibility.js
init_contextkey();
init_instantiation();
var IAccessibilityService = createDecorator("accessibilityService");
var CONTEXT_ACCESSIBILITY_MODE_ENABLED = new RawContextKey("accessibilityModeEnabled", false);

// node_modules/monaco-editor/esm/vs/base/browser/ui/aria/aria.js
init_dom();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/aria/aria.css";
var MAX_MESSAGE_LENGTH = 2e4;
var ariaContainer;
var alertContainer;
var alertContainer2;
var statusContainer;
var statusContainer2;
function setARIAContainer(parent) {
  ariaContainer = document.createElement("div");
  ariaContainer.className = "monaco-aria-container";
  const createAlertContainer = () => {
    const element = document.createElement("div");
    element.className = "monaco-alert";
    element.setAttribute("role", "alert");
    element.setAttribute("aria-atomic", "true");
    ariaContainer.appendChild(element);
    return element;
  };
  alertContainer = createAlertContainer();
  alertContainer2 = createAlertContainer();
  const createStatusContainer = () => {
    const element = document.createElement("div");
    element.className = "monaco-status";
    element.setAttribute("aria-live", "polite");
    element.setAttribute("aria-atomic", "true");
    ariaContainer.appendChild(element);
    return element;
  };
  statusContainer = createStatusContainer();
  statusContainer2 = createStatusContainer();
  parent.appendChild(ariaContainer);
}
function alert(msg) {
  if (!ariaContainer) {
    return;
  }
  if (alertContainer.textContent !== msg) {
    clearNode(alertContainer2);
    insertMessage(alertContainer, msg);
  } else {
    clearNode(alertContainer);
    insertMessage(alertContainer2, msg);
  }
}
function status(msg) {
  if (!ariaContainer) {
    return;
  }
  if (statusContainer.textContent !== msg) {
    clearNode(statusContainer2);
    insertMessage(statusContainer, msg);
  } else {
    clearNode(statusContainer);
    insertMessage(statusContainer2, msg);
  }
}
function insertMessage(target, msg) {
  clearNode(target);
  if (msg.length > MAX_MESSAGE_LENGTH) {
    msg = msg.substr(0, MAX_MESSAGE_LENGTH);
  }
  target.textContent = msg;
  target.style.visibility = "hidden";
  target.style.visibility = "visible";
}

// node_modules/monaco-editor/esm/vs/editor/browser/widget/hoverWidget/hoverWidget.js
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param11 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var $3 = $;
var HoverWidget2 = class HoverWidget3 extends Widget {
  get _targetWindow() {
    return getWindow(this._target.targetElements[0]);
  }
  get _targetDocumentElement() {
    return getWindow(this._target.targetElements[0]).document.documentElement;
  }
  get isDisposed() {
    return this._isDisposed;
  }
  get isMouseIn() {
    return this._lockMouseTracker.isMouseIn;
  }
  get domNode() {
    return this._hover.containerDomNode;
  }
  get onDispose() {
    return this._onDispose.event;
  }
  get onRequestLayout() {
    return this._onRequestLayout.event;
  }
  get anchor() {
    return this._hoverPosition === 2 ? 0 : 1;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  /**
   * Whether the hover is "locked" by holding the alt/option key. When locked, the hover will not
   * hide and can be hovered regardless of whether the `hideOnHover` hover option is set.
   */
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(value) {
    if (this._isLocked === value) {
      return;
    }
    this._isLocked = value;
    this._hoverContainer.classList.toggle("locked", this._isLocked);
  }
  constructor(options2, _keybindingService, _configurationService, _openerService, _instantiationService, _accessibilityService) {
    var _a2, _b2, _c, _d, _e, _f, _g, _h;
    super();
    this._keybindingService = _keybindingService;
    this._configurationService = _configurationService;
    this._openerService = _openerService;
    this._instantiationService = _instantiationService;
    this._accessibilityService = _accessibilityService;
    this._messageListeners = new DisposableStore();
    this._isDisposed = false;
    this._forcePosition = false;
    this._x = 0;
    this._y = 0;
    this._isLocked = false;
    this._enableFocusTraps = false;
    this._addedFocusTrap = false;
    this._onDispose = this._register(new Emitter());
    this._onRequestLayout = this._register(new Emitter());
    this._linkHandler = options2.linkHandler || ((url) => {
      return openLinkFromMarkdown(this._openerService, url, isMarkdownString(options2.content) ? options2.content.isTrusted : void 0);
    });
    this._target = "targetElements" in options2.target ? options2.target : new ElementHoverTarget(options2.target);
    this._hoverPointer = ((_a2 = options2.appearance) === null || _a2 === void 0 ? void 0 : _a2.showPointer) ? $3("div.workbench-hover-pointer") : void 0;
    this._hover = this._register(new HoverWidget());
    this._hover.containerDomNode.classList.add("workbench-hover", "fadeIn");
    if ((_b2 = options2.appearance) === null || _b2 === void 0 ? void 0 : _b2.compact) {
      this._hover.containerDomNode.classList.add("workbench-hover", "compact");
    }
    if ((_c = options2.appearance) === null || _c === void 0 ? void 0 : _c.skipFadeInAnimation) {
      this._hover.containerDomNode.classList.add("skip-fade-in");
    }
    if (options2.additionalClasses) {
      this._hover.containerDomNode.classList.add(...options2.additionalClasses);
    }
    if ((_d = options2.position) === null || _d === void 0 ? void 0 : _d.forcePosition) {
      this._forcePosition = true;
    }
    if (options2.trapFocus) {
      this._enableFocusTraps = true;
    }
    this._hoverPosition = (_f = (_e = options2.position) === null || _e === void 0 ? void 0 : _e.hoverPosition) !== null && _f !== void 0 ? _f : 3;
    this.onmousedown(this._hover.containerDomNode, (e) => e.stopPropagation());
    this.onkeydown(this._hover.containerDomNode, (e) => {
      if (e.equals(
        9
        /* KeyCode.Escape */
      )) {
        this.dispose();
      }
    });
    this._register(addDisposableListener(this._targetWindow, "blur", () => this.dispose()));
    const rowElement = $3("div.hover-row.markdown-hover");
    const contentsElement = $3("div.hover-contents");
    if (typeof options2.content === "string") {
      contentsElement.textContent = options2.content;
      contentsElement.style.whiteSpace = "pre-wrap";
    } else if (options2.content instanceof HTMLElement) {
      contentsElement.appendChild(options2.content);
      contentsElement.classList.add("html-hover-contents");
    } else {
      const markdown = options2.content;
      const mdRenderer = this._instantiationService.createInstance(MarkdownRenderer, { codeBlockFontFamily: this._configurationService.getValue("editor").fontFamily || EDITOR_FONT_DEFAULTS.fontFamily });
      const { element } = mdRenderer.render(markdown, {
        actionHandler: {
          callback: (content) => this._linkHandler(content),
          disposables: this._messageListeners
        },
        asyncRenderCallback: () => {
          contentsElement.classList.add("code-hover-contents");
          this.layout();
          this._onRequestLayout.fire();
        }
      });
      contentsElement.appendChild(element);
    }
    rowElement.appendChild(contentsElement);
    this._hover.contentsDomNode.appendChild(rowElement);
    if (options2.actions && options2.actions.length > 0) {
      const statusBarElement = $3("div.hover-row.status-bar");
      const actionsElement = $3("div.actions");
      options2.actions.forEach((action) => {
        const keybinding = this._keybindingService.lookupKeybinding(action.commandId);
        const keybindingLabel = keybinding ? keybinding.getLabel() : null;
        HoverAction.render(actionsElement, {
          label: action.label,
          commandId: action.commandId,
          run: (e) => {
            action.run(e);
            this.dispose();
          },
          iconClass: action.iconClass
        }, keybindingLabel);
      });
      statusBarElement.appendChild(actionsElement);
      this._hover.containerDomNode.appendChild(statusBarElement);
    }
    this._hoverContainer = $3("div.workbench-hover-container");
    if (this._hoverPointer) {
      this._hoverContainer.appendChild(this._hoverPointer);
    }
    this._hoverContainer.appendChild(this._hover.containerDomNode);
    let hideOnHover;
    if (options2.actions && options2.actions.length > 0) {
      hideOnHover = false;
    } else {
      if (((_g = options2.persistence) === null || _g === void 0 ? void 0 : _g.hideOnHover) === void 0) {
        hideOnHover = typeof options2.content === "string" || isMarkdownString(options2.content) && !options2.content.value.includes("](") && !options2.content.value.includes("</a>");
      } else {
        hideOnHover = options2.persistence.hideOnHover;
      }
    }
    if (hideOnHover && ((_h = options2.appearance) === null || _h === void 0 ? void 0 : _h.showHoverHint)) {
      const statusBarElement = $3("div.hover-row.status-bar");
      const infoElement = $3("div.info");
      infoElement.textContent = localize("hoverhint", "Hold {0} key to mouse over", isMacintosh ? "Option" : "Alt");
      statusBarElement.appendChild(infoElement);
      this._hover.containerDomNode.appendChild(statusBarElement);
    }
    const mouseTrackerTargets = [...this._target.targetElements];
    if (!hideOnHover) {
      mouseTrackerTargets.push(this._hoverContainer);
    }
    const mouseTracker = this._register(new CompositeMouseTracker(mouseTrackerTargets));
    this._register(mouseTracker.onMouseOut(() => {
      if (!this._isLocked) {
        this.dispose();
      }
    }));
    if (hideOnHover) {
      const mouseTracker2Targets = [...this._target.targetElements, this._hoverContainer];
      this._lockMouseTracker = this._register(new CompositeMouseTracker(mouseTracker2Targets));
      this._register(this._lockMouseTracker.onMouseOut(() => {
        if (!this._isLocked) {
          this.dispose();
        }
      }));
    } else {
      this._lockMouseTracker = mouseTracker;
    }
  }
  addFocusTrap() {
    if (!this._enableFocusTraps || this._addedFocusTrap) {
      return;
    }
    this._addedFocusTrap = true;
    const firstContainerFocusElement = this._hover.containerDomNode;
    const lastContainerFocusElement = this.findLastFocusableChild(this._hover.containerDomNode);
    if (lastContainerFocusElement) {
      const beforeContainerFocusElement = prepend(this._hoverContainer, $3("div"));
      const afterContainerFocusElement = append(this._hoverContainer, $3("div"));
      beforeContainerFocusElement.tabIndex = 0;
      afterContainerFocusElement.tabIndex = 0;
      this._register(addDisposableListener(afterContainerFocusElement, "focus", (e) => {
        firstContainerFocusElement.focus();
        e.preventDefault();
      }));
      this._register(addDisposableListener(beforeContainerFocusElement, "focus", (e) => {
        lastContainerFocusElement.focus();
        e.preventDefault();
      }));
    }
  }
  findLastFocusableChild(root) {
    if (root.hasChildNodes()) {
      for (let i = 0; i < root.childNodes.length; i++) {
        const node = root.childNodes.item(root.childNodes.length - i - 1);
        if (node.nodeType === node.ELEMENT_NODE) {
          const parsedNode = node;
          if (typeof parsedNode.tabIndex === "number" && parsedNode.tabIndex >= 0) {
            return parsedNode;
          }
        }
        const recursivelyFoundElement = this.findLastFocusableChild(node);
        if (recursivelyFoundElement) {
          return recursivelyFoundElement;
        }
      }
    }
    return void 0;
  }
  render(container) {
    var _a2;
    container.appendChild(this._hoverContainer);
    const hoverFocused = this._hoverContainer.contains(this._hoverContainer.ownerDocument.activeElement);
    const accessibleViewHint = hoverFocused && getHoverAccessibleViewHint(this._configurationService.getValue("accessibility.verbosity.hover") === true && this._accessibilityService.isScreenReaderOptimized(), (_a2 = this._keybindingService.lookupKeybinding("editor.action.accessibleView")) === null || _a2 === void 0 ? void 0 : _a2.getAriaLabel());
    if (accessibleViewHint) {
      status(accessibleViewHint);
    }
    this.layout();
    this.addFocusTrap();
  }
  layout() {
    this._hover.containerDomNode.classList.remove("right-aligned");
    this._hover.contentsDomNode.style.maxHeight = "";
    const getZoomAccountedBoundingClientRect = (e) => {
      const zoom = getDomNodeZoomLevel(e);
      const boundingRect = e.getBoundingClientRect();
      return {
        top: boundingRect.top * zoom,
        bottom: boundingRect.bottom * zoom,
        right: boundingRect.right * zoom,
        left: boundingRect.left * zoom
      };
    };
    const targetBounds = this._target.targetElements.map((e) => getZoomAccountedBoundingClientRect(e));
    const top = Math.min(...targetBounds.map((e) => e.top));
    const right = Math.max(...targetBounds.map((e) => e.right));
    const bottom = Math.max(...targetBounds.map((e) => e.bottom));
    const left = Math.min(...targetBounds.map((e) => e.left));
    const width = right - left;
    const height = bottom - top;
    const targetRect = {
      top,
      right,
      bottom,
      left,
      width,
      height,
      center: {
        x: left + width / 2,
        y: top + height / 2
      }
    };
    this.adjustHorizontalHoverPosition(targetRect);
    this.adjustVerticalHoverPosition(targetRect);
    this.adjustHoverMaxHeight(targetRect);
    this._hoverContainer.style.padding = "";
    this._hoverContainer.style.margin = "";
    if (this._hoverPointer) {
      switch (this._hoverPosition) {
        case 1:
          targetRect.left += 3;
          targetRect.right += 3;
          this._hoverContainer.style.paddingLeft = `${3}px`;
          this._hoverContainer.style.marginLeft = `${-3}px`;
          break;
        case 0:
          targetRect.left -= 3;
          targetRect.right -= 3;
          this._hoverContainer.style.paddingRight = `${3}px`;
          this._hoverContainer.style.marginRight = `${-3}px`;
          break;
        case 2:
          targetRect.top += 3;
          targetRect.bottom += 3;
          this._hoverContainer.style.paddingTop = `${3}px`;
          this._hoverContainer.style.marginTop = `${-3}px`;
          break;
        case 3:
          targetRect.top -= 3;
          targetRect.bottom -= 3;
          this._hoverContainer.style.paddingBottom = `${3}px`;
          this._hoverContainer.style.marginBottom = `${-3}px`;
          break;
      }
      targetRect.center.x = targetRect.left + width / 2;
      targetRect.center.y = targetRect.top + height / 2;
    }
    this.computeXCordinate(targetRect);
    this.computeYCordinate(targetRect);
    if (this._hoverPointer) {
      this._hoverPointer.classList.remove("top");
      this._hoverPointer.classList.remove("left");
      this._hoverPointer.classList.remove("right");
      this._hoverPointer.classList.remove("bottom");
      this.setHoverPointerPosition(targetRect);
    }
    this._hover.onContentsChanged();
  }
  computeXCordinate(target) {
    const hoverWidth = this._hover.containerDomNode.clientWidth + 2;
    if (this._target.x !== void 0) {
      this._x = this._target.x;
    } else if (this._hoverPosition === 1) {
      this._x = target.right;
    } else if (this._hoverPosition === 0) {
      this._x = target.left - hoverWidth;
    } else {
      if (this._hoverPointer) {
        this._x = target.center.x - this._hover.containerDomNode.clientWidth / 2;
      } else {
        this._x = target.left;
      }
      if (this._x + hoverWidth >= this._targetDocumentElement.clientWidth) {
        this._hover.containerDomNode.classList.add("right-aligned");
        this._x = Math.max(this._targetDocumentElement.clientWidth - hoverWidth - 2, this._targetDocumentElement.clientLeft);
      }
    }
    if (this._x < this._targetDocumentElement.clientLeft) {
      this._x = target.left + 2;
    }
  }
  computeYCordinate(target) {
    if (this._target.y !== void 0) {
      this._y = this._target.y;
    } else if (this._hoverPosition === 3) {
      this._y = target.top;
    } else if (this._hoverPosition === 2) {
      this._y = target.bottom - 2;
    } else {
      if (this._hoverPointer) {
        this._y = target.center.y + this._hover.containerDomNode.clientHeight / 2;
      } else {
        this._y = target.bottom;
      }
    }
    if (this._y > this._targetWindow.innerHeight) {
      this._y = target.bottom;
    }
  }
  adjustHorizontalHoverPosition(target) {
    if (this._target.x !== void 0) {
      return;
    }
    if (this._forcePosition) {
      const padding = (this._hoverPointer ? 3 : 0) + 2;
      if (this._hoverPosition === 1) {
        this._hover.containerDomNode.style.maxWidth = `${this._targetDocumentElement.clientWidth - target.right - padding}px`;
      } else if (this._hoverPosition === 0) {
        this._hover.containerDomNode.style.maxWidth = `${target.left - padding}px`;
      }
      return;
    }
    if (this._hoverPosition === 1) {
      const roomOnRight = this._targetDocumentElement.clientWidth - target.right;
      if (roomOnRight < this._hover.containerDomNode.clientWidth) {
        const roomOnLeft = target.left;
        if (roomOnLeft >= this._hover.containerDomNode.clientWidth) {
          this._hoverPosition = 0;
        } else {
          this._hoverPosition = 2;
        }
      }
    } else if (this._hoverPosition === 0) {
      const roomOnLeft = target.left;
      if (roomOnLeft < this._hover.containerDomNode.clientWidth) {
        const roomOnRight = this._targetDocumentElement.clientWidth - target.right;
        if (roomOnRight >= this._hover.containerDomNode.clientWidth) {
          this._hoverPosition = 1;
        } else {
          this._hoverPosition = 2;
        }
      }
      if (target.left - this._hover.containerDomNode.clientWidth <= this._targetDocumentElement.clientLeft) {
        this._hoverPosition = 1;
      }
    }
  }
  adjustVerticalHoverPosition(target) {
    if (this._target.y !== void 0 || this._forcePosition) {
      return;
    }
    if (this._hoverPosition === 3) {
      if (target.top - this._hover.containerDomNode.clientHeight < 0) {
        this._hoverPosition = 2;
      }
    } else if (this._hoverPosition === 2) {
      if (target.bottom + this._hover.containerDomNode.clientHeight > this._targetWindow.innerHeight) {
        this._hoverPosition = 3;
      }
    }
  }
  adjustHoverMaxHeight(target) {
    let maxHeight = this._targetWindow.innerHeight / 2;
    if (this._forcePosition) {
      const padding = (this._hoverPointer ? 3 : 0) + 2;
      if (this._hoverPosition === 3) {
        maxHeight = Math.min(maxHeight, target.top - padding);
      } else if (this._hoverPosition === 2) {
        maxHeight = Math.min(maxHeight, this._targetWindow.innerHeight - target.bottom - padding);
      }
    }
    this._hover.containerDomNode.style.maxHeight = `${maxHeight}px`;
    if (this._hover.contentsDomNode.clientHeight < this._hover.contentsDomNode.scrollHeight) {
      const extraRightPadding = `${this._hover.scrollbar.options.verticalScrollbarSize}px`;
      if (this._hover.contentsDomNode.style.paddingRight !== extraRightPadding) {
        this._hover.contentsDomNode.style.paddingRight = extraRightPadding;
      }
    }
  }
  setHoverPointerPosition(target) {
    if (!this._hoverPointer) {
      return;
    }
    switch (this._hoverPosition) {
      case 0:
      case 1: {
        this._hoverPointer.classList.add(this._hoverPosition === 0 ? "right" : "left");
        const hoverHeight = this._hover.containerDomNode.clientHeight;
        if (hoverHeight > target.height) {
          this._hoverPointer.style.top = `${target.center.y - (this._y - hoverHeight) - 3}px`;
        } else {
          this._hoverPointer.style.top = `${Math.round(hoverHeight / 2) - 3}px`;
        }
        break;
      }
      case 3:
      case 2: {
        this._hoverPointer.classList.add(this._hoverPosition === 3 ? "bottom" : "top");
        const hoverWidth = this._hover.containerDomNode.clientWidth;
        let pointerLeftPosition = Math.round(hoverWidth / 2) - 3;
        const pointerX = this._x + pointerLeftPosition;
        if (pointerX < target.left || pointerX > target.right) {
          pointerLeftPosition = target.center.x - this._x - 3;
        }
        this._hoverPointer.style.left = `${pointerLeftPosition}px`;
        break;
      }
    }
  }
  focus() {
    this._hover.containerDomNode.focus();
  }
  dispose() {
    if (!this._isDisposed) {
      this._onDispose.fire();
      this._hoverContainer.remove();
      this._messageListeners.dispose();
      this._target.dispose();
      super.dispose();
    }
    this._isDisposed = true;
  }
};
HoverWidget2 = __decorate12([
  __param11(1, IKeybindingService),
  __param11(2, IConfigurationService),
  __param11(3, IOpenerService),
  __param11(4, IInstantiationService),
  __param11(5, IAccessibilityService)
], HoverWidget2);
var CompositeMouseTracker = class extends Widget {
  get onMouseOut() {
    return this._onMouseOut.event;
  }
  get isMouseIn() {
    return this._isMouseIn;
  }
  constructor(_elements) {
    super();
    this._elements = _elements;
    this._isMouseIn = true;
    this._onMouseOut = this._register(new Emitter());
    this._elements.forEach((n) => this.onmouseover(n, () => this._onTargetMouseOver(n)));
    this._elements.forEach((n) => this.onmouseleave(n, () => this._onTargetMouseLeave(n)));
  }
  _onTargetMouseOver(target) {
    this._isMouseIn = true;
    this._clearEvaluateMouseStateTimeout(target);
  }
  _onTargetMouseLeave(target) {
    this._isMouseIn = false;
    this._evaluateMouseState(target);
  }
  _evaluateMouseState(target) {
    this._clearEvaluateMouseStateTimeout(target);
    this._mouseTimeout = getWindow(target).setTimeout(() => this._fireIfMouseOutside(), 0);
  }
  _clearEvaluateMouseStateTimeout(target) {
    if (this._mouseTimeout) {
      getWindow(target).clearTimeout(this._mouseTimeout);
      this._mouseTimeout = void 0;
    }
  }
  _fireIfMouseOutside() {
    if (!this._isMouseIn) {
      this._onMouseOut.fire();
    }
  }
};
var ElementHoverTarget = class {
  constructor(_element) {
    this._element = _element;
    this.targetElements = [this._element];
  }
  dispose() {
  }
};

// node_modules/monaco-editor/esm/vs/editor/browser/services/hoverService.js
init_lifecycle();
init_dom();
init_keyboardEvent();
init_window();
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param12 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var HoverService = class HoverService2 {
  constructor(_instantiationService, _contextViewService, contextMenuService, _keybindingService, _layoutService, _accessibilityService) {
    this._instantiationService = _instantiationService;
    this._contextViewService = _contextViewService;
    this._keybindingService = _keybindingService;
    this._layoutService = _layoutService;
    this._accessibilityService = _accessibilityService;
    contextMenuService.onDidShowContextMenu(() => this.hideHover());
  }
  showHover(options2, focus, skipLastFocusedUpdate) {
    var _a2, _b2, _c, _d;
    if (getHoverOptionsIdentity(this._currentHoverOptions) === getHoverOptionsIdentity(options2)) {
      return void 0;
    }
    if (this._currentHover && ((_b2 = (_a2 = this._currentHoverOptions) === null || _a2 === void 0 ? void 0 : _a2.persistence) === null || _b2 === void 0 ? void 0 : _b2.sticky)) {
      return void 0;
    }
    this._currentHoverOptions = options2;
    this._lastHoverOptions = options2;
    const trapFocus = options2.trapFocus || this._accessibilityService.isScreenReaderOptimized();
    const activeElement = getActiveElement();
    if (!skipLastFocusedUpdate) {
      if (trapFocus && activeElement) {
        this._lastFocusedElementBeforeOpen = activeElement;
      } else {
        this._lastFocusedElementBeforeOpen = void 0;
      }
    }
    const hoverDisposables = new DisposableStore();
    const hover = this._instantiationService.createInstance(HoverWidget2, options2);
    if ((_c = options2.persistence) === null || _c === void 0 ? void 0 : _c.sticky) {
      hover.isLocked = true;
    }
    hover.onDispose(() => {
      var _a3, _b3;
      const hoverWasFocused = ((_a3 = this._currentHover) === null || _a3 === void 0 ? void 0 : _a3.domNode) && isAncestorOfActiveElement(this._currentHover.domNode);
      if (hoverWasFocused) {
        (_b3 = this._lastFocusedElementBeforeOpen) === null || _b3 === void 0 ? void 0 : _b3.focus();
      }
      if (this._currentHoverOptions === options2) {
        this._currentHoverOptions = void 0;
      }
      hoverDisposables.dispose();
    });
    if (!options2.container) {
      const targetElement = options2.target instanceof HTMLElement ? options2.target : options2.target.targetElements[0];
      options2.container = this._layoutService.getContainer(getWindow(targetElement));
    }
    const provider = this._contextViewService;
    provider.showContextView(new HoverContextViewDelegate(hover, focus), options2.container);
    hover.onRequestLayout(() => provider.layout());
    if ((_d = options2.persistence) === null || _d === void 0 ? void 0 : _d.sticky) {
      hoverDisposables.add(addDisposableListener(getWindow(options2.container).document, EventType.MOUSE_DOWN, (e) => {
        if (!isAncestor(e.target, hover.domNode)) {
          this.doHideHover();
        }
      }));
    } else {
      if ("targetElements" in options2.target) {
        for (const element of options2.target.targetElements) {
          hoverDisposables.add(addDisposableListener(element, EventType.CLICK, () => this.hideHover()));
        }
      } else {
        hoverDisposables.add(addDisposableListener(options2.target, EventType.CLICK, () => this.hideHover()));
      }
      const focusedElement = getActiveElement();
      if (focusedElement) {
        const focusedElementDocument = getWindow(focusedElement).document;
        hoverDisposables.add(addDisposableListener(focusedElement, EventType.KEY_DOWN, (e) => {
          var _a3;
          return this._keyDown(e, hover, !!((_a3 = options2.persistence) === null || _a3 === void 0 ? void 0 : _a3.hideOnKeyDown));
        }));
        hoverDisposables.add(addDisposableListener(focusedElementDocument, EventType.KEY_DOWN, (e) => {
          var _a3;
          return this._keyDown(e, hover, !!((_a3 = options2.persistence) === null || _a3 === void 0 ? void 0 : _a3.hideOnKeyDown));
        }));
        hoverDisposables.add(addDisposableListener(focusedElement, EventType.KEY_UP, (e) => this._keyUp(e, hover)));
        hoverDisposables.add(addDisposableListener(focusedElementDocument, EventType.KEY_UP, (e) => this._keyUp(e, hover)));
      }
    }
    if ("IntersectionObserver" in mainWindow) {
      const observer = new IntersectionObserver((e) => this._intersectionChange(e, hover), { threshold: 0 });
      const firstTargetElement = "targetElements" in options2.target ? options2.target.targetElements[0] : options2.target;
      observer.observe(firstTargetElement);
      hoverDisposables.add(toDisposable(() => observer.disconnect()));
    }
    this._currentHover = hover;
    return hover;
  }
  hideHover() {
    var _a2;
    if (((_a2 = this._currentHover) === null || _a2 === void 0 ? void 0 : _a2.isLocked) || !this._currentHoverOptions) {
      return;
    }
    this.doHideHover();
  }
  doHideHover() {
    this._currentHover = void 0;
    this._currentHoverOptions = void 0;
    this._contextViewService.hideContextView();
  }
  _intersectionChange(entries, hover) {
    const entry = entries[entries.length - 1];
    if (!entry.isIntersecting) {
      hover.dispose();
    }
  }
  _keyDown(e, hover, hideOnKeyDown) {
    var _a2, _b2;
    if (e.key === "Alt") {
      hover.isLocked = true;
      return;
    }
    const event = new StandardKeyboardEvent(e);
    const keybinding = this._keybindingService.resolveKeyboardEvent(event);
    if (keybinding.getSingleModifierDispatchChords().some((value) => !!value) || this._keybindingService.softDispatch(event, event.target).kind !== 0) {
      return;
    }
    if (hideOnKeyDown && (!((_a2 = this._currentHoverOptions) === null || _a2 === void 0 ? void 0 : _a2.trapFocus) || e.key !== "Tab")) {
      this.hideHover();
      (_b2 = this._lastFocusedElementBeforeOpen) === null || _b2 === void 0 ? void 0 : _b2.focus();
    }
  }
  _keyUp(e, hover) {
    var _a2;
    if (e.key === "Alt") {
      hover.isLocked = false;
      if (!hover.isMouseIn) {
        this.hideHover();
        (_a2 = this._lastFocusedElementBeforeOpen) === null || _a2 === void 0 ? void 0 : _a2.focus();
      }
    }
  }
};
HoverService = __decorate13([
  __param12(0, IInstantiationService),
  __param12(1, IContextViewService),
  __param12(2, IContextMenuService),
  __param12(3, IKeybindingService),
  __param12(4, ILayoutService),
  __param12(5, IAccessibilityService)
], HoverService);
function getHoverOptionsIdentity(options2) {
  var _a2;
  if (options2 === void 0) {
    return void 0;
  }
  return (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.id) !== null && _a2 !== void 0 ? _a2 : options2;
}
var HoverContextViewDelegate = class {
  get anchorPosition() {
    return this._hover.anchor;
  }
  constructor(_hover, _focus = false) {
    this._hover = _hover;
    this._focus = _focus;
  }
  render(container) {
    this._hover.render(container);
    if (this._focus) {
      this._hover.focus();
    }
    return this._hover;
  }
  getAnchor() {
    return {
      x: this._hover.x,
      y: this._hover.y
    };
  }
  layout() {
    this._hover.layout();
  }
};
registerSingleton(
  IHoverService,
  HoverService,
  1
  /* InstantiationType.Delayed */
);
registerThemingParticipant((theme, collector) => {
  const hoverBorder = theme.getColor(editorHoverBorder);
  if (hoverBorder) {
    collector.addRule(`.monaco-workbench .workbench-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
    collector.addRule(`.monaco-workbench .workbench-hover hr { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
init_strings();
init_dom();
init_keyboardEvent();
init_event();
init_keybindings();
init_lifecycle();
init_platform();
init_uri();

// node_modules/monaco-editor/esm/vs/editor/browser/services/bulkEditService.js
init_instantiation();
init_uri();
init_types();
var IBulkEditService = createDecorator("IWorkspaceEditService");
var ResourceEdit = class {
  constructor(metadata) {
    this.metadata = metadata;
  }
  static convert(edit) {
    return edit.edits.map((edit2) => {
      if (ResourceTextEdit.is(edit2)) {
        return ResourceTextEdit.lift(edit2);
      }
      if (ResourceFileEdit.is(edit2)) {
        return ResourceFileEdit.lift(edit2);
      }
      throw new Error("Unsupported edit");
    });
  }
};
var ResourceTextEdit = class _ResourceTextEdit extends ResourceEdit {
  static is(candidate) {
    if (candidate instanceof _ResourceTextEdit) {
      return true;
    }
    return isObject(candidate) && URI.isUri(candidate.resource) && isObject(candidate.textEdit);
  }
  static lift(edit) {
    if (edit instanceof _ResourceTextEdit) {
      return edit;
    } else {
      return new _ResourceTextEdit(edit.resource, edit.textEdit, edit.versionId, edit.metadata);
    }
  }
  constructor(resource, textEdit, versionId = void 0, metadata) {
    super(metadata);
    this.resource = resource;
    this.textEdit = textEdit;
    this.versionId = versionId;
  }
};
var ResourceFileEdit = class _ResourceFileEdit extends ResourceEdit {
  static is(candidate) {
    if (candidate instanceof _ResourceFileEdit) {
      return true;
    } else {
      return isObject(candidate) && (Boolean(candidate.newResource) || Boolean(candidate.oldResource));
    }
  }
  static lift(edit) {
    if (edit instanceof _ResourceFileEdit) {
      return edit;
    } else {
      return new _ResourceFileEdit(edit.oldResource, edit.newResource, edit.options, edit.metadata);
    }
  }
  constructor(oldResource, newResource, options2 = {}, metadata) {
    super(metadata);
    this.oldResource = oldResource;
    this.newResource = newResource;
    this.options = options2;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/config/diffEditor.js
var diffEditorDefaultOptions = {
  enableSplitViewResizing: true,
  splitViewDefaultRatio: 0.5,
  renderSideBySide: true,
  renderMarginRevertIcon: true,
  maxComputationTime: 5e3,
  maxFileSize: 50,
  ignoreTrimWhitespace: true,
  renderIndicators: true,
  originalEditable: false,
  diffCodeLens: false,
  renderOverviewRuler: true,
  diffWordWrap: "inherit",
  diffAlgorithm: "advanced",
  accessibilityVerbose: false,
  experimental: {
    showMoves: false,
    showEmptyDecorations: true
  },
  hideUnchangedRegions: {
    enabled: false,
    contextLineCount: 3,
    minimumLineCount: 3,
    revealLineCount: 20
  },
  isInEmbeddedEditor: false,
  onlyShowAccessibleDiffViewer: false,
  renderSideBySideInlineBreakpoint: 900,
  useInlineViewWhenSpaceIsLimited: true
};

// node_modules/monaco-editor/esm/vs/editor/common/config/editorConfigurationSchema.js
init_textModelDefaults();
init_nls();
init_configurationRegistry();
init_platform2();
var editorConfigurationBaseNode = Object.freeze({
  id: "editor",
  order: 5,
  type: "object",
  title: localize("editorConfigurationTitle", "Editor"),
  scope: 5
});
var editorConfiguration = {
  ...editorConfigurationBaseNode,
  properties: {
    "editor.tabSize": {
      type: "number",
      default: EDITOR_MODEL_DEFAULTS.tabSize,
      minimum: 1,
      markdownDescription: localize("tabSize", "The number of spaces a tab is equal to. This setting is overridden based on the file contents when {0} is on.", "`#editor.detectIndentation#`")
    },
    "editor.indentSize": {
      "anyOf": [
        {
          type: "string",
          enum: ["tabSize"]
        },
        {
          type: "number",
          minimum: 1
        }
      ],
      default: "tabSize",
      markdownDescription: localize("indentSize", 'The number of spaces used for indentation or `"tabSize"` to use the value from `#editor.tabSize#`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.')
    },
    "editor.insertSpaces": {
      type: "boolean",
      default: EDITOR_MODEL_DEFAULTS.insertSpaces,
      markdownDescription: localize("insertSpaces", "Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when {0} is on.", "`#editor.detectIndentation#`")
    },
    "editor.detectIndentation": {
      type: "boolean",
      default: EDITOR_MODEL_DEFAULTS.detectIndentation,
      markdownDescription: localize("detectIndentation", "Controls whether {0} and {1} will be automatically detected when a file is opened based on the file contents.", "`#editor.tabSize#`", "`#editor.insertSpaces#`")
    },
    "editor.trimAutoWhitespace": {
      type: "boolean",
      default: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,
      description: localize("trimAutoWhitespace", "Remove trailing auto inserted whitespace.")
    },
    "editor.largeFileOptimizations": {
      type: "boolean",
      default: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,
      description: localize("largeFileOptimizations", "Special handling for large files to disable certain memory intensive features.")
    },
    "editor.wordBasedSuggestions": {
      enum: ["off", "currentDocument", "matchingDocuments", "allDocuments"],
      default: "matchingDocuments",
      enumDescriptions: [
        localize("wordBasedSuggestions.off", "Turn off Word Based Suggestions."),
        localize("wordBasedSuggestions.currentDocument", "Only suggest words from the active document."),
        localize("wordBasedSuggestions.matchingDocuments", "Suggest words from all open documents of the same language."),
        localize("wordBasedSuggestions.allDocuments", "Suggest words from all open documents.")
      ],
      description: localize("wordBasedSuggestions", "Controls whether completions should be computed based on words in the document and from which documents they are computed.")
    },
    "editor.semanticHighlighting.enabled": {
      enum: [true, false, "configuredByTheme"],
      enumDescriptions: [
        localize("semanticHighlighting.true", "Semantic highlighting enabled for all color themes."),
        localize("semanticHighlighting.false", "Semantic highlighting disabled for all color themes."),
        localize("semanticHighlighting.configuredByTheme", "Semantic highlighting is configured by the current color theme's `semanticHighlighting` setting.")
      ],
      default: "configuredByTheme",
      description: localize("semanticHighlighting.enabled", "Controls whether the semanticHighlighting is shown for the languages that support it.")
    },
    "editor.stablePeek": {
      type: "boolean",
      default: false,
      markdownDescription: localize("stablePeek", "Keep peek editors open even when double-clicking their content or when hitting `Escape`.")
    },
    "editor.maxTokenizationLineLength": {
      type: "integer",
      default: 2e4,
      description: localize("maxTokenizationLineLength", "Lines above this length will not be tokenized for performance reasons")
    },
    "editor.experimental.asyncTokenization": {
      type: "boolean",
      default: false,
      description: localize("editor.experimental.asyncTokenization", "Controls whether the tokenization should happen asynchronously on a web worker."),
      tags: ["experimental"]
    },
    "editor.experimental.asyncTokenizationLogging": {
      type: "boolean",
      default: false,
      description: localize("editor.experimental.asyncTokenizationLogging", "Controls whether async tokenization should be logged. For debugging only.")
    },
    "editor.experimental.asyncTokenizationVerification": {
      type: "boolean",
      default: false,
      description: localize("editor.experimental.asyncTokenizationVerification", "Controls whether async tokenization should be verified against legacy background tokenization. Might slow down tokenization. For debugging only."),
      tags: ["experimental"]
    },
    "editor.language.brackets": {
      type: ["array", "null"],
      default: null,
      // We want to distinguish the empty array from not configured.
      description: localize("schema.brackets", "Defines the bracket symbols that increase or decrease the indentation."),
      items: {
        type: "array",
        items: [
          {
            type: "string",
            description: localize("schema.openBracket", "The opening bracket character or string sequence.")
          },
          {
            type: "string",
            description: localize("schema.closeBracket", "The closing bracket character or string sequence.")
          }
        ]
      }
    },
    "editor.language.colorizedBracketPairs": {
      type: ["array", "null"],
      default: null,
      // We want to distinguish the empty array from not configured.
      description: localize("schema.colorizedBracketPairs", "Defines the bracket pairs that are colorized by their nesting level if bracket pair colorization is enabled."),
      items: {
        type: "array",
        items: [
          {
            type: "string",
            description: localize("schema.openBracket", "The opening bracket character or string sequence.")
          },
          {
            type: "string",
            description: localize("schema.closeBracket", "The closing bracket character or string sequence.")
          }
        ]
      }
    },
    "diffEditor.maxComputationTime": {
      type: "number",
      default: diffEditorDefaultOptions.maxComputationTime,
      description: localize("maxComputationTime", "Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout.")
    },
    "diffEditor.maxFileSize": {
      type: "number",
      default: diffEditorDefaultOptions.maxFileSize,
      description: localize("maxFileSize", "Maximum file size in MB for which to compute diffs. Use 0 for no limit.")
    },
    "diffEditor.renderSideBySide": {
      type: "boolean",
      default: diffEditorDefaultOptions.renderSideBySide,
      description: localize("sideBySide", "Controls whether the diff editor shows the diff side by side or inline.")
    },
    "diffEditor.renderSideBySideInlineBreakpoint": {
      type: "number",
      default: diffEditorDefaultOptions.renderSideBySideInlineBreakpoint,
      description: localize("renderSideBySideInlineBreakpoint", "If the diff editor width is smaller than this value, the inline view is used.")
    },
    "diffEditor.useInlineViewWhenSpaceIsLimited": {
      type: "boolean",
      default: diffEditorDefaultOptions.useInlineViewWhenSpaceIsLimited,
      description: localize("useInlineViewWhenSpaceIsLimited", "If enabled and the editor width is too small, the inline view is used.")
    },
    "diffEditor.renderMarginRevertIcon": {
      type: "boolean",
      default: diffEditorDefaultOptions.renderMarginRevertIcon,
      description: localize("renderMarginRevertIcon", "When enabled, the diff editor shows arrows in its glyph margin to revert changes.")
    },
    "diffEditor.ignoreTrimWhitespace": {
      type: "boolean",
      default: diffEditorDefaultOptions.ignoreTrimWhitespace,
      description: localize("ignoreTrimWhitespace", "When enabled, the diff editor ignores changes in leading or trailing whitespace.")
    },
    "diffEditor.renderIndicators": {
      type: "boolean",
      default: diffEditorDefaultOptions.renderIndicators,
      description: localize("renderIndicators", "Controls whether the diff editor shows +/- indicators for added/removed changes.")
    },
    "diffEditor.codeLens": {
      type: "boolean",
      default: diffEditorDefaultOptions.diffCodeLens,
      description: localize("codeLens", "Controls whether the editor shows CodeLens.")
    },
    "diffEditor.wordWrap": {
      type: "string",
      enum: ["off", "on", "inherit"],
      default: diffEditorDefaultOptions.diffWordWrap,
      markdownEnumDescriptions: [
        localize("wordWrap.off", "Lines will never wrap."),
        localize("wordWrap.on", "Lines will wrap at the viewport width."),
        localize("wordWrap.inherit", "Lines will wrap according to the {0} setting.", "`#editor.wordWrap#`")
      ]
    },
    "diffEditor.diffAlgorithm": {
      type: "string",
      enum: ["legacy", "advanced"],
      default: diffEditorDefaultOptions.diffAlgorithm,
      markdownEnumDescriptions: [
        localize("diffAlgorithm.legacy", "Uses the legacy diffing algorithm."),
        localize("diffAlgorithm.advanced", "Uses the advanced diffing algorithm.")
      ],
      tags: ["experimental"]
    },
    "diffEditor.hideUnchangedRegions.enabled": {
      type: "boolean",
      default: diffEditorDefaultOptions.hideUnchangedRegions.enabled,
      markdownDescription: localize("hideUnchangedRegions.enabled", "Controls whether the diff editor shows unchanged regions.")
    },
    "diffEditor.hideUnchangedRegions.revealLineCount": {
      type: "integer",
      default: diffEditorDefaultOptions.hideUnchangedRegions.revealLineCount,
      markdownDescription: localize("hideUnchangedRegions.revealLineCount", "Controls how many lines are used for unchanged regions."),
      minimum: 1
    },
    "diffEditor.hideUnchangedRegions.minimumLineCount": {
      type: "integer",
      default: diffEditorDefaultOptions.hideUnchangedRegions.minimumLineCount,
      markdownDescription: localize("hideUnchangedRegions.minimumLineCount", "Controls how many lines are used as a minimum for unchanged regions."),
      minimum: 1
    },
    "diffEditor.hideUnchangedRegions.contextLineCount": {
      type: "integer",
      default: diffEditorDefaultOptions.hideUnchangedRegions.contextLineCount,
      markdownDescription: localize("hideUnchangedRegions.contextLineCount", "Controls how many lines are used as context when comparing unchanged regions."),
      minimum: 1
    },
    "diffEditor.experimental.showMoves": {
      type: "boolean",
      default: diffEditorDefaultOptions.experimental.showMoves,
      markdownDescription: localize("showMoves", "Controls whether the diff editor should show detected code moves.")
    },
    "diffEditor.experimental.showEmptyDecorations": {
      type: "boolean",
      default: diffEditorDefaultOptions.experimental.showEmptyDecorations,
      description: localize("showEmptyDecorations", "Controls whether the diff editor shows empty decorations to see where characters got inserted or deleted.")
    }
  }
};
function isConfigurationPropertySchema(x) {
  return typeof x.type !== "undefined" || typeof x.anyOf !== "undefined";
}
for (const editorOption of editorOptionsRegistry) {
  const schema = editorOption.schema;
  if (typeof schema !== "undefined") {
    if (isConfigurationPropertySchema(schema)) {
      editorConfiguration.properties[`editor.${editorOption.name}`] = schema;
    } else {
      for (const key in schema) {
        if (Object.hasOwnProperty.call(schema, key)) {
          editorConfiguration.properties[key] = schema[key];
        }
      }
    }
  }
}
var cachedEditorConfigurationKeys = null;
function getEditorConfigurationKeys() {
  if (cachedEditorConfigurationKeys === null) {
    cachedEditorConfigurationKeys = /* @__PURE__ */ Object.create(null);
    Object.keys(editorConfiguration.properties).forEach((prop) => {
      cachedEditorConfigurationKeys[prop] = true;
    });
  }
  return cachedEditorConfigurationKeys;
}
function isEditorConfigurationKey(key) {
  const editorConfigurationKeys = getEditorConfigurationKeys();
  return editorConfigurationKeys[`editor.${key}`] || false;
}
function isDiffEditorConfigurationKey(key) {
  const editorConfigurationKeys = getEditorConfigurationKeys();
  return editorConfigurationKeys[`diffEditor.${key}`] || false;
}
var configurationRegistry2 = Registry.as(Extensions2.Configuration);
configurationRegistry2.registerConfiguration(editorConfiguration);

// node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js
init_range();
var EditOperation = class {
  static insert(position, text) {
    return {
      range: new Range2(position.lineNumber, position.column, position.lineNumber, position.column),
      text,
      forceMoveMarkers: true
    };
  }
  static delete(range2) {
    return {
      range: range2,
      text: null
    };
  }
  static replace(range2, text) {
    return {
      range: range2,
      text
    };
  }
  static replaceMove(range2, text) {
    return {
      range: range2,
      text,
      forceMoveMarkers: true
    };
  }
};

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
init_position();
init_range();
init_model2();
init_resolverService();

// node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js
init_instantiation();
var ITextResourceConfigurationService = createDecorator("textResourceConfigurationService");
var ITextResourcePropertiesService = createDecorator("textResourcePropertiesService");

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
init_commands();
init_configuration();

// node_modules/monaco-editor/esm/vs/platform/configuration/common/configurationModels.js
init_arrays();
init_map();
init_objects();
init_types();
init_uri();
init_configuration();
init_configurationRegistry();
init_platform2();
function freeze(data) {
  return Object.isFrozen(data) ? data : deepFreeze(data);
}
var ConfigurationModel = class _ConfigurationModel {
  constructor(_contents = {}, _keys = [], _overrides = [], raw) {
    this._contents = _contents;
    this._keys = _keys;
    this._overrides = _overrides;
    this.raw = raw;
    this.overrideConfigurations = /* @__PURE__ */ new Map();
  }
  get rawConfiguration() {
    var _a2;
    if (!this._rawConfiguration) {
      if ((_a2 = this.raw) === null || _a2 === void 0 ? void 0 : _a2.length) {
        const rawConfigurationModels = this.raw.map((raw) => {
          if (raw instanceof _ConfigurationModel) {
            return raw;
          }
          const parser2 = new ConfigurationModelParser("");
          parser2.parseRaw(raw);
          return parser2.configurationModel;
        });
        this._rawConfiguration = rawConfigurationModels.reduce((previous, current) => current === previous ? current : previous.merge(current), rawConfigurationModels[0]);
      } else {
        this._rawConfiguration = this;
      }
    }
    return this._rawConfiguration;
  }
  get contents() {
    return this._contents;
  }
  get overrides() {
    return this._overrides;
  }
  get keys() {
    return this._keys;
  }
  isEmpty() {
    return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
  }
  getValue(section) {
    return section ? getConfigurationValue(this.contents, section) : this.contents;
  }
  inspect(section, overrideIdentifier) {
    const that = this;
    return {
      get value() {
        return freeze(that.rawConfiguration.getValue(section));
      },
      get override() {
        return overrideIdentifier ? freeze(that.rawConfiguration.getOverrideValue(section, overrideIdentifier)) : void 0;
      },
      get merged() {
        return freeze(overrideIdentifier ? that.rawConfiguration.override(overrideIdentifier).getValue(section) : that.rawConfiguration.getValue(section));
      },
      get overrides() {
        const overrides = [];
        for (const { contents, identifiers, keys } of that.rawConfiguration.overrides) {
          const value = new _ConfigurationModel(contents, keys).getValue(section);
          if (value !== void 0) {
            overrides.push({ identifiers, value });
          }
        }
        return overrides.length ? freeze(overrides) : void 0;
      }
    };
  }
  getOverrideValue(section, overrideIdentifier) {
    const overrideContents = this.getContentsForOverrideIdentifer(overrideIdentifier);
    return overrideContents ? section ? getConfigurationValue(overrideContents, section) : overrideContents : void 0;
  }
  override(identifier) {
    let overrideConfigurationModel = this.overrideConfigurations.get(identifier);
    if (!overrideConfigurationModel) {
      overrideConfigurationModel = this.createOverrideConfigurationModel(identifier);
      this.overrideConfigurations.set(identifier, overrideConfigurationModel);
    }
    return overrideConfigurationModel;
  }
  merge(...others) {
    var _a2, _b2;
    const contents = deepClone(this.contents);
    const overrides = deepClone(this.overrides);
    const keys = [...this.keys];
    const raws = ((_a2 = this.raw) === null || _a2 === void 0 ? void 0 : _a2.length) ? [...this.raw] : [this];
    for (const other of others) {
      raws.push(...((_b2 = other.raw) === null || _b2 === void 0 ? void 0 : _b2.length) ? other.raw : [other]);
      if (other.isEmpty()) {
        continue;
      }
      this.mergeContents(contents, other.contents);
      for (const otherOverride of other.overrides) {
        const [override] = overrides.filter((o) => equals(o.identifiers, otherOverride.identifiers));
        if (override) {
          this.mergeContents(override.contents, otherOverride.contents);
          override.keys.push(...otherOverride.keys);
          override.keys = distinct(override.keys);
        } else {
          overrides.push(deepClone(otherOverride));
        }
      }
      for (const key of other.keys) {
        if (keys.indexOf(key) === -1) {
          keys.push(key);
        }
      }
    }
    return new _ConfigurationModel(contents, keys, overrides, raws.every((raw) => raw instanceof _ConfigurationModel) ? void 0 : raws);
  }
  createOverrideConfigurationModel(identifier) {
    const overrideContents = this.getContentsForOverrideIdentifer(identifier);
    if (!overrideContents || typeof overrideContents !== "object" || !Object.keys(overrideContents).length) {
      return this;
    }
    const contents = {};
    for (const key of distinct([...Object.keys(this.contents), ...Object.keys(overrideContents)])) {
      let contentsForKey = this.contents[key];
      const overrideContentsForKey = overrideContents[key];
      if (overrideContentsForKey) {
        if (typeof contentsForKey === "object" && typeof overrideContentsForKey === "object") {
          contentsForKey = deepClone(contentsForKey);
          this.mergeContents(contentsForKey, overrideContentsForKey);
        } else {
          contentsForKey = overrideContentsForKey;
        }
      }
      contents[key] = contentsForKey;
    }
    return new _ConfigurationModel(contents, this.keys, this.overrides);
  }
  mergeContents(source, target) {
    for (const key of Object.keys(target)) {
      if (key in source) {
        if (isObject(source[key]) && isObject(target[key])) {
          this.mergeContents(source[key], target[key]);
          continue;
        }
      }
      source[key] = deepClone(target[key]);
    }
  }
  getContentsForOverrideIdentifer(identifier) {
    let contentsForIdentifierOnly = null;
    let contents = null;
    const mergeContents = (contentsToMerge) => {
      if (contentsToMerge) {
        if (contents) {
          this.mergeContents(contents, contentsToMerge);
        } else {
          contents = deepClone(contentsToMerge);
        }
      }
    };
    for (const override of this.overrides) {
      if (override.identifiers.length === 1 && override.identifiers[0] === identifier) {
        contentsForIdentifierOnly = override.contents;
      } else if (override.identifiers.includes(identifier)) {
        mergeContents(override.contents);
      }
    }
    mergeContents(contentsForIdentifierOnly);
    return contents;
  }
  toJSON() {
    return {
      contents: this.contents,
      overrides: this.overrides,
      keys: this.keys
    };
  }
  // Update methods
  addValue(key, value) {
    this.updateValue(key, value, true);
  }
  setValue(key, value) {
    this.updateValue(key, value, false);
  }
  removeValue(key) {
    const index = this.keys.indexOf(key);
    if (index === -1) {
      return;
    }
    this.keys.splice(index, 1);
    removeFromValueTree(this.contents, key);
    if (OVERRIDE_PROPERTY_REGEX.test(key)) {
      this.overrides.splice(this.overrides.findIndex((o) => equals(o.identifiers, overrideIdentifiersFromKey(key))), 1);
    }
  }
  updateValue(key, value, add) {
    addToValueTree(this.contents, key, value, (e) => console.error(e));
    add = add || this.keys.indexOf(key) === -1;
    if (add) {
      this.keys.push(key);
    }
    if (OVERRIDE_PROPERTY_REGEX.test(key)) {
      this.overrides.push({
        identifiers: overrideIdentifiersFromKey(key),
        keys: Object.keys(this.contents[key]),
        contents: toValuesTree(this.contents[key], (message) => console.error(message))
      });
    }
  }
};
var ConfigurationModelParser = class {
  constructor(_name) {
    this._name = _name;
    this._raw = null;
    this._configurationModel = null;
    this._restrictedConfigurations = [];
  }
  get configurationModel() {
    return this._configurationModel || new ConfigurationModel();
  }
  parseRaw(raw, options2) {
    this._raw = raw;
    const { contents, keys, overrides, restricted, hasExcludedProperties } = this.doParseRaw(raw, options2);
    this._configurationModel = new ConfigurationModel(
      contents,
      keys,
      overrides,
      hasExcludedProperties ? [raw] : void 0
      /* raw has not changed */
    );
    this._restrictedConfigurations = restricted || [];
  }
  doParseRaw(raw, options2) {
    const configurationProperties = Registry.as(Extensions2.Configuration).getConfigurationProperties();
    const filtered = this.filter(raw, configurationProperties, true, options2);
    raw = filtered.raw;
    const contents = toValuesTree(raw, (message) => console.error(`Conflict in settings file ${this._name}: ${message}`));
    const keys = Object.keys(raw);
    const overrides = this.toOverrides(raw, (message) => console.error(`Conflict in settings file ${this._name}: ${message}`));
    return { contents, keys, overrides, restricted: filtered.restricted, hasExcludedProperties: filtered.hasExcludedProperties };
  }
  filter(properties, configurationProperties, filterOverriddenProperties, options2) {
    var _a2, _b2, _c;
    let hasExcludedProperties = false;
    if (!(options2 === null || options2 === void 0 ? void 0 : options2.scopes) && !(options2 === null || options2 === void 0 ? void 0 : options2.skipRestricted) && !((_a2 = options2 === null || options2 === void 0 ? void 0 : options2.exclude) === null || _a2 === void 0 ? void 0 : _a2.length)) {
      return { raw: properties, restricted: [], hasExcludedProperties };
    }
    const raw = {};
    const restricted = [];
    for (const key in properties) {
      if (OVERRIDE_PROPERTY_REGEX.test(key) && filterOverriddenProperties) {
        const result = this.filter(properties[key], configurationProperties, false, options2);
        raw[key] = result.raw;
        hasExcludedProperties = hasExcludedProperties || result.hasExcludedProperties;
        restricted.push(...result.restricted);
      } else {
        const propertySchema = configurationProperties[key];
        const scope = propertySchema ? typeof propertySchema.scope !== "undefined" ? propertySchema.scope : 3 : void 0;
        if (propertySchema === null || propertySchema === void 0 ? void 0 : propertySchema.restricted) {
          restricted.push(key);
        }
        if (!((_b2 = options2.exclude) === null || _b2 === void 0 ? void 0 : _b2.includes(key)) && (((_c = options2.include) === null || _c === void 0 ? void 0 : _c.includes(key)) || (scope === void 0 || options2.scopes === void 0 || options2.scopes.includes(scope)) && !(options2.skipRestricted && (propertySchema === null || propertySchema === void 0 ? void 0 : propertySchema.restricted)))) {
          raw[key] = properties[key];
        } else {
          hasExcludedProperties = true;
        }
      }
    }
    return { raw, restricted, hasExcludedProperties };
  }
  toOverrides(raw, conflictReporter) {
    const overrides = [];
    for (const key of Object.keys(raw)) {
      if (OVERRIDE_PROPERTY_REGEX.test(key)) {
        const overrideRaw = {};
        for (const keyInOverrideRaw in raw[key]) {
          overrideRaw[keyInOverrideRaw] = raw[key][keyInOverrideRaw];
        }
        overrides.push({
          identifiers: overrideIdentifiersFromKey(key),
          keys: Object.keys(overrideRaw),
          contents: toValuesTree(overrideRaw, conflictReporter)
        });
      }
    }
    return overrides;
  }
};
var ConfigurationInspectValue = class {
  constructor(key, overrides, _value, overrideIdentifiers, defaultConfiguration, policyConfiguration, applicationConfiguration, userConfiguration, localUserConfiguration, remoteUserConfiguration, workspaceConfiguration, folderConfigurationModel, memoryConfigurationModel) {
    this.key = key;
    this.overrides = overrides;
    this._value = _value;
    this.overrideIdentifiers = overrideIdentifiers;
    this.defaultConfiguration = defaultConfiguration;
    this.policyConfiguration = policyConfiguration;
    this.applicationConfiguration = applicationConfiguration;
    this.userConfiguration = userConfiguration;
    this.localUserConfiguration = localUserConfiguration;
    this.remoteUserConfiguration = remoteUserConfiguration;
    this.workspaceConfiguration = workspaceConfiguration;
    this.folderConfigurationModel = folderConfigurationModel;
    this.memoryConfigurationModel = memoryConfigurationModel;
  }
  toInspectValue(inspectValue) {
    return (inspectValue === null || inspectValue === void 0 ? void 0 : inspectValue.value) !== void 0 || (inspectValue === null || inspectValue === void 0 ? void 0 : inspectValue.override) !== void 0 || (inspectValue === null || inspectValue === void 0 ? void 0 : inspectValue.overrides) !== void 0 ? inspectValue : void 0;
  }
  get userInspectValue() {
    if (!this._userInspectValue) {
      this._userInspectValue = this.userConfiguration.inspect(this.key, this.overrides.overrideIdentifier);
    }
    return this._userInspectValue;
  }
  get user() {
    return this.toInspectValue(this.userInspectValue);
  }
};
var Configuration = class _Configuration {
  constructor(_defaultConfiguration, _policyConfiguration, _applicationConfiguration, _localUserConfiguration, _remoteUserConfiguration = new ConfigurationModel(), _workspaceConfiguration = new ConfigurationModel(), _folderConfigurations = new ResourceMap(), _memoryConfiguration = new ConfigurationModel(), _memoryConfigurationByResource = new ResourceMap()) {
    this._defaultConfiguration = _defaultConfiguration;
    this._policyConfiguration = _policyConfiguration;
    this._applicationConfiguration = _applicationConfiguration;
    this._localUserConfiguration = _localUserConfiguration;
    this._remoteUserConfiguration = _remoteUserConfiguration;
    this._workspaceConfiguration = _workspaceConfiguration;
    this._folderConfigurations = _folderConfigurations;
    this._memoryConfiguration = _memoryConfiguration;
    this._memoryConfigurationByResource = _memoryConfigurationByResource;
    this._workspaceConsolidatedConfiguration = null;
    this._foldersConsolidatedConfigurations = new ResourceMap();
    this._userConfiguration = null;
  }
  getValue(section, overrides, workspace) {
    const consolidateConfigurationModel = this.getConsolidatedConfigurationModel(section, overrides, workspace);
    return consolidateConfigurationModel.getValue(section);
  }
  updateValue(key, value, overrides = {}) {
    let memoryConfiguration;
    if (overrides.resource) {
      memoryConfiguration = this._memoryConfigurationByResource.get(overrides.resource);
      if (!memoryConfiguration) {
        memoryConfiguration = new ConfigurationModel();
        this._memoryConfigurationByResource.set(overrides.resource, memoryConfiguration);
      }
    } else {
      memoryConfiguration = this._memoryConfiguration;
    }
    if (value === void 0) {
      memoryConfiguration.removeValue(key);
    } else {
      memoryConfiguration.setValue(key, value);
    }
    if (!overrides.resource) {
      this._workspaceConsolidatedConfiguration = null;
    }
  }
  inspect(key, overrides, workspace) {
    const consolidateConfigurationModel = this.getConsolidatedConfigurationModel(key, overrides, workspace);
    const folderConfigurationModel = this.getFolderConfigurationModelForResource(overrides.resource, workspace);
    const memoryConfigurationModel = overrides.resource ? this._memoryConfigurationByResource.get(overrides.resource) || this._memoryConfiguration : this._memoryConfiguration;
    const overrideIdentifiers = /* @__PURE__ */ new Set();
    for (const override of consolidateConfigurationModel.overrides) {
      for (const overrideIdentifier of override.identifiers) {
        if (consolidateConfigurationModel.getOverrideValue(key, overrideIdentifier) !== void 0) {
          overrideIdentifiers.add(overrideIdentifier);
        }
      }
    }
    return new ConfigurationInspectValue(key, overrides, consolidateConfigurationModel.getValue(key), overrideIdentifiers.size ? [...overrideIdentifiers] : void 0, this._defaultConfiguration, this._policyConfiguration.isEmpty() ? void 0 : this._policyConfiguration, this.applicationConfiguration.isEmpty() ? void 0 : this.applicationConfiguration, this.userConfiguration, this.localUserConfiguration, this.remoteUserConfiguration, workspace ? this._workspaceConfiguration : void 0, folderConfigurationModel ? folderConfigurationModel : void 0, memoryConfigurationModel);
  }
  get applicationConfiguration() {
    return this._applicationConfiguration;
  }
  get userConfiguration() {
    if (!this._userConfiguration) {
      this._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration);
    }
    return this._userConfiguration;
  }
  get localUserConfiguration() {
    return this._localUserConfiguration;
  }
  get remoteUserConfiguration() {
    return this._remoteUserConfiguration;
  }
  getConsolidatedConfigurationModel(section, overrides, workspace) {
    let configurationModel = this.getConsolidatedConfigurationModelForResource(overrides, workspace);
    if (overrides.overrideIdentifier) {
      configurationModel = configurationModel.override(overrides.overrideIdentifier);
    }
    if (!this._policyConfiguration.isEmpty() && this._policyConfiguration.getValue(section) !== void 0) {
      configurationModel = configurationModel.merge(this._policyConfiguration);
    }
    return configurationModel;
  }
  getConsolidatedConfigurationModelForResource({ resource }, workspace) {
    let consolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
    if (workspace && resource) {
      const root = workspace.getFolder(resource);
      if (root) {
        consolidateConfiguration = this.getFolderConsolidatedConfiguration(root.uri) || consolidateConfiguration;
      }
      const memoryConfigurationForResource = this._memoryConfigurationByResource.get(resource);
      if (memoryConfigurationForResource) {
        consolidateConfiguration = consolidateConfiguration.merge(memoryConfigurationForResource);
      }
    }
    return consolidateConfiguration;
  }
  getWorkspaceConsolidatedConfiguration() {
    if (!this._workspaceConsolidatedConfiguration) {
      this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.applicationConfiguration, this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);
    }
    return this._workspaceConsolidatedConfiguration;
  }
  getFolderConsolidatedConfiguration(folder) {
    let folderConsolidatedConfiguration = this._foldersConsolidatedConfigurations.get(folder);
    if (!folderConsolidatedConfiguration) {
      const workspaceConsolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
      const folderConfiguration = this._folderConfigurations.get(folder);
      if (folderConfiguration) {
        folderConsolidatedConfiguration = workspaceConsolidateConfiguration.merge(folderConfiguration);
        this._foldersConsolidatedConfigurations.set(folder, folderConsolidatedConfiguration);
      } else {
        folderConsolidatedConfiguration = workspaceConsolidateConfiguration;
      }
    }
    return folderConsolidatedConfiguration;
  }
  getFolderConfigurationModelForResource(resource, workspace) {
    if (workspace && resource) {
      const root = workspace.getFolder(resource);
      if (root) {
        return this._folderConfigurations.get(root.uri);
      }
    }
    return void 0;
  }
  toData() {
    return {
      defaults: {
        contents: this._defaultConfiguration.contents,
        overrides: this._defaultConfiguration.overrides,
        keys: this._defaultConfiguration.keys
      },
      policy: {
        contents: this._policyConfiguration.contents,
        overrides: this._policyConfiguration.overrides,
        keys: this._policyConfiguration.keys
      },
      application: {
        contents: this.applicationConfiguration.contents,
        overrides: this.applicationConfiguration.overrides,
        keys: this.applicationConfiguration.keys
      },
      user: {
        contents: this.userConfiguration.contents,
        overrides: this.userConfiguration.overrides,
        keys: this.userConfiguration.keys
      },
      workspace: {
        contents: this._workspaceConfiguration.contents,
        overrides: this._workspaceConfiguration.overrides,
        keys: this._workspaceConfiguration.keys
      },
      folders: [...this._folderConfigurations.keys()].reduce((result, folder) => {
        const { contents, overrides, keys } = this._folderConfigurations.get(folder);
        result.push([folder, { contents, overrides, keys }]);
        return result;
      }, [])
    };
  }
  static parse(data) {
    const defaultConfiguration = this.parseConfigurationModel(data.defaults);
    const policyConfiguration = this.parseConfigurationModel(data.policy);
    const applicationConfiguration = this.parseConfigurationModel(data.application);
    const userConfiguration = this.parseConfigurationModel(data.user);
    const workspaceConfiguration = this.parseConfigurationModel(data.workspace);
    const folders = data.folders.reduce((result, value) => {
      result.set(URI.revive(value[0]), this.parseConfigurationModel(value[1]));
      return result;
    }, new ResourceMap());
    return new _Configuration(defaultConfiguration, policyConfiguration, applicationConfiguration, userConfiguration, new ConfigurationModel(), workspaceConfiguration, folders, new ConfigurationModel(), new ResourceMap());
  }
  static parseConfigurationModel(model) {
    return new ConfigurationModel(model.contents, model.keys, model.overrides);
  }
};
var ConfigurationChangeEvent = class {
  constructor(change, previous, currentConfiguraiton, currentWorkspace) {
    this.change = change;
    this.previous = previous;
    this.currentConfiguraiton = currentConfiguraiton;
    this.currentWorkspace = currentWorkspace;
    this._marker = "\n";
    this._markerCode1 = this._marker.charCodeAt(0);
    this._markerCode2 = ".".charCodeAt(0);
    this.affectedKeys = /* @__PURE__ */ new Set();
    this._previousConfiguration = void 0;
    for (const key of change.keys) {
      this.affectedKeys.add(key);
    }
    for (const [, keys] of change.overrides) {
      for (const key of keys) {
        this.affectedKeys.add(key);
      }
    }
    this._affectsConfigStr = this._marker;
    for (const key of this.affectedKeys) {
      this._affectsConfigStr += key + this._marker;
    }
  }
  get previousConfiguration() {
    if (!this._previousConfiguration && this.previous) {
      this._previousConfiguration = Configuration.parse(this.previous.data);
    }
    return this._previousConfiguration;
  }
  affectsConfiguration(section, overrides) {
    var _a2;
    const needle = this._marker + section;
    const idx = this._affectsConfigStr.indexOf(needle);
    if (idx < 0) {
      return false;
    }
    const pos = idx + needle.length;
    if (pos >= this._affectsConfigStr.length) {
      return false;
    }
    const code = this._affectsConfigStr.charCodeAt(pos);
    if (code !== this._markerCode1 && code !== this._markerCode2) {
      return false;
    }
    if (overrides) {
      const value1 = this.previousConfiguration ? this.previousConfiguration.getValue(section, overrides, (_a2 = this.previous) === null || _a2 === void 0 ? void 0 : _a2.workspace) : void 0;
      const value2 = this.currentConfiguraiton.getValue(section, overrides, this.currentWorkspace);
      return !equals2(value1, value2);
    }
    return true;
  }
};

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
init_contextkey();
init_instantiation();

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/abstractKeybindingService.js
init_async();
init_errors();
init_event();

// node_modules/monaco-editor/esm/vs/base/common/ime.js
init_event();
var IMEImpl = class {
  constructor() {
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._enabled = true;
  }
  get enabled() {
    return this._enabled;
  }
  /**
   * Enable IME
   */
  enable() {
    this._enabled = true;
    this._onDidChange.fire();
  }
  /**
   * Disable IME
   */
  disable() {
    this._enabled = false;
    this._onDidChange.fire();
  }
};
var IME = new IMEImpl();

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/abstractKeybindingService.js
init_lifecycle();
init_nls();

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingResolver.js
init_contextkey();
var NoMatchingKb = {
  kind: 0
  /* ResultKind.NoMatchingKb */
};
var MoreChordsNeeded = {
  kind: 1
  /* ResultKind.MoreChordsNeeded */
};
function KbFound(commandId, commandArgs, isBubble) {
  return { kind: 2, commandId, commandArgs, isBubble };
}
var KeybindingResolver = class _KeybindingResolver {
  constructor(defaultKeybindings, overrides, log) {
    var _a2;
    this._log = log;
    this._defaultKeybindings = defaultKeybindings;
    this._defaultBoundCommands = /* @__PURE__ */ new Map();
    for (const defaultKeybinding of defaultKeybindings) {
      const command = defaultKeybinding.command;
      if (command && command.charAt(0) !== "-") {
        this._defaultBoundCommands.set(command, true);
      }
    }
    this._map = /* @__PURE__ */ new Map();
    this._lookupMap = /* @__PURE__ */ new Map();
    this._keybindings = _KeybindingResolver.handleRemovals([].concat(defaultKeybindings).concat(overrides));
    for (let i = 0, len = this._keybindings.length; i < len; i++) {
      const k = this._keybindings[i];
      if (k.chords.length === 0) {
        continue;
      }
      const when = (_a2 = k.when) === null || _a2 === void 0 ? void 0 : _a2.substituteConstants();
      if (when && when.type === 0) {
        continue;
      }
      this._addKeyPress(k.chords[0], k);
    }
  }
  static _isTargetedForRemoval(defaultKb, keypress, when) {
    if (keypress) {
      for (let i = 0; i < keypress.length; i++) {
        if (keypress[i] !== defaultKb.chords[i]) {
          return false;
        }
      }
    }
    if (when && when.type !== 1) {
      if (!defaultKb.when) {
        return false;
      }
      if (!expressionsAreEqualWithConstantSubstitution(when, defaultKb.when)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Looks for rules containing "-commandId" and removes them.
   */
  static handleRemovals(rules) {
    const removals = /* @__PURE__ */ new Map();
    for (let i = 0, len = rules.length; i < len; i++) {
      const rule = rules[i];
      if (rule.command && rule.command.charAt(0) === "-") {
        const command = rule.command.substring(1);
        if (!removals.has(command)) {
          removals.set(command, [rule]);
        } else {
          removals.get(command).push(rule);
        }
      }
    }
    if (removals.size === 0) {
      return rules;
    }
    const result = [];
    for (let i = 0, len = rules.length; i < len; i++) {
      const rule = rules[i];
      if (!rule.command || rule.command.length === 0) {
        result.push(rule);
        continue;
      }
      if (rule.command.charAt(0) === "-") {
        continue;
      }
      const commandRemovals = removals.get(rule.command);
      if (!commandRemovals || !rule.isDefault) {
        result.push(rule);
        continue;
      }
      let isRemoved = false;
      for (const commandRemoval of commandRemovals) {
        const when = commandRemoval.when;
        if (this._isTargetedForRemoval(rule, commandRemoval.chords, when)) {
          isRemoved = true;
          break;
        }
      }
      if (!isRemoved) {
        result.push(rule);
        continue;
      }
    }
    return result;
  }
  _addKeyPress(keypress, item) {
    const conflicts = this._map.get(keypress);
    if (typeof conflicts === "undefined") {
      this._map.set(keypress, [item]);
      this._addToLookupMap(item);
      return;
    }
    for (let i = conflicts.length - 1; i >= 0; i--) {
      const conflict = conflicts[i];
      if (conflict.command === item.command) {
        continue;
      }
      let isShorterKbPrefix = true;
      for (let i2 = 1; i2 < conflict.chords.length && i2 < item.chords.length; i2++) {
        if (conflict.chords[i2] !== item.chords[i2]) {
          isShorterKbPrefix = false;
          break;
        }
      }
      if (!isShorterKbPrefix) {
        continue;
      }
      if (_KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {
        this._removeFromLookupMap(conflict);
      }
    }
    conflicts.push(item);
    this._addToLookupMap(item);
  }
  _addToLookupMap(item) {
    if (!item.command) {
      return;
    }
    let arr = this._lookupMap.get(item.command);
    if (typeof arr === "undefined") {
      arr = [item];
      this._lookupMap.set(item.command, arr);
    } else {
      arr.push(item);
    }
  }
  _removeFromLookupMap(item) {
    if (!item.command) {
      return;
    }
    const arr = this._lookupMap.get(item.command);
    if (typeof arr === "undefined") {
      return;
    }
    for (let i = 0, len = arr.length; i < len; i++) {
      if (arr[i] === item) {
        arr.splice(i, 1);
        return;
      }
    }
  }
  /**
   * Returns true if it is provable `a` implies `b`.
   */
  static whenIsEntirelyIncluded(a, b) {
    if (!b || b.type === 1) {
      return true;
    }
    if (!a || a.type === 1) {
      return false;
    }
    return implies(a, b);
  }
  getKeybindings() {
    return this._keybindings;
  }
  lookupPrimaryKeybinding(commandId, context) {
    const items = this._lookupMap.get(commandId);
    if (typeof items === "undefined" || items.length === 0) {
      return null;
    }
    if (items.length === 1) {
      return items[0];
    }
    for (let i = items.length - 1; i >= 0; i--) {
      const item = items[i];
      if (context.contextMatchesRules(item.when)) {
        return item;
      }
    }
    return items[items.length - 1];
  }
  /**
   * Looks up a keybinding trigged as a result of pressing a sequence of chords - `[...currentChords, keypress]`
   *
   * Example: resolving 3 chords pressed sequentially - `cmd+k cmd+p cmd+i`:
   * 	`currentChords = [ 'cmd+k' , 'cmd+p' ]` and `keypress = `cmd+i` - last pressed chord
   */
  resolve(context, currentChords, keypress) {
    const pressedChords = [...currentChords, keypress];
    this._log(`| Resolving ${pressedChords}`);
    const kbCandidates = this._map.get(pressedChords[0]);
    if (kbCandidates === void 0) {
      this._log(`\\ No keybinding entries.`);
      return NoMatchingKb;
    }
    let lookupMap = null;
    if (pressedChords.length < 2) {
      lookupMap = kbCandidates;
    } else {
      lookupMap = [];
      for (let i = 0, len = kbCandidates.length; i < len; i++) {
        const candidate = kbCandidates[i];
        if (pressedChords.length > candidate.chords.length) {
          continue;
        }
        let prefixMatches = true;
        for (let i2 = 1; i2 < pressedChords.length; i2++) {
          if (candidate.chords[i2] !== pressedChords[i2]) {
            prefixMatches = false;
            break;
          }
        }
        if (prefixMatches) {
          lookupMap.push(candidate);
        }
      }
    }
    const result = this._findCommand(context, lookupMap);
    if (!result) {
      this._log(`\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);
      return NoMatchingKb;
    }
    if (pressedChords.length < result.chords.length) {
      this._log(`\\ From ${lookupMap.length} keybinding entries, awaiting ${result.chords.length - pressedChords.length} more chord(s), when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);
      return MoreChordsNeeded;
    }
    this._log(`\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);
    return KbFound(result.command, result.commandArgs, result.bubble);
  }
  _findCommand(context, matches) {
    for (let i = matches.length - 1; i >= 0; i--) {
      const k = matches[i];
      if (!_KeybindingResolver._contextMatchesRules(context, k.when)) {
        continue;
      }
      return k;
    }
    return null;
  }
  static _contextMatchesRules(context, rules) {
    if (!rules) {
      return true;
    }
    return rules.evaluate(context);
  }
};
function printWhenExplanation(when) {
  if (!when) {
    return `no when condition`;
  }
  return `${when.serialize()}`;
}
function printSourceExplanation(kb) {
  return kb.extensionId ? kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}` : kb.isDefault ? `built-in` : `user`;
}

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/abstractKeybindingService.js
var HIGH_FREQ_COMMANDS = /^(cursor|delete|undo|redo|tab|editor\.action\.clipboard)/;
var AbstractKeybindingService = class extends Disposable {
  get onDidUpdateKeybindings() {
    return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None;
  }
  get inChordMode() {
    return this._currentChords.length > 0;
  }
  constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {
    super();
    this._contextKeyService = _contextKeyService;
    this._commandService = _commandService;
    this._telemetryService = _telemetryService;
    this._notificationService = _notificationService;
    this._logService = _logService;
    this._onDidUpdateKeybindings = this._register(new Emitter());
    this._currentChords = [];
    this._currentChordChecker = new IntervalTimer();
    this._currentChordStatusMessage = null;
    this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;
    this._currentSingleModifier = null;
    this._currentSingleModifierClearTimeout = new TimeoutTimer();
    this._currentlyDispatchingCommandId = null;
    this._logging = false;
  }
  dispose() {
    super.dispose();
  }
  _log(str) {
    if (this._logging) {
      this._logService.info(`[KeybindingService]: ${str}`);
    }
  }
  getKeybindings() {
    return this._getResolver().getKeybindings();
  }
  lookupKeybinding(commandId, context) {
    const result = this._getResolver().lookupPrimaryKeybinding(commandId, context || this._contextKeyService);
    if (!result) {
      return void 0;
    }
    return result.resolvedKeybinding;
  }
  dispatchEvent(e, target) {
    return this._dispatch(e, target);
  }
  // TODO@ulugbekna: update namings to align with `_doDispatch`
  // TODO@ulugbekna: this fn doesn't seem to take into account single-modifier keybindings, eg `shift shift`
  softDispatch(e, target) {
    this._log(`/ Soft dispatching keyboard event`);
    const keybinding = this.resolveKeyboardEvent(e);
    if (keybinding.hasMultipleChords()) {
      console.warn("keyboard event should not be mapped to multiple chords");
      return NoMatchingKb;
    }
    const [firstChord] = keybinding.getDispatchChords();
    if (firstChord === null) {
      this._log(`\\ Keyboard event cannot be dispatched`);
      return NoMatchingKb;
    }
    const contextValue = this._contextKeyService.getContext(target);
    const currentChords = this._currentChords.map(({ keypress }) => keypress);
    return this._getResolver().resolve(contextValue, currentChords, firstChord);
  }
  _scheduleLeaveChordMode() {
    const chordLastInteractedTime = Date.now();
    this._currentChordChecker.cancelAndSet(() => {
      if (!this._documentHasFocus()) {
        this._leaveChordMode();
        return;
      }
      if (Date.now() - chordLastInteractedTime > 5e3) {
        this._leaveChordMode();
      }
    }, 500);
  }
  _expectAnotherChord(firstChord, keypressLabel) {
    this._currentChords.push({ keypress: firstChord, label: keypressLabel });
    switch (this._currentChords.length) {
      case 0:
        throw illegalState("impossible");
      case 1:
        this._currentChordStatusMessage = this._notificationService.status(localize("first.chord", "({0}) was pressed. Waiting for second key of chord...", keypressLabel));
        break;
      default: {
        const fullKeypressLabel = this._currentChords.map(({ label }) => label).join(", ");
        this._currentChordStatusMessage = this._notificationService.status(localize("next.chord", "({0}) was pressed. Waiting for next key of chord...", fullKeypressLabel));
      }
    }
    this._scheduleLeaveChordMode();
    if (IME.enabled) {
      IME.disable();
    }
  }
  _leaveChordMode() {
    if (this._currentChordStatusMessage) {
      this._currentChordStatusMessage.dispose();
      this._currentChordStatusMessage = null;
    }
    this._currentChordChecker.cancel();
    this._currentChords = [];
    IME.enable();
  }
  _dispatch(e, target) {
    return this._doDispatch(
      this.resolveKeyboardEvent(e),
      target,
      /*isSingleModiferChord*/
      false
    );
  }
  _singleModifierDispatch(e, target) {
    const keybinding = this.resolveKeyboardEvent(e);
    const [singleModifier] = keybinding.getSingleModifierDispatchChords();
    if (singleModifier) {
      if (this._ignoreSingleModifiers.has(singleModifier)) {
        this._log(`+ Ignoring single modifier ${singleModifier} due to it being pressed together with other keys.`);
        this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;
        this._currentSingleModifierClearTimeout.cancel();
        this._currentSingleModifier = null;
        return false;
      }
      this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;
      if (this._currentSingleModifier === null) {
        this._log(`+ Storing single modifier for possible chord ${singleModifier}.`);
        this._currentSingleModifier = singleModifier;
        this._currentSingleModifierClearTimeout.cancelAndSet(() => {
          this._log(`+ Clearing single modifier due to 300ms elapsed.`);
          this._currentSingleModifier = null;
        }, 300);
        return false;
      }
      if (singleModifier === this._currentSingleModifier) {
        this._log(`/ Dispatching single modifier chord ${singleModifier} ${singleModifier}`);
        this._currentSingleModifierClearTimeout.cancel();
        this._currentSingleModifier = null;
        return this._doDispatch(
          keybinding,
          target,
          /*isSingleModiferChord*/
          true
        );
      }
      this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${singleModifier}`);
      this._currentSingleModifierClearTimeout.cancel();
      this._currentSingleModifier = null;
      return false;
    }
    const [firstChord] = keybinding.getChords();
    this._ignoreSingleModifiers = new KeybindingModifierSet(firstChord);
    if (this._currentSingleModifier !== null) {
      this._log(`+ Clearing single modifier due to other key up.`);
    }
    this._currentSingleModifierClearTimeout.cancel();
    this._currentSingleModifier = null;
    return false;
  }
  _doDispatch(userKeypress, target, isSingleModiferChord = false) {
    var _a2;
    let shouldPreventDefault = false;
    if (userKeypress.hasMultipleChords()) {
      console.warn("Unexpected keyboard event mapped to multiple chords");
      return false;
    }
    let userPressedChord = null;
    let currentChords = null;
    if (isSingleModiferChord) {
      const [dispatchKeyname] = userKeypress.getSingleModifierDispatchChords();
      userPressedChord = dispatchKeyname;
      currentChords = dispatchKeyname ? [dispatchKeyname] : [];
    } else {
      [userPressedChord] = userKeypress.getDispatchChords();
      currentChords = this._currentChords.map(({ keypress }) => keypress);
    }
    if (userPressedChord === null) {
      this._log(`\\ Keyboard event cannot be dispatched in keydown phase.`);
      return shouldPreventDefault;
    }
    const contextValue = this._contextKeyService.getContext(target);
    const keypressLabel = userKeypress.getLabel();
    const resolveResult = this._getResolver().resolve(contextValue, currentChords, userPressedChord);
    switch (resolveResult.kind) {
      case 0: {
        this._logService.trace("KeybindingService#dispatch", keypressLabel, `[ No matching keybinding ]`);
        if (this.inChordMode) {
          const currentChordsLabel = this._currentChords.map(({ label }) => label).join(", ");
          this._log(`+ Leaving multi-chord mode: Nothing bound to "${currentChordsLabel}, ${keypressLabel}".`);
          this._notificationService.status(localize("missing.chord", "The key combination ({0}, {1}) is not a command.", currentChordsLabel, keypressLabel), {
            hideAfter: 10 * 1e3
            /* 10s */
          });
          this._leaveChordMode();
          shouldPreventDefault = true;
        }
        return shouldPreventDefault;
      }
      case 1: {
        this._logService.trace("KeybindingService#dispatch", keypressLabel, `[ Several keybindings match - more chords needed ]`);
        shouldPreventDefault = true;
        this._expectAnotherChord(userPressedChord, keypressLabel);
        this._log(this._currentChords.length === 1 ? `+ Entering multi-chord mode...` : `+ Continuing multi-chord mode...`);
        return shouldPreventDefault;
      }
      case 2: {
        this._logService.trace("KeybindingService#dispatch", keypressLabel, `[ Will dispatch command ${resolveResult.commandId} ]`);
        if (resolveResult.commandId === null || resolveResult.commandId === "") {
          if (this.inChordMode) {
            const currentChordsLabel = this._currentChords.map(({ label }) => label).join(", ");
            this._log(`+ Leaving chord mode: Nothing bound to "${currentChordsLabel}, ${keypressLabel}".`);
            this._notificationService.status(localize("missing.chord", "The key combination ({0}, {1}) is not a command.", currentChordsLabel, keypressLabel), {
              hideAfter: 10 * 1e3
              /* 10s */
            });
            this._leaveChordMode();
            shouldPreventDefault = true;
          }
        } else {
          if (this.inChordMode) {
            this._leaveChordMode();
          }
          if (!resolveResult.isBubble) {
            shouldPreventDefault = true;
          }
          this._log(`+ Invoking command ${resolveResult.commandId}.`);
          this._currentlyDispatchingCommandId = resolveResult.commandId;
          try {
            if (typeof resolveResult.commandArgs === "undefined") {
              this._commandService.executeCommand(resolveResult.commandId).then(void 0, (err) => this._notificationService.warn(err));
            } else {
              this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(void 0, (err) => this._notificationService.warn(err));
            }
          } finally {
            this._currentlyDispatchingCommandId = null;
          }
          if (!HIGH_FREQ_COMMANDS.test(resolveResult.commandId)) {
            this._telemetryService.publicLog2("workbenchActionExecuted", { id: resolveResult.commandId, from: "keybinding", detail: (_a2 = userKeypress.getUserSettingsLabel()) !== null && _a2 !== void 0 ? _a2 : void 0 });
          }
        }
        return shouldPreventDefault;
      }
    }
  }
  mightProducePrintableCharacter(event) {
    if (event.ctrlKey || event.metaKey) {
      return false;
    }
    if (event.keyCode >= 31 && event.keyCode <= 56 || event.keyCode >= 21 && event.keyCode <= 30) {
      return true;
    }
    return false;
  }
};
var KeybindingModifierSet = class {
  constructor(source) {
    this._ctrlKey = source ? source.ctrlKey : false;
    this._shiftKey = source ? source.shiftKey : false;
    this._altKey = source ? source.altKey : false;
    this._metaKey = source ? source.metaKey : false;
  }
  has(modifier) {
    switch (modifier) {
      case "ctrl":
        return this._ctrlKey;
      case "shift":
        return this._shiftKey;
      case "alt":
        return this._altKey;
      case "meta":
        return this._metaKey;
    }
  }
};
KeybindingModifierSet.EMPTY = new KeybindingModifierSet(null);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
init_keybindingsRegistry();

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/resolvedKeybindingItem.js
var ResolvedKeybindingItem = class {
  constructor(resolvedKeybinding, command, commandArgs, when, isDefault, extensionId, isBuiltinExtension) {
    this._resolvedKeybindingItemBrand = void 0;
    this.resolvedKeybinding = resolvedKeybinding;
    this.chords = resolvedKeybinding ? toEmptyArrayIfContainsNull(resolvedKeybinding.getDispatchChords()) : [];
    if (resolvedKeybinding && this.chords.length === 0) {
      this.chords = toEmptyArrayIfContainsNull(resolvedKeybinding.getSingleModifierDispatchChords());
    }
    this.bubble = command ? command.charCodeAt(0) === 94 : false;
    this.command = this.bubble ? command.substr(1) : command;
    this.commandArgs = commandArgs;
    this.when = when;
    this.isDefault = isDefault;
    this.extensionId = extensionId;
    this.isBuiltinExtension = isBuiltinExtension;
  }
};
function toEmptyArrayIfContainsNull(arr) {
  const result = [];
  for (let i = 0, len = arr.length; i < len; i++) {
    const element = arr[i];
    if (!element) {
      return [];
    }
    result.push(element);
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/usLayoutResolvedKeybinding.js
init_keyCodes();
init_keybindings();

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/baseResolvedKeybinding.js
init_errors();

// node_modules/monaco-editor/esm/vs/base/common/keybindingLabels.js
init_nls();
var ModifierLabelProvider = class {
  constructor(mac, windows, linux = windows) {
    this.modifierLabels = [null];
    this.modifierLabels[
      2
      /* OperatingSystem.Macintosh */
    ] = mac;
    this.modifierLabels[
      1
      /* OperatingSystem.Windows */
    ] = windows;
    this.modifierLabels[
      3
      /* OperatingSystem.Linux */
    ] = linux;
  }
  toLabel(OS2, chords, keyLabelProvider) {
    if (chords.length === 0) {
      return null;
    }
    const result = [];
    for (let i = 0, len = chords.length; i < len; i++) {
      const chord = chords[i];
      const keyLabel = keyLabelProvider(chord);
      if (keyLabel === null) {
        return null;
      }
      result[i] = _simpleAsString(chord, keyLabel, this.modifierLabels[OS2]);
    }
    return result.join(" ");
  }
};
var UILabelProvider = new ModifierLabelProvider({
  ctrlKey: "",
  shiftKey: "",
  altKey: "",
  metaKey: "",
  separator: ""
}, {
  ctrlKey: localize({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
  shiftKey: localize({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
  altKey: localize({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: localize({ key: "windowsKey", comment: ["This is the short form for the Windows key on the keyboard"] }, "Windows"),
  separator: "+"
}, {
  ctrlKey: localize({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
  shiftKey: localize({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
  altKey: localize({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: localize({ key: "superKey", comment: ["This is the short form for the Super key on the keyboard"] }, "Super"),
  separator: "+"
});
var AriaLabelProvider = new ModifierLabelProvider({
  ctrlKey: localize({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: localize({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: localize({ key: "optKey.long", comment: ["This is the long form for the Alt/Option key on the keyboard"] }, "Option"),
  metaKey: localize({ key: "cmdKey.long", comment: ["This is the long form for the Command key on the keyboard"] }, "Command"),
  separator: "+"
}, {
  ctrlKey: localize({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: localize({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: localize({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: localize({ key: "windowsKey.long", comment: ["This is the long form for the Windows key on the keyboard"] }, "Windows"),
  separator: "+"
}, {
  ctrlKey: localize({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: localize({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: localize({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: localize({ key: "superKey.long", comment: ["This is the long form for the Super key on the keyboard"] }, "Super"),
  separator: "+"
});
var ElectronAcceleratorLabelProvider = new ModifierLabelProvider({
  ctrlKey: "Ctrl",
  shiftKey: "Shift",
  altKey: "Alt",
  metaKey: "Cmd",
  separator: "+"
}, {
  ctrlKey: "Ctrl",
  shiftKey: "Shift",
  altKey: "Alt",
  metaKey: "Super",
  separator: "+"
});
var UserSettingsLabelProvider = new ModifierLabelProvider({
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "cmd",
  separator: "+"
}, {
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "win",
  separator: "+"
}, {
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "meta",
  separator: "+"
});
function _simpleAsString(modifiers, key, labels) {
  if (key === null) {
    return "";
  }
  const result = [];
  if (modifiers.ctrlKey) {
    result.push(labels.ctrlKey);
  }
  if (modifiers.shiftKey) {
    result.push(labels.shiftKey);
  }
  if (modifiers.altKey) {
    result.push(labels.altKey);
  }
  if (modifiers.metaKey) {
    result.push(labels.metaKey);
  }
  if (key !== "") {
    result.push(key);
  }
  return result.join(labels.separator);
}

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/baseResolvedKeybinding.js
init_keybindings();
var BaseResolvedKeybinding = class extends ResolvedKeybinding {
  constructor(os, chords) {
    super();
    if (chords.length === 0) {
      throw illegalArgument(`chords`);
    }
    this._os = os;
    this._chords = chords;
  }
  getLabel() {
    return UILabelProvider.toLabel(this._os, this._chords, (keybinding) => this._getLabel(keybinding));
  }
  getAriaLabel() {
    return AriaLabelProvider.toLabel(this._os, this._chords, (keybinding) => this._getAriaLabel(keybinding));
  }
  getElectronAccelerator() {
    if (this._chords.length > 1) {
      return null;
    }
    if (this._chords[0].isDuplicateModifierCase()) {
      return null;
    }
    return ElectronAcceleratorLabelProvider.toLabel(this._os, this._chords, (keybinding) => this._getElectronAccelerator(keybinding));
  }
  getUserSettingsLabel() {
    return UserSettingsLabelProvider.toLabel(this._os, this._chords, (keybinding) => this._getUserSettingsLabel(keybinding));
  }
  hasMultipleChords() {
    return this._chords.length > 1;
  }
  getChords() {
    return this._chords.map((keybinding) => this._getChord(keybinding));
  }
  _getChord(keybinding) {
    return new ResolvedChord(keybinding.ctrlKey, keybinding.shiftKey, keybinding.altKey, keybinding.metaKey, this._getLabel(keybinding), this._getAriaLabel(keybinding));
  }
  getDispatchChords() {
    return this._chords.map((keybinding) => this._getChordDispatch(keybinding));
  }
  getSingleModifierDispatchChords() {
    return this._chords.map((keybinding) => this._getSingleModifierChordDispatch(keybinding));
  }
};

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/usLayoutResolvedKeybinding.js
var USLayoutResolvedKeybinding = class _USLayoutResolvedKeybinding extends BaseResolvedKeybinding {
  constructor(chords, os) {
    super(os, chords);
  }
  _keyCodeToUILabel(keyCode) {
    if (this._os === 2) {
      switch (keyCode) {
        case 15:
          return "";
        case 16:
          return "";
        case 17:
          return "";
        case 18:
          return "";
      }
    }
    return KeyCodeUtils.toString(keyCode);
  }
  _getLabel(chord) {
    if (chord.isDuplicateModifierCase()) {
      return "";
    }
    return this._keyCodeToUILabel(chord.keyCode);
  }
  _getAriaLabel(chord) {
    if (chord.isDuplicateModifierCase()) {
      return "";
    }
    return KeyCodeUtils.toString(chord.keyCode);
  }
  _getElectronAccelerator(chord) {
    return KeyCodeUtils.toElectronAccelerator(chord.keyCode);
  }
  _getUserSettingsLabel(chord) {
    if (chord.isDuplicateModifierCase()) {
      return "";
    }
    const result = KeyCodeUtils.toUserSettingsUS(chord.keyCode);
    return result ? result.toLowerCase() : result;
  }
  _getChordDispatch(chord) {
    return _USLayoutResolvedKeybinding.getDispatchStr(chord);
  }
  static getDispatchStr(chord) {
    if (chord.isModifierKey()) {
      return null;
    }
    let result = "";
    if (chord.ctrlKey) {
      result += "ctrl+";
    }
    if (chord.shiftKey) {
      result += "shift+";
    }
    if (chord.altKey) {
      result += "alt+";
    }
    if (chord.metaKey) {
      result += "meta+";
    }
    result += KeyCodeUtils.toString(chord.keyCode);
    return result;
  }
  _getSingleModifierChordDispatch(keybinding) {
    if (keybinding.keyCode === 5 && !keybinding.shiftKey && !keybinding.altKey && !keybinding.metaKey) {
      return "ctrl";
    }
    if (keybinding.keyCode === 4 && !keybinding.ctrlKey && !keybinding.altKey && !keybinding.metaKey) {
      return "shift";
    }
    if (keybinding.keyCode === 6 && !keybinding.ctrlKey && !keybinding.shiftKey && !keybinding.metaKey) {
      return "alt";
    }
    if (keybinding.keyCode === 57 && !keybinding.ctrlKey && !keybinding.shiftKey && !keybinding.altKey) {
      return "meta";
    }
    return null;
  }
  /**
   * *NOTE*: Check return value for `KeyCode.Unknown`.
   */
  static _scanCodeToKeyCode(scanCode) {
    const immutableKeyCode = IMMUTABLE_CODE_TO_KEY_CODE[scanCode];
    if (immutableKeyCode !== -1) {
      return immutableKeyCode;
    }
    switch (scanCode) {
      case 10:
        return 31;
      case 11:
        return 32;
      case 12:
        return 33;
      case 13:
        return 34;
      case 14:
        return 35;
      case 15:
        return 36;
      case 16:
        return 37;
      case 17:
        return 38;
      case 18:
        return 39;
      case 19:
        return 40;
      case 20:
        return 41;
      case 21:
        return 42;
      case 22:
        return 43;
      case 23:
        return 44;
      case 24:
        return 45;
      case 25:
        return 46;
      case 26:
        return 47;
      case 27:
        return 48;
      case 28:
        return 49;
      case 29:
        return 50;
      case 30:
        return 51;
      case 31:
        return 52;
      case 32:
        return 53;
      case 33:
        return 54;
      case 34:
        return 55;
      case 35:
        return 56;
      case 36:
        return 22;
      case 37:
        return 23;
      case 38:
        return 24;
      case 39:
        return 25;
      case 40:
        return 26;
      case 41:
        return 27;
      case 42:
        return 28;
      case 43:
        return 29;
      case 44:
        return 30;
      case 45:
        return 21;
      case 51:
        return 88;
      case 52:
        return 86;
      case 53:
        return 92;
      case 54:
        return 94;
      case 55:
        return 93;
      case 56:
        return 0;
      case 57:
        return 85;
      case 58:
        return 95;
      case 59:
        return 91;
      case 60:
        return 87;
      case 61:
        return 89;
      case 62:
        return 90;
      case 106:
        return 97;
    }
    return 0;
  }
  static _toKeyCodeChord(chord) {
    if (!chord) {
      return null;
    }
    if (chord instanceof KeyCodeChord) {
      return chord;
    }
    const keyCode = this._scanCodeToKeyCode(chord.scanCode);
    if (keyCode === 0) {
      return null;
    }
    return new KeyCodeChord(chord.ctrlKey, chord.shiftKey, chord.altKey, chord.metaKey, keyCode);
  }
  static resolveKeybinding(keybinding, os) {
    const chords = toEmptyArrayIfContainsNull(keybinding.chords.map((chord) => this._toKeyCodeChord(chord)));
    if (chords.length > 0) {
      return [new _USLayoutResolvedKeybinding(chords, os)];
    }
    return [];
  }
};

// node_modules/monaco-editor/esm/vs/platform/label/common/label.js
init_instantiation();
var ILabelService = createDecorator("labelService");

// node_modules/monaco-editor/esm/vs/platform/progress/common/progress.js
init_instantiation();
var IProgressService = createDecorator("progressService");
var emptyProgressRunner = Object.freeze({
  total() {
  },
  worked() {
  },
  done() {
  }
});
var Progress = class {
  constructor(callback) {
    this.callback = callback;
  }
  report(item) {
    this._value = item;
    this.callback(this._value);
  }
};
Progress.None = Object.freeze({ report() {
} });
var IEditorProgressService = createDecorator("editorProgressService");

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
init_telemetry();

// node_modules/monaco-editor/esm/vs/platform/workspace/common/workspace.js
init_nls();
init_path();

// node_modules/monaco-editor/esm/vs/base/common/ternarySearchTree.js
init_strings();
var StringIterator = class {
  constructor() {
    this._value = "";
    this._pos = 0;
  }
  reset(key) {
    this._value = key;
    this._pos = 0;
    return this;
  }
  next() {
    this._pos += 1;
    return this;
  }
  hasNext() {
    return this._pos < this._value.length - 1;
  }
  cmp(a) {
    const aCode = a.charCodeAt(0);
    const thisCode = this._value.charCodeAt(this._pos);
    return aCode - thisCode;
  }
  value() {
    return this._value[this._pos];
  }
};
var ConfigKeysIterator = class {
  constructor(_caseSensitive = true) {
    this._caseSensitive = _caseSensitive;
  }
  reset(key) {
    this._value = key;
    this._from = 0;
    this._to = 0;
    return this.next();
  }
  hasNext() {
    return this._to < this._value.length;
  }
  next() {
    this._from = this._to;
    let justSeps = true;
    for (; this._to < this._value.length; this._to++) {
      const ch = this._value.charCodeAt(this._to);
      if (ch === 46) {
        if (justSeps) {
          this._from++;
        } else {
          break;
        }
      } else {
        justSeps = false;
      }
    }
    return this;
  }
  cmp(a) {
    return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
};
var PathIterator = class {
  constructor(_splitOnBackslash = true, _caseSensitive = true) {
    this._splitOnBackslash = _splitOnBackslash;
    this._caseSensitive = _caseSensitive;
  }
  reset(key) {
    this._from = 0;
    this._to = 0;
    this._value = key;
    this._valueLen = key.length;
    for (let pos = key.length - 1; pos >= 0; pos--, this._valueLen--) {
      const ch = this._value.charCodeAt(pos);
      if (!(ch === 47 || this._splitOnBackslash && ch === 92)) {
        break;
      }
    }
    return this.next();
  }
  hasNext() {
    return this._to < this._valueLen;
  }
  next() {
    this._from = this._to;
    let justSeps = true;
    for (; this._to < this._valueLen; this._to++) {
      const ch = this._value.charCodeAt(this._to);
      if (ch === 47 || this._splitOnBackslash && ch === 92) {
        if (justSeps) {
          this._from++;
        } else {
          break;
        }
      } else {
        justSeps = false;
      }
    }
    return this;
  }
  cmp(a) {
    return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
};
var UriIterator = class {
  constructor(_ignorePathCasing, _ignoreQueryAndFragment) {
    this._ignorePathCasing = _ignorePathCasing;
    this._ignoreQueryAndFragment = _ignoreQueryAndFragment;
    this._states = [];
    this._stateIdx = 0;
  }
  reset(key) {
    this._value = key;
    this._states = [];
    if (this._value.scheme) {
      this._states.push(
        1
        /* UriIteratorState.Scheme */
      );
    }
    if (this._value.authority) {
      this._states.push(
        2
        /* UriIteratorState.Authority */
      );
    }
    if (this._value.path) {
      this._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));
      this._pathIterator.reset(key.path);
      if (this._pathIterator.value()) {
        this._states.push(
          3
          /* UriIteratorState.Path */
        );
      }
    }
    if (!this._ignoreQueryAndFragment(key)) {
      if (this._value.query) {
        this._states.push(
          4
          /* UriIteratorState.Query */
        );
      }
      if (this._value.fragment) {
        this._states.push(
          5
          /* UriIteratorState.Fragment */
        );
      }
    }
    this._stateIdx = 0;
    return this;
  }
  next() {
    if (this._states[this._stateIdx] === 3 && this._pathIterator.hasNext()) {
      this._pathIterator.next();
    } else {
      this._stateIdx += 1;
    }
    return this;
  }
  hasNext() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
  }
  cmp(a) {
    if (this._states[this._stateIdx] === 1) {
      return compareIgnoreCase(a, this._value.scheme);
    } else if (this._states[this._stateIdx] === 2) {
      return compareIgnoreCase(a, this._value.authority);
    } else if (this._states[this._stateIdx] === 3) {
      return this._pathIterator.cmp(a);
    } else if (this._states[this._stateIdx] === 4) {
      return compare(a, this._value.query);
    } else if (this._states[this._stateIdx] === 5) {
      return compare(a, this._value.fragment);
    }
    throw new Error();
  }
  value() {
    if (this._states[this._stateIdx] === 1) {
      return this._value.scheme;
    } else if (this._states[this._stateIdx] === 2) {
      return this._value.authority;
    } else if (this._states[this._stateIdx] === 3) {
      return this._pathIterator.value();
    } else if (this._states[this._stateIdx] === 4) {
      return this._value.query;
    } else if (this._states[this._stateIdx] === 5) {
      return this._value.fragment;
    }
    throw new Error();
  }
};
var TernarySearchTreeNode = class {
  constructor() {
    this.height = 1;
  }
  rotateLeft() {
    const tmp = this.right;
    this.right = tmp.left;
    tmp.left = this;
    this.updateHeight();
    tmp.updateHeight();
    return tmp;
  }
  rotateRight() {
    const tmp = this.left;
    this.left = tmp.right;
    tmp.right = this;
    this.updateHeight();
    tmp.updateHeight();
    return tmp;
  }
  updateHeight() {
    this.height = 1 + Math.max(this.heightLeft, this.heightRight);
  }
  balanceFactor() {
    return this.heightRight - this.heightLeft;
  }
  get heightLeft() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.left) === null || _a2 === void 0 ? void 0 : _a2.height) !== null && _b2 !== void 0 ? _b2 : 0;
  }
  get heightRight() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.right) === null || _a2 === void 0 ? void 0 : _a2.height) !== null && _b2 !== void 0 ? _b2 : 0;
  }
};
var TernarySearchTree = class _TernarySearchTree {
  static forUris(ignorePathCasing = () => false, ignoreQueryAndFragment = () => false) {
    return new _TernarySearchTree(new UriIterator(ignorePathCasing, ignoreQueryAndFragment));
  }
  static forStrings() {
    return new _TernarySearchTree(new StringIterator());
  }
  static forConfigKeys() {
    return new _TernarySearchTree(new ConfigKeysIterator());
  }
  constructor(segments) {
    this._iter = segments;
  }
  clear() {
    this._root = void 0;
  }
  set(key, element) {
    const iter = this._iter.reset(key);
    let node;
    if (!this._root) {
      this._root = new TernarySearchTreeNode();
      this._root.segment = iter.value();
    }
    const stack = [];
    node = this._root;
    while (true) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        if (!node.left) {
          node.left = new TernarySearchTreeNode();
          node.left.segment = iter.value();
        }
        stack.push([-1, node]);
        node = node.left;
      } else if (val < 0) {
        if (!node.right) {
          node.right = new TernarySearchTreeNode();
          node.right.segment = iter.value();
        }
        stack.push([1, node]);
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        if (!node.mid) {
          node.mid = new TernarySearchTreeNode();
          node.mid.segment = iter.value();
        }
        stack.push([0, node]);
        node = node.mid;
      } else {
        break;
      }
    }
    const oldElement = node.value;
    node.value = element;
    node.key = key;
    for (let i = stack.length - 1; i >= 0; i--) {
      const node2 = stack[i][1];
      node2.updateHeight();
      const bf = node2.balanceFactor();
      if (bf < -1 || bf > 1) {
        const d1 = stack[i][0];
        const d2 = stack[i + 1][0];
        if (d1 === 1 && d2 === 1) {
          stack[i][1] = node2.rotateLeft();
        } else if (d1 === -1 && d2 === -1) {
          stack[i][1] = node2.rotateRight();
        } else if (d1 === 1 && d2 === -1) {
          node2.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();
          stack[i][1] = node2.rotateLeft();
        } else if (d1 === -1 && d2 === 1) {
          node2.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();
          stack[i][1] = node2.rotateRight();
        } else {
          throw new Error();
        }
        if (i > 0) {
          switch (stack[i - 1][0]) {
            case -1:
              stack[i - 1][1].left = stack[i][1];
              break;
            case 1:
              stack[i - 1][1].right = stack[i][1];
              break;
            case 0:
              stack[i - 1][1].mid = stack[i][1];
              break;
          }
        } else {
          this._root = stack[0][1];
        }
      }
    }
    return oldElement;
  }
  get(key) {
    var _a2;
    return (_a2 = this._getNode(key)) === null || _a2 === void 0 ? void 0 : _a2.value;
  }
  _getNode(key) {
    const iter = this._iter.reset(key);
    let node = this._root;
    while (node) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        node = node.left;
      } else if (val < 0) {
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        node = node.mid;
      } else {
        break;
      }
    }
    return node;
  }
  has(key) {
    const node = this._getNode(key);
    return !((node === null || node === void 0 ? void 0 : node.value) === void 0 && (node === null || node === void 0 ? void 0 : node.mid) === void 0);
  }
  delete(key) {
    return this._delete(key, false);
  }
  deleteSuperstr(key) {
    return this._delete(key, true);
  }
  _delete(key, superStr) {
    var _a2;
    const iter = this._iter.reset(key);
    const stack = [];
    let node = this._root;
    while (node) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        stack.push([-1, node]);
        node = node.left;
      } else if (val < 0) {
        stack.push([1, node]);
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        stack.push([0, node]);
        node = node.mid;
      } else {
        break;
      }
    }
    if (!node) {
      return;
    }
    if (superStr) {
      node.left = void 0;
      node.mid = void 0;
      node.right = void 0;
      node.height = 1;
    } else {
      node.key = void 0;
      node.value = void 0;
    }
    if (!node.mid && !node.value) {
      if (node.left && node.right) {
        const min = this._min(node.right);
        if (min.key) {
          const { key: key2, value, segment } = min;
          this._delete(min.key, false);
          node.key = key2;
          node.value = value;
          node.segment = segment;
        }
      } else {
        const newChild = (_a2 = node.left) !== null && _a2 !== void 0 ? _a2 : node.right;
        if (stack.length > 0) {
          const [dir, parent] = stack[stack.length - 1];
          switch (dir) {
            case -1:
              parent.left = newChild;
              break;
            case 0:
              parent.mid = newChild;
              break;
            case 1:
              parent.right = newChild;
              break;
          }
        } else {
          this._root = newChild;
        }
      }
    }
    for (let i = stack.length - 1; i >= 0; i--) {
      const node2 = stack[i][1];
      node2.updateHeight();
      const bf = node2.balanceFactor();
      if (bf > 1) {
        if (node2.right.balanceFactor() >= 0) {
          stack[i][1] = node2.rotateLeft();
        } else {
          node2.right = node2.right.rotateRight();
          stack[i][1] = node2.rotateLeft();
        }
      } else if (bf < -1) {
        if (node2.left.balanceFactor() <= 0) {
          stack[i][1] = node2.rotateRight();
        } else {
          node2.left = node2.left.rotateLeft();
          stack[i][1] = node2.rotateRight();
        }
      }
      if (i > 0) {
        switch (stack[i - 1][0]) {
          case -1:
            stack[i - 1][1].left = stack[i][1];
            break;
          case 1:
            stack[i - 1][1].right = stack[i][1];
            break;
          case 0:
            stack[i - 1][1].mid = stack[i][1];
            break;
        }
      } else {
        this._root = stack[0][1];
      }
    }
  }
  _min(node) {
    while (node.left) {
      node = node.left;
    }
    return node;
  }
  findSubstr(key) {
    const iter = this._iter.reset(key);
    let node = this._root;
    let candidate = void 0;
    while (node) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        node = node.left;
      } else if (val < 0) {
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        candidate = node.value || candidate;
        node = node.mid;
      } else {
        break;
      }
    }
    return node && node.value || candidate;
  }
  findSuperstr(key) {
    return this._findSuperstrOrElement(key, false);
  }
  _findSuperstrOrElement(key, allowValue) {
    const iter = this._iter.reset(key);
    let node = this._root;
    while (node) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        node = node.left;
      } else if (val < 0) {
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        node = node.mid;
      } else {
        if (!node.mid) {
          if (allowValue) {
            return node.value;
          } else {
            return void 0;
          }
        } else {
          return this._entries(node.mid);
        }
      }
    }
    return void 0;
  }
  forEach(callback) {
    for (const [key, value] of this) {
      callback(value, key);
    }
  }
  *[Symbol.iterator]() {
    yield* this._entries(this._root);
  }
  _entries(node) {
    const result = [];
    this._dfsEntries(node, result);
    return result[Symbol.iterator]();
  }
  _dfsEntries(node, bucket) {
    if (!node) {
      return;
    }
    if (node.left) {
      this._dfsEntries(node.left, bucket);
    }
    if (node.value) {
      bucket.push([node.key, node.value]);
    }
    if (node.mid) {
      this._dfsEntries(node.mid, bucket);
    }
    if (node.right) {
      this._dfsEntries(node.right, bucket);
    }
  }
};

// node_modules/monaco-editor/esm/vs/platform/workspace/common/workspace.js
init_uri();
init_instantiation();
var IWorkspaceContextService = createDecorator("contextService");
function isSingleFolderWorkspaceIdentifier(obj) {
  const singleFolderIdentifier = obj;
  return typeof (singleFolderIdentifier === null || singleFolderIdentifier === void 0 ? void 0 : singleFolderIdentifier.id) === "string" && URI.isUri(singleFolderIdentifier.uri);
}
function isEmptyWorkspaceIdentifier(obj) {
  const emptyWorkspaceIdentifier = obj;
  return typeof (emptyWorkspaceIdentifier === null || emptyWorkspaceIdentifier === void 0 ? void 0 : emptyWorkspaceIdentifier.id) === "string" && !isSingleFolderWorkspaceIdentifier(obj) && !isWorkspaceIdentifier(obj);
}
var EXTENSION_DEVELOPMENT_EMPTY_WINDOW_WORKSPACE = { id: "ext-dev" };
var UNKNOWN_EMPTY_WINDOW_WORKSPACE = { id: "empty-window" };
function toWorkspaceIdentifier(arg0, isExtensionDevelopment) {
  if (typeof arg0 === "string" || typeof arg0 === "undefined") {
    if (typeof arg0 === "string") {
      return {
        id: basename(arg0)
      };
    }
    if (isExtensionDevelopment) {
      return EXTENSION_DEVELOPMENT_EMPTY_WINDOW_WORKSPACE;
    }
    return UNKNOWN_EMPTY_WINDOW_WORKSPACE;
  }
  const workspace = arg0;
  if (workspace.configuration) {
    return {
      id: workspace.id,
      configPath: workspace.configuration
    };
  }
  if (workspace.folders.length === 1) {
    return {
      id: workspace.id,
      uri: workspace.folders[0].uri
    };
  }
  return {
    id: workspace.id
  };
}
function isWorkspaceIdentifier(obj) {
  const workspaceIdentifier = obj;
  return typeof (workspaceIdentifier === null || workspaceIdentifier === void 0 ? void 0 : workspaceIdentifier.id) === "string" && URI.isUri(workspaceIdentifier.configPath);
}
var WorkspaceFolder = class {
  constructor(data, raw) {
    this.raw = raw;
    this.uri = data.uri;
    this.index = data.index;
    this.name = data.name;
  }
  toJSON() {
    return { uri: this.uri, name: this.name, index: this.index };
  }
};
var WORKSPACE_EXTENSION = "code-workspace";
var WORKSPACE_FILTER = [{ name: localize("codeWorkspace", "Code Workspace"), extensions: [WORKSPACE_EXTENSION] }];
var STANDALONE_EDITOR_WORKSPACE_ID = "4064f6ec-cb38-4ad0-af64-ee6467e63c82";
function isStandaloneEditorWorkspace(workspace) {
  return workspace.id === STANDALONE_EDITOR_WORKSPACE_ID;
}

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
init_standaloneStrings();
init_resources();
init_codeEditorService();
init_log();

// node_modules/monaco-editor/esm/vs/platform/workspace/common/workspaceTrust.js
init_instantiation();
var IWorkspaceTrustManagementService = createDecorator("workspaceTrustManagementService");

// node_modules/monaco-editor/esm/vs/editor/common/services/languageService.js
init_event();
init_lifecycle();

// node_modules/monaco-editor/esm/vs/editor/common/services/languagesRegistry.js
init_event();
init_lifecycle();
init_strings();

// node_modules/monaco-editor/esm/vs/editor/common/services/languagesAssociations.js
init_mime();
init_network();
init_path();
init_resources();
init_strings();
init_modesRegistry();
var registeredAssociations = [];
var nonUserRegisteredAssociations = [];
var userRegisteredAssociations = [];
function registerPlatformLanguageAssociation(association, warnOnOverwrite = false) {
  _registerLanguageAssociation(association, false, warnOnOverwrite);
}
function _registerLanguageAssociation(association, userConfigured, warnOnOverwrite) {
  const associationItem = toLanguageAssociationItem(association, userConfigured);
  registeredAssociations.push(associationItem);
  if (!associationItem.userConfigured) {
    nonUserRegisteredAssociations.push(associationItem);
  } else {
    userRegisteredAssociations.push(associationItem);
  }
  if (warnOnOverwrite && !associationItem.userConfigured) {
    registeredAssociations.forEach((a) => {
      if (a.mime === associationItem.mime || a.userConfigured) {
        return;
      }
      if (associationItem.extension && a.extension === associationItem.extension) {
        console.warn(`Overwriting extension <<${associationItem.extension}>> to now point to mime <<${associationItem.mime}>>`);
      }
      if (associationItem.filename && a.filename === associationItem.filename) {
        console.warn(`Overwriting filename <<${associationItem.filename}>> to now point to mime <<${associationItem.mime}>>`);
      }
      if (associationItem.filepattern && a.filepattern === associationItem.filepattern) {
        console.warn(`Overwriting filepattern <<${associationItem.filepattern}>> to now point to mime <<${associationItem.mime}>>`);
      }
      if (associationItem.firstline && a.firstline === associationItem.firstline) {
        console.warn(`Overwriting firstline <<${associationItem.firstline}>> to now point to mime <<${associationItem.mime}>>`);
      }
    });
  }
}
function toLanguageAssociationItem(association, userConfigured) {
  return {
    id: association.id,
    mime: association.mime,
    filename: association.filename,
    extension: association.extension,
    filepattern: association.filepattern,
    firstline: association.firstline,
    userConfigured,
    filenameLowercase: association.filename ? association.filename.toLowerCase() : void 0,
    extensionLowercase: association.extension ? association.extension.toLowerCase() : void 0,
    filepatternLowercase: association.filepattern ? parse(association.filepattern.toLowerCase()) : void 0,
    filepatternOnPath: association.filepattern ? association.filepattern.indexOf(posix.sep) >= 0 : false
  };
}
function clearPlatformLanguageAssociations() {
  registeredAssociations = registeredAssociations.filter((a) => a.userConfigured);
  nonUserRegisteredAssociations = [];
}
function getLanguageIds(resource, firstLine) {
  return getAssociations(resource, firstLine).map((item) => item.id);
}
function getAssociations(resource, firstLine) {
  let path;
  if (resource) {
    switch (resource.scheme) {
      case Schemas.file:
        path = resource.fsPath;
        break;
      case Schemas.data: {
        const metadata = DataUri.parseMetaData(resource);
        path = metadata.get(DataUri.META_DATA_LABEL);
        break;
      }
      case Schemas.vscodeNotebookCell:
        path = void 0;
        break;
      default:
        path = resource.path;
    }
  }
  if (!path) {
    return [{ id: "unknown", mime: Mimes.unknown }];
  }
  path = path.toLowerCase();
  const filename = basename(path);
  const configuredLanguage = getAssociationByPath(path, filename, userRegisteredAssociations);
  if (configuredLanguage) {
    return [configuredLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];
  }
  const registeredLanguage = getAssociationByPath(path, filename, nonUserRegisteredAssociations);
  if (registeredLanguage) {
    return [registeredLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];
  }
  if (firstLine) {
    const firstlineLanguage = getAssociationByFirstline(firstLine);
    if (firstlineLanguage) {
      return [firstlineLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];
    }
  }
  return [{ id: "unknown", mime: Mimes.unknown }];
}
function getAssociationByPath(path, filename, associations) {
  var _a2;
  let filenameMatch = void 0;
  let patternMatch = void 0;
  let extensionMatch = void 0;
  for (let i = associations.length - 1; i >= 0; i--) {
    const association = associations[i];
    if (filename === association.filenameLowercase) {
      filenameMatch = association;
      break;
    }
    if (association.filepattern) {
      if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {
        const target = association.filepatternOnPath ? path : filename;
        if ((_a2 = association.filepatternLowercase) === null || _a2 === void 0 ? void 0 : _a2.call(association, target)) {
          patternMatch = association;
        }
      }
    }
    if (association.extension) {
      if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {
        if (filename.endsWith(association.extensionLowercase)) {
          extensionMatch = association;
        }
      }
    }
  }
  if (filenameMatch) {
    return filenameMatch;
  }
  if (patternMatch) {
    return patternMatch;
  }
  if (extensionMatch) {
    return extensionMatch;
  }
  return void 0;
}
function getAssociationByFirstline(firstLine) {
  if (startsWithUTF8BOM(firstLine)) {
    firstLine = firstLine.substr(1);
  }
  if (firstLine.length > 0) {
    for (let i = registeredAssociations.length - 1; i >= 0; i--) {
      const association = registeredAssociations[i];
      if (!association.firstline) {
        continue;
      }
      const matches = firstLine.match(association.firstline);
      if (matches && matches.length > 0) {
        return association;
      }
    }
  }
  return void 0;
}

// node_modules/monaco-editor/esm/vs/editor/common/services/languagesRegistry.js
init_modesRegistry();
init_configurationRegistry();
init_platform2();
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
var NULL_LANGUAGE_ID = "vs.editor.nullLanguage";
var LanguageIdCodec = class {
  constructor() {
    this._languageIdToLanguage = [];
    this._languageToLanguageId = /* @__PURE__ */ new Map();
    this._register(
      NULL_LANGUAGE_ID,
      0
      /* LanguageId.Null */
    );
    this._register(
      PLAINTEXT_LANGUAGE_ID,
      1
      /* LanguageId.PlainText */
    );
    this._nextLanguageId = 2;
  }
  _register(language, languageId) {
    this._languageIdToLanguage[languageId] = language;
    this._languageToLanguageId.set(language, languageId);
  }
  register(language) {
    if (this._languageToLanguageId.has(language)) {
      return;
    }
    const languageId = this._nextLanguageId++;
    this._register(language, languageId);
  }
  encodeLanguageId(languageId) {
    return this._languageToLanguageId.get(languageId) || 0;
  }
  decodeLanguageId(languageId) {
    return this._languageIdToLanguage[languageId] || NULL_LANGUAGE_ID;
  }
};
var LanguagesRegistry = class _LanguagesRegistry extends Disposable {
  constructor(useModesRegistry = true, warnOnOverwrite = false) {
    super();
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    _LanguagesRegistry.instanceCount++;
    this._warnOnOverwrite = warnOnOverwrite;
    this.languageIdCodec = new LanguageIdCodec();
    this._dynamicLanguages = [];
    this._languages = {};
    this._mimeTypesMap = {};
    this._nameMap = {};
    this._lowercaseNameMap = {};
    if (useModesRegistry) {
      this._initializeFromRegistry();
      this._register(ModesRegistry.onDidChangeLanguages((m) => {
        this._initializeFromRegistry();
      }));
    }
  }
  dispose() {
    _LanguagesRegistry.instanceCount--;
    super.dispose();
  }
  _initializeFromRegistry() {
    this._languages = {};
    this._mimeTypesMap = {};
    this._nameMap = {};
    this._lowercaseNameMap = {};
    clearPlatformLanguageAssociations();
    const desc = [].concat(ModesRegistry.getLanguages()).concat(this._dynamicLanguages);
    this._registerLanguages(desc);
  }
  _registerLanguages(desc) {
    for (const d of desc) {
      this._registerLanguage(d);
    }
    this._mimeTypesMap = {};
    this._nameMap = {};
    this._lowercaseNameMap = {};
    Object.keys(this._languages).forEach((langId) => {
      const language = this._languages[langId];
      if (language.name) {
        this._nameMap[language.name] = language.identifier;
      }
      language.aliases.forEach((alias) => {
        this._lowercaseNameMap[alias.toLowerCase()] = language.identifier;
      });
      language.mimetypes.forEach((mimetype) => {
        this._mimeTypesMap[mimetype] = language.identifier;
      });
    });
    Registry.as(Extensions2.Configuration).registerOverrideIdentifiers(this.getRegisteredLanguageIds());
    this._onDidChange.fire();
  }
  _registerLanguage(lang) {
    const langId = lang.id;
    let resolvedLanguage;
    if (hasOwnProperty2.call(this._languages, langId)) {
      resolvedLanguage = this._languages[langId];
    } else {
      this.languageIdCodec.register(langId);
      resolvedLanguage = {
        identifier: langId,
        name: null,
        mimetypes: [],
        aliases: [],
        extensions: [],
        filenames: [],
        configurationFiles: [],
        icons: []
      };
      this._languages[langId] = resolvedLanguage;
    }
    this._mergeLanguage(resolvedLanguage, lang);
  }
  _mergeLanguage(resolvedLanguage, lang) {
    const langId = lang.id;
    let primaryMime = null;
    if (Array.isArray(lang.mimetypes) && lang.mimetypes.length > 0) {
      resolvedLanguage.mimetypes.push(...lang.mimetypes);
      primaryMime = lang.mimetypes[0];
    }
    if (!primaryMime) {
      primaryMime = `text/x-${langId}`;
      resolvedLanguage.mimetypes.push(primaryMime);
    }
    if (Array.isArray(lang.extensions)) {
      if (lang.configuration) {
        resolvedLanguage.extensions = lang.extensions.concat(resolvedLanguage.extensions);
      } else {
        resolvedLanguage.extensions = resolvedLanguage.extensions.concat(lang.extensions);
      }
      for (const extension of lang.extensions) {
        registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, extension }, this._warnOnOverwrite);
      }
    }
    if (Array.isArray(lang.filenames)) {
      for (const filename of lang.filenames) {
        registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, filename }, this._warnOnOverwrite);
        resolvedLanguage.filenames.push(filename);
      }
    }
    if (Array.isArray(lang.filenamePatterns)) {
      for (const filenamePattern of lang.filenamePatterns) {
        registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, filepattern: filenamePattern }, this._warnOnOverwrite);
      }
    }
    if (typeof lang.firstLine === "string" && lang.firstLine.length > 0) {
      let firstLineRegexStr = lang.firstLine;
      if (firstLineRegexStr.charAt(0) !== "^") {
        firstLineRegexStr = "^" + firstLineRegexStr;
      }
      try {
        const firstLineRegex = new RegExp(firstLineRegexStr);
        if (!regExpLeadsToEndlessLoop(firstLineRegex)) {
          registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, firstline: firstLineRegex }, this._warnOnOverwrite);
        }
      } catch (err) {
        console.warn(`[${lang.id}]: Invalid regular expression \`${firstLineRegexStr}\`: `, err);
      }
    }
    resolvedLanguage.aliases.push(langId);
    let langAliases = null;
    if (typeof lang.aliases !== "undefined" && Array.isArray(lang.aliases)) {
      if (lang.aliases.length === 0) {
        langAliases = [null];
      } else {
        langAliases = lang.aliases;
      }
    }
    if (langAliases !== null) {
      for (const langAlias of langAliases) {
        if (!langAlias || langAlias.length === 0) {
          continue;
        }
        resolvedLanguage.aliases.push(langAlias);
      }
    }
    const containsAliases = langAliases !== null && langAliases.length > 0;
    if (containsAliases && langAliases[0] === null) {
    } else {
      const bestName = (containsAliases ? langAliases[0] : null) || langId;
      if (containsAliases || !resolvedLanguage.name) {
        resolvedLanguage.name = bestName;
      }
    }
    if (lang.configuration) {
      resolvedLanguage.configurationFiles.push(lang.configuration);
    }
    if (lang.icon) {
      resolvedLanguage.icons.push(lang.icon);
    }
  }
  isRegisteredLanguageId(languageId) {
    if (!languageId) {
      return false;
    }
    return hasOwnProperty2.call(this._languages, languageId);
  }
  getRegisteredLanguageIds() {
    return Object.keys(this._languages);
  }
  getLanguageIdByLanguageName(languageName) {
    const languageNameLower = languageName.toLowerCase();
    if (!hasOwnProperty2.call(this._lowercaseNameMap, languageNameLower)) {
      return null;
    }
    return this._lowercaseNameMap[languageNameLower];
  }
  getLanguageIdByMimeType(mimeType) {
    if (!mimeType) {
      return null;
    }
    if (hasOwnProperty2.call(this._mimeTypesMap, mimeType)) {
      return this._mimeTypesMap[mimeType];
    }
    return null;
  }
  guessLanguageIdByFilepathOrFirstLine(resource, firstLine) {
    if (!resource && !firstLine) {
      return [];
    }
    return getLanguageIds(resource, firstLine);
  }
};
LanguagesRegistry.instanceCount = 0;

// node_modules/monaco-editor/esm/vs/editor/common/services/languageService.js
init_arrays();
init_languages();
init_modesRegistry();
var LanguageService = class _LanguageService extends Disposable {
  constructor(warnOnOverwrite = false) {
    super();
    this._onDidRequestBasicLanguageFeatures = this._register(new Emitter());
    this.onDidRequestBasicLanguageFeatures = this._onDidRequestBasicLanguageFeatures.event;
    this._onDidRequestRichLanguageFeatures = this._register(new Emitter());
    this.onDidRequestRichLanguageFeatures = this._onDidRequestRichLanguageFeatures.event;
    this._onDidChange = this._register(new Emitter({
      leakWarningThreshold: 200
      /* https://github.com/microsoft/vscode/issues/119968 */
    }));
    this.onDidChange = this._onDidChange.event;
    this._requestedBasicLanguages = /* @__PURE__ */ new Set();
    this._requestedRichLanguages = /* @__PURE__ */ new Set();
    _LanguageService.instanceCount++;
    this._registry = this._register(new LanguagesRegistry(true, warnOnOverwrite));
    this.languageIdCodec = this._registry.languageIdCodec;
    this._register(this._registry.onDidChange(() => this._onDidChange.fire()));
  }
  dispose() {
    _LanguageService.instanceCount--;
    super.dispose();
  }
  isRegisteredLanguageId(languageId) {
    return this._registry.isRegisteredLanguageId(languageId);
  }
  getLanguageIdByLanguageName(languageName) {
    return this._registry.getLanguageIdByLanguageName(languageName);
  }
  getLanguageIdByMimeType(mimeType) {
    return this._registry.getLanguageIdByMimeType(mimeType);
  }
  guessLanguageIdByFilepathOrFirstLine(resource, firstLine) {
    const languageIds = this._registry.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);
    return firstOrDefault(languageIds, null);
  }
  createById(languageId) {
    return new LanguageSelection(this.onDidChange, () => {
      return this._createAndGetLanguageIdentifier(languageId);
    });
  }
  createByFilepathOrFirstLine(resource, firstLine) {
    return new LanguageSelection(this.onDidChange, () => {
      const languageId = this.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);
      return this._createAndGetLanguageIdentifier(languageId);
    });
  }
  _createAndGetLanguageIdentifier(languageId) {
    if (!languageId || !this.isRegisteredLanguageId(languageId)) {
      languageId = PLAINTEXT_LANGUAGE_ID;
    }
    return languageId;
  }
  requestBasicLanguageFeatures(languageId) {
    if (!this._requestedBasicLanguages.has(languageId)) {
      this._requestedBasicLanguages.add(languageId);
      this._onDidRequestBasicLanguageFeatures.fire(languageId);
    }
  }
  requestRichLanguageFeatures(languageId) {
    if (!this._requestedRichLanguages.has(languageId)) {
      this._requestedRichLanguages.add(languageId);
      this.requestBasicLanguageFeatures(languageId);
      TokenizationRegistry2.getOrCreate(languageId);
      this._onDidRequestRichLanguageFeatures.fire(languageId);
    }
  }
};
LanguageService.instanceCount = 0;
var LanguageSelection = class {
  constructor(_onDidChangeLanguages, _selector) {
    this._onDidChangeLanguages = _onDidChangeLanguages;
    this._selector = _selector;
    this._listener = null;
    this._emitter = null;
    this.languageId = this._selector();
  }
  _dispose() {
    if (this._listener) {
      this._listener.dispose();
      this._listener = null;
    }
    if (this._emitter) {
      this._emitter.dispose();
      this._emitter = null;
    }
  }
  get onDidChange() {
    if (!this._listener) {
      this._listener = this._onDidChangeLanguages(() => this._evaluate());
    }
    if (!this._emitter) {
      this._emitter = new Emitter({
        onDidRemoveLastListener: () => {
          this._dispose();
        }
      });
    }
    return this._emitter.event;
  }
  _evaluate() {
    var _a2;
    const languageId = this._selector();
    if (languageId === this.languageId) {
      return;
    }
    this.languageId = languageId;
    (_a2 = this._emitter) === null || _a2 === void 0 ? void 0 : _a2.fire(this.languageId);
  }
};

// node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextMenuService.js
init_dom();
init_actions();
init_event();
init_lifecycle();

// node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js
init_dom();
init_keyboardEvent();

// node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionViewItems.js
init_browser();

// node_modules/monaco-editor/esm/vs/base/browser/dnd.js
init_mime();
var DataTransfers = {
  /**
   * Application specific resource transfer type
   */
  RESOURCES: "ResourceURLs",
  /**
   * Browser specific transfer type to download
   */
  DOWNLOAD_URL: "DownloadURL",
  /**
   * Browser specific transfer type for files
   */
  FILES: "Files",
  /**
   * Typically transfer type for copy/paste transfers.
   */
  TEXT: Mimes.text,
  /**
   * Internal type used to pass around text/uri-list data.
   *
   * This is needed to work around https://bugs.chromium.org/p/chromium/issues/detail?id=239745.
   */
  INTERNAL_URI_LIST: "application/vnd.code.uri-list"
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionViewItems.js
init_dom();

// node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hoverDelegate.js
init_lazy();
var nullHoverDelegateFactory = () => ({
  get delay() {
    return -1;
  },
  dispose: () => {
  },
  showHover: () => {
    return void 0;
  }
});
var hoverDelegateFactory = nullHoverDelegateFactory;
var defaultHoverDelegateMouse = new Lazy(() => hoverDelegateFactory("mouse", false));
var defaultHoverDelegateElement = new Lazy(() => hoverDelegateFactory("element", false));
function setHoverDelegateFactory(hoverDelegateProvider) {
  hoverDelegateFactory = hoverDelegateProvider;
}
function getDefaultHoverDelegate(placement, enableInstantHover) {
  if (enableInstantHover) {
    return hoverDelegateFactory(placement, true);
  }
  if (placement === "element") {
    return defaultHoverDelegateElement.value;
  }
  return defaultHoverDelegateMouse.value;
}

// node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabelHover.js
init_dom();
init_async();
init_cancellation();
init_htmlContent();
init_iconLabels2();
init_lifecycle();
init_types();
init_nls();
function setupNativeHover(htmlElement, tooltip) {
  if (isString(tooltip)) {
    htmlElement.title = stripIcons(tooltip);
  } else if (tooltip === null || tooltip === void 0 ? void 0 : tooltip.markdownNotSupportedFallback) {
    htmlElement.title = tooltip.markdownNotSupportedFallback;
  } else {
    htmlElement.removeAttribute("title");
  }
}
var UpdatableHoverWidget = class {
  constructor(hoverDelegate, target, fadeInAnimation) {
    this.hoverDelegate = hoverDelegate;
    this.target = target;
    this.fadeInAnimation = fadeInAnimation;
  }
  async update(content, focus, options2) {
    var _a2;
    if (this._cancellationTokenSource) {
      this._cancellationTokenSource.dispose(true);
      this._cancellationTokenSource = void 0;
    }
    if (this.isDisposed) {
      return;
    }
    let resolvedContent;
    if (content === void 0 || isString(content) || content instanceof HTMLElement) {
      resolvedContent = content;
    } else if (!isFunction(content.markdown)) {
      resolvedContent = (_a2 = content.markdown) !== null && _a2 !== void 0 ? _a2 : content.markdownNotSupportedFallback;
    } else {
      if (!this._hoverWidget) {
        this.show(localize("iconLabel.loading", "Loading..."), focus);
      }
      this._cancellationTokenSource = new CancellationTokenSource();
      const token = this._cancellationTokenSource.token;
      resolvedContent = await content.markdown(token);
      if (resolvedContent === void 0) {
        resolvedContent = content.markdownNotSupportedFallback;
      }
      if (this.isDisposed || token.isCancellationRequested) {
        return;
      }
    }
    this.show(resolvedContent, focus, options2);
  }
  show(content, focus, options2) {
    const oldHoverWidget = this._hoverWidget;
    if (this.hasContent(content)) {
      const hoverOptions = {
        content,
        target: this.target,
        appearance: {
          showPointer: this.hoverDelegate.placement === "element",
          skipFadeInAnimation: !this.fadeInAnimation || !!oldHoverWidget
          // do not fade in if the hover is already showing
        },
        position: {
          hoverPosition: 2
        },
        ...options2
      };
      this._hoverWidget = this.hoverDelegate.showHover(hoverOptions, focus);
    }
    oldHoverWidget === null || oldHoverWidget === void 0 ? void 0 : oldHoverWidget.dispose();
  }
  hasContent(content) {
    if (!content) {
      return false;
    }
    if (isMarkdownString(content)) {
      return !!content.value;
    }
    return true;
  }
  get isDisposed() {
    var _a2;
    return (_a2 = this._hoverWidget) === null || _a2 === void 0 ? void 0 : _a2.isDisposed;
  }
  dispose() {
    var _a2, _b2;
    (_a2 = this._hoverWidget) === null || _a2 === void 0 ? void 0 : _a2.dispose();
    (_b2 = this._cancellationTokenSource) === null || _b2 === void 0 ? void 0 : _b2.dispose(true);
    this._cancellationTokenSource = void 0;
  }
};
function setupCustomHover(hoverDelegate, htmlElement, content, options2) {
  let hoverPreparation;
  let hoverWidget;
  const hideHover = (disposeWidget, disposePreparation) => {
    var _a2;
    const hadHover = hoverWidget !== void 0;
    if (disposeWidget) {
      hoverWidget === null || hoverWidget === void 0 ? void 0 : hoverWidget.dispose();
      hoverWidget = void 0;
    }
    if (disposePreparation) {
      hoverPreparation === null || hoverPreparation === void 0 ? void 0 : hoverPreparation.dispose();
      hoverPreparation = void 0;
    }
    if (hadHover) {
      (_a2 = hoverDelegate.onDidHideHover) === null || _a2 === void 0 ? void 0 : _a2.call(hoverDelegate);
      hoverWidget = void 0;
    }
  };
  const triggerShowHover = (delay, focus, target) => {
    return new TimeoutTimer(async () => {
      if (!hoverWidget || hoverWidget.isDisposed) {
        hoverWidget = new UpdatableHoverWidget(hoverDelegate, target || htmlElement, delay > 0);
        await hoverWidget.update(typeof content === "function" ? content() : content, focus, options2);
      }
    }, delay);
  };
  let isMouseDown = false;
  const mouseDownEmitter = addDisposableListener(htmlElement, EventType.MOUSE_DOWN, () => {
    isMouseDown = true;
    hideHover(true, true);
  }, true);
  const mouseUpEmitter = addDisposableListener(htmlElement, EventType.MOUSE_UP, () => {
    isMouseDown = false;
  }, true);
  const mouseLeaveEmitter = addDisposableListener(htmlElement, EventType.MOUSE_LEAVE, (e) => {
    isMouseDown = false;
    hideHover(false, e.fromElement === htmlElement);
  }, true);
  const onMouseOver = () => {
    if (hoverPreparation) {
      return;
    }
    const toDispose = new DisposableStore();
    const target = {
      targetElements: [htmlElement],
      dispose: () => {
      }
    };
    if (hoverDelegate.placement === void 0 || hoverDelegate.placement === "mouse") {
      const onMouseMove = (e) => {
        target.x = e.x + 10;
        if (e.target instanceof HTMLElement && e.target.classList.contains("action-label")) {
          hideHover(true, true);
        }
      };
      toDispose.add(addDisposableListener(htmlElement, EventType.MOUSE_MOVE, onMouseMove, true));
    }
    toDispose.add(triggerShowHover(hoverDelegate.delay, false, target));
    hoverPreparation = toDispose;
  };
  const mouseOverDomEmitter = addDisposableListener(htmlElement, EventType.MOUSE_OVER, onMouseOver, true);
  const onFocus = () => {
    if (isMouseDown || hoverPreparation) {
      return;
    }
    const target = {
      targetElements: [htmlElement],
      dispose: () => {
      }
    };
    const toDispose = new DisposableStore();
    const onBlur = () => hideHover(true, true);
    toDispose.add(addDisposableListener(htmlElement, EventType.BLUR, onBlur, true));
    toDispose.add(triggerShowHover(hoverDelegate.delay, false, target));
    hoverPreparation = toDispose;
  };
  const focusDomEmitter = addDisposableListener(htmlElement, EventType.FOCUS, onFocus, true);
  const hover = {
    show: (focus) => {
      hideHover(false, true);
      triggerShowHover(0, focus);
    },
    hide: () => {
      hideHover(true, true);
    },
    update: async (newContent, hoverOptions) => {
      content = newContent;
      await (hoverWidget === null || hoverWidget === void 0 ? void 0 : hoverWidget.update(content, void 0, hoverOptions));
    },
    dispose: () => {
      mouseOverDomEmitter.dispose();
      mouseLeaveEmitter.dispose();
      mouseDownEmitter.dispose();
      mouseUpEmitter.dispose();
      focusDomEmitter.dispose();
      hideHover(true, true);
    }
  };
  return hover;
}

// node_modules/monaco-editor/esm/vs/base/browser/ui/selectBox/selectBoxCustom.js
init_dom();
init_keyboardEvent();

// node_modules/monaco-editor/esm/vs/base/browser/ui/list/listWidget.js
init_dom();
init_keyboardEvent();

// node_modules/monaco-editor/esm/vs/base/browser/ui/list/splice.js
var CombinedSpliceable = class {
  constructor(spliceables) {
    this.spliceables = spliceables;
  }
  splice(start, deleteCount, elements) {
    this.spliceables.forEach((s) => s.splice(start, deleteCount, elements));
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/list/listWidget.js
init_arrays();
init_async();
init_color();
init_event();
init_filters();
init_lifecycle();
init_numbers();
init_platform();
init_types();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/list/list.css";

// node_modules/monaco-editor/esm/vs/base/browser/ui/list/list.js
var ListError = class extends Error {
  constructor(user, message) {
    super(`ListError [${user}] ${message}`);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/list/listView.js
init_dom();
init_arrays();
init_async();
init_event();
init_lifecycle();

// node_modules/monaco-editor/esm/vs/base/browser/ui/list/rangeMap.js
function groupIntersect(range2, groups) {
  const result = [];
  for (const r of groups) {
    if (range2.start >= r.range.end) {
      continue;
    }
    if (range2.end < r.range.start) {
      break;
    }
    const intersection2 = Range.intersect(range2, r.range);
    if (Range.isEmpty(intersection2)) {
      continue;
    }
    result.push({
      range: intersection2,
      size: r.size
    });
  }
  return result;
}
function shift({ start, end }, much) {
  return { start: start + much, end: end + much };
}
function consolidate(groups) {
  const result = [];
  let previousGroup = null;
  for (const group of groups) {
    const start = group.range.start;
    const end = group.range.end;
    const size = group.size;
    if (previousGroup && size === previousGroup.size) {
      previousGroup.range.end = end;
      continue;
    }
    previousGroup = { range: { start, end }, size };
    result.push(previousGroup);
  }
  return result;
}
function concat(...groups) {
  return consolidate(groups.reduce((r, g) => r.concat(g), []));
}
var RangeMap = class {
  get paddingTop() {
    return this._paddingTop;
  }
  set paddingTop(paddingTop) {
    this._size = this._size + paddingTop - this._paddingTop;
    this._paddingTop = paddingTop;
  }
  constructor(topPadding) {
    this.groups = [];
    this._size = 0;
    this._paddingTop = 0;
    this._paddingTop = topPadding !== null && topPadding !== void 0 ? topPadding : 0;
    this._size = this._paddingTop;
  }
  splice(index, deleteCount, items = []) {
    const diff = items.length - deleteCount;
    const before = groupIntersect({ start: 0, end: index }, this.groups);
    const after2 = groupIntersect({ start: index + deleteCount, end: Number.POSITIVE_INFINITY }, this.groups).map((g) => ({ range: shift(g.range, diff), size: g.size }));
    const middle = items.map((item, i) => ({
      range: { start: index + i, end: index + i + 1 },
      size: item.size
    }));
    this.groups = concat(before, middle, after2);
    this._size = this._paddingTop + this.groups.reduce((t, g) => t + g.size * (g.range.end - g.range.start), 0);
  }
  /**
   * Returns the number of items in the range map.
   */
  get count() {
    const len = this.groups.length;
    if (!len) {
      return 0;
    }
    return this.groups[len - 1].range.end;
  }
  /**
   * Returns the sum of the sizes of all items in the range map.
   */
  get size() {
    return this._size;
  }
  /**
   * Returns the index of the item at the given position.
   */
  indexAt(position) {
    if (position < 0) {
      return -1;
    }
    if (position < this._paddingTop) {
      return 0;
    }
    let index = 0;
    let size = this._paddingTop;
    for (const group of this.groups) {
      const count = group.range.end - group.range.start;
      const newSize = size + count * group.size;
      if (position < newSize) {
        return index + Math.floor((position - size) / group.size);
      }
      index += count;
      size = newSize;
    }
    return index;
  }
  /**
   * Returns the index of the item right after the item at the
   * index of the given position.
   */
  indexAfter(position) {
    return Math.min(this.indexAt(position) + 1, this.count);
  }
  /**
   * Returns the start position of the item at the given index.
   */
  positionAt(index) {
    if (index < 0) {
      return -1;
    }
    let position = 0;
    let count = 0;
    for (const group of this.groups) {
      const groupCount = group.range.end - group.range.start;
      const newCount = count + groupCount;
      if (index < newCount) {
        return this._paddingTop + position + (index - count) * group.size;
      }
      position += groupCount * group.size;
      count = newCount;
    }
    return -1;
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/list/rowCache.js
init_dom();
function removeFromParent(element) {
  var _a2;
  try {
    (_a2 = element.parentElement) === null || _a2 === void 0 ? void 0 : _a2.removeChild(element);
  } catch (e) {
  }
}
var RowCache = class {
  constructor(renderers) {
    this.renderers = renderers;
    this.cache = /* @__PURE__ */ new Map();
    this.transactionNodesPendingRemoval = /* @__PURE__ */ new Set();
    this.inTransaction = false;
  }
  /**
   * Returns a row either by creating a new one or reusing
   * a previously released row which shares the same templateId.
   *
   * @returns A row and `isReusingConnectedDomNode` if the row's node is already in the dom in a stale position.
   */
  alloc(templateId) {
    let result = this.getTemplateCache(templateId).pop();
    let isStale = false;
    if (result) {
      isStale = this.transactionNodesPendingRemoval.has(result.domNode);
      if (isStale) {
        this.transactionNodesPendingRemoval.delete(result.domNode);
      }
    } else {
      const domNode = $(".monaco-list-row");
      const renderer = this.getRenderer(templateId);
      const templateData = renderer.renderTemplate(domNode);
      result = { domNode, templateId, templateData };
    }
    return { row: result, isReusingConnectedDomNode: isStale };
  }
  /**
   * Releases the row for eventual reuse.
   */
  release(row) {
    if (!row) {
      return;
    }
    this.releaseRow(row);
  }
  /**
   * Begin a set of changes that use the cache. This lets us skip work when a row is removed and then inserted again.
   */
  transact(makeChanges) {
    if (this.inTransaction) {
      throw new Error("Already in transaction");
    }
    this.inTransaction = true;
    try {
      makeChanges();
    } finally {
      for (const domNode of this.transactionNodesPendingRemoval) {
        this.doRemoveNode(domNode);
      }
      this.transactionNodesPendingRemoval.clear();
      this.inTransaction = false;
    }
  }
  releaseRow(row) {
    const { domNode, templateId } = row;
    if (domNode) {
      if (this.inTransaction) {
        this.transactionNodesPendingRemoval.add(domNode);
      } else {
        this.doRemoveNode(domNode);
      }
    }
    const cache = this.getTemplateCache(templateId);
    cache.push(row);
  }
  doRemoveNode(domNode) {
    domNode.classList.remove("scrolling");
    removeFromParent(domNode);
  }
  getTemplateCache(templateId) {
    let result = this.cache.get(templateId);
    if (!result) {
      result = [];
      this.cache.set(templateId, result);
    }
    return result;
  }
  dispose() {
    this.cache.forEach((cachedRows, templateId) => {
      for (const cachedRow of cachedRows) {
        const renderer = this.getRenderer(templateId);
        renderer.disposeTemplate(cachedRow.templateData);
        cachedRow.templateData = null;
      }
    });
    this.cache.clear();
    this.transactionNodesPendingRemoval.clear();
  }
  getRenderer(templateId) {
    const renderer = this.renderers.get(templateId);
    if (!renderer) {
      throw new Error(`No renderer found for ${templateId}`);
    }
    return renderer;
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/list/listView.js
init_errors();
init_numbers();
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var StaticDND = {
  CurrentDragAndDropData: void 0
};
var DefaultOptions = {
  useShadows: true,
  verticalScrollMode: 1,
  setRowLineHeight: true,
  setRowHeight: true,
  supportDynamicHeights: false,
  dnd: {
    getDragElements(e) {
      return [e];
    },
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return false;
    },
    drop() {
    },
    dispose() {
    }
  },
  horizontalScrolling: false,
  transformOptimization: true,
  alwaysConsumeMouseWheel: true
};
var ElementsDragAndDropData = class {
  constructor(elements) {
    this.elements = elements;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
};
var ExternalElementsDragAndDropData = class {
  constructor(elements) {
    this.elements = elements;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
};
var NativeDragAndDropData = class {
  constructor() {
    this.types = [];
    this.files = [];
  }
  update(dataTransfer) {
    if (dataTransfer.types) {
      this.types.splice(0, this.types.length, ...dataTransfer.types);
    }
    if (dataTransfer.files) {
      this.files.splice(0, this.files.length);
      for (let i = 0; i < dataTransfer.files.length; i++) {
        const file = dataTransfer.files.item(i);
        if (file && (file.size || file.type)) {
          this.files.push(file);
        }
      }
    }
  }
  getData() {
    return {
      types: this.types,
      files: this.files
    };
  }
};
function equalsDragFeedback(f1, f2) {
  if (Array.isArray(f1) && Array.isArray(f2)) {
    return equals(f1, f2);
  }
  return f1 === f2;
}
var ListViewAccessibilityProvider = class {
  constructor(accessibilityProvider) {
    if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.getSetSize) {
      this.getSetSize = accessibilityProvider.getSetSize.bind(accessibilityProvider);
    } else {
      this.getSetSize = (e, i, l) => l;
    }
    if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.getPosInSet) {
      this.getPosInSet = accessibilityProvider.getPosInSet.bind(accessibilityProvider);
    } else {
      this.getPosInSet = (e, i) => i + 1;
    }
    if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.getRole) {
      this.getRole = accessibilityProvider.getRole.bind(accessibilityProvider);
    } else {
      this.getRole = (_) => "listitem";
    }
    if (accessibilityProvider === null || accessibilityProvider === void 0 ? void 0 : accessibilityProvider.isChecked) {
      this.isChecked = accessibilityProvider.isChecked.bind(accessibilityProvider);
    } else {
      this.isChecked = (_) => void 0;
    }
  }
};
var ListView = class _ListView {
  get contentHeight() {
    return this.rangeMap.size;
  }
  get onDidScroll() {
    return this.scrollableElement.onScroll;
  }
  get scrollableElementDomNode() {
    return this.scrollableElement.getDomNode();
  }
  get horizontalScrolling() {
    return this._horizontalScrolling;
  }
  set horizontalScrolling(value) {
    if (value === this._horizontalScrolling) {
      return;
    }
    if (value && this.supportDynamicHeights) {
      throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
    }
    this._horizontalScrolling = value;
    this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling);
    if (this._horizontalScrolling) {
      for (const item of this.items) {
        this.measureItemWidth(item);
      }
      this.updateScrollWidth();
      this.scrollableElement.setScrollDimensions({ width: getContentWidth(this.domNode) });
      this.rowsContainer.style.width = `${Math.max(this.scrollWidth || 0, this.renderWidth)}px`;
    } else {
      this.scrollableElementWidthDelayer.cancel();
      this.scrollableElement.setScrollDimensions({ width: this.renderWidth, scrollWidth: this.renderWidth });
      this.rowsContainer.style.width = "";
    }
  }
  constructor(container, virtualDelegate, renderers, options2 = DefaultOptions) {
    var _a2, _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    this.virtualDelegate = virtualDelegate;
    this.domId = `list_id_${++_ListView.InstanceCount}`;
    this.renderers = /* @__PURE__ */ new Map();
    this.renderWidth = 0;
    this._scrollHeight = 0;
    this.scrollableElementUpdateDisposable = null;
    this.scrollableElementWidthDelayer = new Delayer(50);
    this.splicing = false;
    this.dragOverAnimationStopDisposable = Disposable.None;
    this.dragOverMouseY = 0;
    this.canDrop = false;
    this.currentDragFeedbackDisposable = Disposable.None;
    this.onDragLeaveTimeout = Disposable.None;
    this.disposables = new DisposableStore();
    this._onDidChangeContentHeight = new Emitter();
    this._onDidChangeContentWidth = new Emitter();
    this.onDidChangeContentHeight = Event.latch(this._onDidChangeContentHeight.event, void 0, this.disposables);
    this._horizontalScrolling = false;
    if (options2.horizontalScrolling && options2.supportDynamicHeights) {
      throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
    }
    this.items = [];
    this.itemId = 0;
    this.rangeMap = this.createRangeMap((_a2 = options2.paddingTop) !== null && _a2 !== void 0 ? _a2 : 0);
    for (const renderer of renderers) {
      this.renderers.set(renderer.templateId, renderer);
    }
    this.cache = this.disposables.add(new RowCache(this.renderers));
    this.lastRenderTop = 0;
    this.lastRenderHeight = 0;
    this.domNode = document.createElement("div");
    this.domNode.className = "monaco-list";
    this.domNode.classList.add(this.domId);
    this.domNode.tabIndex = 0;
    this.domNode.classList.toggle("mouse-support", typeof options2.mouseSupport === "boolean" ? options2.mouseSupport : true);
    this._horizontalScrolling = (_b2 = options2.horizontalScrolling) !== null && _b2 !== void 0 ? _b2 : DefaultOptions.horizontalScrolling;
    this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling);
    this.paddingBottom = typeof options2.paddingBottom === "undefined" ? 0 : options2.paddingBottom;
    this.accessibilityProvider = new ListViewAccessibilityProvider(options2.accessibilityProvider);
    this.rowsContainer = document.createElement("div");
    this.rowsContainer.className = "monaco-list-rows";
    const transformOptimization = (_c = options2.transformOptimization) !== null && _c !== void 0 ? _c : DefaultOptions.transformOptimization;
    if (transformOptimization) {
      this.rowsContainer.style.transform = "translate3d(0px, 0px, 0px)";
      this.rowsContainer.style.overflow = "hidden";
      this.rowsContainer.style.contain = "strict";
    }
    this.disposables.add(Gesture.addTarget(this.rowsContainer));
    this.scrollable = this.disposables.add(new Scrollable({
      forceIntegerValues: true,
      smoothScrollDuration: ((_d = options2.smoothScrolling) !== null && _d !== void 0 ? _d : false) ? 125 : 0,
      scheduleAtNextAnimationFrame: (cb) => scheduleAtNextAnimationFrame(getWindow(this.domNode), cb)
    }));
    this.scrollableElement = this.disposables.add(new SmoothScrollableElement(this.rowsContainer, {
      alwaysConsumeMouseWheel: (_e = options2.alwaysConsumeMouseWheel) !== null && _e !== void 0 ? _e : DefaultOptions.alwaysConsumeMouseWheel,
      horizontal: 1,
      vertical: (_f = options2.verticalScrollMode) !== null && _f !== void 0 ? _f : DefaultOptions.verticalScrollMode,
      useShadows: (_g = options2.useShadows) !== null && _g !== void 0 ? _g : DefaultOptions.useShadows,
      mouseWheelScrollSensitivity: options2.mouseWheelScrollSensitivity,
      fastScrollSensitivity: options2.fastScrollSensitivity,
      scrollByPage: options2.scrollByPage
    }, this.scrollable));
    this.domNode.appendChild(this.scrollableElement.getDomNode());
    container.appendChild(this.domNode);
    this.scrollableElement.onScroll(this.onScroll, this, this.disposables);
    this.disposables.add(addDisposableListener(this.rowsContainer, EventType2.Change, (e) => this.onTouchChange(e)));
    this.disposables.add(addDisposableListener(this.scrollableElement.getDomNode(), "scroll", (e) => e.target.scrollTop = 0));
    this.disposables.add(addDisposableListener(this.domNode, "dragover", (e) => this.onDragOver(this.toDragEvent(e))));
    this.disposables.add(addDisposableListener(this.domNode, "drop", (e) => this.onDrop(this.toDragEvent(e))));
    this.disposables.add(addDisposableListener(this.domNode, "dragleave", (e) => this.onDragLeave(this.toDragEvent(e))));
    this.disposables.add(addDisposableListener(this.domNode, "dragend", (e) => this.onDragEnd(e)));
    this.setRowLineHeight = (_h = options2.setRowLineHeight) !== null && _h !== void 0 ? _h : DefaultOptions.setRowLineHeight;
    this.setRowHeight = (_j = options2.setRowHeight) !== null && _j !== void 0 ? _j : DefaultOptions.setRowHeight;
    this.supportDynamicHeights = (_k = options2.supportDynamicHeights) !== null && _k !== void 0 ? _k : DefaultOptions.supportDynamicHeights;
    this.dnd = (_l = options2.dnd) !== null && _l !== void 0 ? _l : this.disposables.add(DefaultOptions.dnd);
    this.layout((_m = options2.initialSize) === null || _m === void 0 ? void 0 : _m.height, (_o = options2.initialSize) === null || _o === void 0 ? void 0 : _o.width);
  }
  updateOptions(options2) {
    if (options2.paddingBottom !== void 0) {
      this.paddingBottom = options2.paddingBottom;
      this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight });
    }
    if (options2.smoothScrolling !== void 0) {
      this.scrollable.setSmoothScrollDuration(options2.smoothScrolling ? 125 : 0);
    }
    if (options2.horizontalScrolling !== void 0) {
      this.horizontalScrolling = options2.horizontalScrolling;
    }
    let scrollableOptions;
    if (options2.scrollByPage !== void 0) {
      scrollableOptions = { ...scrollableOptions !== null && scrollableOptions !== void 0 ? scrollableOptions : {}, scrollByPage: options2.scrollByPage };
    }
    if (options2.mouseWheelScrollSensitivity !== void 0) {
      scrollableOptions = { ...scrollableOptions !== null && scrollableOptions !== void 0 ? scrollableOptions : {}, mouseWheelScrollSensitivity: options2.mouseWheelScrollSensitivity };
    }
    if (options2.fastScrollSensitivity !== void 0) {
      scrollableOptions = { ...scrollableOptions !== null && scrollableOptions !== void 0 ? scrollableOptions : {}, fastScrollSensitivity: options2.fastScrollSensitivity };
    }
    if (scrollableOptions) {
      this.scrollableElement.updateOptions(scrollableOptions);
    }
    if (options2.paddingTop !== void 0 && options2.paddingTop !== this.rangeMap.paddingTop) {
      const lastRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
      const offset = options2.paddingTop - this.rangeMap.paddingTop;
      this.rangeMap.paddingTop = options2.paddingTop;
      this.render(lastRenderRange, Math.max(0, this.lastRenderTop + offset), this.lastRenderHeight, void 0, void 0, true);
      this.setScrollTop(this.lastRenderTop);
      this.eventuallyUpdateScrollDimensions();
      if (this.supportDynamicHeights) {
        this._rerender(this.lastRenderTop, this.lastRenderHeight);
      }
    }
  }
  createRangeMap(paddingTop) {
    return new RangeMap(paddingTop);
  }
  splice(start, deleteCount, elements = []) {
    if (this.splicing) {
      throw new Error("Can't run recursive splices.");
    }
    this.splicing = true;
    try {
      return this._splice(start, deleteCount, elements);
    } finally {
      this.splicing = false;
      this._onDidChangeContentHeight.fire(this.contentHeight);
    }
  }
  _splice(start, deleteCount, elements = []) {
    const previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
    const deleteRange = { start, end: start + deleteCount };
    const removeRange = Range.intersect(previousRenderRange, deleteRange);
    const rowsToDispose = /* @__PURE__ */ new Map();
    for (let i = removeRange.end - 1; i >= removeRange.start; i--) {
      const item = this.items[i];
      item.dragStartDisposable.dispose();
      item.checkedDisposable.dispose();
      if (item.row) {
        let rows = rowsToDispose.get(item.templateId);
        if (!rows) {
          rows = [];
          rowsToDispose.set(item.templateId, rows);
        }
        const renderer = this.renderers.get(item.templateId);
        if (renderer && renderer.disposeElement) {
          renderer.disposeElement(item.element, i, item.row.templateData, item.size);
        }
        rows.push(item.row);
      }
      item.row = null;
      item.stale = true;
    }
    const previousRestRange = { start: start + deleteCount, end: this.items.length };
    const previousRenderedRestRange = Range.intersect(previousRestRange, previousRenderRange);
    const previousUnrenderedRestRanges = Range.relativeComplement(previousRestRange, previousRenderRange);
    const inserted = elements.map((element) => ({
      id: String(this.itemId++),
      element,
      templateId: this.virtualDelegate.getTemplateId(element),
      size: this.virtualDelegate.getHeight(element),
      width: void 0,
      hasDynamicHeight: !!this.virtualDelegate.hasDynamicHeight && this.virtualDelegate.hasDynamicHeight(element),
      lastDynamicHeightWidth: void 0,
      row: null,
      uri: void 0,
      dropTarget: false,
      dragStartDisposable: Disposable.None,
      checkedDisposable: Disposable.None,
      stale: false
    }));
    let deleted;
    if (start === 0 && deleteCount >= this.items.length) {
      this.rangeMap = this.createRangeMap(this.rangeMap.paddingTop);
      this.rangeMap.splice(0, 0, inserted);
      deleted = this.items;
      this.items = inserted;
    } else {
      this.rangeMap.splice(start, deleteCount, inserted);
      deleted = this.items.splice(start, deleteCount, ...inserted);
    }
    const delta = elements.length - deleteCount;
    const renderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
    const renderedRestRange = shift(previousRenderedRestRange, delta);
    const updateRange = Range.intersect(renderRange, renderedRestRange);
    for (let i = updateRange.start; i < updateRange.end; i++) {
      this.updateItemInDOM(this.items[i], i);
    }
    const removeRanges = Range.relativeComplement(renderedRestRange, renderRange);
    for (const range2 of removeRanges) {
      for (let i = range2.start; i < range2.end; i++) {
        this.removeItemFromDOM(i);
      }
    }
    const unrenderedRestRanges = previousUnrenderedRestRanges.map((r) => shift(r, delta));
    const elementsRange = { start, end: start + elements.length };
    const insertRanges = [elementsRange, ...unrenderedRestRanges].map((r) => Range.intersect(renderRange, r)).reverse();
    for (const range2 of insertRanges) {
      for (let i = range2.end - 1; i >= range2.start; i--) {
        const item = this.items[i];
        const rows = rowsToDispose.get(item.templateId);
        const row = rows === null || rows === void 0 ? void 0 : rows.pop();
        this.insertItemInDOM(i, row);
      }
    }
    for (const rows of rowsToDispose.values()) {
      for (const row of rows) {
        this.cache.release(row);
      }
    }
    this.eventuallyUpdateScrollDimensions();
    if (this.supportDynamicHeights) {
      this._rerender(this.scrollTop, this.renderHeight);
    }
    return deleted.map((i) => i.element);
  }
  eventuallyUpdateScrollDimensions() {
    this._scrollHeight = this.contentHeight;
    this.rowsContainer.style.height = `${this._scrollHeight}px`;
    if (!this.scrollableElementUpdateDisposable) {
      this.scrollableElementUpdateDisposable = scheduleAtNextAnimationFrame(getWindow(this.domNode), () => {
        this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight });
        this.updateScrollWidth();
        this.scrollableElementUpdateDisposable = null;
      });
    }
  }
  eventuallyUpdateScrollWidth() {
    if (!this.horizontalScrolling) {
      this.scrollableElementWidthDelayer.cancel();
      return;
    }
    this.scrollableElementWidthDelayer.trigger(() => this.updateScrollWidth());
  }
  updateScrollWidth() {
    if (!this.horizontalScrolling) {
      return;
    }
    let scrollWidth = 0;
    for (const item of this.items) {
      if (typeof item.width !== "undefined") {
        scrollWidth = Math.max(scrollWidth, item.width);
      }
    }
    this.scrollWidth = scrollWidth;
    this.scrollableElement.setScrollDimensions({ scrollWidth: scrollWidth === 0 ? 0 : scrollWidth + 10 });
    this._onDidChangeContentWidth.fire(this.scrollWidth);
  }
  rerender() {
    if (!this.supportDynamicHeights) {
      return;
    }
    for (const item of this.items) {
      item.lastDynamicHeightWidth = void 0;
    }
    this._rerender(this.lastRenderTop, this.lastRenderHeight);
  }
  get length() {
    return this.items.length;
  }
  get renderHeight() {
    const scrollDimensions = this.scrollableElement.getScrollDimensions();
    return scrollDimensions.height;
  }
  get firstVisibleIndex() {
    const range2 = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
    return range2.start;
  }
  element(index) {
    return this.items[index].element;
  }
  indexOf(element) {
    return this.items.findIndex((item) => item.element === element);
  }
  domElement(index) {
    const row = this.items[index].row;
    return row && row.domNode;
  }
  elementHeight(index) {
    return this.items[index].size;
  }
  elementTop(index) {
    return this.rangeMap.positionAt(index);
  }
  indexAt(position) {
    return this.rangeMap.indexAt(position);
  }
  indexAfter(position) {
    return this.rangeMap.indexAfter(position);
  }
  layout(height, width) {
    const scrollDimensions = {
      height: typeof height === "number" ? height : getContentHeight(this.domNode)
    };
    if (this.scrollableElementUpdateDisposable) {
      this.scrollableElementUpdateDisposable.dispose();
      this.scrollableElementUpdateDisposable = null;
      scrollDimensions.scrollHeight = this.scrollHeight;
    }
    this.scrollableElement.setScrollDimensions(scrollDimensions);
    if (typeof width !== "undefined") {
      this.renderWidth = width;
      if (this.supportDynamicHeights) {
        this._rerender(this.scrollTop, this.renderHeight);
      }
    }
    if (this.horizontalScrolling) {
      this.scrollableElement.setScrollDimensions({
        width: typeof width === "number" ? width : getContentWidth(this.domNode)
      });
    }
  }
  // Render
  render(previousRenderRange, renderTop, renderHeight, renderLeft, scrollWidth, updateItemsInDOM = false) {
    const renderRange = this.getRenderRange(renderTop, renderHeight);
    const rangesToInsert = Range.relativeComplement(renderRange, previousRenderRange).reverse();
    const rangesToRemove = Range.relativeComplement(previousRenderRange, renderRange);
    if (updateItemsInDOM) {
      const rangesToUpdate = Range.intersect(previousRenderRange, renderRange);
      for (let i = rangesToUpdate.start; i < rangesToUpdate.end; i++) {
        this.updateItemInDOM(this.items[i], i);
      }
    }
    this.cache.transact(() => {
      for (const range2 of rangesToRemove) {
        for (let i = range2.start; i < range2.end; i++) {
          this.removeItemFromDOM(i);
        }
      }
      for (const range2 of rangesToInsert) {
        for (let i = range2.end - 1; i >= range2.start; i--) {
          this.insertItemInDOM(i);
        }
      }
    });
    if (renderLeft !== void 0) {
      this.rowsContainer.style.left = `-${renderLeft}px`;
    }
    this.rowsContainer.style.top = `-${renderTop}px`;
    if (this.horizontalScrolling && scrollWidth !== void 0) {
      this.rowsContainer.style.width = `${Math.max(scrollWidth, this.renderWidth)}px`;
    }
    this.lastRenderTop = renderTop;
    this.lastRenderHeight = renderHeight;
  }
  // DOM operations
  insertItemInDOM(index, row) {
    var _a2, _b2, _c;
    const item = this.items[index];
    if (!item.row) {
      if (row) {
        item.row = row;
        item.stale = true;
      } else {
        const result = this.cache.alloc(item.templateId);
        item.row = result.row;
        item.stale || (item.stale = result.isReusingConnectedDomNode);
      }
    }
    const role = this.accessibilityProvider.getRole(item.element) || "listitem";
    item.row.domNode.setAttribute("role", role);
    const checked = this.accessibilityProvider.isChecked(item.element);
    if (typeof checked === "boolean") {
      item.row.domNode.setAttribute("aria-checked", String(!!checked));
    } else if (checked) {
      const update = (checked2) => item.row.domNode.setAttribute("aria-checked", String(!!checked2));
      update(checked.value);
      item.checkedDisposable = checked.onDidChange(update);
    }
    if (item.stale || !item.row.domNode.parentElement) {
      const referenceNode = (_c = (_b2 = (_a2 = this.items.at(index + 1)) === null || _a2 === void 0 ? void 0 : _a2.row) === null || _b2 === void 0 ? void 0 : _b2.domNode) !== null && _c !== void 0 ? _c : null;
      this.rowsContainer.insertBefore(item.row.domNode, referenceNode);
      item.stale = false;
    }
    this.updateItemInDOM(item, index);
    const renderer = this.renderers.get(item.templateId);
    if (!renderer) {
      throw new Error(`No renderer found for template id ${item.templateId}`);
    }
    renderer === null || renderer === void 0 ? void 0 : renderer.renderElement(item.element, index, item.row.templateData, item.size);
    const uri = this.dnd.getDragURI(item.element);
    item.dragStartDisposable.dispose();
    item.row.domNode.draggable = !!uri;
    if (uri) {
      item.dragStartDisposable = addDisposableListener(item.row.domNode, "dragstart", (event) => this.onDragStart(item.element, uri, event));
    }
    if (this.horizontalScrolling) {
      this.measureItemWidth(item);
      this.eventuallyUpdateScrollWidth();
    }
  }
  measureItemWidth(item) {
    if (!item.row || !item.row.domNode) {
      return;
    }
    item.row.domNode.style.width = "fit-content";
    item.width = getContentWidth(item.row.domNode);
    const style = getWindow(item.row.domNode).getComputedStyle(item.row.domNode);
    if (style.paddingLeft) {
      item.width += parseFloat(style.paddingLeft);
    }
    if (style.paddingRight) {
      item.width += parseFloat(style.paddingRight);
    }
    item.row.domNode.style.width = "";
  }
  updateItemInDOM(item, index) {
    item.row.domNode.style.top = `${this.elementTop(index)}px`;
    if (this.setRowHeight) {
      item.row.domNode.style.height = `${item.size}px`;
    }
    if (this.setRowLineHeight) {
      item.row.domNode.style.lineHeight = `${item.size}px`;
    }
    item.row.domNode.setAttribute("data-index", `${index}`);
    item.row.domNode.setAttribute("data-last-element", index === this.length - 1 ? "true" : "false");
    item.row.domNode.setAttribute("data-parity", index % 2 === 0 ? "even" : "odd");
    item.row.domNode.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(item.element, index, this.length)));
    item.row.domNode.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(item.element, index)));
    item.row.domNode.setAttribute("id", this.getElementDomId(index));
    item.row.domNode.classList.toggle("drop-target", item.dropTarget);
  }
  removeItemFromDOM(index) {
    const item = this.items[index];
    item.dragStartDisposable.dispose();
    item.checkedDisposable.dispose();
    if (item.row) {
      const renderer = this.renderers.get(item.templateId);
      if (renderer && renderer.disposeElement) {
        renderer.disposeElement(item.element, index, item.row.templateData, item.size);
      }
      this.cache.release(item.row);
      item.row = null;
    }
    if (this.horizontalScrolling) {
      this.eventuallyUpdateScrollWidth();
    }
  }
  getScrollTop() {
    const scrollPosition = this.scrollableElement.getScrollPosition();
    return scrollPosition.scrollTop;
  }
  setScrollTop(scrollTop, reuseAnimation) {
    if (this.scrollableElementUpdateDisposable) {
      this.scrollableElementUpdateDisposable.dispose();
      this.scrollableElementUpdateDisposable = null;
      this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight });
    }
    this.scrollableElement.setScrollPosition({ scrollTop, reuseAnimation });
  }
  get scrollTop() {
    return this.getScrollTop();
  }
  set scrollTop(scrollTop) {
    this.setScrollTop(scrollTop);
  }
  get scrollHeight() {
    return this._scrollHeight + (this.horizontalScrolling ? 10 : 0) + this.paddingBottom;
  }
  // Events
  get onMouseClick() {
    return Event.map(this.disposables.add(new DomEmitter(this.domNode, "click")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseDblClick() {
    return Event.map(this.disposables.add(new DomEmitter(this.domNode, "dblclick")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseMiddleClick() {
    return Event.filter(Event.map(this.disposables.add(new DomEmitter(this.domNode, "auxclick")).event, (e) => this.toMouseEvent(e), this.disposables), (e) => e.browserEvent.button === 1, this.disposables);
  }
  get onMouseDown() {
    return Event.map(this.disposables.add(new DomEmitter(this.domNode, "mousedown")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseOver() {
    return Event.map(this.disposables.add(new DomEmitter(this.domNode, "mouseover")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseOut() {
    return Event.map(this.disposables.add(new DomEmitter(this.domNode, "mouseout")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onContextMenu() {
    return Event.any(Event.map(this.disposables.add(new DomEmitter(this.domNode, "contextmenu")).event, (e) => this.toMouseEvent(e), this.disposables), Event.map(this.disposables.add(new DomEmitter(this.domNode, EventType2.Contextmenu)).event, (e) => this.toGestureEvent(e), this.disposables));
  }
  get onTouchStart() {
    return Event.map(this.disposables.add(new DomEmitter(this.domNode, "touchstart")).event, (e) => this.toTouchEvent(e), this.disposables);
  }
  get onTap() {
    return Event.map(this.disposables.add(new DomEmitter(this.rowsContainer, EventType2.Tap)).event, (e) => this.toGestureEvent(e), this.disposables);
  }
  toMouseEvent(browserEvent) {
    const index = this.getItemIndexFromEventTarget(browserEvent.target || null);
    const item = typeof index === "undefined" ? void 0 : this.items[index];
    const element = item && item.element;
    return { browserEvent, index, element };
  }
  toTouchEvent(browserEvent) {
    const index = this.getItemIndexFromEventTarget(browserEvent.target || null);
    const item = typeof index === "undefined" ? void 0 : this.items[index];
    const element = item && item.element;
    return { browserEvent, index, element };
  }
  toGestureEvent(browserEvent) {
    const index = this.getItemIndexFromEventTarget(browserEvent.initialTarget || null);
    const item = typeof index === "undefined" ? void 0 : this.items[index];
    const element = item && item.element;
    return { browserEvent, index, element };
  }
  toDragEvent(browserEvent) {
    const index = this.getItemIndexFromEventTarget(browserEvent.target || null);
    const item = typeof index === "undefined" ? void 0 : this.items[index];
    const element = item && item.element;
    const sector = this.getTargetSector(browserEvent, index);
    return { browserEvent, index, element, sector };
  }
  onScroll(e) {
    try {
      const previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
      this.render(previousRenderRange, e.scrollTop, e.height, e.scrollLeft, e.scrollWidth);
      if (this.supportDynamicHeights) {
        this._rerender(e.scrollTop, e.height, e.inSmoothScrolling);
      }
    } catch (err) {
      console.error("Got bad scroll event:", e);
      throw err;
    }
  }
  onTouchChange(event) {
    event.preventDefault();
    event.stopPropagation();
    this.scrollTop -= event.translationY;
  }
  // DND
  onDragStart(element, uri, event) {
    var _a2, _b2;
    if (!event.dataTransfer) {
      return;
    }
    const elements = this.dnd.getDragElements(element);
    event.dataTransfer.effectAllowed = "copyMove";
    event.dataTransfer.setData(DataTransfers.TEXT, uri);
    if (event.dataTransfer.setDragImage) {
      let label;
      if (this.dnd.getDragLabel) {
        label = this.dnd.getDragLabel(elements, event);
      }
      if (typeof label === "undefined") {
        label = String(elements.length);
      }
      const dragImage = $(".monaco-drag-image");
      dragImage.textContent = label;
      const getDragImageContainer = (e) => {
        while (e && !e.classList.contains("monaco-workbench")) {
          e = e.parentElement;
        }
        return e || this.domNode.ownerDocument;
      };
      const container = getDragImageContainer(this.domNode);
      container.appendChild(dragImage);
      event.dataTransfer.setDragImage(dragImage, -10, -10);
      setTimeout(() => container.removeChild(dragImage), 0);
    }
    this.domNode.classList.add("dragging");
    this.currentDragData = new ElementsDragAndDropData(elements);
    StaticDND.CurrentDragAndDropData = new ExternalElementsDragAndDropData(elements);
    (_b2 = (_a2 = this.dnd).onDragStart) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, this.currentDragData, event);
  }
  onDragOver(event) {
    var _a2, _b2;
    event.browserEvent.preventDefault();
    this.onDragLeaveTimeout.dispose();
    if (StaticDND.CurrentDragAndDropData && StaticDND.CurrentDragAndDropData.getData() === "vscode-ui") {
      return false;
    }
    this.setupDragAndDropScrollTopAnimation(event.browserEvent);
    if (!event.browserEvent.dataTransfer) {
      return false;
    }
    if (!this.currentDragData) {
      if (StaticDND.CurrentDragAndDropData) {
        this.currentDragData = StaticDND.CurrentDragAndDropData;
      } else {
        if (!event.browserEvent.dataTransfer.types) {
          return false;
        }
        this.currentDragData = new NativeDragAndDropData();
      }
    }
    const result = this.dnd.onDragOver(this.currentDragData, event.element, event.index, event.sector, event.browserEvent);
    this.canDrop = typeof result === "boolean" ? result : result.accept;
    if (!this.canDrop) {
      this.currentDragFeedback = void 0;
      this.currentDragFeedbackDisposable.dispose();
      return false;
    }
    event.browserEvent.dataTransfer.dropEffect = typeof result !== "boolean" && ((_a2 = result.effect) === null || _a2 === void 0 ? void 0 : _a2.type) === 0 ? "copy" : "move";
    let feedback;
    if (typeof result !== "boolean" && result.feedback) {
      feedback = result.feedback;
    } else {
      if (typeof event.index === "undefined") {
        feedback = [-1];
      } else {
        feedback = [event.index];
      }
    }
    feedback = distinct(feedback).filter((i) => i >= -1 && i < this.length).sort((a, b) => a - b);
    feedback = feedback[0] === -1 ? [-1] : feedback;
    let dragOverEffectPosition = typeof result !== "boolean" && result.effect && result.effect.position ? result.effect.position : "drop-target";
    if (equalsDragFeedback(this.currentDragFeedback, feedback) && this.currentDragFeedbackPosition === dragOverEffectPosition) {
      return true;
    }
    this.currentDragFeedback = feedback;
    this.currentDragFeedbackPosition = dragOverEffectPosition;
    this.currentDragFeedbackDisposable.dispose();
    if (feedback[0] === -1) {
      this.domNode.classList.add(dragOverEffectPosition);
      this.rowsContainer.classList.add(dragOverEffectPosition);
      this.currentDragFeedbackDisposable = toDisposable(() => {
        this.domNode.classList.remove(dragOverEffectPosition);
        this.rowsContainer.classList.remove(dragOverEffectPosition);
      });
    } else {
      if (feedback.length > 1 && dragOverEffectPosition !== "drop-target") {
        throw new Error("Can't use multiple feedbacks with position different than 'over'");
      }
      if (dragOverEffectPosition === "drop-target-after") {
        if (feedback[0] < this.length - 1) {
          feedback[0] += 1;
          dragOverEffectPosition = "drop-target-before";
        }
      }
      for (const index of feedback) {
        const item = this.items[index];
        item.dropTarget = true;
        (_b2 = item.row) === null || _b2 === void 0 ? void 0 : _b2.domNode.classList.add(dragOverEffectPosition);
      }
      this.currentDragFeedbackDisposable = toDisposable(() => {
        var _a3;
        for (const index of feedback) {
          const item = this.items[index];
          item.dropTarget = false;
          (_a3 = item.row) === null || _a3 === void 0 ? void 0 : _a3.domNode.classList.remove(dragOverEffectPosition);
        }
      });
    }
    return true;
  }
  onDragLeave(event) {
    var _a2, _b2;
    this.onDragLeaveTimeout.dispose();
    this.onDragLeaveTimeout = disposableTimeout(() => this.clearDragOverFeedback(), 100, this.disposables);
    if (this.currentDragData) {
      (_b2 = (_a2 = this.dnd).onDragLeave) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, this.currentDragData, event.element, event.index, event.browserEvent);
    }
  }
  onDrop(event) {
    if (!this.canDrop) {
      return;
    }
    const dragData = this.currentDragData;
    this.teardownDragAndDropScrollTopAnimation();
    this.clearDragOverFeedback();
    this.domNode.classList.remove("dragging");
    this.currentDragData = void 0;
    StaticDND.CurrentDragAndDropData = void 0;
    if (!dragData || !event.browserEvent.dataTransfer) {
      return;
    }
    event.browserEvent.preventDefault();
    dragData.update(event.browserEvent.dataTransfer);
    this.dnd.drop(dragData, event.element, event.index, event.sector, event.browserEvent);
  }
  onDragEnd(event) {
    var _a2, _b2;
    this.canDrop = false;
    this.teardownDragAndDropScrollTopAnimation();
    this.clearDragOverFeedback();
    this.domNode.classList.remove("dragging");
    this.currentDragData = void 0;
    StaticDND.CurrentDragAndDropData = void 0;
    (_b2 = (_a2 = this.dnd).onDragEnd) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, event);
  }
  clearDragOverFeedback() {
    this.currentDragFeedback = void 0;
    this.currentDragFeedbackPosition = void 0;
    this.currentDragFeedbackDisposable.dispose();
    this.currentDragFeedbackDisposable = Disposable.None;
  }
  // DND scroll top animation
  setupDragAndDropScrollTopAnimation(event) {
    if (!this.dragOverAnimationDisposable) {
      const viewTop = getTopLeftOffset(this.domNode).top;
      this.dragOverAnimationDisposable = animate(getWindow(this.domNode), this.animateDragAndDropScrollTop.bind(this, viewTop));
    }
    this.dragOverAnimationStopDisposable.dispose();
    this.dragOverAnimationStopDisposable = disposableTimeout(() => {
      if (this.dragOverAnimationDisposable) {
        this.dragOverAnimationDisposable.dispose();
        this.dragOverAnimationDisposable = void 0;
      }
    }, 1e3, this.disposables);
    this.dragOverMouseY = event.pageY;
  }
  animateDragAndDropScrollTop(viewTop) {
    if (this.dragOverMouseY === void 0) {
      return;
    }
    const diff = this.dragOverMouseY - viewTop;
    const upperLimit = this.renderHeight - 35;
    if (diff < 35) {
      this.scrollTop += Math.max(-14, Math.floor(0.3 * (diff - 35)));
    } else if (diff > upperLimit) {
      this.scrollTop += Math.min(14, Math.floor(0.3 * (diff - upperLimit)));
    }
  }
  teardownDragAndDropScrollTopAnimation() {
    this.dragOverAnimationStopDisposable.dispose();
    if (this.dragOverAnimationDisposable) {
      this.dragOverAnimationDisposable.dispose();
      this.dragOverAnimationDisposable = void 0;
    }
  }
  // Util
  getTargetSector(browserEvent, targetIndex) {
    if (targetIndex === void 0) {
      return void 0;
    }
    const relativePosition = browserEvent.offsetY / this.items[targetIndex].size;
    const sector = Math.floor(relativePosition / 0.25);
    return clamp(sector, 0, 3);
  }
  getItemIndexFromEventTarget(target) {
    const scrollableElement = this.scrollableElement.getDomNode();
    let element = target;
    while (element instanceof HTMLElement && element !== this.rowsContainer && scrollableElement.contains(element)) {
      const rawIndex = element.getAttribute("data-index");
      if (rawIndex) {
        const index = Number(rawIndex);
        if (!isNaN(index)) {
          return index;
        }
      }
      element = element.parentElement;
    }
    return void 0;
  }
  getRenderRange(renderTop, renderHeight) {
    return {
      start: this.rangeMap.indexAt(renderTop),
      end: this.rangeMap.indexAfter(renderTop + renderHeight - 1)
    };
  }
  /**
   * Given a stable rendered state, checks every rendered element whether it needs
   * to be probed for dynamic height. Adjusts scroll height and top if necessary.
   */
  _rerender(renderTop, renderHeight, inSmoothScrolling) {
    const previousRenderRange = this.getRenderRange(renderTop, renderHeight);
    let anchorElementIndex;
    let anchorElementTopDelta;
    if (renderTop === this.elementTop(previousRenderRange.start)) {
      anchorElementIndex = previousRenderRange.start;
      anchorElementTopDelta = 0;
    } else if (previousRenderRange.end - previousRenderRange.start > 1) {
      anchorElementIndex = previousRenderRange.start + 1;
      anchorElementTopDelta = this.elementTop(anchorElementIndex) - renderTop;
    }
    let heightDiff2 = 0;
    while (true) {
      const renderRange = this.getRenderRange(renderTop, renderHeight);
      let didChange = false;
      for (let i = renderRange.start; i < renderRange.end; i++) {
        const diff = this.probeDynamicHeight(i);
        if (diff !== 0) {
          this.rangeMap.splice(i, 1, [this.items[i]]);
        }
        heightDiff2 += diff;
        didChange = didChange || diff !== 0;
      }
      if (!didChange) {
        if (heightDiff2 !== 0) {
          this.eventuallyUpdateScrollDimensions();
        }
        const unrenderRanges = Range.relativeComplement(previousRenderRange, renderRange);
        for (const range2 of unrenderRanges) {
          for (let i = range2.start; i < range2.end; i++) {
            if (this.items[i].row) {
              this.removeItemFromDOM(i);
            }
          }
        }
        const renderRanges = Range.relativeComplement(renderRange, previousRenderRange).reverse();
        for (const range2 of renderRanges) {
          for (let i = range2.end - 1; i >= range2.start; i--) {
            this.insertItemInDOM(i);
          }
        }
        for (let i = renderRange.start; i < renderRange.end; i++) {
          if (this.items[i].row) {
            this.updateItemInDOM(this.items[i], i);
          }
        }
        if (typeof anchorElementIndex === "number") {
          const deltaScrollTop = this.scrollable.getFutureScrollPosition().scrollTop - renderTop;
          const newScrollTop = this.elementTop(anchorElementIndex) - anchorElementTopDelta + deltaScrollTop;
          this.setScrollTop(newScrollTop, inSmoothScrolling);
        }
        this._onDidChangeContentHeight.fire(this.contentHeight);
        return;
      }
    }
  }
  probeDynamicHeight(index) {
    var _a2, _b2, _c;
    const item = this.items[index];
    if (!!this.virtualDelegate.getDynamicHeight) {
      const newSize = this.virtualDelegate.getDynamicHeight(item.element);
      if (newSize !== null) {
        const size2 = item.size;
        item.size = newSize;
        item.lastDynamicHeightWidth = this.renderWidth;
        return newSize - size2;
      }
    }
    if (!item.hasDynamicHeight || item.lastDynamicHeightWidth === this.renderWidth) {
      return 0;
    }
    if (!!this.virtualDelegate.hasDynamicHeight && !this.virtualDelegate.hasDynamicHeight(item.element)) {
      return 0;
    }
    const size = item.size;
    if (item.row) {
      item.row.domNode.style.height = "";
      item.size = item.row.domNode.offsetHeight;
      item.lastDynamicHeightWidth = this.renderWidth;
      return item.size - size;
    }
    const { row } = this.cache.alloc(item.templateId);
    row.domNode.style.height = "";
    this.rowsContainer.appendChild(row.domNode);
    const renderer = this.renderers.get(item.templateId);
    if (!renderer) {
      throw new BugIndicatingError("Missing renderer for templateId: " + item.templateId);
    }
    renderer.renderElement(item.element, index, row.templateData, void 0);
    item.size = row.domNode.offsetHeight;
    (_a2 = renderer.disposeElement) === null || _a2 === void 0 ? void 0 : _a2.call(renderer, item.element, index, row.templateData, void 0);
    (_c = (_b2 = this.virtualDelegate).setDynamicHeight) === null || _c === void 0 ? void 0 : _c.call(_b2, item.element, item.size);
    item.lastDynamicHeightWidth = this.renderWidth;
    this.rowsContainer.removeChild(row.domNode);
    this.cache.release(row);
    return item.size - size;
  }
  getElementDomId(index) {
    return `${this.domId}_${index}`;
  }
  // Dispose
  dispose() {
    var _a2, _b2;
    for (const item of this.items) {
      item.dragStartDisposable.dispose();
      item.checkedDisposable.dispose();
      if (item.row) {
        const renderer = this.renderers.get(item.row.templateId);
        if (renderer) {
          (_a2 = renderer.disposeElement) === null || _a2 === void 0 ? void 0 : _a2.call(renderer, item.element, -1, item.row.templateData, void 0);
          renderer.disposeTemplate(item.row.templateData);
        }
      }
    }
    this.items = [];
    if (this.domNode && this.domNode.parentNode) {
      this.domNode.parentNode.removeChild(this.domNode);
    }
    (_b2 = this.dragOverAnimationDisposable) === null || _b2 === void 0 ? void 0 : _b2.dispose();
    this.disposables.dispose();
  }
};
ListView.InstanceCount = 0;
__decorate14([
  memoize
], ListView.prototype, "onMouseClick", null);
__decorate14([
  memoize
], ListView.prototype, "onMouseDblClick", null);
__decorate14([
  memoize
], ListView.prototype, "onMouseMiddleClick", null);
__decorate14([
  memoize
], ListView.prototype, "onMouseDown", null);
__decorate14([
  memoize
], ListView.prototype, "onMouseOver", null);
__decorate14([
  memoize
], ListView.prototype, "onMouseOut", null);
__decorate14([
  memoize
], ListView.prototype, "onContextMenu", null);
__decorate14([
  memoize
], ListView.prototype, "onTouchStart", null);
__decorate14([
  memoize
], ListView.prototype, "onTap", null);

// node_modules/monaco-editor/esm/vs/base/browser/ui/list/listWidget.js
init_mouseEvent();
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TraitRenderer = class {
  constructor(trait) {
    this.trait = trait;
    this.renderedElements = [];
  }
  get templateId() {
    return `template:${this.trait.name}`;
  }
  renderTemplate(container) {
    return container;
  }
  renderElement(element, index, templateData) {
    const renderedElementIndex = this.renderedElements.findIndex((el) => el.templateData === templateData);
    if (renderedElementIndex >= 0) {
      const rendered = this.renderedElements[renderedElementIndex];
      this.trait.unrender(templateData);
      rendered.index = index;
    } else {
      const rendered = { index, templateData };
      this.renderedElements.push(rendered);
    }
    this.trait.renderIndex(index, templateData);
  }
  splice(start, deleteCount, insertCount) {
    const rendered = [];
    for (const renderedElement of this.renderedElements) {
      if (renderedElement.index < start) {
        rendered.push(renderedElement);
      } else if (renderedElement.index >= start + deleteCount) {
        rendered.push({
          index: renderedElement.index + insertCount - deleteCount,
          templateData: renderedElement.templateData
        });
      }
    }
    this.renderedElements = rendered;
  }
  renderIndexes(indexes) {
    for (const { index, templateData } of this.renderedElements) {
      if (indexes.indexOf(index) > -1) {
        this.trait.renderIndex(index, templateData);
      }
    }
  }
  disposeTemplate(templateData) {
    const index = this.renderedElements.findIndex((el) => el.templateData === templateData);
    if (index < 0) {
      return;
    }
    this.renderedElements.splice(index, 1);
  }
};
var Trait = class {
  get name() {
    return this._trait;
  }
  get renderer() {
    return new TraitRenderer(this);
  }
  constructor(_trait) {
    this._trait = _trait;
    this.indexes = [];
    this.sortedIndexes = [];
    this._onChange = new Emitter();
    this.onChange = this._onChange.event;
  }
  splice(start, deleteCount, elements) {
    const diff = elements.length - deleteCount;
    const end = start + deleteCount;
    const sortedIndexes = [];
    let i = 0;
    while (i < this.sortedIndexes.length && this.sortedIndexes[i] < start) {
      sortedIndexes.push(this.sortedIndexes[i++]);
    }
    for (let j = 0; j < elements.length; j++) {
      if (elements[j]) {
        sortedIndexes.push(j + start);
      }
    }
    while (i < this.sortedIndexes.length && this.sortedIndexes[i] >= end) {
      sortedIndexes.push(this.sortedIndexes[i++] + diff);
    }
    this.renderer.splice(start, deleteCount, elements.length);
    this._set(sortedIndexes, sortedIndexes);
  }
  renderIndex(index, container) {
    container.classList.toggle(this._trait, this.contains(index));
  }
  unrender(container) {
    container.classList.remove(this._trait);
  }
  /**
   * Sets the indexes which should have this trait.
   *
   * @param indexes Indexes which should have this trait.
   * @return The old indexes which had this trait.
   */
  set(indexes, browserEvent) {
    return this._set(indexes, [...indexes].sort(numericSort), browserEvent);
  }
  _set(indexes, sortedIndexes, browserEvent) {
    const result = this.indexes;
    const sortedResult = this.sortedIndexes;
    this.indexes = indexes;
    this.sortedIndexes = sortedIndexes;
    const toRender = disjunction(sortedResult, indexes);
    this.renderer.renderIndexes(toRender);
    this._onChange.fire({ indexes, browserEvent });
    return result;
  }
  get() {
    return this.indexes;
  }
  contains(index) {
    return binarySearch(this.sortedIndexes, index, numericSort) >= 0;
  }
  dispose() {
    dispose(this._onChange);
  }
};
__decorate15([
  memoize
], Trait.prototype, "renderer", null);
var SelectionTrait = class extends Trait {
  constructor(setAriaSelected) {
    super("selected");
    this.setAriaSelected = setAriaSelected;
  }
  renderIndex(index, container) {
    super.renderIndex(index, container);
    if (this.setAriaSelected) {
      if (this.contains(index)) {
        container.setAttribute("aria-selected", "true");
      } else {
        container.setAttribute("aria-selected", "false");
      }
    }
  }
};
var TraitSpliceable = class {
  constructor(trait, view, identityProvider) {
    this.trait = trait;
    this.view = view;
    this.identityProvider = identityProvider;
  }
  splice(start, deleteCount, elements) {
    if (!this.identityProvider) {
      return this.trait.splice(start, deleteCount, new Array(elements.length).fill(false));
    }
    const pastElementsWithTrait = this.trait.get().map((i) => this.identityProvider.getId(this.view.element(i)).toString());
    if (pastElementsWithTrait.length === 0) {
      return this.trait.splice(start, deleteCount, new Array(elements.length).fill(false));
    }
    const pastElementsWithTraitSet = new Set(pastElementsWithTrait);
    const elementsWithTrait = elements.map((e) => pastElementsWithTraitSet.has(this.identityProvider.getId(e).toString()));
    this.trait.splice(start, deleteCount, elementsWithTrait);
  }
};
function isInputElement(e) {
  return e.tagName === "INPUT" || e.tagName === "TEXTAREA";
}
function isListElementDescendantOfClass(e, className) {
  if (e.classList.contains(className)) {
    return true;
  }
  if (e.classList.contains("monaco-list")) {
    return false;
  }
  if (!e.parentElement) {
    return false;
  }
  return isListElementDescendantOfClass(e.parentElement, className);
}
function isMonacoEditor(e) {
  return isListElementDescendantOfClass(e, "monaco-editor");
}
function isMonacoCustomToggle(e) {
  return isListElementDescendantOfClass(e, "monaco-custom-toggle");
}
function isActionItem(e) {
  return isListElementDescendantOfClass(e, "action-item");
}
function isStickyScrollElement(e) {
  return isListElementDescendantOfClass(e, "monaco-tree-sticky-row");
}
function isStickyScrollContainer(e) {
  return e.classList.contains("monaco-tree-sticky-container");
}
function isButton(e) {
  if (e.tagName === "A" && e.classList.contains("monaco-button") || e.tagName === "DIV" && e.classList.contains("monaco-button-dropdown")) {
    return true;
  }
  if (e.classList.contains("monaco-list")) {
    return false;
  }
  if (!e.parentElement) {
    return false;
  }
  return isButton(e.parentElement);
}
var KeyboardController = class {
  get onKeyDown() {
    return Event.chain(this.disposables.add(new DomEmitter(this.view.domNode, "keydown")).event, ($10) => $10.filter((e) => !isInputElement(e.target)).map((e) => new StandardKeyboardEvent(e)));
  }
  constructor(list, view, options2) {
    this.list = list;
    this.view = view;
    this.disposables = new DisposableStore();
    this.multipleSelectionDisposables = new DisposableStore();
    this.multipleSelectionSupport = options2.multipleSelectionSupport;
    this.disposables.add(this.onKeyDown((e) => {
      switch (e.keyCode) {
        case 3:
          return this.onEnter(e);
        case 16:
          return this.onUpArrow(e);
        case 18:
          return this.onDownArrow(e);
        case 11:
          return this.onPageUpArrow(e);
        case 12:
          return this.onPageDownArrow(e);
        case 9:
          return this.onEscape(e);
        case 31:
          if (this.multipleSelectionSupport && (isMacintosh ? e.metaKey : e.ctrlKey)) {
            this.onCtrlA(e);
          }
      }
    }));
  }
  updateOptions(optionsUpdate) {
    if (optionsUpdate.multipleSelectionSupport !== void 0) {
      this.multipleSelectionSupport = optionsUpdate.multipleSelectionSupport;
    }
  }
  onEnter(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.setSelection(this.list.getFocus(), e.browserEvent);
  }
  onUpArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.focusPrevious(1, false, e.browserEvent);
    const el = this.list.getFocus()[0];
    this.list.setAnchor(el);
    this.list.reveal(el);
    this.view.domNode.focus();
  }
  onDownArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.focusNext(1, false, e.browserEvent);
    const el = this.list.getFocus()[0];
    this.list.setAnchor(el);
    this.list.reveal(el);
    this.view.domNode.focus();
  }
  onPageUpArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.focusPreviousPage(e.browserEvent);
    const el = this.list.getFocus()[0];
    this.list.setAnchor(el);
    this.list.reveal(el);
    this.view.domNode.focus();
  }
  onPageDownArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.focusNextPage(e.browserEvent);
    const el = this.list.getFocus()[0];
    this.list.setAnchor(el);
    this.list.reveal(el);
    this.view.domNode.focus();
  }
  onCtrlA(e) {
    e.preventDefault();
    e.stopPropagation();
    this.list.setSelection(range(this.list.length), e.browserEvent);
    this.list.setAnchor(void 0);
    this.view.domNode.focus();
  }
  onEscape(e) {
    if (this.list.getSelection().length) {
      e.preventDefault();
      e.stopPropagation();
      this.list.setSelection([], e.browserEvent);
      this.list.setAnchor(void 0);
      this.view.domNode.focus();
    }
  }
  dispose() {
    this.disposables.dispose();
    this.multipleSelectionDisposables.dispose();
  }
};
__decorate15([
  memoize
], KeyboardController.prototype, "onKeyDown", null);
var TypeNavigationMode;
(function(TypeNavigationMode2) {
  TypeNavigationMode2[TypeNavigationMode2["Automatic"] = 0] = "Automatic";
  TypeNavigationMode2[TypeNavigationMode2["Trigger"] = 1] = "Trigger";
})(TypeNavigationMode || (TypeNavigationMode = {}));
var TypeNavigationControllerState;
(function(TypeNavigationControllerState2) {
  TypeNavigationControllerState2[TypeNavigationControllerState2["Idle"] = 0] = "Idle";
  TypeNavigationControllerState2[TypeNavigationControllerState2["Typing"] = 1] = "Typing";
})(TypeNavigationControllerState || (TypeNavigationControllerState = {}));
var DefaultKeyboardNavigationDelegate = new class {
  mightProducePrintableCharacter(event) {
    if (event.ctrlKey || event.metaKey || event.altKey) {
      return false;
    }
    return event.keyCode >= 31 && event.keyCode <= 56 || event.keyCode >= 21 && event.keyCode <= 30 || event.keyCode >= 98 && event.keyCode <= 107 || event.keyCode >= 85 && event.keyCode <= 95;
  }
}();
var TypeNavigationController = class {
  constructor(list, view, keyboardNavigationLabelProvider, keyboardNavigationEventFilter, delegate) {
    this.list = list;
    this.view = view;
    this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;
    this.keyboardNavigationEventFilter = keyboardNavigationEventFilter;
    this.delegate = delegate;
    this.enabled = false;
    this.state = TypeNavigationControllerState.Idle;
    this.mode = TypeNavigationMode.Automatic;
    this.triggered = false;
    this.previouslyFocused = -1;
    this.enabledDisposables = new DisposableStore();
    this.disposables = new DisposableStore();
    this.updateOptions(list.options);
  }
  updateOptions(options2) {
    var _a2, _b2;
    if ((_a2 = options2.typeNavigationEnabled) !== null && _a2 !== void 0 ? _a2 : true) {
      this.enable();
    } else {
      this.disable();
    }
    this.mode = (_b2 = options2.typeNavigationMode) !== null && _b2 !== void 0 ? _b2 : TypeNavigationMode.Automatic;
  }
  enable() {
    if (this.enabled) {
      return;
    }
    let typing = false;
    const onChar = Event.chain(this.enabledDisposables.add(new DomEmitter(this.view.domNode, "keydown")).event, ($10) => $10.filter((e) => !isInputElement(e.target)).filter(() => this.mode === TypeNavigationMode.Automatic || this.triggered).map((event) => new StandardKeyboardEvent(event)).filter((e) => typing || this.keyboardNavigationEventFilter(e)).filter((e) => this.delegate.mightProducePrintableCharacter(e)).forEach((e) => EventHelper.stop(e, true)).map((event) => event.browserEvent.key));
    const onClear = Event.debounce(onChar, () => null, 800, void 0, void 0, void 0, this.enabledDisposables);
    const onInput = Event.reduce(Event.any(onChar, onClear), (r, i) => i === null ? null : (r || "") + i, void 0, this.enabledDisposables);
    onInput(this.onInput, this, this.enabledDisposables);
    onClear(this.onClear, this, this.enabledDisposables);
    onChar(() => typing = true, void 0, this.enabledDisposables);
    onClear(() => typing = false, void 0, this.enabledDisposables);
    this.enabled = true;
    this.triggered = false;
  }
  disable() {
    if (!this.enabled) {
      return;
    }
    this.enabledDisposables.clear();
    this.enabled = false;
    this.triggered = false;
  }
  onClear() {
    var _a2;
    const focus = this.list.getFocus();
    if (focus.length > 0 && focus[0] === this.previouslyFocused) {
      const ariaLabel = (_a2 = this.list.options.accessibilityProvider) === null || _a2 === void 0 ? void 0 : _a2.getAriaLabel(this.list.element(focus[0]));
      if (ariaLabel) {
        alert(ariaLabel);
      }
    }
    this.previouslyFocused = -1;
  }
  onInput(word) {
    if (!word) {
      this.state = TypeNavigationControllerState.Idle;
      this.triggered = false;
      return;
    }
    const focus = this.list.getFocus();
    const start = focus.length > 0 ? focus[0] : 0;
    const delta = this.state === TypeNavigationControllerState.Idle ? 1 : 0;
    this.state = TypeNavigationControllerState.Typing;
    for (let i = 0; i < this.list.length; i++) {
      const index = (start + i + delta) % this.list.length;
      const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(index));
      const labelStr = label && label.toString();
      if (this.list.options.typeNavigationEnabled) {
        if (typeof labelStr !== "undefined") {
          if (matchesPrefix(word, labelStr)) {
            this.previouslyFocused = start;
            this.list.setFocus([index]);
            this.list.reveal(index);
            return;
          }
          const fuzzy = matchesFuzzy2(word, labelStr);
          if (fuzzy) {
            const fuzzyScore2 = fuzzy[0].end - fuzzy[0].start;
            if (fuzzyScore2 > 1 && fuzzy.length === 1) {
              this.previouslyFocused = start;
              this.list.setFocus([index]);
              this.list.reveal(index);
              return;
            }
          }
        }
      } else if (typeof labelStr === "undefined" || matchesPrefix(word, labelStr)) {
        this.previouslyFocused = start;
        this.list.setFocus([index]);
        this.list.reveal(index);
        return;
      }
    }
  }
  dispose() {
    this.disable();
    this.enabledDisposables.dispose();
    this.disposables.dispose();
  }
};
var DOMFocusController = class {
  constructor(list, view) {
    this.list = list;
    this.view = view;
    this.disposables = new DisposableStore();
    const onKeyDown = Event.chain(this.disposables.add(new DomEmitter(view.domNode, "keydown")).event, ($10) => $10.filter((e) => !isInputElement(e.target)).map((e) => new StandardKeyboardEvent(e)));
    const onTab = Event.chain(onKeyDown, ($10) => $10.filter((e) => e.keyCode === 2 && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey));
    onTab(this.onTab, this, this.disposables);
  }
  onTab(e) {
    if (e.target !== this.view.domNode) {
      return;
    }
    const focus = this.list.getFocus();
    if (focus.length === 0) {
      return;
    }
    const focusedDomElement = this.view.domElement(focus[0]);
    if (!focusedDomElement) {
      return;
    }
    const tabIndexElement = focusedDomElement.querySelector("[tabIndex]");
    if (!tabIndexElement || !(tabIndexElement instanceof HTMLElement) || tabIndexElement.tabIndex === -1) {
      return;
    }
    const style = getWindow(tabIndexElement).getComputedStyle(tabIndexElement);
    if (style.visibility === "hidden" || style.display === "none") {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    tabIndexElement.focus();
  }
  dispose() {
    this.disposables.dispose();
  }
};
function isSelectionSingleChangeEvent(event) {
  return isMacintosh ? event.browserEvent.metaKey : event.browserEvent.ctrlKey;
}
function isSelectionRangeChangeEvent(event) {
  return event.browserEvent.shiftKey;
}
function isMouseRightClick(event) {
  return isMouseEvent(event) && event.button === 2;
}
var DefaultMultipleSelectionController = {
  isSelectionSingleChangeEvent,
  isSelectionRangeChangeEvent
};
var MouseController = class {
  constructor(list) {
    this.list = list;
    this.disposables = new DisposableStore();
    this._onPointer = new Emitter();
    this.onPointer = this._onPointer.event;
    if (list.options.multipleSelectionSupport !== false) {
      this.multipleSelectionController = this.list.options.multipleSelectionController || DefaultMultipleSelectionController;
    }
    this.mouseSupport = typeof list.options.mouseSupport === "undefined" || !!list.options.mouseSupport;
    if (this.mouseSupport) {
      list.onMouseDown(this.onMouseDown, this, this.disposables);
      list.onContextMenu(this.onContextMenu, this, this.disposables);
      list.onMouseDblClick(this.onDoubleClick, this, this.disposables);
      list.onTouchStart(this.onMouseDown, this, this.disposables);
      this.disposables.add(Gesture.addTarget(list.getHTMLElement()));
    }
    Event.any(list.onMouseClick, list.onMouseMiddleClick, list.onTap)(this.onViewPointer, this, this.disposables);
  }
  updateOptions(optionsUpdate) {
    if (optionsUpdate.multipleSelectionSupport !== void 0) {
      this.multipleSelectionController = void 0;
      if (optionsUpdate.multipleSelectionSupport) {
        this.multipleSelectionController = this.list.options.multipleSelectionController || DefaultMultipleSelectionController;
      }
    }
  }
  isSelectionSingleChangeEvent(event) {
    if (!this.multipleSelectionController) {
      return false;
    }
    return this.multipleSelectionController.isSelectionSingleChangeEvent(event);
  }
  isSelectionRangeChangeEvent(event) {
    if (!this.multipleSelectionController) {
      return false;
    }
    return this.multipleSelectionController.isSelectionRangeChangeEvent(event);
  }
  isSelectionChangeEvent(event) {
    return this.isSelectionSingleChangeEvent(event) || this.isSelectionRangeChangeEvent(event);
  }
  onMouseDown(e) {
    if (isMonacoEditor(e.browserEvent.target)) {
      return;
    }
    if (getActiveElement() !== e.browserEvent.target) {
      this.list.domFocus();
    }
  }
  onContextMenu(e) {
    if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {
      return;
    }
    const focus = typeof e.index === "undefined" ? [] : [e.index];
    this.list.setFocus(focus, e.browserEvent);
  }
  onViewPointer(e) {
    if (!this.mouseSupport) {
      return;
    }
    if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {
      return;
    }
    if (e.browserEvent.isHandledByList) {
      return;
    }
    e.browserEvent.isHandledByList = true;
    const focus = e.index;
    if (typeof focus === "undefined") {
      this.list.setFocus([], e.browserEvent);
      this.list.setSelection([], e.browserEvent);
      this.list.setAnchor(void 0);
      return;
    }
    if (this.isSelectionChangeEvent(e)) {
      return this.changeSelection(e);
    }
    this.list.setFocus([focus], e.browserEvent);
    this.list.setAnchor(focus);
    if (!isMouseRightClick(e.browserEvent)) {
      this.list.setSelection([focus], e.browserEvent);
    }
    this._onPointer.fire(e);
  }
  onDoubleClick(e) {
    if (isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {
      return;
    }
    if (this.isSelectionChangeEvent(e)) {
      return;
    }
    if (e.browserEvent.isHandledByList) {
      return;
    }
    e.browserEvent.isHandledByList = true;
    const focus = this.list.getFocus();
    this.list.setSelection(focus, e.browserEvent);
  }
  changeSelection(e) {
    const focus = e.index;
    let anchor = this.list.getAnchor();
    if (this.isSelectionRangeChangeEvent(e)) {
      if (typeof anchor === "undefined") {
        const currentFocus = this.list.getFocus()[0];
        anchor = currentFocus !== null && currentFocus !== void 0 ? currentFocus : focus;
        this.list.setAnchor(anchor);
      }
      const min = Math.min(anchor, focus);
      const max = Math.max(anchor, focus);
      const rangeSelection = range(min, max + 1);
      const selection = this.list.getSelection();
      const contiguousRange = getContiguousRangeContaining(disjunction(selection, [anchor]), anchor);
      if (contiguousRange.length === 0) {
        return;
      }
      const newSelection = disjunction(rangeSelection, relativeComplement(selection, contiguousRange));
      this.list.setSelection(newSelection, e.browserEvent);
      this.list.setFocus([focus], e.browserEvent);
    } else if (this.isSelectionSingleChangeEvent(e)) {
      const selection = this.list.getSelection();
      const newSelection = selection.filter((i) => i !== focus);
      this.list.setFocus([focus]);
      this.list.setAnchor(focus);
      if (selection.length === newSelection.length) {
        this.list.setSelection([...newSelection, focus], e.browserEvent);
      } else {
        this.list.setSelection(newSelection, e.browserEvent);
      }
    }
  }
  dispose() {
    this.disposables.dispose();
  }
};
var DefaultStyleController = class {
  constructor(styleElement, selectorSuffix) {
    this.styleElement = styleElement;
    this.selectorSuffix = selectorSuffix;
  }
  style(styles) {
    var _a2, _b2;
    const suffix = this.selectorSuffix && `.${this.selectorSuffix}`;
    const content = [];
    if (styles.listBackground) {
      content.push(`.monaco-list${suffix} .monaco-list-rows { background: ${styles.listBackground}; }`);
    }
    if (styles.listFocusBackground) {
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused { background-color: ${styles.listFocusBackground}; }`);
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused:hover { background-color: ${styles.listFocusBackground}; }`);
    }
    if (styles.listFocusForeground) {
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused { color: ${styles.listFocusForeground}; }`);
    }
    if (styles.listActiveSelectionBackground) {
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected { background-color: ${styles.listActiveSelectionBackground}; }`);
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected:hover { background-color: ${styles.listActiveSelectionBackground}; }`);
    }
    if (styles.listActiveSelectionForeground) {
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected { color: ${styles.listActiveSelectionForeground}; }`);
    }
    if (styles.listActiveSelectionIconForeground) {
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.selected .codicon { color: ${styles.listActiveSelectionIconForeground}; }`);
    }
    if (styles.listFocusAndSelectionBackground) {
      content.push(`
				.monaco-drag-image,
				.monaco-list${suffix}:focus .monaco-list-row.selected.focused { background-color: ${styles.listFocusAndSelectionBackground}; }
			`);
    }
    if (styles.listFocusAndSelectionForeground) {
      content.push(`
				.monaco-drag-image,
				.monaco-list${suffix}:focus .monaco-list-row.selected.focused { color: ${styles.listFocusAndSelectionForeground}; }
			`);
    }
    if (styles.listInactiveFocusForeground) {
      content.push(`.monaco-list${suffix} .monaco-list-row.focused { color:  ${styles.listInactiveFocusForeground}; }`);
      content.push(`.monaco-list${suffix} .monaco-list-row.focused:hover { color:  ${styles.listInactiveFocusForeground}; }`);
    }
    if (styles.listInactiveSelectionIconForeground) {
      content.push(`.monaco-list${suffix} .monaco-list-row.focused .codicon { color:  ${styles.listInactiveSelectionIconForeground}; }`);
    }
    if (styles.listInactiveFocusBackground) {
      content.push(`.monaco-list${suffix} .monaco-list-row.focused { background-color:  ${styles.listInactiveFocusBackground}; }`);
      content.push(`.monaco-list${suffix} .monaco-list-row.focused:hover { background-color:  ${styles.listInactiveFocusBackground}; }`);
    }
    if (styles.listInactiveSelectionBackground) {
      content.push(`.monaco-list${suffix} .monaco-list-row.selected { background-color:  ${styles.listInactiveSelectionBackground}; }`);
      content.push(`.monaco-list${suffix} .monaco-list-row.selected:hover { background-color:  ${styles.listInactiveSelectionBackground}; }`);
    }
    if (styles.listInactiveSelectionForeground) {
      content.push(`.monaco-list${suffix} .monaco-list-row.selected { color: ${styles.listInactiveSelectionForeground}; }`);
    }
    if (styles.listHoverBackground) {
      content.push(`.monaco-list${suffix}:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused) { background-color: ${styles.listHoverBackground}; }`);
    }
    if (styles.listHoverForeground) {
      content.push(`.monaco-list${suffix}:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused) { color:  ${styles.listHoverForeground}; }`);
    }
    const focusAndSelectionOutline = asCssValueWithDefault(styles.listFocusAndSelectionOutline, asCssValueWithDefault(styles.listSelectionOutline, (_a2 = styles.listFocusOutline) !== null && _a2 !== void 0 ? _a2 : ""));
    if (focusAndSelectionOutline) {
      content.push(`.monaco-list${suffix}:focus .monaco-list-row.focused.selected { outline: 1px solid ${focusAndSelectionOutline}; outline-offset: -1px;}`);
    }
    if (styles.listFocusOutline) {
      content.push(`
				.monaco-drag-image,
				.monaco-list${suffix}:focus .monaco-list-row.focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }
				.monaco-workbench.context-menu-visible .monaco-list${suffix}.last-focused .monaco-list-row.focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }
			`);
    }
    const inactiveFocusAndSelectionOutline = asCssValueWithDefault(styles.listSelectionOutline, (_b2 = styles.listInactiveFocusOutline) !== null && _b2 !== void 0 ? _b2 : "");
    if (inactiveFocusAndSelectionOutline) {
      content.push(`.monaco-list${suffix} .monaco-list-row.focused.selected { outline: 1px dotted ${inactiveFocusAndSelectionOutline}; outline-offset: -1px; }`);
    }
    if (styles.listSelectionOutline) {
      content.push(`.monaco-list${suffix} .monaco-list-row.selected { outline: 1px dotted ${styles.listSelectionOutline}; outline-offset: -1px; }`);
    }
    if (styles.listInactiveFocusOutline) {
      content.push(`.monaco-list${suffix} .monaco-list-row.focused { outline: 1px dotted ${styles.listInactiveFocusOutline}; outline-offset: -1px; }`);
    }
    if (styles.listHoverOutline) {
      content.push(`.monaco-list${suffix} .monaco-list-row:hover { outline: 1px dashed ${styles.listHoverOutline}; outline-offset: -1px; }`);
    }
    if (styles.listDropOverBackground) {
      content.push(`
				.monaco-list${suffix}.drop-target,
				.monaco-list${suffix} .monaco-list-rows.drop-target,
				.monaco-list${suffix} .monaco-list-row.drop-target { background-color: ${styles.listDropOverBackground} !important; color: inherit !important; }
			`);
    }
    if (styles.listDropBetweenBackground) {
      content.push(`
			.monaco-list${suffix} .monaco-list-rows.drop-target-before .monaco-list-row:first-child::before,
			.monaco-list${suffix} .monaco-list-row.drop-target-before::before {
				content: ""; position: absolute; top: 0px; left: 0px; width: 100%; height: 1px;
				background-color: ${styles.listDropBetweenBackground};
			}`);
      content.push(`
			.monaco-list${suffix} .monaco-list-rows.drop-target-after .monaco-list-row:last-child::after,
			.monaco-list${suffix} .monaco-list-row.drop-target-after::after {
				content: ""; position: absolute; bottom: 0px; left: 0px; width: 100%; height: 1px;
				background-color: ${styles.listDropBetweenBackground};
			}`);
    }
    if (styles.tableColumnsBorder) {
      content.push(`
				.monaco-table > .monaco-split-view2,
				.monaco-table > .monaco-split-view2 .monaco-sash.vertical::before,
				.monaco-workbench:not(.reduce-motion) .monaco-table:hover > .monaco-split-view2,
				.monaco-workbench:not(.reduce-motion) .monaco-table:hover > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: ${styles.tableColumnsBorder};
				}

				.monaco-workbench:not(.reduce-motion) .monaco-table > .monaco-split-view2,
				.monaco-workbench:not(.reduce-motion) .monaco-table > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: transparent;
				}
			`);
    }
    if (styles.tableOddRowsBackgroundColor) {
      content.push(`
				.monaco-table .monaco-list-row[data-parity=odd]:not(.focused):not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(:focus) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(.focused) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr {
					background-color: ${styles.tableOddRowsBackgroundColor};
				}
			`);
    }
    this.styleElement.textContent = content.join("\n");
  }
};
var unthemedListStyles = {
  listFocusBackground: "#7FB0D0",
  listActiveSelectionBackground: "#0E639C",
  listActiveSelectionForeground: "#FFFFFF",
  listActiveSelectionIconForeground: "#FFFFFF",
  listFocusAndSelectionOutline: "#90C2F9",
  listFocusAndSelectionBackground: "#094771",
  listFocusAndSelectionForeground: "#FFFFFF",
  listInactiveSelectionBackground: "#3F3F46",
  listInactiveSelectionIconForeground: "#FFFFFF",
  listHoverBackground: "#2A2D2E",
  listDropOverBackground: "#383B3D",
  listDropBetweenBackground: "#EEEEEE",
  treeIndentGuidesStroke: "#a9a9a9",
  treeInactiveIndentGuidesStroke: Color.fromHex("#a9a9a9").transparent(0.4).toString(),
  tableColumnsBorder: Color.fromHex("#cccccc").transparent(0.2).toString(),
  tableOddRowsBackgroundColor: Color.fromHex("#cccccc").transparent(0.04).toString(),
  listBackground: void 0,
  listFocusForeground: void 0,
  listInactiveSelectionForeground: void 0,
  listInactiveFocusForeground: void 0,
  listInactiveFocusBackground: void 0,
  listHoverForeground: void 0,
  listFocusOutline: void 0,
  listInactiveFocusOutline: void 0,
  listSelectionOutline: void 0,
  listHoverOutline: void 0
};
var DefaultOptions2 = {
  keyboardSupport: true,
  mouseSupport: true,
  multipleSelectionSupport: true,
  dnd: {
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return false;
    },
    drop() {
    },
    dispose() {
    }
  }
};
function getContiguousRangeContaining(range2, value) {
  const index = range2.indexOf(value);
  if (index === -1) {
    return [];
  }
  const result = [];
  let i = index - 1;
  while (i >= 0 && range2[i] === value - (index - i)) {
    result.push(range2[i--]);
  }
  result.reverse();
  i = index;
  while (i < range2.length && range2[i] === value + (i - index)) {
    result.push(range2[i++]);
  }
  return result;
}
function disjunction(one, other) {
  const result = [];
  let i = 0, j = 0;
  while (i < one.length || j < other.length) {
    if (i >= one.length) {
      result.push(other[j++]);
    } else if (j >= other.length) {
      result.push(one[i++]);
    } else if (one[i] === other[j]) {
      result.push(one[i]);
      i++;
      j++;
      continue;
    } else if (one[i] < other[j]) {
      result.push(one[i++]);
    } else {
      result.push(other[j++]);
    }
  }
  return result;
}
function relativeComplement(one, other) {
  const result = [];
  let i = 0, j = 0;
  while (i < one.length || j < other.length) {
    if (i >= one.length) {
      result.push(other[j++]);
    } else if (j >= other.length) {
      result.push(one[i++]);
    } else if (one[i] === other[j]) {
      i++;
      j++;
      continue;
    } else if (one[i] < other[j]) {
      result.push(one[i++]);
    } else {
      j++;
    }
  }
  return result;
}
var numericSort = (a, b) => a - b;
var PipelineRenderer = class {
  constructor(_templateId, renderers) {
    this._templateId = _templateId;
    this.renderers = renderers;
  }
  get templateId() {
    return this._templateId;
  }
  renderTemplate(container) {
    return this.renderers.map((r) => r.renderTemplate(container));
  }
  renderElement(element, index, templateData, height) {
    let i = 0;
    for (const renderer of this.renderers) {
      renderer.renderElement(element, index, templateData[i++], height);
    }
  }
  disposeElement(element, index, templateData, height) {
    var _a2;
    let i = 0;
    for (const renderer of this.renderers) {
      (_a2 = renderer.disposeElement) === null || _a2 === void 0 ? void 0 : _a2.call(renderer, element, index, templateData[i], height);
      i += 1;
    }
  }
  disposeTemplate(templateData) {
    let i = 0;
    for (const renderer of this.renderers) {
      renderer.disposeTemplate(templateData[i++]);
    }
  }
};
var AccessibiltyRenderer = class {
  constructor(accessibilityProvider) {
    this.accessibilityProvider = accessibilityProvider;
    this.templateId = "a18n";
  }
  renderTemplate(container) {
    return container;
  }
  renderElement(element, index, container) {
    const ariaLabel = this.accessibilityProvider.getAriaLabel(element);
    if (ariaLabel) {
      container.setAttribute("aria-label", ariaLabel);
    } else {
      container.removeAttribute("aria-label");
    }
    const ariaLevel = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(element);
    if (typeof ariaLevel === "number") {
      container.setAttribute("aria-level", `${ariaLevel}`);
    } else {
      container.removeAttribute("aria-level");
    }
  }
  disposeTemplate(templateData) {
  }
};
var ListViewDragAndDrop = class {
  constructor(list, dnd) {
    this.list = list;
    this.dnd = dnd;
  }
  getDragElements(element) {
    const selection = this.list.getSelectedElements();
    const elements = selection.indexOf(element) > -1 ? selection : [element];
    return elements;
  }
  getDragURI(element) {
    return this.dnd.getDragURI(element);
  }
  getDragLabel(elements, originalEvent) {
    if (this.dnd.getDragLabel) {
      return this.dnd.getDragLabel(elements, originalEvent);
    }
    return void 0;
  }
  onDragStart(data, originalEvent) {
    var _a2, _b2;
    (_b2 = (_a2 = this.dnd).onDragStart) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, data, originalEvent);
  }
  onDragOver(data, targetElement, targetIndex, targetSector, originalEvent) {
    return this.dnd.onDragOver(data, targetElement, targetIndex, targetSector, originalEvent);
  }
  onDragLeave(data, targetElement, targetIndex, originalEvent) {
    var _a2, _b2;
    (_b2 = (_a2 = this.dnd).onDragLeave) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, data, targetElement, targetIndex, originalEvent);
  }
  onDragEnd(originalEvent) {
    var _a2, _b2;
    (_b2 = (_a2 = this.dnd).onDragEnd) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, originalEvent);
  }
  drop(data, targetElement, targetIndex, targetSector, originalEvent) {
    this.dnd.drop(data, targetElement, targetIndex, targetSector, originalEvent);
  }
  dispose() {
    this.dnd.dispose();
  }
};
var List = class {
  get onDidChangeFocus() {
    return Event.map(this.eventBufferer.wrapEvent(this.focus.onChange), (e) => this.toListEvent(e), this.disposables);
  }
  get onDidChangeSelection() {
    return Event.map(this.eventBufferer.wrapEvent(this.selection.onChange), (e) => this.toListEvent(e), this.disposables);
  }
  get domId() {
    return this.view.domId;
  }
  get onDidScroll() {
    return this.view.onDidScroll;
  }
  get onMouseClick() {
    return this.view.onMouseClick;
  }
  get onMouseDblClick() {
    return this.view.onMouseDblClick;
  }
  get onMouseMiddleClick() {
    return this.view.onMouseMiddleClick;
  }
  get onPointer() {
    return this.mouseController.onPointer;
  }
  get onMouseDown() {
    return this.view.onMouseDown;
  }
  get onMouseOver() {
    return this.view.onMouseOver;
  }
  get onMouseOut() {
    return this.view.onMouseOut;
  }
  get onTouchStart() {
    return this.view.onTouchStart;
  }
  get onTap() {
    return this.view.onTap;
  }
  /**
   * Possible context menu trigger events:
   * - ContextMenu key
   * - Shift F10
   * - Ctrl Option Shift M (macOS with VoiceOver)
   * - Mouse right click
   */
  get onContextMenu() {
    let didJustPressContextMenuKey = false;
    const fromKeyDown = Event.chain(this.disposables.add(new DomEmitter(this.view.domNode, "keydown")).event, ($10) => $10.map((e) => new StandardKeyboardEvent(e)).filter((e) => didJustPressContextMenuKey = e.keyCode === 58 || e.shiftKey && e.keyCode === 68).map((e) => EventHelper.stop(e, true)).filter(() => false));
    const fromKeyUp = Event.chain(this.disposables.add(new DomEmitter(this.view.domNode, "keyup")).event, ($10) => $10.forEach(() => didJustPressContextMenuKey = false).map((e) => new StandardKeyboardEvent(e)).filter((e) => e.keyCode === 58 || e.shiftKey && e.keyCode === 68).map((e) => EventHelper.stop(e, true)).map(({ browserEvent }) => {
      const focus = this.getFocus();
      const index = focus.length ? focus[0] : void 0;
      const element = typeof index !== "undefined" ? this.view.element(index) : void 0;
      const anchor = typeof index !== "undefined" ? this.view.domElement(index) : this.view.domNode;
      return { index, element, anchor, browserEvent };
    }));
    const fromMouse = Event.chain(this.view.onContextMenu, ($10) => $10.filter((_) => !didJustPressContextMenuKey).map(({ element, index, browserEvent }) => ({ element, index, anchor: new StandardMouseEvent(getWindow(this.view.domNode), browserEvent), browserEvent })));
    return Event.any(fromKeyDown, fromKeyUp, fromMouse);
  }
  get onKeyDown() {
    return this.disposables.add(new DomEmitter(this.view.domNode, "keydown")).event;
  }
  get onDidFocus() {
    return Event.signal(this.disposables.add(new DomEmitter(this.view.domNode, "focus", true)).event);
  }
  get onDidBlur() {
    return Event.signal(this.disposables.add(new DomEmitter(this.view.domNode, "blur", true)).event);
  }
  constructor(user, container, virtualDelegate, renderers, _options = DefaultOptions2) {
    var _a2, _b2, _c, _d;
    this.user = user;
    this._options = _options;
    this.focus = new Trait("focused");
    this.anchor = new Trait("anchor");
    this.eventBufferer = new EventBufferer();
    this._ariaLabel = "";
    this.disposables = new DisposableStore();
    this._onDidDispose = new Emitter();
    this.onDidDispose = this._onDidDispose.event;
    const role = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? (_a2 = this._options.accessibilityProvider) === null || _a2 === void 0 ? void 0 : _a2.getWidgetRole() : "list";
    this.selection = new SelectionTrait(role !== "listbox");
    const baseRenderers = [this.focus.renderer, this.selection.renderer];
    this.accessibilityProvider = _options.accessibilityProvider;
    if (this.accessibilityProvider) {
      baseRenderers.push(new AccessibiltyRenderer(this.accessibilityProvider));
      (_c = (_b2 = this.accessibilityProvider).onDidChangeActiveDescendant) === null || _c === void 0 ? void 0 : _c.call(_b2, this.onDidChangeActiveDescendant, this, this.disposables);
    }
    renderers = renderers.map((r) => new PipelineRenderer(r.templateId, [...baseRenderers, r]));
    const viewOptions = {
      ..._options,
      dnd: _options.dnd && new ListViewDragAndDrop(this, _options.dnd)
    };
    this.view = this.createListView(container, virtualDelegate, renderers, viewOptions);
    this.view.domNode.setAttribute("role", role);
    if (_options.styleController) {
      this.styleController = _options.styleController(this.view.domId);
    } else {
      const styleElement = createStyleSheet(this.view.domNode);
      this.styleController = new DefaultStyleController(styleElement, this.view.domId);
    }
    this.spliceable = new CombinedSpliceable([
      new TraitSpliceable(this.focus, this.view, _options.identityProvider),
      new TraitSpliceable(this.selection, this.view, _options.identityProvider),
      new TraitSpliceable(this.anchor, this.view, _options.identityProvider),
      this.view
    ]);
    this.disposables.add(this.focus);
    this.disposables.add(this.selection);
    this.disposables.add(this.anchor);
    this.disposables.add(this.view);
    this.disposables.add(this._onDidDispose);
    this.disposables.add(new DOMFocusController(this, this.view));
    if (typeof _options.keyboardSupport !== "boolean" || _options.keyboardSupport) {
      this.keyboardController = new KeyboardController(this, this.view, _options);
      this.disposables.add(this.keyboardController);
    }
    if (_options.keyboardNavigationLabelProvider) {
      const delegate = _options.keyboardNavigationDelegate || DefaultKeyboardNavigationDelegate;
      this.typeNavigationController = new TypeNavigationController(this, this.view, _options.keyboardNavigationLabelProvider, (_d = _options.keyboardNavigationEventFilter) !== null && _d !== void 0 ? _d : () => true, delegate);
      this.disposables.add(this.typeNavigationController);
    }
    this.mouseController = this.createMouseController(_options);
    this.disposables.add(this.mouseController);
    this.onDidChangeFocus(this._onFocusChange, this, this.disposables);
    this.onDidChangeSelection(this._onSelectionChange, this, this.disposables);
    if (this.accessibilityProvider) {
      this.ariaLabel = this.accessibilityProvider.getWidgetAriaLabel();
    }
    if (this._options.multipleSelectionSupport !== false) {
      this.view.domNode.setAttribute("aria-multiselectable", "true");
    }
  }
  createListView(container, virtualDelegate, renderers, viewOptions) {
    return new ListView(container, virtualDelegate, renderers, viewOptions);
  }
  createMouseController(options2) {
    return new MouseController(this);
  }
  updateOptions(optionsUpdate = {}) {
    var _a2, _b2;
    this._options = { ...this._options, ...optionsUpdate };
    (_a2 = this.typeNavigationController) === null || _a2 === void 0 ? void 0 : _a2.updateOptions(this._options);
    if (this._options.multipleSelectionController !== void 0) {
      if (this._options.multipleSelectionSupport) {
        this.view.domNode.setAttribute("aria-multiselectable", "true");
      } else {
        this.view.domNode.removeAttribute("aria-multiselectable");
      }
    }
    this.mouseController.updateOptions(optionsUpdate);
    (_b2 = this.keyboardController) === null || _b2 === void 0 ? void 0 : _b2.updateOptions(optionsUpdate);
    this.view.updateOptions(optionsUpdate);
  }
  get options() {
    return this._options;
  }
  splice(start, deleteCount, elements = []) {
    if (start < 0 || start > this.view.length) {
      throw new ListError(this.user, `Invalid start index: ${start}`);
    }
    if (deleteCount < 0) {
      throw new ListError(this.user, `Invalid delete count: ${deleteCount}`);
    }
    if (deleteCount === 0 && elements.length === 0) {
      return;
    }
    this.eventBufferer.bufferEvents(() => this.spliceable.splice(start, deleteCount, elements));
  }
  rerender() {
    this.view.rerender();
  }
  element(index) {
    return this.view.element(index);
  }
  indexOf(element) {
    return this.view.indexOf(element);
  }
  indexAt(position) {
    return this.view.indexAt(position);
  }
  get length() {
    return this.view.length;
  }
  get contentHeight() {
    return this.view.contentHeight;
  }
  get onDidChangeContentHeight() {
    return this.view.onDidChangeContentHeight;
  }
  get scrollTop() {
    return this.view.getScrollTop();
  }
  set scrollTop(scrollTop) {
    this.view.setScrollTop(scrollTop);
  }
  get scrollHeight() {
    return this.view.scrollHeight;
  }
  get renderHeight() {
    return this.view.renderHeight;
  }
  get firstVisibleIndex() {
    return this.view.firstVisibleIndex;
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  set ariaLabel(value) {
    this._ariaLabel = value;
    this.view.domNode.setAttribute("aria-label", value);
  }
  domFocus() {
    this.view.domNode.focus({ preventScroll: true });
  }
  layout(height, width) {
    this.view.layout(height, width);
  }
  setSelection(indexes, browserEvent) {
    for (const index of indexes) {
      if (index < 0 || index >= this.length) {
        throw new ListError(this.user, `Invalid index ${index}`);
      }
    }
    this.selection.set(indexes, browserEvent);
  }
  getSelection() {
    return this.selection.get();
  }
  getSelectedElements() {
    return this.getSelection().map((i) => this.view.element(i));
  }
  setAnchor(index) {
    if (typeof index === "undefined") {
      this.anchor.set([]);
      return;
    }
    if (index < 0 || index >= this.length) {
      throw new ListError(this.user, `Invalid index ${index}`);
    }
    this.anchor.set([index]);
  }
  getAnchor() {
    return firstOrDefault(this.anchor.get(), void 0);
  }
  getAnchorElement() {
    const anchor = this.getAnchor();
    return typeof anchor === "undefined" ? void 0 : this.element(anchor);
  }
  setFocus(indexes, browserEvent) {
    for (const index of indexes) {
      if (index < 0 || index >= this.length) {
        throw new ListError(this.user, `Invalid index ${index}`);
      }
    }
    this.focus.set(indexes, browserEvent);
  }
  focusNext(n = 1, loop = false, browserEvent, filter) {
    if (this.length === 0) {
      return;
    }
    const focus = this.focus.get();
    const index = this.findNextIndex(focus.length > 0 ? focus[0] + n : 0, loop, filter);
    if (index > -1) {
      this.setFocus([index], browserEvent);
    }
  }
  focusPrevious(n = 1, loop = false, browserEvent, filter) {
    if (this.length === 0) {
      return;
    }
    const focus = this.focus.get();
    const index = this.findPreviousIndex(focus.length > 0 ? focus[0] - n : 0, loop, filter);
    if (index > -1) {
      this.setFocus([index], browserEvent);
    }
  }
  async focusNextPage(browserEvent, filter) {
    let lastPageIndex = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
    lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;
    const currentlyFocusedElementIndex = this.getFocus()[0];
    if (currentlyFocusedElementIndex !== lastPageIndex && (currentlyFocusedElementIndex === void 0 || lastPageIndex > currentlyFocusedElementIndex)) {
      const lastGoodPageIndex = this.findPreviousIndex(lastPageIndex, false, filter);
      if (lastGoodPageIndex > -1 && currentlyFocusedElementIndex !== lastGoodPageIndex) {
        this.setFocus([lastGoodPageIndex], browserEvent);
      } else {
        this.setFocus([lastPageIndex], browserEvent);
      }
    } else {
      const previousScrollTop = this.view.getScrollTop();
      let nextpageScrollTop = previousScrollTop + this.view.renderHeight;
      if (lastPageIndex > currentlyFocusedElementIndex) {
        nextpageScrollTop -= this.view.elementHeight(lastPageIndex);
      }
      this.view.setScrollTop(nextpageScrollTop);
      if (this.view.getScrollTop() !== previousScrollTop) {
        this.setFocus([]);
        await timeout(0);
        await this.focusNextPage(browserEvent, filter);
      }
    }
  }
  async focusPreviousPage(browserEvent, filter, getPaddingTop = () => 0) {
    let firstPageIndex;
    const paddingTop = getPaddingTop();
    const scrollTop = this.view.getScrollTop() + paddingTop;
    if (scrollTop === 0) {
      firstPageIndex = this.view.indexAt(scrollTop);
    } else {
      firstPageIndex = this.view.indexAfter(scrollTop - 1);
    }
    const currentlyFocusedElementIndex = this.getFocus()[0];
    if (currentlyFocusedElementIndex !== firstPageIndex && (currentlyFocusedElementIndex === void 0 || currentlyFocusedElementIndex >= firstPageIndex)) {
      const firstGoodPageIndex = this.findNextIndex(firstPageIndex, false, filter);
      if (firstGoodPageIndex > -1 && currentlyFocusedElementIndex !== firstGoodPageIndex) {
        this.setFocus([firstGoodPageIndex], browserEvent);
      } else {
        this.setFocus([firstPageIndex], browserEvent);
      }
    } else {
      const previousScrollTop = scrollTop;
      this.view.setScrollTop(scrollTop - this.view.renderHeight - paddingTop);
      if (this.view.getScrollTop() + getPaddingTop() !== previousScrollTop) {
        this.setFocus([]);
        await timeout(0);
        await this.focusPreviousPage(browserEvent, filter, getPaddingTop);
      }
    }
  }
  focusLast(browserEvent, filter) {
    if (this.length === 0) {
      return;
    }
    const index = this.findPreviousIndex(this.length - 1, false, filter);
    if (index > -1) {
      this.setFocus([index], browserEvent);
    }
  }
  focusFirst(browserEvent, filter) {
    this.focusNth(0, browserEvent, filter);
  }
  focusNth(n, browserEvent, filter) {
    if (this.length === 0) {
      return;
    }
    const index = this.findNextIndex(n, false, filter);
    if (index > -1) {
      this.setFocus([index], browserEvent);
    }
  }
  findNextIndex(index, loop = false, filter) {
    for (let i = 0; i < this.length; i++) {
      if (index >= this.length && !loop) {
        return -1;
      }
      index = index % this.length;
      if (!filter || filter(this.element(index))) {
        return index;
      }
      index++;
    }
    return -1;
  }
  findPreviousIndex(index, loop = false, filter) {
    for (let i = 0; i < this.length; i++) {
      if (index < 0 && !loop) {
        return -1;
      }
      index = (this.length + index % this.length) % this.length;
      if (!filter || filter(this.element(index))) {
        return index;
      }
      index--;
    }
    return -1;
  }
  getFocus() {
    return this.focus.get();
  }
  getFocusedElements() {
    return this.getFocus().map((i) => this.view.element(i));
  }
  reveal(index, relativeTop, paddingTop = 0) {
    if (index < 0 || index >= this.length) {
      throw new ListError(this.user, `Invalid index ${index}`);
    }
    const scrollTop = this.view.getScrollTop();
    const elementTop = this.view.elementTop(index);
    const elementHeight = this.view.elementHeight(index);
    if (isNumber(relativeTop)) {
      const m = elementHeight - this.view.renderHeight + paddingTop;
      this.view.setScrollTop(m * clamp(relativeTop, 0, 1) + elementTop - paddingTop);
    } else {
      const viewItemBottom = elementTop + elementHeight;
      const scrollBottom = scrollTop + this.view.renderHeight;
      if (elementTop < scrollTop + paddingTop && viewItemBottom >= scrollBottom) {
      } else if (elementTop < scrollTop + paddingTop || viewItemBottom >= scrollBottom && elementHeight >= this.view.renderHeight) {
        this.view.setScrollTop(elementTop - paddingTop);
      } else if (viewItemBottom >= scrollBottom) {
        this.view.setScrollTop(viewItemBottom - this.view.renderHeight);
      }
    }
  }
  /**
   * Returns the relative position of an element rendered in the list.
   * Returns `null` if the element isn't *entirely* in the visible viewport.
   */
  getRelativeTop(index, paddingTop = 0) {
    if (index < 0 || index >= this.length) {
      throw new ListError(this.user, `Invalid index ${index}`);
    }
    const scrollTop = this.view.getScrollTop();
    const elementTop = this.view.elementTop(index);
    const elementHeight = this.view.elementHeight(index);
    if (elementTop < scrollTop + paddingTop || elementTop + elementHeight > scrollTop + this.view.renderHeight) {
      return null;
    }
    const m = elementHeight - this.view.renderHeight + paddingTop;
    return Math.abs((scrollTop + paddingTop - elementTop) / m);
  }
  isDOMFocused() {
    return isActiveElement(this.view.domNode);
  }
  getHTMLElement() {
    return this.view.domNode;
  }
  getScrollableElement() {
    return this.view.scrollableElementDomNode;
  }
  getElementID(index) {
    return this.view.getElementDomId(index);
  }
  getElementTop(index) {
    return this.view.elementTop(index);
  }
  style(styles) {
    this.styleController.style(styles);
  }
  toListEvent({ indexes, browserEvent }) {
    return { indexes, elements: indexes.map((i) => this.view.element(i)), browserEvent };
  }
  _onFocusChange() {
    const focus = this.focus.get();
    this.view.domNode.classList.toggle("element-focused", focus.length > 0);
    this.onDidChangeActiveDescendant();
  }
  onDidChangeActiveDescendant() {
    var _a2;
    const focus = this.focus.get();
    if (focus.length > 0) {
      let id;
      if ((_a2 = this.accessibilityProvider) === null || _a2 === void 0 ? void 0 : _a2.getActiveDescendantId) {
        id = this.accessibilityProvider.getActiveDescendantId(this.view.element(focus[0]));
      }
      this.view.domNode.setAttribute("aria-activedescendant", id || this.view.getElementDomId(focus[0]));
    } else {
      this.view.domNode.removeAttribute("aria-activedescendant");
    }
  }
  _onSelectionChange() {
    const selection = this.selection.get();
    this.view.domNode.classList.toggle("selection-none", selection.length === 0);
    this.view.domNode.classList.toggle("selection-single", selection.length === 1);
    this.view.domNode.classList.toggle("selection-multiple", selection.length > 1);
  }
  dispose() {
    this._onDidDispose.fire();
    this.disposables.dispose();
    this._onDidDispose.dispose();
  }
};
__decorate15([
  memoize
], List.prototype, "onDidChangeFocus", null);
__decorate15([
  memoize
], List.prototype, "onDidChangeSelection", null);
__decorate15([
  memoize
], List.prototype, "onContextMenu", null);
__decorate15([
  memoize
], List.prototype, "onKeyDown", null);
__decorate15([
  memoize
], List.prototype, "onDidFocus", null);
__decorate15([
  memoize
], List.prototype, "onDidBlur", null);

// node_modules/monaco-editor/esm/vs/base/browser/ui/selectBox/selectBoxCustom.js
init_arrays();
init_event();
init_keyCodes();
init_lifecycle();
init_platform();
init_nls();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/selectBox/selectBoxCustom.css";
var $4 = $;
var SELECT_OPTION_ENTRY_TEMPLATE_ID = "selectOption.entry.template";
var SelectListRenderer = class {
  get templateId() {
    return SELECT_OPTION_ENTRY_TEMPLATE_ID;
  }
  renderTemplate(container) {
    const data = /* @__PURE__ */ Object.create(null);
    data.root = container;
    data.text = append(container, $4(".option-text"));
    data.detail = append(container, $4(".option-detail"));
    data.decoratorRight = append(container, $4(".option-decorator-right"));
    return data;
  }
  renderElement(element, index, templateData) {
    const data = templateData;
    const text = element.text;
    const detail = element.detail;
    const decoratorRight = element.decoratorRight;
    const isDisabled = element.isDisabled;
    data.text.textContent = text;
    data.detail.textContent = !!detail ? detail : "";
    data.decoratorRight.innerText = !!decoratorRight ? decoratorRight : "";
    if (isDisabled) {
      data.root.classList.add("option-disabled");
    } else {
      data.root.classList.remove("option-disabled");
    }
  }
  disposeTemplate(_templateData) {
  }
};
var SelectBoxList = class _SelectBoxList extends Disposable {
  constructor(options2, selected, contextViewProvider, styles, selectBoxOptions) {
    super();
    this.options = [];
    this._currentSelection = 0;
    this._hasDetails = false;
    this._skipLayout = false;
    this._sticky = false;
    this._isVisible = false;
    this.styles = styles;
    this.selectBoxOptions = selectBoxOptions || /* @__PURE__ */ Object.create(null);
    if (typeof this.selectBoxOptions.minBottomMargin !== "number") {
      this.selectBoxOptions.minBottomMargin = _SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN;
    } else if (this.selectBoxOptions.minBottomMargin < 0) {
      this.selectBoxOptions.minBottomMargin = 0;
    }
    this.selectElement = document.createElement("select");
    this.selectElement.className = "monaco-select-box monaco-select-box-dropdown-padding";
    if (typeof this.selectBoxOptions.ariaLabel === "string") {
      this.selectElement.setAttribute("aria-label", this.selectBoxOptions.ariaLabel);
    }
    if (typeof this.selectBoxOptions.ariaDescription === "string") {
      this.selectElement.setAttribute("aria-description", this.selectBoxOptions.ariaDescription);
    }
    this._hover = this._register(setupCustomHover(getDefaultHoverDelegate("mouse"), this.selectElement, ""));
    this._onDidSelect = new Emitter();
    this._register(this._onDidSelect);
    this.registerListeners();
    this.constructSelectDropDown(contextViewProvider);
    this.selected = selected || 0;
    if (options2) {
      this.setOptions(options2, selected);
    }
    this.initStyleSheet();
  }
  // IDelegate - List renderer
  getHeight() {
    return 22;
  }
  getTemplateId() {
    return SELECT_OPTION_ENTRY_TEMPLATE_ID;
  }
  constructSelectDropDown(contextViewProvider) {
    this.contextViewProvider = contextViewProvider;
    this.selectDropDownContainer = $(".monaco-select-box-dropdown-container");
    this.selectDropDownContainer.classList.add("monaco-select-box-dropdown-padding");
    this.selectionDetailsPane = append(this.selectDropDownContainer, $4(".select-box-details-pane"));
    const widthControlOuterDiv = append(this.selectDropDownContainer, $4(".select-box-dropdown-container-width-control"));
    const widthControlInnerDiv = append(widthControlOuterDiv, $4(".width-control-div"));
    this.widthControlElement = document.createElement("span");
    this.widthControlElement.className = "option-text-width-control";
    append(widthControlInnerDiv, this.widthControlElement);
    this._dropDownPosition = 0;
    this.styleElement = createStyleSheet(this.selectDropDownContainer);
    this.selectDropDownContainer.setAttribute("draggable", "true");
    this._register(addDisposableListener(this.selectDropDownContainer, EventType.DRAG_START, (e) => {
      EventHelper.stop(e, true);
    }));
  }
  registerListeners() {
    this._register(addStandardDisposableListener(this.selectElement, "change", (e) => {
      this.selected = e.target.selectedIndex;
      this._onDidSelect.fire({
        index: e.target.selectedIndex,
        selected: e.target.value
      });
      if (!!this.options[this.selected] && !!this.options[this.selected].text) {
        this._hover.update(this.options[this.selected].text);
      }
    }));
    this._register(addDisposableListener(this.selectElement, EventType.CLICK, (e) => {
      EventHelper.stop(e);
      if (this._isVisible) {
        this.hideSelectDropDown(true);
      } else {
        this.showSelectDropDown();
      }
    }));
    this._register(addDisposableListener(this.selectElement, EventType.MOUSE_DOWN, (e) => {
      EventHelper.stop(e);
    }));
    let listIsVisibleOnTouchStart;
    this._register(addDisposableListener(this.selectElement, "touchstart", (e) => {
      listIsVisibleOnTouchStart = this._isVisible;
    }));
    this._register(addDisposableListener(this.selectElement, "touchend", (e) => {
      EventHelper.stop(e);
      if (listIsVisibleOnTouchStart) {
        this.hideSelectDropDown(true);
      } else {
        this.showSelectDropDown();
      }
    }));
    this._register(addDisposableListener(this.selectElement, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      let showDropDown = false;
      if (isMacintosh) {
        if (event.keyCode === 18 || event.keyCode === 16 || event.keyCode === 10 || event.keyCode === 3) {
          showDropDown = true;
        }
      } else {
        if (event.keyCode === 18 && event.altKey || event.keyCode === 16 && event.altKey || event.keyCode === 10 || event.keyCode === 3) {
          showDropDown = true;
        }
      }
      if (showDropDown) {
        this.showSelectDropDown();
        EventHelper.stop(e, true);
      }
    }));
  }
  get onDidSelect() {
    return this._onDidSelect.event;
  }
  setOptions(options2, selected) {
    if (!equals(this.options, options2)) {
      this.options = options2;
      this.selectElement.options.length = 0;
      this._hasDetails = false;
      this._cachedMaxDetailsHeight = void 0;
      this.options.forEach((option, index) => {
        this.selectElement.add(this.createOption(option.text, index, option.isDisabled));
        if (typeof option.description === "string") {
          this._hasDetails = true;
        }
      });
    }
    if (selected !== void 0) {
      this.select(selected);
      this._currentSelection = this.selected;
    }
  }
  setOptionsList() {
    var _a2;
    (_a2 = this.selectList) === null || _a2 === void 0 ? void 0 : _a2.splice(0, this.selectList.length, this.options);
  }
  select(index) {
    if (index >= 0 && index < this.options.length) {
      this.selected = index;
    } else if (index > this.options.length - 1) {
      this.select(this.options.length - 1);
    } else if (this.selected < 0) {
      this.selected = 0;
    }
    this.selectElement.selectedIndex = this.selected;
    if (!!this.options[this.selected] && !!this.options[this.selected].text) {
      this._hover.update(this.options[this.selected].text);
    }
  }
  focus() {
    if (this.selectElement) {
      this.selectElement.tabIndex = 0;
      this.selectElement.focus();
    }
  }
  blur() {
    if (this.selectElement) {
      this.selectElement.tabIndex = -1;
      this.selectElement.blur();
    }
  }
  setFocusable(focusable) {
    this.selectElement.tabIndex = focusable ? 0 : -1;
  }
  render(container) {
    this.container = container;
    container.classList.add("select-container");
    container.appendChild(this.selectElement);
    this.styleSelectElement();
  }
  initStyleSheet() {
    const content = [];
    if (this.styles.listFocusBackground) {
      content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: ${this.styles.listFocusBackground} !important; }`);
    }
    if (this.styles.listFocusForeground) {
      content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { color: ${this.styles.listFocusForeground} !important; }`);
    }
    if (this.styles.decoratorRightForeground) {
      content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.focused) .option-decorator-right { color: ${this.styles.decoratorRightForeground}; }`);
    }
    if (this.styles.selectBackground && this.styles.selectBorder && this.styles.selectBorder !== this.styles.selectBackground) {
      content.push(`.monaco-select-box-dropdown-container { border: 1px solid ${this.styles.selectBorder} } `);
      content.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectBorder} } `);
      content.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectBorder} } `);
    } else if (this.styles.selectListBorder) {
      content.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectListBorder} } `);
      content.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectListBorder} } `);
    }
    if (this.styles.listHoverForeground) {
      content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { color: ${this.styles.listHoverForeground} !important; }`);
    }
    if (this.styles.listHoverBackground) {
      content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: ${this.styles.listHoverBackground} !important; }`);
    }
    if (this.styles.listFocusOutline) {
      content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`);
    }
    if (this.styles.listHoverOutline) {
      content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { outline: 1.6px dashed ${this.styles.listHoverOutline} !important; outline-offset: -1.6px !important; }`);
    }
    content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled.focused { background-color: transparent !important; color: inherit !important; outline: none !important; }`);
    content.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: transparent !important; color: inherit !important; outline: none !important; }`);
    this.styleElement.textContent = content.join("\n");
  }
  styleSelectElement() {
    var _a2, _b2, _c;
    const background = (_a2 = this.styles.selectBackground) !== null && _a2 !== void 0 ? _a2 : "";
    const foreground2 = (_b2 = this.styles.selectForeground) !== null && _b2 !== void 0 ? _b2 : "";
    const border = (_c = this.styles.selectBorder) !== null && _c !== void 0 ? _c : "";
    this.selectElement.style.backgroundColor = background;
    this.selectElement.style.color = foreground2;
    this.selectElement.style.borderColor = border;
  }
  styleList() {
    var _a2, _b2;
    const background = (_a2 = this.styles.selectBackground) !== null && _a2 !== void 0 ? _a2 : "";
    const listBackground = asCssValueWithDefault(this.styles.selectListBackground, background);
    this.selectDropDownListContainer.style.backgroundColor = listBackground;
    this.selectionDetailsPane.style.backgroundColor = listBackground;
    const optionsBorder = (_b2 = this.styles.focusBorder) !== null && _b2 !== void 0 ? _b2 : "";
    this.selectDropDownContainer.style.outlineColor = optionsBorder;
    this.selectDropDownContainer.style.outlineOffset = "-1px";
    this.selectList.style(this.styles);
  }
  createOption(value, index, disabled) {
    const option = document.createElement("option");
    option.value = value;
    option.text = value;
    option.disabled = !!disabled;
    return option;
  }
  // ContextView dropdown methods
  showSelectDropDown() {
    this.selectionDetailsPane.innerText = "";
    if (!this.contextViewProvider || this._isVisible) {
      return;
    }
    this.createSelectList(this.selectDropDownContainer);
    this.setOptionsList();
    this.contextViewProvider.showContextView({
      getAnchor: () => this.selectElement,
      render: (container) => this.renderSelectDropDown(container, true),
      layout: () => {
        this.layoutSelectDropDown();
      },
      onHide: () => {
        this.selectDropDownContainer.classList.remove("visible");
        this.selectElement.classList.remove("synthetic-focus");
      },
      anchorPosition: this._dropDownPosition
    }, this.selectBoxOptions.optionsAsChildren ? this.container : void 0);
    this._isVisible = true;
    this.hideSelectDropDown(false);
    this.contextViewProvider.showContextView({
      getAnchor: () => this.selectElement,
      render: (container) => this.renderSelectDropDown(container),
      layout: () => this.layoutSelectDropDown(),
      onHide: () => {
        this.selectDropDownContainer.classList.remove("visible");
        this.selectElement.classList.remove("synthetic-focus");
      },
      anchorPosition: this._dropDownPosition
    }, this.selectBoxOptions.optionsAsChildren ? this.container : void 0);
    this._currentSelection = this.selected;
    this._isVisible = true;
    this.selectElement.setAttribute("aria-expanded", "true");
  }
  hideSelectDropDown(focusSelect) {
    if (!this.contextViewProvider || !this._isVisible) {
      return;
    }
    this._isVisible = false;
    this.selectElement.setAttribute("aria-expanded", "false");
    if (focusSelect) {
      this.selectElement.focus();
    }
    this.contextViewProvider.hideContextView();
  }
  renderSelectDropDown(container, preLayoutPosition) {
    container.appendChild(this.selectDropDownContainer);
    this.layoutSelectDropDown(preLayoutPosition);
    return {
      dispose: () => {
        try {
          container.removeChild(this.selectDropDownContainer);
        } catch (error) {
        }
      }
    };
  }
  // Iterate over detailed descriptions, find max height
  measureMaxDetailsHeight() {
    let maxDetailsPaneHeight = 0;
    this.options.forEach((_option, index) => {
      this.updateDetail(index);
      if (this.selectionDetailsPane.offsetHeight > maxDetailsPaneHeight) {
        maxDetailsPaneHeight = this.selectionDetailsPane.offsetHeight;
      }
    });
    return maxDetailsPaneHeight;
  }
  layoutSelectDropDown(preLayoutPosition) {
    if (this._skipLayout) {
      return false;
    }
    if (this.selectList) {
      this.selectDropDownContainer.classList.add("visible");
      const window = getWindow(this.selectElement);
      const selectPosition = getDomNodePagePosition(this.selectElement);
      const styles = getWindow(this.selectElement).getComputedStyle(this.selectElement);
      const verticalPadding = parseFloat(styles.getPropertyValue("--dropdown-padding-top")) + parseFloat(styles.getPropertyValue("--dropdown-padding-bottom"));
      const maxSelectDropDownHeightBelow = window.innerHeight - selectPosition.top - selectPosition.height - (this.selectBoxOptions.minBottomMargin || 0);
      const maxSelectDropDownHeightAbove = selectPosition.top - _SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN;
      const selectWidth = this.selectElement.offsetWidth;
      const selectMinWidth = this.setWidthControlElement(this.widthControlElement);
      const selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + "px";
      this.selectDropDownContainer.style.width = selectOptimalWidth;
      this.selectList.getHTMLElement().style.height = "";
      this.selectList.layout();
      let listHeight = this.selectList.contentHeight;
      if (this._hasDetails && this._cachedMaxDetailsHeight === void 0) {
        this._cachedMaxDetailsHeight = this.measureMaxDetailsHeight();
      }
      const maxDetailsPaneHeight = this._hasDetails ? this._cachedMaxDetailsHeight : 0;
      const minRequiredDropDownHeight = listHeight + verticalPadding + maxDetailsPaneHeight;
      const maxVisibleOptionsBelow = Math.floor((maxSelectDropDownHeightBelow - verticalPadding - maxDetailsPaneHeight) / this.getHeight());
      const maxVisibleOptionsAbove = Math.floor((maxSelectDropDownHeightAbove - verticalPadding - maxDetailsPaneHeight) / this.getHeight());
      if (preLayoutPosition) {
        if (selectPosition.top + selectPosition.height > window.innerHeight - 22 || selectPosition.top < _SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN || maxVisibleOptionsBelow < 1 && maxVisibleOptionsAbove < 1) {
          return false;
        }
        if (maxVisibleOptionsBelow < _SelectBoxList.DEFAULT_MINIMUM_VISIBLE_OPTIONS && maxVisibleOptionsAbove > maxVisibleOptionsBelow && this.options.length > maxVisibleOptionsBelow) {
          this._dropDownPosition = 1;
          this.selectDropDownContainer.removeChild(this.selectDropDownListContainer);
          this.selectDropDownContainer.removeChild(this.selectionDetailsPane);
          this.selectDropDownContainer.appendChild(this.selectionDetailsPane);
          this.selectDropDownContainer.appendChild(this.selectDropDownListContainer);
          this.selectionDetailsPane.classList.remove("border-top");
          this.selectionDetailsPane.classList.add("border-bottom");
        } else {
          this._dropDownPosition = 0;
          this.selectDropDownContainer.removeChild(this.selectDropDownListContainer);
          this.selectDropDownContainer.removeChild(this.selectionDetailsPane);
          this.selectDropDownContainer.appendChild(this.selectDropDownListContainer);
          this.selectDropDownContainer.appendChild(this.selectionDetailsPane);
          this.selectionDetailsPane.classList.remove("border-bottom");
          this.selectionDetailsPane.classList.add("border-top");
        }
        return true;
      }
      if (selectPosition.top + selectPosition.height > window.innerHeight - 22 || selectPosition.top < _SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN || this._dropDownPosition === 0 && maxVisibleOptionsBelow < 1 || this._dropDownPosition === 1 && maxVisibleOptionsAbove < 1) {
        this.hideSelectDropDown(true);
        return false;
      }
      if (this._dropDownPosition === 0) {
        if (this._isVisible && maxVisibleOptionsBelow + maxVisibleOptionsAbove < 1) {
          this.hideSelectDropDown(true);
          return false;
        }
        if (minRequiredDropDownHeight > maxSelectDropDownHeightBelow) {
          listHeight = maxVisibleOptionsBelow * this.getHeight();
        }
      } else {
        if (minRequiredDropDownHeight > maxSelectDropDownHeightAbove) {
          listHeight = maxVisibleOptionsAbove * this.getHeight();
        }
      }
      this.selectList.layout(listHeight);
      this.selectList.domFocus();
      if (this.selectList.length > 0) {
        this.selectList.setFocus([this.selected || 0]);
        this.selectList.reveal(this.selectList.getFocus()[0] || 0);
      }
      if (this._hasDetails) {
        this.selectList.getHTMLElement().style.height = listHeight + verticalPadding + "px";
        this.selectDropDownContainer.style.height = "";
      } else {
        this.selectDropDownContainer.style.height = listHeight + verticalPadding + "px";
      }
      this.updateDetail(this.selected);
      this.selectDropDownContainer.style.width = selectOptimalWidth;
      this.selectDropDownListContainer.setAttribute("tabindex", "0");
      this.selectElement.classList.add("synthetic-focus");
      this.selectDropDownContainer.classList.add("synthetic-focus");
      return true;
    } else {
      return false;
    }
  }
  setWidthControlElement(container) {
    let elementWidth = 0;
    if (container) {
      let longest = 0;
      let longestLength = 0;
      this.options.forEach((option, index) => {
        const detailLength = !!option.detail ? option.detail.length : 0;
        const rightDecoratorLength = !!option.decoratorRight ? option.decoratorRight.length : 0;
        const len = option.text.length + detailLength + rightDecoratorLength;
        if (len > longestLength) {
          longest = index;
          longestLength = len;
        }
      });
      container.textContent = this.options[longest].text + (!!this.options[longest].decoratorRight ? this.options[longest].decoratorRight + " " : "");
      elementWidth = getTotalWidth(container);
    }
    return elementWidth;
  }
  createSelectList(parent) {
    if (this.selectList) {
      return;
    }
    this.selectDropDownListContainer = append(parent, $4(".select-box-dropdown-list-container"));
    this.listRenderer = new SelectListRenderer();
    this.selectList = new List("SelectBoxCustom", this.selectDropDownListContainer, this, [this.listRenderer], {
      useShadows: false,
      verticalScrollMode: 3,
      keyboardSupport: false,
      mouseSupport: false,
      accessibilityProvider: {
        getAriaLabel: (element) => {
          let label = element.text;
          if (element.detail) {
            label += `. ${element.detail}`;
          }
          if (element.decoratorRight) {
            label += `. ${element.decoratorRight}`;
          }
          if (element.description) {
            label += `. ${element.description}`;
          }
          return label;
        },
        getWidgetAriaLabel: () => localize({ key: "selectBox", comment: ["Behave like native select dropdown element."] }, "Select Box"),
        getRole: () => isMacintosh ? "" : "option",
        getWidgetRole: () => "listbox"
      }
    });
    if (this.selectBoxOptions.ariaLabel) {
      this.selectList.ariaLabel = this.selectBoxOptions.ariaLabel;
    }
    const onKeyDown = this._register(new DomEmitter(this.selectDropDownListContainer, "keydown"));
    const onSelectDropDownKeyDown = Event.chain(onKeyDown.event, ($10) => $10.filter(() => this.selectList.length > 0).map((e) => new StandardKeyboardEvent(e)));
    this._register(Event.chain(onSelectDropDownKeyDown, ($10) => $10.filter(
      (e) => e.keyCode === 3
      /* KeyCode.Enter */
    ))(this.onEnter, this));
    this._register(Event.chain(onSelectDropDownKeyDown, ($10) => $10.filter(
      (e) => e.keyCode === 2
      /* KeyCode.Tab */
    ))(this.onEnter, this));
    this._register(Event.chain(onSelectDropDownKeyDown, ($10) => $10.filter(
      (e) => e.keyCode === 9
      /* KeyCode.Escape */
    ))(this.onEscape, this));
    this._register(Event.chain(onSelectDropDownKeyDown, ($10) => $10.filter(
      (e) => e.keyCode === 16
      /* KeyCode.UpArrow */
    ))(this.onUpArrow, this));
    this._register(Event.chain(onSelectDropDownKeyDown, ($10) => $10.filter(
      (e) => e.keyCode === 18
      /* KeyCode.DownArrow */
    ))(this.onDownArrow, this));
    this._register(Event.chain(onSelectDropDownKeyDown, ($10) => $10.filter(
      (e) => e.keyCode === 12
      /* KeyCode.PageDown */
    ))(this.onPageDown, this));
    this._register(Event.chain(onSelectDropDownKeyDown, ($10) => $10.filter(
      (e) => e.keyCode === 11
      /* KeyCode.PageUp */
    ))(this.onPageUp, this));
    this._register(Event.chain(onSelectDropDownKeyDown, ($10) => $10.filter(
      (e) => e.keyCode === 14
      /* KeyCode.Home */
    ))(this.onHome, this));
    this._register(Event.chain(onSelectDropDownKeyDown, ($10) => $10.filter(
      (e) => e.keyCode === 13
      /* KeyCode.End */
    ))(this.onEnd, this));
    this._register(Event.chain(onSelectDropDownKeyDown, ($10) => $10.filter((e) => e.keyCode >= 21 && e.keyCode <= 56 || e.keyCode >= 85 && e.keyCode <= 113))(this.onCharacter, this));
    this._register(addDisposableListener(this.selectList.getHTMLElement(), EventType.POINTER_UP, (e) => this.onPointerUp(e)));
    this._register(this.selectList.onMouseOver((e) => typeof e.index !== "undefined" && this.selectList.setFocus([e.index])));
    this._register(this.selectList.onDidChangeFocus((e) => this.onListFocus(e)));
    this._register(addDisposableListener(this.selectDropDownContainer, EventType.FOCUS_OUT, (e) => {
      if (!this._isVisible || isAncestor(e.relatedTarget, this.selectDropDownContainer)) {
        return;
      }
      this.onListBlur();
    }));
    this.selectList.getHTMLElement().setAttribute("aria-label", this.selectBoxOptions.ariaLabel || "");
    this.selectList.getHTMLElement().setAttribute("aria-expanded", "true");
    this.styleList();
  }
  // List methods
  // List mouse controller - active exit, select option, fire onDidSelect if change, return focus to parent select
  // Also takes in touchend events
  onPointerUp(e) {
    if (!this.selectList.length) {
      return;
    }
    EventHelper.stop(e);
    const target = e.target;
    if (!target) {
      return;
    }
    if (target.classList.contains("slider")) {
      return;
    }
    const listRowElement = target.closest(".monaco-list-row");
    if (!listRowElement) {
      return;
    }
    const index = Number(listRowElement.getAttribute("data-index"));
    const disabled = listRowElement.classList.contains("option-disabled");
    if (index >= 0 && index < this.options.length && !disabled) {
      this.selected = index;
      this.select(this.selected);
      this.selectList.setFocus([this.selected]);
      this.selectList.reveal(this.selectList.getFocus()[0]);
      if (this.selected !== this._currentSelection) {
        this._currentSelection = this.selected;
        this._onDidSelect.fire({
          index: this.selectElement.selectedIndex,
          selected: this.options[this.selected].text
        });
        if (!!this.options[this.selected] && !!this.options[this.selected].text) {
          this._hover.update(this.options[this.selected].text);
        }
      }
      this.hideSelectDropDown(true);
    }
  }
  // List Exit - passive - implicit no selection change, hide drop-down
  onListBlur() {
    if (this._sticky) {
      return;
    }
    if (this.selected !== this._currentSelection) {
      this.select(this._currentSelection);
    }
    this.hideSelectDropDown(false);
  }
  renderDescriptionMarkdown(text, actionHandler) {
    const cleanRenderedMarkdown = (element) => {
      for (let i = 0; i < element.childNodes.length; i++) {
        const child = element.childNodes.item(i);
        const tagName = child.tagName && child.tagName.toLowerCase();
        if (tagName === "img") {
          element.removeChild(child);
        } else {
          cleanRenderedMarkdown(child);
        }
      }
    };
    const rendered = renderMarkdown({ value: text, supportThemeIcons: true }, { actionHandler });
    rendered.element.classList.add("select-box-description-markdown");
    cleanRenderedMarkdown(rendered.element);
    return rendered.element;
  }
  // List Focus Change - passive - update details pane with newly focused element's data
  onListFocus(e) {
    if (!this._isVisible || !this._hasDetails) {
      return;
    }
    this.updateDetail(e.indexes[0]);
  }
  updateDetail(selectedIndex) {
    var _a2, _b2;
    this.selectionDetailsPane.innerText = "";
    const option = this.options[selectedIndex];
    const description = (_a2 = option === null || option === void 0 ? void 0 : option.description) !== null && _a2 !== void 0 ? _a2 : "";
    const descriptionIsMarkdown = (_b2 = option === null || option === void 0 ? void 0 : option.descriptionIsMarkdown) !== null && _b2 !== void 0 ? _b2 : false;
    if (description) {
      if (descriptionIsMarkdown) {
        const actionHandler = option.descriptionMarkdownActionHandler;
        this.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description, actionHandler));
      } else {
        this.selectionDetailsPane.innerText = description;
      }
      this.selectionDetailsPane.style.display = "block";
    } else {
      this.selectionDetailsPane.style.display = "none";
    }
    this._skipLayout = true;
    this.contextViewProvider.layout();
    this._skipLayout = false;
  }
  // List keyboard controller
  // List exit - active - hide ContextView dropdown, reset selection, return focus to parent select
  onEscape(e) {
    EventHelper.stop(e);
    this.select(this._currentSelection);
    this.hideSelectDropDown(true);
  }
  // List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect if change
  onEnter(e) {
    EventHelper.stop(e);
    if (this.selected !== this._currentSelection) {
      this._currentSelection = this.selected;
      this._onDidSelect.fire({
        index: this.selectElement.selectedIndex,
        selected: this.options[this.selected].text
      });
      if (!!this.options[this.selected] && !!this.options[this.selected].text) {
        this._hover.update(this.options[this.selected].text);
      }
    }
    this.hideSelectDropDown(true);
  }
  // List navigation - have to handle a disabled option (jump over)
  onDownArrow(e) {
    if (this.selected < this.options.length - 1) {
      EventHelper.stop(e, true);
      const nextOptionDisabled = this.options[this.selected + 1].isDisabled;
      if (nextOptionDisabled && this.options.length > this.selected + 2) {
        this.selected += 2;
      } else if (nextOptionDisabled) {
        return;
      } else {
        this.selected++;
      }
      this.select(this.selected);
      this.selectList.setFocus([this.selected]);
      this.selectList.reveal(this.selectList.getFocus()[0]);
    }
  }
  onUpArrow(e) {
    if (this.selected > 0) {
      EventHelper.stop(e, true);
      const previousOptionDisabled = this.options[this.selected - 1].isDisabled;
      if (previousOptionDisabled && this.selected > 1) {
        this.selected -= 2;
      } else {
        this.selected--;
      }
      this.select(this.selected);
      this.selectList.setFocus([this.selected]);
      this.selectList.reveal(this.selectList.getFocus()[0]);
    }
  }
  onPageUp(e) {
    EventHelper.stop(e);
    this.selectList.focusPreviousPage();
    setTimeout(() => {
      this.selected = this.selectList.getFocus()[0];
      if (this.options[this.selected].isDisabled && this.selected < this.options.length - 1) {
        this.selected++;
        this.selectList.setFocus([this.selected]);
      }
      this.selectList.reveal(this.selected);
      this.select(this.selected);
    }, 1);
  }
  onPageDown(e) {
    EventHelper.stop(e);
    this.selectList.focusNextPage();
    setTimeout(() => {
      this.selected = this.selectList.getFocus()[0];
      if (this.options[this.selected].isDisabled && this.selected > 0) {
        this.selected--;
        this.selectList.setFocus([this.selected]);
      }
      this.selectList.reveal(this.selected);
      this.select(this.selected);
    }, 1);
  }
  onHome(e) {
    EventHelper.stop(e);
    if (this.options.length < 2) {
      return;
    }
    this.selected = 0;
    if (this.options[this.selected].isDisabled && this.selected > 1) {
      this.selected++;
    }
    this.selectList.setFocus([this.selected]);
    this.selectList.reveal(this.selected);
    this.select(this.selected);
  }
  onEnd(e) {
    EventHelper.stop(e);
    if (this.options.length < 2) {
      return;
    }
    this.selected = this.options.length - 1;
    if (this.options[this.selected].isDisabled && this.selected > 1) {
      this.selected--;
    }
    this.selectList.setFocus([this.selected]);
    this.selectList.reveal(this.selected);
    this.select(this.selected);
  }
  // Mimic option first character navigation of native select
  onCharacter(e) {
    const ch = KeyCodeUtils.toString(e.keyCode);
    let optionIndex = -1;
    for (let i = 0; i < this.options.length - 1; i++) {
      optionIndex = (i + this.selected + 1) % this.options.length;
      if (this.options[optionIndex].text.charAt(0).toUpperCase() === ch && !this.options[optionIndex].isDisabled) {
        this.select(optionIndex);
        this.selectList.setFocus([optionIndex]);
        this.selectList.reveal(this.selectList.getFocus()[0]);
        EventHelper.stop(e);
        break;
      }
    }
  }
  dispose() {
    this.hideSelectDropDown(false);
    super.dispose();
  }
};
SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32;
SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN = 2;
SelectBoxList.DEFAULT_MINIMUM_VISIBLE_OPTIONS = 3;

// node_modules/monaco-editor/esm/vs/base/browser/ui/selectBox/selectBoxNative.js
init_dom();
init_arrays();
init_event();
init_lifecycle();
init_platform();
var SelectBoxNative = class extends Disposable {
  constructor(options2, selected, styles, selectBoxOptions) {
    super();
    this.selected = 0;
    this.selectBoxOptions = selectBoxOptions || /* @__PURE__ */ Object.create(null);
    this.options = [];
    this.selectElement = document.createElement("select");
    this.selectElement.className = "monaco-select-box";
    if (typeof this.selectBoxOptions.ariaLabel === "string") {
      this.selectElement.setAttribute("aria-label", this.selectBoxOptions.ariaLabel);
    }
    if (typeof this.selectBoxOptions.ariaDescription === "string") {
      this.selectElement.setAttribute("aria-description", this.selectBoxOptions.ariaDescription);
    }
    this._onDidSelect = this._register(new Emitter());
    this.styles = styles;
    this.registerListeners();
    this.setOptions(options2, selected);
  }
  registerListeners() {
    this._register(Gesture.addTarget(this.selectElement));
    [EventType2.Tap].forEach((eventType) => {
      this._register(addDisposableListener(this.selectElement, eventType, (e) => {
        this.selectElement.focus();
      }));
    });
    this._register(addStandardDisposableListener(this.selectElement, "click", (e) => {
      EventHelper.stop(e, true);
    }));
    this._register(addStandardDisposableListener(this.selectElement, "change", (e) => {
      this.selectElement.title = e.target.value;
      this._onDidSelect.fire({
        index: e.target.selectedIndex,
        selected: e.target.value
      });
    }));
    this._register(addStandardDisposableListener(this.selectElement, "keydown", (e) => {
      let showSelect = false;
      if (isMacintosh) {
        if (e.keyCode === 18 || e.keyCode === 16 || e.keyCode === 10) {
          showSelect = true;
        }
      } else {
        if (e.keyCode === 18 && e.altKey || e.keyCode === 10 || e.keyCode === 3) {
          showSelect = true;
        }
      }
      if (showSelect) {
        e.stopPropagation();
      }
    }));
  }
  get onDidSelect() {
    return this._onDidSelect.event;
  }
  setOptions(options2, selected) {
    if (!this.options || !equals(this.options, options2)) {
      this.options = options2;
      this.selectElement.options.length = 0;
      this.options.forEach((option, index) => {
        this.selectElement.add(this.createOption(option.text, index, option.isDisabled));
      });
    }
    if (selected !== void 0) {
      this.select(selected);
    }
  }
  select(index) {
    if (this.options.length === 0) {
      this.selected = 0;
    } else if (index >= 0 && index < this.options.length) {
      this.selected = index;
    } else if (index > this.options.length - 1) {
      this.select(this.options.length - 1);
    } else if (this.selected < 0) {
      this.selected = 0;
    }
    this.selectElement.selectedIndex = this.selected;
    if (this.selected < this.options.length && typeof this.options[this.selected].text === "string") {
      this.selectElement.title = this.options[this.selected].text;
    } else {
      this.selectElement.title = "";
    }
  }
  focus() {
    if (this.selectElement) {
      this.selectElement.tabIndex = 0;
      this.selectElement.focus();
    }
  }
  blur() {
    if (this.selectElement) {
      this.selectElement.tabIndex = -1;
      this.selectElement.blur();
    }
  }
  setFocusable(focusable) {
    this.selectElement.tabIndex = focusable ? 0 : -1;
  }
  render(container) {
    container.classList.add("select-container");
    container.appendChild(this.selectElement);
    this.setOptions(this.options, this.selected);
    this.applyStyles();
  }
  applyStyles() {
    var _a2, _b2, _c;
    if (this.selectElement) {
      this.selectElement.style.backgroundColor = (_a2 = this.styles.selectBackground) !== null && _a2 !== void 0 ? _a2 : "";
      this.selectElement.style.color = (_b2 = this.styles.selectForeground) !== null && _b2 !== void 0 ? _b2 : "";
      this.selectElement.style.borderColor = (_c = this.styles.selectBorder) !== null && _c !== void 0 ? _c : "";
    }
  }
  createOption(value, index, disabled) {
    const option = document.createElement("option");
    option.value = value;
    option.text = value;
    option.disabled = !!disabled;
    return option;
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/selectBox/selectBox.js
init_platform();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/selectBox/selectBox.css";
var SelectBox = class extends Widget {
  constructor(options2, selected, contextViewProvider, styles, selectBoxOptions) {
    super();
    if (isMacintosh && !(selectBoxOptions === null || selectBoxOptions === void 0 ? void 0 : selectBoxOptions.useCustomDrawn)) {
      this.selectBoxDelegate = new SelectBoxNative(options2, selected, styles, selectBoxOptions);
    } else {
      this.selectBoxDelegate = new SelectBoxList(options2, selected, contextViewProvider, styles, selectBoxOptions);
    }
    this._register(this.selectBoxDelegate);
  }
  // Public SelectBox Methods - routed through delegate interface
  get onDidSelect() {
    return this.selectBoxDelegate.onDidSelect;
  }
  setOptions(options2, selected) {
    this.selectBoxDelegate.setOptions(options2, selected);
  }
  select(index) {
    this.selectBoxDelegate.select(index);
  }
  focus() {
    this.selectBoxDelegate.focus();
  }
  blur() {
    this.selectBoxDelegate.blur();
  }
  setFocusable(focusable) {
    this.selectBoxDelegate.setFocusable(focusable);
  }
  render(container) {
    this.selectBoxDelegate.render(container);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionViewItems.js
init_actions();
init_lifecycle();
init_platform();
init_types();
init_nls();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.css";
var BaseActionViewItem = class extends Disposable {
  get action() {
    return this._action;
  }
  constructor(context, action, options2 = {}) {
    super();
    this.options = options2;
    this._context = context || this;
    this._action = action;
    if (action instanceof Action) {
      this._register(action.onDidChange((event) => {
        if (!this.element) {
          return;
        }
        this.handleActionChangeEvent(event);
      }));
    }
  }
  handleActionChangeEvent(event) {
    if (event.enabled !== void 0) {
      this.updateEnabled();
    }
    if (event.checked !== void 0) {
      this.updateChecked();
    }
    if (event.class !== void 0) {
      this.updateClass();
    }
    if (event.label !== void 0) {
      this.updateLabel();
      this.updateTooltip();
    }
    if (event.tooltip !== void 0) {
      this.updateTooltip();
    }
  }
  get actionRunner() {
    if (!this._actionRunner) {
      this._actionRunner = this._register(new ActionRunner());
    }
    return this._actionRunner;
  }
  set actionRunner(actionRunner) {
    this._actionRunner = actionRunner;
  }
  isEnabled() {
    return this._action.enabled;
  }
  setActionContext(newContext) {
    this._context = newContext;
  }
  render(container) {
    const element = this.element = container;
    this._register(Gesture.addTarget(container));
    const enableDragging = this.options && this.options.draggable;
    if (enableDragging) {
      container.draggable = true;
      if (isFirefox2) {
        this._register(addDisposableListener(container, EventType.DRAG_START, (e) => {
          var _a2;
          return (_a2 = e.dataTransfer) === null || _a2 === void 0 ? void 0 : _a2.setData(DataTransfers.TEXT, this._action.label);
        }));
      }
    }
    this._register(addDisposableListener(element, EventType2.Tap, (e) => this.onClick(e, true)));
    this._register(addDisposableListener(element, EventType.MOUSE_DOWN, (e) => {
      if (!enableDragging) {
        EventHelper.stop(e, true);
      }
      if (this._action.enabled && e.button === 0) {
        element.classList.add("active");
      }
    }));
    if (isMacintosh) {
      this._register(addDisposableListener(element, EventType.CONTEXT_MENU, (e) => {
        if (e.button === 0 && e.ctrlKey === true) {
          this.onClick(e);
        }
      }));
    }
    this._register(addDisposableListener(element, EventType.CLICK, (e) => {
      EventHelper.stop(e, true);
      if (!(this.options && this.options.isMenu)) {
        this.onClick(e);
      }
    }));
    this._register(addDisposableListener(element, EventType.DBLCLICK, (e) => {
      EventHelper.stop(e, true);
    }));
    [EventType.MOUSE_UP, EventType.MOUSE_OUT].forEach((event) => {
      this._register(addDisposableListener(element, event, (e) => {
        EventHelper.stop(e);
        element.classList.remove("active");
      }));
    });
  }
  onClick(event, preserveFocus = false) {
    var _a2;
    EventHelper.stop(event, true);
    const context = isUndefinedOrNull(this._context) ? ((_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.useEventAsContext) ? event : { preserveFocus } : this._context;
    this.actionRunner.run(this._action, context);
  }
  // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441
  focus() {
    if (this.element) {
      this.element.tabIndex = 0;
      this.element.focus();
      this.element.classList.add("focused");
    }
  }
  blur() {
    if (this.element) {
      this.element.blur();
      this.element.tabIndex = -1;
      this.element.classList.remove("focused");
    }
  }
  setFocusable(focusable) {
    if (this.element) {
      this.element.tabIndex = focusable ? 0 : -1;
    }
  }
  get trapsArrowNavigation() {
    return false;
  }
  updateEnabled() {
  }
  updateLabel() {
  }
  getClass() {
    return this.action.class;
  }
  getTooltip() {
    return this.action.tooltip;
  }
  updateTooltip() {
    var _a2, _b2, _c;
    if (!this.element) {
      return;
    }
    const title = (_a2 = this.getTooltip()) !== null && _a2 !== void 0 ? _a2 : "";
    this.updateAriaLabel();
    if ((_b2 = this.options.hoverDelegate) === null || _b2 === void 0 ? void 0 : _b2.showNativeHover) {
      this.element.title = title;
    } else {
      if (!this.customHover) {
        const hoverDelegate = (_c = this.options.hoverDelegate) !== null && _c !== void 0 ? _c : getDefaultHoverDelegate("element");
        this.customHover = setupCustomHover(hoverDelegate, this.element, title);
        this._store.add(this.customHover);
      } else {
        this.customHover.update(title);
      }
    }
  }
  updateAriaLabel() {
    var _a2;
    if (this.element) {
      const title = (_a2 = this.getTooltip()) !== null && _a2 !== void 0 ? _a2 : "";
      this.element.setAttribute("aria-label", title);
    }
  }
  updateClass() {
  }
  updateChecked() {
  }
  dispose() {
    if (this.element) {
      this.element.remove();
      this.element = void 0;
    }
    this._context = void 0;
    super.dispose();
  }
};
var ActionViewItem = class extends BaseActionViewItem {
  constructor(context, action, options2) {
    super(context, action, options2);
    this.options = options2;
    this.options.icon = options2.icon !== void 0 ? options2.icon : false;
    this.options.label = options2.label !== void 0 ? options2.label : true;
    this.cssClass = "";
  }
  render(container) {
    super.render(container);
    assertType(this.element);
    const label = document.createElement("a");
    label.classList.add("action-label");
    label.setAttribute("role", this.getDefaultAriaRole());
    this.label = label;
    this.element.appendChild(label);
    if (this.options.label && this.options.keybinding) {
      const kbLabel = document.createElement("span");
      kbLabel.classList.add("keybinding");
      kbLabel.textContent = this.options.keybinding;
      this.element.appendChild(kbLabel);
    }
    this.updateClass();
    this.updateLabel();
    this.updateTooltip();
    this.updateEnabled();
    this.updateChecked();
  }
  getDefaultAriaRole() {
    if (this._action.id === Separator.ID) {
      return "presentation";
    } else {
      if (this.options.isMenu) {
        return "menuitem";
      } else {
        return "button";
      }
    }
  }
  // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441
  focus() {
    if (this.label) {
      this.label.tabIndex = 0;
      this.label.focus();
    }
  }
  blur() {
    if (this.label) {
      this.label.tabIndex = -1;
    }
  }
  setFocusable(focusable) {
    if (this.label) {
      this.label.tabIndex = focusable ? 0 : -1;
    }
  }
  updateLabel() {
    if (this.options.label && this.label) {
      this.label.textContent = this.action.label;
    }
  }
  getTooltip() {
    let title = null;
    if (this.action.tooltip) {
      title = this.action.tooltip;
    } else if (!this.options.label && this.action.label && this.options.icon) {
      title = this.action.label;
      if (this.options.keybinding) {
        title = localize({ key: "titleLabel", comment: ["action title", "action keybinding"] }, "{0} ({1})", title, this.options.keybinding);
      }
    }
    return title !== null && title !== void 0 ? title : void 0;
  }
  updateClass() {
    var _a2;
    if (this.cssClass && this.label) {
      this.label.classList.remove(...this.cssClass.split(" "));
    }
    if (this.options.icon) {
      this.cssClass = this.getClass();
      if (this.label) {
        this.label.classList.add("codicon");
        if (this.cssClass) {
          this.label.classList.add(...this.cssClass.split(" "));
        }
      }
      this.updateEnabled();
    } else {
      (_a2 = this.label) === null || _a2 === void 0 ? void 0 : _a2.classList.remove("codicon");
    }
  }
  updateEnabled() {
    var _a2, _b2;
    if (this.action.enabled) {
      if (this.label) {
        this.label.removeAttribute("aria-disabled");
        this.label.classList.remove("disabled");
      }
      (_a2 = this.element) === null || _a2 === void 0 ? void 0 : _a2.classList.remove("disabled");
    } else {
      if (this.label) {
        this.label.setAttribute("aria-disabled", "true");
        this.label.classList.add("disabled");
      }
      (_b2 = this.element) === null || _b2 === void 0 ? void 0 : _b2.classList.add("disabled");
    }
  }
  updateAriaLabel() {
    var _a2;
    if (this.label) {
      const title = (_a2 = this.getTooltip()) !== null && _a2 !== void 0 ? _a2 : "";
      this.label.setAttribute("aria-label", title);
    }
  }
  updateChecked() {
    if (this.label) {
      if (this.action.checked !== void 0) {
        this.label.classList.toggle("checked", this.action.checked);
        this.label.setAttribute("aria-checked", this.action.checked ? "true" : "false");
        this.label.setAttribute("role", "checkbox");
      } else {
        this.label.classList.remove("checked");
        this.label.removeAttribute("aria-checked");
        this.label.setAttribute("role", this.getDefaultAriaRole());
      }
    }
  }
};
var SelectActionViewItem = class extends BaseActionViewItem {
  constructor(ctx, action, options2, selected, contextViewProvider, styles, selectBoxOptions) {
    super(ctx, action);
    this.selectBox = new SelectBox(options2, selected, contextViewProvider, styles, selectBoxOptions);
    this.selectBox.setFocusable(false);
    this._register(this.selectBox);
    this.registerListeners();
  }
  select(index) {
    this.selectBox.select(index);
  }
  registerListeners() {
    this._register(this.selectBox.onDidSelect((e) => this.runAction(e.selected, e.index)));
  }
  runAction(option, index) {
    this.actionRunner.run(this._action, this.getActionContext(option, index));
  }
  getActionContext(option, index) {
    return option;
  }
  setFocusable(focusable) {
    this.selectBox.setFocusable(focusable);
  }
  focus() {
    var _a2;
    (_a2 = this.selectBox) === null || _a2 === void 0 ? void 0 : _a2.focus();
  }
  blur() {
    var _a2;
    (_a2 = this.selectBox) === null || _a2 === void 0 ? void 0 : _a2.blur();
  }
  render(container) {
    this.selectBox.render(container);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdownActionViewItem.js
init_dom();

// node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.js
init_dom();
init_keyboardEvent();
init_actions();
init_event();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.css";
var BaseDropdown = class extends ActionRunner {
  constructor(container, options2) {
    super();
    this._onDidChangeVisibility = this._register(new Emitter());
    this.onDidChangeVisibility = this._onDidChangeVisibility.event;
    this._element = append(container, $(".monaco-dropdown"));
    this._label = append(this._element, $(".dropdown-label"));
    let labelRenderer = options2.labelRenderer;
    if (!labelRenderer) {
      labelRenderer = (container2) => {
        container2.textContent = options2.label || "";
        return null;
      };
    }
    for (const event of [EventType.CLICK, EventType.MOUSE_DOWN, EventType2.Tap]) {
      this._register(addDisposableListener(this.element, event, (e) => EventHelper.stop(e, true)));
    }
    for (const event of [EventType.MOUSE_DOWN, EventType2.Tap]) {
      this._register(addDisposableListener(this._label, event, (e) => {
        if (isMouseEvent(e) && (e.detail > 1 || e.button !== 0)) {
          return;
        }
        if (this.visible) {
          this.hide();
        } else {
          this.show();
        }
      }));
    }
    this._register(addDisposableListener(this._label, EventType.KEY_UP, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(
        3
        /* KeyCode.Enter */
      ) || event.equals(
        10
        /* KeyCode.Space */
      )) {
        EventHelper.stop(e, true);
        if (this.visible) {
          this.hide();
        } else {
          this.show();
        }
      }
    }));
    const cleanupFn = labelRenderer(this._label);
    if (cleanupFn) {
      this._register(cleanupFn);
    }
    this._register(Gesture.addTarget(this._label));
  }
  get element() {
    return this._element;
  }
  show() {
    if (!this.visible) {
      this.visible = true;
      this._onDidChangeVisibility.fire(true);
    }
  }
  hide() {
    if (this.visible) {
      this.visible = false;
      this._onDidChangeVisibility.fire(false);
    }
  }
  dispose() {
    super.dispose();
    this.hide();
    if (this.boxContainer) {
      this.boxContainer.remove();
      this.boxContainer = void 0;
    }
    if (this.contents) {
      this.contents.remove();
      this.contents = void 0;
    }
    if (this._label) {
      this._label.remove();
      this._label = void 0;
    }
  }
};
var DropdownMenu = class extends BaseDropdown {
  constructor(container, _options) {
    super(container, _options);
    this._options = _options;
    this._actions = [];
    this.actions = _options.actions || [];
  }
  set menuOptions(options2) {
    this._menuOptions = options2;
  }
  get menuOptions() {
    return this._menuOptions;
  }
  get actions() {
    if (this._options.actionProvider) {
      return this._options.actionProvider.getActions();
    }
    return this._actions;
  }
  set actions(actions) {
    this._actions = actions;
  }
  show() {
    super.show();
    this.element.classList.add("active");
    this._options.contextMenuProvider.showContextMenu({
      getAnchor: () => this.element,
      getActions: () => this.actions,
      getActionsContext: () => this.menuOptions ? this.menuOptions.context : null,
      getActionViewItem: (action, options2) => this.menuOptions && this.menuOptions.actionViewItemProvider ? this.menuOptions.actionViewItemProvider(action, options2) : void 0,
      getKeyBinding: (action) => this.menuOptions && this.menuOptions.getKeyBinding ? this.menuOptions.getKeyBinding(action) : void 0,
      getMenuClassName: () => this._options.menuClassName || "",
      onHide: () => this.onHide(),
      actionRunner: this.menuOptions ? this.menuOptions.actionRunner : void 0,
      anchorAlignment: this.menuOptions ? this.menuOptions.anchorAlignment : 0,
      domForShadowRoot: this._options.menuAsChild ? this.element : void 0,
      skipTelemetry: this._options.skipTelemetry
    });
  }
  hide() {
    super.hide();
  }
  onHide() {
    this.hide();
    this.element.classList.remove("active");
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdownActionViewItem.js
init_event();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.css";
var DropdownMenuActionViewItem = class extends BaseActionViewItem {
  constructor(action, menuActionsOrProvider, contextMenuProvider, options2 = /* @__PURE__ */ Object.create(null)) {
    super(null, action, options2);
    this.actionItem = null;
    this._onDidChangeVisibility = this._register(new Emitter());
    this.onDidChangeVisibility = this._onDidChangeVisibility.event;
    this.menuActionsOrProvider = menuActionsOrProvider;
    this.contextMenuProvider = contextMenuProvider;
    this.options = options2;
    if (this.options.actionRunner) {
      this.actionRunner = this.options.actionRunner;
    }
  }
  render(container) {
    this.actionItem = container;
    const labelRenderer = (el) => {
      this.element = append(el, $("a.action-label"));
      let classNames = [];
      if (typeof this.options.classNames === "string") {
        classNames = this.options.classNames.split(/\s+/g).filter((s) => !!s);
      } else if (this.options.classNames) {
        classNames = this.options.classNames;
      }
      if (!classNames.find((c) => c === "icon")) {
        classNames.push("codicon");
      }
      this.element.classList.add(...classNames);
      this.element.setAttribute("role", "button");
      this.element.setAttribute("aria-haspopup", "true");
      this.element.setAttribute("aria-expanded", "false");
      if (this._action.label) {
        this._register(setupCustomHover(getDefaultHoverDelegate("mouse"), this.element, this._action.label));
      }
      this.element.ariaLabel = this._action.label || "";
      return null;
    };
    const isActionsArray = Array.isArray(this.menuActionsOrProvider);
    const options2 = {
      contextMenuProvider: this.contextMenuProvider,
      labelRenderer,
      menuAsChild: this.options.menuAsChild,
      actions: isActionsArray ? this.menuActionsOrProvider : void 0,
      actionProvider: isActionsArray ? void 0 : this.menuActionsOrProvider,
      skipTelemetry: this.options.skipTelemetry
    };
    this.dropdownMenu = this._register(new DropdownMenu(container, options2));
    this._register(this.dropdownMenu.onDidChangeVisibility((visible) => {
      var _a2;
      (_a2 = this.element) === null || _a2 === void 0 ? void 0 : _a2.setAttribute("aria-expanded", `${visible}`);
      this._onDidChangeVisibility.fire(visible);
    }));
    this.dropdownMenu.menuOptions = {
      actionViewItemProvider: this.options.actionViewItemProvider,
      actionRunner: this.actionRunner,
      getKeyBinding: this.options.keybindingProvider,
      context: this._context
    };
    if (this.options.anchorAlignmentProvider) {
      const that = this;
      this.dropdownMenu.menuOptions = {
        ...this.dropdownMenu.menuOptions,
        get anchorAlignment() {
          return that.options.anchorAlignmentProvider();
        }
      };
    }
    this.updateTooltip();
    this.updateEnabled();
  }
  getTooltip() {
    let title = null;
    if (this.action.tooltip) {
      title = this.action.tooltip;
    } else if (this.action.label) {
      title = this.action.label;
    }
    return title !== null && title !== void 0 ? title : void 0;
  }
  setActionContext(newContext) {
    super.setActionContext(newContext);
    if (this.dropdownMenu) {
      if (this.dropdownMenu.menuOptions) {
        this.dropdownMenu.menuOptions.context = newContext;
      } else {
        this.dropdownMenu.menuOptions = { context: newContext };
      }
    }
  }
  show() {
    var _a2;
    (_a2 = this.dropdownMenu) === null || _a2 === void 0 ? void 0 : _a2.show();
  }
  updateEnabled() {
    var _a2, _b2;
    const disabled = !this.action.enabled;
    (_a2 = this.actionItem) === null || _a2 === void 0 ? void 0 : _a2.classList.toggle("disabled", disabled);
    (_b2 = this.element) === null || _b2 === void 0 ? void 0 : _b2.classList.toggle("disabled", disabled);
  }
};

// node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js
init_actions();
init_lifecycle();
init_platform();
init_nls();
init_actions2();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.css";

// node_modules/monaco-editor/esm/vs/platform/action/common/action.js
function isICommandActionToggleInfo(thing) {
  return thing ? thing.condition !== void 0 : false;
}

// node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js
init_contextkey();
init_instantiation();

// node_modules/monaco-editor/esm/vs/platform/storage/common/storage.js
init_event();
init_lifecycle();
init_types();

// node_modules/monaco-editor/esm/vs/base/parts/storage/common/storage.js
init_async();
init_event();
init_lifecycle();
init_types();
var StorageHint;
(function(StorageHint2) {
  StorageHint2[StorageHint2["STORAGE_DOES_NOT_EXIST"] = 0] = "STORAGE_DOES_NOT_EXIST";
  StorageHint2[StorageHint2["STORAGE_IN_MEMORY"] = 1] = "STORAGE_IN_MEMORY";
})(StorageHint || (StorageHint = {}));
var StorageState;
(function(StorageState2) {
  StorageState2[StorageState2["None"] = 0] = "None";
  StorageState2[StorageState2["Initialized"] = 1] = "Initialized";
  StorageState2[StorageState2["Closed"] = 2] = "Closed";
})(StorageState || (StorageState = {}));
var Storage = class _Storage extends Disposable {
  constructor(database, options2 = /* @__PURE__ */ Object.create(null)) {
    super();
    this.database = database;
    this.options = options2;
    this._onDidChangeStorage = this._register(new PauseableEmitter());
    this.onDidChangeStorage = this._onDidChangeStorage.event;
    this.state = StorageState.None;
    this.cache = /* @__PURE__ */ new Map();
    this.flushDelayer = this._register(new ThrottledDelayer(_Storage.DEFAULT_FLUSH_DELAY));
    this.pendingDeletes = /* @__PURE__ */ new Set();
    this.pendingInserts = /* @__PURE__ */ new Map();
    this.whenFlushedCallbacks = [];
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.database.onDidChangeItemsExternal((e) => this.onDidChangeItemsExternal(e)));
  }
  onDidChangeItemsExternal(e) {
    var _a2, _b2;
    this._onDidChangeStorage.pause();
    try {
      (_a2 = e.changed) === null || _a2 === void 0 ? void 0 : _a2.forEach((value, key) => this.acceptExternal(key, value));
      (_b2 = e.deleted) === null || _b2 === void 0 ? void 0 : _b2.forEach((key) => this.acceptExternal(key, void 0));
    } finally {
      this._onDidChangeStorage.resume();
    }
  }
  acceptExternal(key, value) {
    if (this.state === StorageState.Closed) {
      return;
    }
    let changed = false;
    if (isUndefinedOrNull(value)) {
      changed = this.cache.delete(key);
    } else {
      const currentValue = this.cache.get(key);
      if (currentValue !== value) {
        this.cache.set(key, value);
        changed = true;
      }
    }
    if (changed) {
      this._onDidChangeStorage.fire({ key, external: true });
    }
  }
  get(key, fallbackValue) {
    const value = this.cache.get(key);
    if (isUndefinedOrNull(value)) {
      return fallbackValue;
    }
    return value;
  }
  getBoolean(key, fallbackValue) {
    const value = this.get(key);
    if (isUndefinedOrNull(value)) {
      return fallbackValue;
    }
    return value === "true";
  }
  getNumber(key, fallbackValue) {
    const value = this.get(key);
    if (isUndefinedOrNull(value)) {
      return fallbackValue;
    }
    return parseInt(value, 10);
  }
  async set(key, value, external = false) {
    if (this.state === StorageState.Closed) {
      return;
    }
    if (isUndefinedOrNull(value)) {
      return this.delete(key, external);
    }
    const valueStr = isObject(value) || Array.isArray(value) ? stringify(value) : String(value);
    const currentValue = this.cache.get(key);
    if (currentValue === valueStr) {
      return;
    }
    this.cache.set(key, valueStr);
    this.pendingInserts.set(key, valueStr);
    this.pendingDeletes.delete(key);
    this._onDidChangeStorage.fire({ key, external });
    return this.doFlush();
  }
  async delete(key, external = false) {
    if (this.state === StorageState.Closed) {
      return;
    }
    const wasDeleted = this.cache.delete(key);
    if (!wasDeleted) {
      return;
    }
    if (!this.pendingDeletes.has(key)) {
      this.pendingDeletes.add(key);
    }
    this.pendingInserts.delete(key);
    this._onDidChangeStorage.fire({ key, external });
    return this.doFlush();
  }
  get hasPending() {
    return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;
  }
  async flushPending() {
    if (!this.hasPending) {
      return;
    }
    const updateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };
    this.pendingDeletes = /* @__PURE__ */ new Set();
    this.pendingInserts = /* @__PURE__ */ new Map();
    return this.database.updateItems(updateRequest).finally(() => {
      var _a2;
      if (!this.hasPending) {
        while (this.whenFlushedCallbacks.length) {
          (_a2 = this.whenFlushedCallbacks.pop()) === null || _a2 === void 0 ? void 0 : _a2();
        }
      }
    });
  }
  async doFlush(delay) {
    if (this.options.hint === StorageHint.STORAGE_IN_MEMORY) {
      return this.flushPending();
    }
    return this.flushDelayer.trigger(() => this.flushPending(), delay);
  }
};
Storage.DEFAULT_FLUSH_DELAY = 100;
var InMemoryStorageDatabase = class {
  constructor() {
    this.onDidChangeItemsExternal = Event.None;
    this.items = /* @__PURE__ */ new Map();
  }
  async updateItems(request) {
    var _a2, _b2;
    (_a2 = request.insert) === null || _a2 === void 0 ? void 0 : _a2.forEach((value, key) => this.items.set(key, value));
    (_b2 = request.delete) === null || _b2 === void 0 ? void 0 : _b2.forEach((key) => this.items.delete(key));
  }
};

// node_modules/monaco-editor/esm/vs/platform/storage/common/storage.js
init_instantiation();
var TARGET_KEY = "__$__targetStorageMarker";
var IStorageService = createDecorator("storageService");
var WillSaveStateReason;
(function(WillSaveStateReason2) {
  WillSaveStateReason2[WillSaveStateReason2["NONE"] = 0] = "NONE";
  WillSaveStateReason2[WillSaveStateReason2["SHUTDOWN"] = 1] = "SHUTDOWN";
})(WillSaveStateReason || (WillSaveStateReason = {}));
function loadKeyTargets(storage) {
  const keysRaw = storage.get(TARGET_KEY);
  if (keysRaw) {
    try {
      return JSON.parse(keysRaw);
    } catch (error) {
    }
  }
  return /* @__PURE__ */ Object.create(null);
}
var AbstractStorageService = class _AbstractStorageService extends Disposable {
  constructor(options2 = { flushInterval: _AbstractStorageService.DEFAULT_FLUSH_INTERVAL }) {
    super();
    this.options = options2;
    this._onDidChangeValue = this._register(new PauseableEmitter());
    this._onDidChangeTarget = this._register(new PauseableEmitter());
    this._onWillSaveState = this._register(new Emitter());
    this.onWillSaveState = this._onWillSaveState.event;
    this._workspaceKeyTargets = void 0;
    this._profileKeyTargets = void 0;
    this._applicationKeyTargets = void 0;
  }
  onDidChangeValue(scope, key, disposable) {
    return Event.filter(this._onDidChangeValue.event, (e) => e.scope === scope && (key === void 0 || e.key === key), disposable);
  }
  emitDidChangeValue(scope, event) {
    const { key, external } = event;
    if (key === TARGET_KEY) {
      switch (scope) {
        case -1:
          this._applicationKeyTargets = void 0;
          break;
        case 0:
          this._profileKeyTargets = void 0;
          break;
        case 1:
          this._workspaceKeyTargets = void 0;
          break;
      }
      this._onDidChangeTarget.fire({ scope });
    } else {
      this._onDidChangeValue.fire({ scope, key, target: this.getKeyTargets(scope)[key], external });
    }
  }
  get(key, scope, fallbackValue) {
    var _a2;
    return (_a2 = this.getStorage(scope)) === null || _a2 === void 0 ? void 0 : _a2.get(key, fallbackValue);
  }
  getBoolean(key, scope, fallbackValue) {
    var _a2;
    return (_a2 = this.getStorage(scope)) === null || _a2 === void 0 ? void 0 : _a2.getBoolean(key, fallbackValue);
  }
  getNumber(key, scope, fallbackValue) {
    var _a2;
    return (_a2 = this.getStorage(scope)) === null || _a2 === void 0 ? void 0 : _a2.getNumber(key, fallbackValue);
  }
  store(key, value, scope, target, external = false) {
    if (isUndefinedOrNull(value)) {
      this.remove(key, scope, external);
      return;
    }
    this.withPausedEmitters(() => {
      var _a2;
      this.updateKeyTarget(key, scope, target);
      (_a2 = this.getStorage(scope)) === null || _a2 === void 0 ? void 0 : _a2.set(key, value, external);
    });
  }
  remove(key, scope, external = false) {
    this.withPausedEmitters(() => {
      var _a2;
      this.updateKeyTarget(key, scope, void 0);
      (_a2 = this.getStorage(scope)) === null || _a2 === void 0 ? void 0 : _a2.delete(key, external);
    });
  }
  withPausedEmitters(fn) {
    this._onDidChangeValue.pause();
    this._onDidChangeTarget.pause();
    try {
      fn();
    } finally {
      this._onDidChangeValue.resume();
      this._onDidChangeTarget.resume();
    }
  }
  updateKeyTarget(key, scope, target, external = false) {
    var _a2, _b2;
    const keyTargets = this.getKeyTargets(scope);
    if (typeof target === "number") {
      if (keyTargets[key] !== target) {
        keyTargets[key] = target;
        (_a2 = this.getStorage(scope)) === null || _a2 === void 0 ? void 0 : _a2.set(TARGET_KEY, JSON.stringify(keyTargets), external);
      }
    } else {
      if (typeof keyTargets[key] === "number") {
        delete keyTargets[key];
        (_b2 = this.getStorage(scope)) === null || _b2 === void 0 ? void 0 : _b2.set(TARGET_KEY, JSON.stringify(keyTargets), external);
      }
    }
  }
  get workspaceKeyTargets() {
    if (!this._workspaceKeyTargets) {
      this._workspaceKeyTargets = this.loadKeyTargets(
        1
        /* StorageScope.WORKSPACE */
      );
    }
    return this._workspaceKeyTargets;
  }
  get profileKeyTargets() {
    if (!this._profileKeyTargets) {
      this._profileKeyTargets = this.loadKeyTargets(
        0
        /* StorageScope.PROFILE */
      );
    }
    return this._profileKeyTargets;
  }
  get applicationKeyTargets() {
    if (!this._applicationKeyTargets) {
      this._applicationKeyTargets = this.loadKeyTargets(
        -1
        /* StorageScope.APPLICATION */
      );
    }
    return this._applicationKeyTargets;
  }
  getKeyTargets(scope) {
    switch (scope) {
      case -1:
        return this.applicationKeyTargets;
      case 0:
        return this.profileKeyTargets;
      default:
        return this.workspaceKeyTargets;
    }
  }
  loadKeyTargets(scope) {
    const storage = this.getStorage(scope);
    return storage ? loadKeyTargets(storage) : /* @__PURE__ */ Object.create(null);
  }
};
AbstractStorageService.DEFAULT_FLUSH_INTERVAL = 60 * 1e3;
var InMemoryStorageService = class extends AbstractStorageService {
  constructor() {
    super();
    this.applicationStorage = this._register(new Storage(new InMemoryStorageDatabase(), { hint: StorageHint.STORAGE_IN_MEMORY }));
    this.profileStorage = this._register(new Storage(new InMemoryStorageDatabase(), { hint: StorageHint.STORAGE_IN_MEMORY }));
    this.workspaceStorage = this._register(new Storage(new InMemoryStorageDatabase(), { hint: StorageHint.STORAGE_IN_MEMORY }));
    this._register(this.workspaceStorage.onDidChangeStorage((e) => this.emitDidChangeValue(1, e)));
    this._register(this.profileStorage.onDidChangeStorage((e) => this.emitDidChangeValue(0, e)));
    this._register(this.applicationStorage.onDidChangeStorage((e) => this.emitDidChangeValue(-1, e)));
  }
  getStorage(scope) {
    switch (scope) {
      case -1:
        return this.applicationStorage;
      case 0:
        return this.profileStorage;
      default:
        return this.workspaceStorage;
    }
  }
};

// node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js
init_themeService();
init_themables();
init_theme();
init_types();
init_colorRegistry();

// node_modules/monaco-editor/esm/vs/platform/theme/browser/defaultStyles.js
init_colorRegistry();
init_color();
function overrideStyles(override, styles) {
  const result = { ...styles };
  for (const key in override) {
    const val = override[key];
    result[key] = val !== void 0 ? asCssVariable(val) : void 0;
  }
  return result;
}
var defaultKeybindingLabelStyles = {
  keybindingLabelBackground: asCssVariable(keybindingLabelBackground),
  keybindingLabelForeground: asCssVariable(keybindingLabelForeground),
  keybindingLabelBorder: asCssVariable(keybindingLabelBorder),
  keybindingLabelBottomBorder: asCssVariable(keybindingLabelBottomBorder),
  keybindingLabelShadow: asCssVariable(widgetShadow)
};
var defaultButtonStyles = {
  buttonForeground: asCssVariable(buttonForeground),
  buttonSeparator: asCssVariable(buttonSeparator),
  buttonBackground: asCssVariable(buttonBackground),
  buttonHoverBackground: asCssVariable(buttonHoverBackground),
  buttonSecondaryForeground: asCssVariable(buttonSecondaryForeground),
  buttonSecondaryBackground: asCssVariable(buttonSecondaryBackground),
  buttonSecondaryHoverBackground: asCssVariable(buttonSecondaryHoverBackground),
  buttonBorder: asCssVariable(buttonBorder)
};
var defaultProgressBarStyles = {
  progressBarBackground: asCssVariable(progressBarBackground)
};
var defaultToggleStyles = {
  inputActiveOptionBorder: asCssVariable(inputActiveOptionBorder),
  inputActiveOptionForeground: asCssVariable(inputActiveOptionForeground),
  inputActiveOptionBackground: asCssVariable(inputActiveOptionBackground)
};
var defaultCheckboxStyles = {
  checkboxBackground: asCssVariable(checkboxBackground),
  checkboxBorder: asCssVariable(checkboxBorder),
  checkboxForeground: asCssVariable(checkboxForeground)
};
var defaultDialogStyles = {
  dialogBackground: asCssVariable(editorWidgetBackground),
  dialogForeground: asCssVariable(editorWidgetForeground),
  dialogShadow: asCssVariable(widgetShadow),
  dialogBorder: asCssVariable(contrastBorder),
  errorIconForeground: asCssVariable(problemsErrorIconForeground),
  warningIconForeground: asCssVariable(problemsWarningIconForeground),
  infoIconForeground: asCssVariable(problemsInfoIconForeground),
  textLinkForeground: asCssVariable(textLinkForeground)
};
var defaultInputBoxStyles = {
  inputBackground: asCssVariable(inputBackground),
  inputForeground: asCssVariable(inputForeground),
  inputBorder: asCssVariable(inputBorder),
  inputValidationInfoBorder: asCssVariable(inputValidationInfoBorder),
  inputValidationInfoBackground: asCssVariable(inputValidationInfoBackground),
  inputValidationInfoForeground: asCssVariable(inputValidationInfoForeground),
  inputValidationWarningBorder: asCssVariable(inputValidationWarningBorder),
  inputValidationWarningBackground: asCssVariable(inputValidationWarningBackground),
  inputValidationWarningForeground: asCssVariable(inputValidationWarningForeground),
  inputValidationErrorBorder: asCssVariable(inputValidationErrorBorder),
  inputValidationErrorBackground: asCssVariable(inputValidationErrorBackground),
  inputValidationErrorForeground: asCssVariable(inputValidationErrorForeground)
};
var defaultFindWidgetStyles = {
  listFilterWidgetBackground: asCssVariable(listFilterWidgetBackground),
  listFilterWidgetOutline: asCssVariable(listFilterWidgetOutline),
  listFilterWidgetNoMatchesOutline: asCssVariable(listFilterWidgetNoMatchesOutline),
  listFilterWidgetShadow: asCssVariable(listFilterWidgetShadow),
  inputBoxStyles: defaultInputBoxStyles,
  toggleStyles: defaultToggleStyles
};
var defaultCountBadgeStyles = {
  badgeBackground: asCssVariable(badgeBackground),
  badgeForeground: asCssVariable(badgeForeground),
  badgeBorder: asCssVariable(contrastBorder)
};
var defaultBreadcrumbsWidgetStyles = {
  breadcrumbsBackground: asCssVariable(breadcrumbsBackground),
  breadcrumbsForeground: asCssVariable(breadcrumbsForeground),
  breadcrumbsHoverForeground: asCssVariable(breadcrumbsFocusForeground),
  breadcrumbsFocusForeground: asCssVariable(breadcrumbsFocusForeground),
  breadcrumbsFocusAndSelectionForeground: asCssVariable(breadcrumbsActiveSelectionForeground)
};
var defaultListStyles = {
  listBackground: void 0,
  listInactiveFocusForeground: void 0,
  listFocusBackground: asCssVariable(listFocusBackground),
  listFocusForeground: asCssVariable(listFocusForeground),
  listFocusOutline: asCssVariable(listFocusOutline),
  listActiveSelectionBackground: asCssVariable(listActiveSelectionBackground),
  listActiveSelectionForeground: asCssVariable(listActiveSelectionForeground),
  listActiveSelectionIconForeground: asCssVariable(listActiveSelectionIconForeground),
  listFocusAndSelectionOutline: asCssVariable(listFocusAndSelectionOutline),
  listFocusAndSelectionBackground: asCssVariable(listActiveSelectionBackground),
  listFocusAndSelectionForeground: asCssVariable(listActiveSelectionForeground),
  listInactiveSelectionBackground: asCssVariable(listInactiveSelectionBackground),
  listInactiveSelectionIconForeground: asCssVariable(listInactiveSelectionIconForeground),
  listInactiveSelectionForeground: asCssVariable(listInactiveSelectionForeground),
  listInactiveFocusBackground: asCssVariable(listInactiveFocusBackground),
  listInactiveFocusOutline: asCssVariable(listInactiveFocusOutline),
  listHoverBackground: asCssVariable(listHoverBackground),
  listHoverForeground: asCssVariable(listHoverForeground),
  listDropOverBackground: asCssVariable(listDropOverBackground),
  listDropBetweenBackground: asCssVariable(listDropBetweenBackground),
  listSelectionOutline: asCssVariable(activeContrastBorder),
  listHoverOutline: asCssVariable(activeContrastBorder),
  treeIndentGuidesStroke: asCssVariable(treeIndentGuidesStroke),
  treeInactiveIndentGuidesStroke: asCssVariable(treeInactiveIndentGuidesStroke),
  tableColumnsBorder: asCssVariable(tableColumnsBorder),
  tableOddRowsBackgroundColor: asCssVariable(tableOddRowsBackgroundColor)
};
function getListStyles(override) {
  return overrideStyles(override, defaultListStyles);
}
var defaultSelectBoxStyles = {
  selectBackground: asCssVariable(selectBackground),
  selectListBackground: asCssVariable(selectListBackground),
  selectForeground: asCssVariable(selectForeground),
  decoratorRightForeground: asCssVariable(pickerGroupForeground),
  selectBorder: asCssVariable(selectBorder),
  focusBorder: asCssVariable(focusBorder),
  listFocusBackground: asCssVariable(quickInputListFocusBackground),
  listInactiveSelectionIconForeground: asCssVariable(quickInputListFocusIconForeground),
  listFocusForeground: asCssVariable(quickInputListFocusForeground),
  listFocusOutline: asCssVariableWithDefault(activeContrastBorder, Color.transparent.toString()),
  listHoverBackground: asCssVariable(listHoverBackground),
  listHoverForeground: asCssVariable(listHoverForeground),
  listHoverOutline: asCssVariable(activeContrastBorder),
  selectListBorder: asCssVariable(editorWidgetBorder),
  listBackground: void 0,
  listActiveSelectionBackground: void 0,
  listActiveSelectionForeground: void 0,
  listActiveSelectionIconForeground: void 0,
  listFocusAndSelectionBackground: void 0,
  listDropOverBackground: void 0,
  listDropBetweenBackground: void 0,
  listInactiveSelectionBackground: void 0,
  listInactiveSelectionForeground: void 0,
  listInactiveFocusBackground: void 0,
  listInactiveFocusOutline: void 0,
  listSelectionOutline: void 0,
  listFocusAndSelectionForeground: void 0,
  listFocusAndSelectionOutline: void 0,
  listInactiveFocusForeground: void 0,
  tableColumnsBorder: void 0,
  tableOddRowsBackgroundColor: void 0,
  treeIndentGuidesStroke: void 0,
  treeInactiveIndentGuidesStroke: void 0
};
var defaultMenuStyles = {
  shadowColor: asCssVariable(widgetShadow),
  borderColor: asCssVariable(menuBorder),
  foregroundColor: asCssVariable(menuForeground),
  backgroundColor: asCssVariable(menuBackground),
  selectionForegroundColor: asCssVariable(menuSelectionForeground),
  selectionBackgroundColor: asCssVariable(menuSelectionBackground),
  selectionBorderColor: asCssVariable(menuSelectionBorder),
  separatorColor: asCssVariable(menuSeparatorBackground),
  scrollbarShadow: asCssVariable(scrollbarShadow),
  scrollbarSliderBackground: asCssVariable(scrollbarSliderBackground),
  scrollbarSliderHoverBackground: asCssVariable(scrollbarSliderHoverBackground),
  scrollbarSliderActiveBackground: asCssVariable(scrollbarSliderActiveBackground)
};

// node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param14 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function createAndFillInContextMenuActions(menu, options2, target, primaryGroup) {
  const groups = menu.getActions(options2);
  const modifierKeyEmitter = ModifierKeyEmitter.getInstance();
  const useAlternativeActions = modifierKeyEmitter.keyStatus.altKey || (isWindows || isLinux) && modifierKeyEmitter.keyStatus.shiftKey;
  fillInActions(groups, target, useAlternativeActions, primaryGroup ? (actionGroup) => actionGroup === primaryGroup : (actionGroup) => actionGroup === "navigation");
}
function createAndFillInActionBarActions(menu, options2, target, primaryGroup, shouldInlineSubmenu, useSeparatorsInPrimaryActions) {
  const groups = menu.getActions(options2);
  const isPrimaryAction = typeof primaryGroup === "string" ? (actionGroup) => actionGroup === primaryGroup : primaryGroup;
  fillInActions(groups, target, false, isPrimaryAction, shouldInlineSubmenu, useSeparatorsInPrimaryActions);
}
function fillInActions(groups, target, useAlternativeActions, isPrimaryAction = (actionGroup) => actionGroup === "navigation", shouldInlineSubmenu = () => false, useSeparatorsInPrimaryActions = false) {
  let primaryBucket;
  let secondaryBucket;
  if (Array.isArray(target)) {
    primaryBucket = target;
    secondaryBucket = target;
  } else {
    primaryBucket = target.primary;
    secondaryBucket = target.secondary;
  }
  const submenuInfo = /* @__PURE__ */ new Set();
  for (const [group, actions] of groups) {
    let target2;
    if (isPrimaryAction(group)) {
      target2 = primaryBucket;
      if (target2.length > 0 && useSeparatorsInPrimaryActions) {
        target2.push(new Separator());
      }
    } else {
      target2 = secondaryBucket;
      if (target2.length > 0) {
        target2.push(new Separator());
      }
    }
    for (let action of actions) {
      if (useAlternativeActions) {
        action = action instanceof MenuItemAction && action.alt ? action.alt : action;
      }
      const newLen = target2.push(action);
      if (action instanceof SubmenuAction) {
        submenuInfo.add({ group, action, index: newLen - 1 });
      }
    }
  }
  for (const { group, action, index } of submenuInfo) {
    const target2 = isPrimaryAction(group) ? primaryBucket : secondaryBucket;
    const submenuActions = action.actions;
    if (shouldInlineSubmenu(action, group, target2.length)) {
      target2.splice(index, 1, ...submenuActions);
    }
  }
}
var MenuEntryActionViewItem = class MenuEntryActionViewItem2 extends ActionViewItem {
  constructor(action, options2, _keybindingService, _notificationService, _contextKeyService, _themeService, _contextMenuService, _accessibilityService) {
    super(void 0, action, { icon: !!(action.class || action.item.icon), label: !action.class && !action.item.icon, draggable: options2 === null || options2 === void 0 ? void 0 : options2.draggable, keybinding: options2 === null || options2 === void 0 ? void 0 : options2.keybinding, hoverDelegate: options2 === null || options2 === void 0 ? void 0 : options2.hoverDelegate });
    this._keybindingService = _keybindingService;
    this._notificationService = _notificationService;
    this._contextKeyService = _contextKeyService;
    this._themeService = _themeService;
    this._contextMenuService = _contextMenuService;
    this._accessibilityService = _accessibilityService;
    this._wantsAltCommand = false;
    this._itemClassDispose = this._register(new MutableDisposable());
    this._altKey = ModifierKeyEmitter.getInstance();
  }
  get _menuItemAction() {
    return this._action;
  }
  get _commandAction() {
    return this._wantsAltCommand && this._menuItemAction.alt || this._menuItemAction;
  }
  async onClick(event) {
    event.preventDefault();
    event.stopPropagation();
    try {
      await this.actionRunner.run(this._commandAction, this._context);
    } catch (err) {
      this._notificationService.error(err);
    }
  }
  render(container) {
    super.render(container);
    container.classList.add("menu-entry");
    if (this.options.icon) {
      this._updateItemClass(this._menuItemAction.item);
    }
    if (this._menuItemAction.alt) {
      let isMouseOver = false;
      const updateAltState = () => {
        var _a2;
        const wantsAltCommand = !!((_a2 = this._menuItemAction.alt) === null || _a2 === void 0 ? void 0 : _a2.enabled) && (!this._accessibilityService.isMotionReduced() || isMouseOver) && (this._altKey.keyStatus.altKey || this._altKey.keyStatus.shiftKey && isMouseOver);
        if (wantsAltCommand !== this._wantsAltCommand) {
          this._wantsAltCommand = wantsAltCommand;
          this.updateLabel();
          this.updateTooltip();
          this.updateClass();
        }
      };
      this._register(this._altKey.event(updateAltState));
      this._register(addDisposableListener(container, "mouseleave", (_) => {
        isMouseOver = false;
        updateAltState();
      }));
      this._register(addDisposableListener(container, "mouseenter", (_) => {
        isMouseOver = true;
        updateAltState();
      }));
      updateAltState();
    }
  }
  updateLabel() {
    if (this.options.label && this.label) {
      this.label.textContent = this._commandAction.label;
    }
  }
  getTooltip() {
    var _a2;
    const keybinding = this._keybindingService.lookupKeybinding(this._commandAction.id, this._contextKeyService);
    const keybindingLabel = keybinding && keybinding.getLabel();
    const tooltip = this._commandAction.tooltip || this._commandAction.label;
    let title = keybindingLabel ? localize("titleAndKb", "{0} ({1})", tooltip, keybindingLabel) : tooltip;
    if (!this._wantsAltCommand && ((_a2 = this._menuItemAction.alt) === null || _a2 === void 0 ? void 0 : _a2.enabled)) {
      const altTooltip = this._menuItemAction.alt.tooltip || this._menuItemAction.alt.label;
      const altKeybinding = this._keybindingService.lookupKeybinding(this._menuItemAction.alt.id, this._contextKeyService);
      const altKeybindingLabel = altKeybinding && altKeybinding.getLabel();
      const altTitleSection = altKeybindingLabel ? localize("titleAndKb", "{0} ({1})", altTooltip, altKeybindingLabel) : altTooltip;
      title = localize("titleAndKbAndAlt", "{0}\n[{1}] {2}", title, UILabelProvider.modifierLabels[OS].altKey, altTitleSection);
    }
    return title;
  }
  updateClass() {
    if (this.options.icon) {
      if (this._commandAction !== this._menuItemAction) {
        if (this._menuItemAction.alt) {
          this._updateItemClass(this._menuItemAction.alt.item);
        }
      } else {
        this._updateItemClass(this._menuItemAction.item);
      }
    }
  }
  _updateItemClass(item) {
    this._itemClassDispose.value = void 0;
    const { element, label } = this;
    if (!element || !label) {
      return;
    }
    const icon = this._commandAction.checked && isICommandActionToggleInfo(item.toggled) && item.toggled.icon ? item.toggled.icon : item.icon;
    if (!icon) {
      return;
    }
    if (ThemeIcon.isThemeIcon(icon)) {
      const iconClasses = ThemeIcon.asClassNameArray(icon);
      label.classList.add(...iconClasses);
      this._itemClassDispose.value = toDisposable(() => {
        label.classList.remove(...iconClasses);
      });
    } else {
      label.style.backgroundImage = isDark(this._themeService.getColorTheme().type) ? asCSSUrl(icon.dark) : asCSSUrl(icon.light);
      label.classList.add("icon");
      this._itemClassDispose.value = combinedDisposable(toDisposable(() => {
        label.style.backgroundImage = "";
        label.classList.remove("icon");
      }), this._themeService.onDidColorThemeChange(() => {
        this.updateClass();
      }));
    }
  }
};
MenuEntryActionViewItem = __decorate17([
  __param14(2, IKeybindingService),
  __param14(3, INotificationService),
  __param14(4, IContextKeyService),
  __param14(5, IThemeService),
  __param14(6, IContextMenuService),
  __param14(7, IAccessibilityService)
], MenuEntryActionViewItem);
var SubmenuEntryActionViewItem = class SubmenuEntryActionViewItem2 extends DropdownMenuActionViewItem {
  constructor(action, options2, _keybindingService, _contextMenuService, _themeService) {
    var _a2, _b2, _c;
    const dropdownOptions = {
      ...options2,
      menuAsChild: (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.menuAsChild) !== null && _a2 !== void 0 ? _a2 : false,
      classNames: (_b2 = options2 === null || options2 === void 0 ? void 0 : options2.classNames) !== null && _b2 !== void 0 ? _b2 : ThemeIcon.isThemeIcon(action.item.icon) ? ThemeIcon.asClassName(action.item.icon) : void 0,
      keybindingProvider: (_c = options2 === null || options2 === void 0 ? void 0 : options2.keybindingProvider) !== null && _c !== void 0 ? _c : (action2) => _keybindingService.lookupKeybinding(action2.id)
    };
    super(action, { getActions: () => action.actions }, _contextMenuService, dropdownOptions);
    this._keybindingService = _keybindingService;
    this._contextMenuService = _contextMenuService;
    this._themeService = _themeService;
  }
  render(container) {
    super.render(container);
    assertType(this.element);
    container.classList.add("menu-entry");
    const action = this._action;
    const { icon } = action.item;
    if (icon && !ThemeIcon.isThemeIcon(icon)) {
      this.element.classList.add("icon");
      const setBackgroundImage = () => {
        if (this.element) {
          this.element.style.backgroundImage = isDark(this._themeService.getColorTheme().type) ? asCSSUrl(icon.dark) : asCSSUrl(icon.light);
        }
      };
      setBackgroundImage();
      this._register(this._themeService.onDidColorThemeChange(() => {
        setBackgroundImage();
      }));
    }
  }
};
SubmenuEntryActionViewItem = __decorate17([
  __param14(2, IKeybindingService),
  __param14(3, IContextMenuService),
  __param14(4, IThemeService)
], SubmenuEntryActionViewItem);
var DropdownWithDefaultActionViewItem = class DropdownWithDefaultActionViewItem2 extends BaseActionViewItem {
  constructor(submenuAction, options2, _keybindingService, _notificationService, _contextMenuService, _menuService, _instaService, _storageService) {
    var _a2, _b2, _c;
    super(null, submenuAction);
    this._keybindingService = _keybindingService;
    this._notificationService = _notificationService;
    this._contextMenuService = _contextMenuService;
    this._menuService = _menuService;
    this._instaService = _instaService;
    this._storageService = _storageService;
    this._container = null;
    this._options = options2;
    this._storageKey = `${submenuAction.item.submenu.id}_lastActionId`;
    let defaultAction;
    const defaultActionId = (options2 === null || options2 === void 0 ? void 0 : options2.persistLastActionId) ? _storageService.get(
      this._storageKey,
      1
      /* StorageScope.WORKSPACE */
    ) : void 0;
    if (defaultActionId) {
      defaultAction = submenuAction.actions.find((a) => defaultActionId === a.id);
    }
    if (!defaultAction) {
      defaultAction = submenuAction.actions[0];
    }
    this._defaultAction = this._instaService.createInstance(MenuEntryActionViewItem, defaultAction, { keybinding: this._getDefaultActionKeybindingLabel(defaultAction) });
    const dropdownOptions = {
      keybindingProvider: (action) => this._keybindingService.lookupKeybinding(action.id),
      ...options2,
      menuAsChild: (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.menuAsChild) !== null && _a2 !== void 0 ? _a2 : true,
      classNames: (_b2 = options2 === null || options2 === void 0 ? void 0 : options2.classNames) !== null && _b2 !== void 0 ? _b2 : ["codicon", "codicon-chevron-down"],
      actionRunner: (_c = options2 === null || options2 === void 0 ? void 0 : options2.actionRunner) !== null && _c !== void 0 ? _c : new ActionRunner()
    };
    this._dropdown = new DropdownMenuActionViewItem(submenuAction, submenuAction.actions, this._contextMenuService, dropdownOptions);
    this._register(this._dropdown.actionRunner.onDidRun((e) => {
      if (e.action instanceof MenuItemAction) {
        this.update(e.action);
      }
    }));
  }
  update(lastAction) {
    var _a2;
    if ((_a2 = this._options) === null || _a2 === void 0 ? void 0 : _a2.persistLastActionId) {
      this._storageService.store(
        this._storageKey,
        lastAction.id,
        1,
        1
        /* StorageTarget.MACHINE */
      );
    }
    this._defaultAction.dispose();
    this._defaultAction = this._instaService.createInstance(MenuEntryActionViewItem, lastAction, { keybinding: this._getDefaultActionKeybindingLabel(lastAction) });
    this._defaultAction.actionRunner = new class extends ActionRunner {
      async runAction(action, context) {
        await action.run(void 0);
      }
    }();
    if (this._container) {
      this._defaultAction.render(prepend(this._container, $(".action-container")));
    }
  }
  _getDefaultActionKeybindingLabel(defaultAction) {
    var _a2;
    let defaultActionKeybinding;
    if ((_a2 = this._options) === null || _a2 === void 0 ? void 0 : _a2.renderKeybindingWithDefaultActionLabel) {
      const kb = this._keybindingService.lookupKeybinding(defaultAction.id);
      if (kb) {
        defaultActionKeybinding = `(${kb.getLabel()})`;
      }
    }
    return defaultActionKeybinding;
  }
  setActionContext(newContext) {
    super.setActionContext(newContext);
    this._defaultAction.setActionContext(newContext);
    this._dropdown.setActionContext(newContext);
  }
  render(container) {
    this._container = container;
    super.render(this._container);
    this._container.classList.add("monaco-dropdown-with-default");
    const primaryContainer = $(".action-container");
    this._defaultAction.render(append(this._container, primaryContainer));
    this._register(addDisposableListener(primaryContainer, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(
        17
        /* KeyCode.RightArrow */
      )) {
        this._defaultAction.element.tabIndex = -1;
        this._dropdown.focus();
        event.stopPropagation();
      }
    }));
    const dropdownContainer = $(".dropdown-action-container");
    this._dropdown.render(append(this._container, dropdownContainer));
    this._register(addDisposableListener(dropdownContainer, EventType.KEY_DOWN, (e) => {
      var _a2;
      const event = new StandardKeyboardEvent(e);
      if (event.equals(
        15
        /* KeyCode.LeftArrow */
      )) {
        this._defaultAction.element.tabIndex = 0;
        this._dropdown.setFocusable(false);
        (_a2 = this._defaultAction.element) === null || _a2 === void 0 ? void 0 : _a2.focus();
        event.stopPropagation();
      }
    }));
  }
  focus(fromRight) {
    if (fromRight) {
      this._dropdown.focus();
    } else {
      this._defaultAction.element.tabIndex = 0;
      this._defaultAction.element.focus();
    }
  }
  blur() {
    this._defaultAction.element.tabIndex = -1;
    this._dropdown.blur();
    this._container.blur();
  }
  setFocusable(focusable) {
    if (focusable) {
      this._defaultAction.element.tabIndex = 0;
    } else {
      this._defaultAction.element.tabIndex = -1;
      this._dropdown.setFocusable(false);
    }
  }
  dispose() {
    this._defaultAction.dispose();
    this._dropdown.dispose();
    super.dispose();
  }
};
DropdownWithDefaultActionViewItem = __decorate17([
  __param14(2, IKeybindingService),
  __param14(3, INotificationService),
  __param14(4, IContextMenuService),
  __param14(5, IMenuService),
  __param14(6, IInstantiationService),
  __param14(7, IStorageService)
], DropdownWithDefaultActionViewItem);
var SubmenuEntrySelectActionViewItem = class SubmenuEntrySelectActionViewItem2 extends SelectActionViewItem {
  constructor(action, contextViewService) {
    super(null, action, action.actions.map((a) => ({
      text: a.id === Separator.ID ? "" : a.label,
      isDisabled: !a.enabled
    })), 0, contextViewService, defaultSelectBoxStyles, { ariaLabel: action.tooltip, optionsAsChildren: true });
    this.select(Math.max(0, action.actions.findIndex((a) => a.checked)));
  }
  render(container) {
    super.render(container);
    container.style.borderColor = asCssVariable(selectBorder);
  }
  runAction(option, index) {
    const action = this.action.actions[index];
    if (action) {
      this.actionRunner.run(action);
    }
  }
};
SubmenuEntrySelectActionViewItem = __decorate17([
  __param14(1, IContextViewService)
], SubmenuEntrySelectActionViewItem);
function createActionViewItem(instaService, action, options2) {
  if (action instanceof MenuItemAction) {
    return instaService.createInstance(MenuEntryActionViewItem, action, options2);
  } else if (action instanceof SubmenuItemAction) {
    if (action.item.isSelection) {
      return instaService.createInstance(SubmenuEntrySelectActionViewItem, action);
    } else {
      if (action.item.rememberDefaultAction) {
        return instaService.createInstance(DropdownWithDefaultActionViewItem, action, { ...options2, persistLastActionId: true });
      } else {
        return instaService.createInstance(SubmenuEntryActionViewItem, action, options2);
      }
    }
  } else {
    return void 0;
  }
}

// node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextMenuService.js
init_actions2();
init_contextkey();
init_telemetry();

// node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextMenuHandler.js
init_dom();
init_mouseEvent();

// node_modules/monaco-editor/esm/vs/base/browser/ui/menu/menu.js
init_browser();
init_dom();
init_keyboardEvent();
init_mouseEvent();

// node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.js
init_dom();
init_keyboardEvent();
init_actions();
init_event();
init_lifecycle();
init_types();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.css";
var ActionBar = class extends Disposable {
  constructor(container, options2 = {}) {
    var _a2, _b2, _c, _d, _e, _f, _g;
    super();
    this._actionRunnerDisposables = this._register(new DisposableStore());
    this.viewItemDisposables = this._register(new DisposableMap());
    this.triggerKeyDown = false;
    this.focusable = true;
    this._onDidBlur = this._register(new Emitter());
    this.onDidBlur = this._onDidBlur.event;
    this._onDidCancel = this._register(new Emitter({ onWillAddFirstListener: () => this.cancelHasListener = true }));
    this.onDidCancel = this._onDidCancel.event;
    this.cancelHasListener = false;
    this._onDidRun = this._register(new Emitter());
    this.onDidRun = this._onDidRun.event;
    this._onWillRun = this._register(new Emitter());
    this.onWillRun = this._onWillRun.event;
    this.options = options2;
    this._context = (_a2 = options2.context) !== null && _a2 !== void 0 ? _a2 : null;
    this._orientation = (_b2 = this.options.orientation) !== null && _b2 !== void 0 ? _b2 : 0;
    this._triggerKeys = {
      keyDown: (_d = (_c = this.options.triggerKeys) === null || _c === void 0 ? void 0 : _c.keyDown) !== null && _d !== void 0 ? _d : false,
      keys: (_f = (_e = this.options.triggerKeys) === null || _e === void 0 ? void 0 : _e.keys) !== null && _f !== void 0 ? _f : [
        3,
        10
        /* KeyCode.Space */
      ]
    };
    this._hoverDelegate = (_g = options2.hoverDelegate) !== null && _g !== void 0 ? _g : this._register(getDefaultHoverDelegate("element", true));
    if (this.options.actionRunner) {
      this._actionRunner = this.options.actionRunner;
    } else {
      this._actionRunner = new ActionRunner();
      this._actionRunnerDisposables.add(this._actionRunner);
    }
    this._actionRunnerDisposables.add(this._actionRunner.onDidRun((e) => this._onDidRun.fire(e)));
    this._actionRunnerDisposables.add(this._actionRunner.onWillRun((e) => this._onWillRun.fire(e)));
    this.viewItems = [];
    this.focusedItem = void 0;
    this.domNode = document.createElement("div");
    this.domNode.className = "monaco-action-bar";
    let previousKeys;
    let nextKeys;
    switch (this._orientation) {
      case 0:
        previousKeys = [
          15
          /* KeyCode.LeftArrow */
        ];
        nextKeys = [
          17
          /* KeyCode.RightArrow */
        ];
        break;
      case 1:
        previousKeys = [
          16
          /* KeyCode.UpArrow */
        ];
        nextKeys = [
          18
          /* KeyCode.DownArrow */
        ];
        this.domNode.className += " vertical";
        break;
    }
    this._register(addDisposableListener(this.domNode, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      let eventHandled = true;
      const focusedItem = typeof this.focusedItem === "number" ? this.viewItems[this.focusedItem] : void 0;
      if (previousKeys && (event.equals(previousKeys[0]) || event.equals(previousKeys[1]))) {
        eventHandled = this.focusPrevious();
      } else if (nextKeys && (event.equals(nextKeys[0]) || event.equals(nextKeys[1]))) {
        eventHandled = this.focusNext();
      } else if (event.equals(
        9
        /* KeyCode.Escape */
      ) && this.cancelHasListener) {
        this._onDidCancel.fire();
      } else if (event.equals(
        14
        /* KeyCode.Home */
      )) {
        eventHandled = this.focusFirst();
      } else if (event.equals(
        13
        /* KeyCode.End */
      )) {
        eventHandled = this.focusLast();
      } else if (event.equals(
        2
        /* KeyCode.Tab */
      ) && focusedItem instanceof BaseActionViewItem && focusedItem.trapsArrowNavigation) {
        eventHandled = this.focusNext();
      } else if (this.isTriggerKeyEvent(event)) {
        if (this._triggerKeys.keyDown) {
          this.doTrigger(event);
        } else {
          this.triggerKeyDown = true;
        }
      } else {
        eventHandled = false;
      }
      if (eventHandled) {
        event.preventDefault();
        event.stopPropagation();
      }
    }));
    this._register(addDisposableListener(this.domNode, EventType.KEY_UP, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (this.isTriggerKeyEvent(event)) {
        if (!this._triggerKeys.keyDown && this.triggerKeyDown) {
          this.triggerKeyDown = false;
          this.doTrigger(event);
        }
        event.preventDefault();
        event.stopPropagation();
      } else if (event.equals(
        2
        /* KeyCode.Tab */
      ) || event.equals(
        1024 | 2
        /* KeyCode.Tab */
      ) || event.equals(
        16
        /* KeyCode.UpArrow */
      ) || event.equals(
        18
        /* KeyCode.DownArrow */
      ) || event.equals(
        15
        /* KeyCode.LeftArrow */
      ) || event.equals(
        17
        /* KeyCode.RightArrow */
      )) {
        this.updateFocusedItem();
      }
    }));
    this.focusTracker = this._register(trackFocus(this.domNode));
    this._register(this.focusTracker.onDidBlur(() => {
      if (getActiveElement() === this.domNode || !isAncestor(getActiveElement(), this.domNode)) {
        this._onDidBlur.fire();
        this.previouslyFocusedItem = this.focusedItem;
        this.focusedItem = void 0;
        this.triggerKeyDown = false;
      }
    }));
    this._register(this.focusTracker.onDidFocus(() => this.updateFocusedItem()));
    this.actionsList = document.createElement("ul");
    this.actionsList.className = "actions-container";
    if (this.options.highlightToggledItems) {
      this.actionsList.classList.add("highlight-toggled");
    }
    this.actionsList.setAttribute("role", this.options.ariaRole || "toolbar");
    if (this.options.ariaLabel) {
      this.actionsList.setAttribute("aria-label", this.options.ariaLabel);
    }
    this.domNode.appendChild(this.actionsList);
    container.appendChild(this.domNode);
  }
  refreshRole() {
    if (this.length() >= 1) {
      this.actionsList.setAttribute("role", this.options.ariaRole || "toolbar");
    } else {
      this.actionsList.setAttribute("role", "presentation");
    }
  }
  // Some action bars should not be focusable at times
  // When an action bar is not focusable make sure to make all the elements inside it not focusable
  // When an action bar is focusable again, make sure the first item can be focused
  setFocusable(focusable) {
    this.focusable = focusable;
    if (this.focusable) {
      const firstEnabled = this.viewItems.find((vi) => vi instanceof BaseActionViewItem && vi.isEnabled());
      if (firstEnabled instanceof BaseActionViewItem) {
        firstEnabled.setFocusable(true);
      }
    } else {
      this.viewItems.forEach((vi) => {
        if (vi instanceof BaseActionViewItem) {
          vi.setFocusable(false);
        }
      });
    }
  }
  isTriggerKeyEvent(event) {
    let ret = false;
    this._triggerKeys.keys.forEach((keyCode) => {
      ret = ret || event.equals(keyCode);
    });
    return ret;
  }
  updateFocusedItem() {
    var _a2, _b2;
    for (let i = 0; i < this.actionsList.children.length; i++) {
      const elem = this.actionsList.children[i];
      if (isAncestor(getActiveElement(), elem)) {
        this.focusedItem = i;
        (_b2 = (_a2 = this.viewItems[this.focusedItem]) === null || _a2 === void 0 ? void 0 : _a2.showHover) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
        break;
      }
    }
  }
  get context() {
    return this._context;
  }
  set context(context) {
    this._context = context;
    this.viewItems.forEach((i) => i.setActionContext(context));
  }
  get actionRunner() {
    return this._actionRunner;
  }
  set actionRunner(actionRunner) {
    this._actionRunner = actionRunner;
    this._actionRunnerDisposables.clear();
    this._actionRunnerDisposables.add(this._actionRunner.onDidRun((e) => this._onDidRun.fire(e)));
    this._actionRunnerDisposables.add(this._actionRunner.onWillRun((e) => this._onWillRun.fire(e)));
    this.viewItems.forEach((item) => item.actionRunner = actionRunner);
  }
  getContainer() {
    return this.domNode;
  }
  getAction(indexOrElement) {
    var _a2;
    if (typeof indexOrElement === "number") {
      return (_a2 = this.viewItems[indexOrElement]) === null || _a2 === void 0 ? void 0 : _a2.action;
    }
    if (indexOrElement instanceof HTMLElement) {
      while (indexOrElement.parentElement !== this.actionsList) {
        if (!indexOrElement.parentElement) {
          return void 0;
        }
        indexOrElement = indexOrElement.parentElement;
      }
      for (let i = 0; i < this.actionsList.childNodes.length; i++) {
        if (this.actionsList.childNodes[i] === indexOrElement) {
          return this.viewItems[i].action;
        }
      }
    }
    return void 0;
  }
  push(arg, options2 = {}) {
    const actions = Array.isArray(arg) ? arg : [arg];
    let index = isNumber(options2.index) ? options2.index : null;
    actions.forEach((action) => {
      const actionViewItemElement = document.createElement("li");
      actionViewItemElement.className = "action-item";
      actionViewItemElement.setAttribute("role", "presentation");
      let item;
      const viewItemOptions = { hoverDelegate: this._hoverDelegate, ...options2 };
      if (this.options.actionViewItemProvider) {
        item = this.options.actionViewItemProvider(action, viewItemOptions);
      }
      if (!item) {
        item = new ActionViewItem(this.context, action, viewItemOptions);
      }
      if (!this.options.allowContextMenu) {
        this.viewItemDisposables.set(item, addDisposableListener(actionViewItemElement, EventType.CONTEXT_MENU, (e) => {
          EventHelper.stop(e, true);
        }));
      }
      item.actionRunner = this._actionRunner;
      item.setActionContext(this.context);
      item.render(actionViewItemElement);
      if (this.focusable && item instanceof BaseActionViewItem && this.viewItems.length === 0) {
        item.setFocusable(true);
      }
      if (index === null || index < 0 || index >= this.actionsList.children.length) {
        this.actionsList.appendChild(actionViewItemElement);
        this.viewItems.push(item);
      } else {
        this.actionsList.insertBefore(actionViewItemElement, this.actionsList.children[index]);
        this.viewItems.splice(index, 0, item);
        index++;
      }
    });
    if (typeof this.focusedItem === "number") {
      this.focus(this.focusedItem);
    }
    this.refreshRole();
  }
  clear() {
    if (this.isEmpty()) {
      return;
    }
    this.viewItems = dispose(this.viewItems);
    this.viewItemDisposables.clearAndDisposeAll();
    clearNode(this.actionsList);
    this.refreshRole();
  }
  length() {
    return this.viewItems.length;
  }
  isEmpty() {
    return this.viewItems.length === 0;
  }
  focus(arg) {
    let selectFirst = false;
    let index = void 0;
    if (arg === void 0) {
      selectFirst = true;
    } else if (typeof arg === "number") {
      index = arg;
    } else if (typeof arg === "boolean") {
      selectFirst = arg;
    }
    if (selectFirst && typeof this.focusedItem === "undefined") {
      const firstEnabled = this.viewItems.findIndex((item) => item.isEnabled());
      this.focusedItem = firstEnabled === -1 ? void 0 : firstEnabled;
      this.updateFocus(void 0, void 0, true);
    } else {
      if (index !== void 0) {
        this.focusedItem = index;
      }
      this.updateFocus(void 0, void 0, true);
    }
  }
  focusFirst() {
    this.focusedItem = this.length() - 1;
    return this.focusNext(true);
  }
  focusLast() {
    this.focusedItem = 0;
    return this.focusPrevious(true);
  }
  focusNext(forceLoop) {
    if (typeof this.focusedItem === "undefined") {
      this.focusedItem = this.viewItems.length - 1;
    } else if (this.viewItems.length <= 1) {
      return false;
    }
    const startIndex = this.focusedItem;
    let item;
    do {
      if (!forceLoop && this.options.preventLoopNavigation && this.focusedItem + 1 >= this.viewItems.length) {
        this.focusedItem = startIndex;
        return false;
      }
      this.focusedItem = (this.focusedItem + 1) % this.viewItems.length;
      item = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== startIndex && (this.options.focusOnlyEnabledItems && !item.isEnabled() || item.action.id === Separator.ID));
    this.updateFocus();
    return true;
  }
  focusPrevious(forceLoop) {
    if (typeof this.focusedItem === "undefined") {
      this.focusedItem = 0;
    } else if (this.viewItems.length <= 1) {
      return false;
    }
    const startIndex = this.focusedItem;
    let item;
    do {
      this.focusedItem = this.focusedItem - 1;
      if (this.focusedItem < 0) {
        if (!forceLoop && this.options.preventLoopNavigation) {
          this.focusedItem = startIndex;
          return false;
        }
        this.focusedItem = this.viewItems.length - 1;
      }
      item = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== startIndex && (this.options.focusOnlyEnabledItems && !item.isEnabled() || item.action.id === Separator.ID));
    this.updateFocus(true);
    return true;
  }
  updateFocus(fromRight, preventScroll, forceFocus = false) {
    var _a2, _b2;
    if (typeof this.focusedItem === "undefined") {
      this.actionsList.focus({ preventScroll });
    }
    if (this.previouslyFocusedItem !== void 0 && this.previouslyFocusedItem !== this.focusedItem) {
      (_a2 = this.viewItems[this.previouslyFocusedItem]) === null || _a2 === void 0 ? void 0 : _a2.blur();
    }
    const actionViewItem = this.focusedItem !== void 0 ? this.viewItems[this.focusedItem] : void 0;
    if (actionViewItem) {
      let focusItem = true;
      if (!isFunction(actionViewItem.focus)) {
        focusItem = false;
      }
      if (this.options.focusOnlyEnabledItems && isFunction(actionViewItem.isEnabled) && !actionViewItem.isEnabled()) {
        focusItem = false;
      }
      if (actionViewItem.action.id === Separator.ID) {
        focusItem = false;
      }
      if (!focusItem) {
        this.actionsList.focus({ preventScroll });
        this.previouslyFocusedItem = void 0;
      } else if (forceFocus || this.previouslyFocusedItem !== this.focusedItem) {
        actionViewItem.focus(fromRight);
        this.previouslyFocusedItem = this.focusedItem;
      }
      if (focusItem) {
        (_b2 = actionViewItem.showHover) === null || _b2 === void 0 ? void 0 : _b2.call(actionViewItem);
      }
    }
  }
  doTrigger(event) {
    if (typeof this.focusedItem === "undefined") {
      return;
    }
    const actionViewItem = this.viewItems[this.focusedItem];
    if (actionViewItem instanceof BaseActionViewItem) {
      const context = actionViewItem._context === null || actionViewItem._context === void 0 ? event : actionViewItem._context;
      this.run(actionViewItem._action, context);
    }
  }
  async run(action, context) {
    await this._actionRunner.run(action, context);
  }
  dispose() {
    this._context = void 0;
    this.viewItems = dispose(this.viewItems);
    this.getContainer().remove();
    super.dispose();
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/menu/menu.js
init_actions();
init_async();
init_codicons();
init_themables();
init_iconLabels2();
init_lifecycle();
init_platform();
init_strings();
var MENU_MNEMONIC_REGEX = /\(&([^\s&])\)|(^|[^&])&([^\s&])/;
var MENU_ESCAPED_MNEMONIC_REGEX = /(&amp;)?(&amp;)([^\s&])/g;
var Direction;
(function(Direction2) {
  Direction2[Direction2["Right"] = 0] = "Right";
  Direction2[Direction2["Left"] = 1] = "Left";
})(Direction || (Direction = {}));
var Menu = class _Menu extends ActionBar {
  constructor(container, actions, options2, menuStyles) {
    container.classList.add("monaco-menu-container");
    container.setAttribute("role", "presentation");
    const menuElement = document.createElement("div");
    menuElement.classList.add("monaco-menu");
    menuElement.setAttribute("role", "presentation");
    super(menuElement, {
      orientation: 1,
      actionViewItemProvider: (action) => this.doGetActionViewItem(action, options2, parentData),
      context: options2.context,
      actionRunner: options2.actionRunner,
      ariaLabel: options2.ariaLabel,
      ariaRole: "menu",
      focusOnlyEnabledItems: true,
      triggerKeys: { keys: [3, ...isMacintosh || isLinux ? [
        10
        /* KeyCode.Space */
      ] : []], keyDown: true }
    });
    this.menuStyles = menuStyles;
    this.menuElement = menuElement;
    this.actionsList.tabIndex = 0;
    this.initializeOrUpdateStyleSheet(container, menuStyles);
    this._register(Gesture.addTarget(menuElement));
    this._register(addDisposableListener(menuElement, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(
        2
        /* KeyCode.Tab */
      )) {
        e.preventDefault();
      }
    }));
    if (options2.enableMnemonics) {
      this._register(addDisposableListener(menuElement, EventType.KEY_DOWN, (e) => {
        const key = e.key.toLocaleLowerCase();
        if (this.mnemonics.has(key)) {
          EventHelper.stop(e, true);
          const actions2 = this.mnemonics.get(key);
          if (actions2.length === 1) {
            if (actions2[0] instanceof SubmenuMenuActionViewItem && actions2[0].container) {
              this.focusItemByElement(actions2[0].container);
            }
            actions2[0].onClick(e);
          }
          if (actions2.length > 1) {
            const action = actions2.shift();
            if (action && action.container) {
              this.focusItemByElement(action.container);
              actions2.push(action);
            }
            this.mnemonics.set(key, actions2);
          }
        }
      }));
    }
    if (isLinux) {
      this._register(addDisposableListener(menuElement, EventType.KEY_DOWN, (e) => {
        const event = new StandardKeyboardEvent(e);
        if (event.equals(
          14
          /* KeyCode.Home */
        ) || event.equals(
          11
          /* KeyCode.PageUp */
        )) {
          this.focusedItem = this.viewItems.length - 1;
          this.focusNext();
          EventHelper.stop(e, true);
        } else if (event.equals(
          13
          /* KeyCode.End */
        ) || event.equals(
          12
          /* KeyCode.PageDown */
        )) {
          this.focusedItem = 0;
          this.focusPrevious();
          EventHelper.stop(e, true);
        }
      }));
    }
    this._register(addDisposableListener(this.domNode, EventType.MOUSE_OUT, (e) => {
      const relatedTarget = e.relatedTarget;
      if (!isAncestor(relatedTarget, this.domNode)) {
        this.focusedItem = void 0;
        this.updateFocus();
        e.stopPropagation();
      }
    }));
    this._register(addDisposableListener(this.actionsList, EventType.MOUSE_OVER, (e) => {
      let target = e.target;
      if (!target || !isAncestor(target, this.actionsList) || target === this.actionsList) {
        return;
      }
      while (target.parentElement !== this.actionsList && target.parentElement !== null) {
        target = target.parentElement;
      }
      if (target.classList.contains("action-item")) {
        const lastFocusedItem = this.focusedItem;
        this.setFocusedItem(target);
        if (lastFocusedItem !== this.focusedItem) {
          this.updateFocus();
        }
      }
    }));
    this._register(Gesture.addTarget(this.actionsList));
    this._register(addDisposableListener(this.actionsList, EventType2.Tap, (e) => {
      let target = e.initialTarget;
      if (!target || !isAncestor(target, this.actionsList) || target === this.actionsList) {
        return;
      }
      while (target.parentElement !== this.actionsList && target.parentElement !== null) {
        target = target.parentElement;
      }
      if (target.classList.contains("action-item")) {
        const lastFocusedItem = this.focusedItem;
        this.setFocusedItem(target);
        if (lastFocusedItem !== this.focusedItem) {
          this.updateFocus();
        }
      }
    }));
    const parentData = {
      parent: this
    };
    this.mnemonics = /* @__PURE__ */ new Map();
    this.scrollableElement = this._register(new DomScrollableElement(menuElement, {
      alwaysConsumeMouseWheel: true,
      horizontal: 2,
      vertical: 3,
      verticalScrollbarSize: 7,
      handleMouseWheel: true,
      useShadows: true
    }));
    const scrollElement = this.scrollableElement.getDomNode();
    scrollElement.style.position = "";
    this.styleScrollElement(scrollElement, menuStyles);
    this._register(addDisposableListener(menuElement, EventType2.Change, (e) => {
      EventHelper.stop(e, true);
      const scrollTop = this.scrollableElement.getScrollPosition().scrollTop;
      this.scrollableElement.setScrollPosition({ scrollTop: scrollTop - e.translationY });
    }));
    this._register(addDisposableListener(scrollElement, EventType.MOUSE_UP, (e) => {
      e.preventDefault();
    }));
    const window = getWindow(container);
    menuElement.style.maxHeight = `${Math.max(10, window.innerHeight - container.getBoundingClientRect().top - 35)}px`;
    actions = actions.filter((a, idx) => {
      var _a2;
      if ((_a2 = options2.submenuIds) === null || _a2 === void 0 ? void 0 : _a2.has(a.id)) {
        console.warn(`Found submenu cycle: ${a.id}`);
        return false;
      }
      if (a instanceof Separator) {
        if (idx === actions.length - 1 || idx === 0) {
          return false;
        }
        const prevAction = actions[idx - 1];
        if (prevAction instanceof Separator) {
          return false;
        }
      }
      return true;
    });
    this.push(actions, { icon: true, label: true, isMenu: true });
    container.appendChild(this.scrollableElement.getDomNode());
    this.scrollableElement.scanDomNode();
    this.viewItems.filter((item) => !(item instanceof MenuSeparatorActionViewItem)).forEach((item, index, array) => {
      item.updatePositionInSet(index + 1, array.length);
    });
  }
  initializeOrUpdateStyleSheet(container, style) {
    if (!this.styleSheet) {
      if (isInShadowDOM(container)) {
        this.styleSheet = createStyleSheet(container);
      } else {
        if (!_Menu.globalStyleSheet) {
          _Menu.globalStyleSheet = createStyleSheet();
        }
        this.styleSheet = _Menu.globalStyleSheet;
      }
    }
    this.styleSheet.textContent = getMenuWidgetCSS(style, isInShadowDOM(container));
  }
  styleScrollElement(scrollElement, style) {
    var _a2, _b2;
    const fgColor = (_a2 = style.foregroundColor) !== null && _a2 !== void 0 ? _a2 : "";
    const bgColor = (_b2 = style.backgroundColor) !== null && _b2 !== void 0 ? _b2 : "";
    const border = style.borderColor ? `1px solid ${style.borderColor}` : "";
    const borderRadius = "5px";
    const shadow = style.shadowColor ? `0 2px 8px ${style.shadowColor}` : "";
    scrollElement.style.outline = border;
    scrollElement.style.borderRadius = borderRadius;
    scrollElement.style.color = fgColor;
    scrollElement.style.backgroundColor = bgColor;
    scrollElement.style.boxShadow = shadow;
  }
  getContainer() {
    return this.scrollableElement.getDomNode();
  }
  get onScroll() {
    return this.scrollableElement.onScroll;
  }
  focusItemByElement(element) {
    const lastFocusedItem = this.focusedItem;
    this.setFocusedItem(element);
    if (lastFocusedItem !== this.focusedItem) {
      this.updateFocus();
    }
  }
  setFocusedItem(element) {
    for (let i = 0; i < this.actionsList.children.length; i++) {
      const elem = this.actionsList.children[i];
      if (element === elem) {
        this.focusedItem = i;
        break;
      }
    }
  }
  updateFocus(fromRight) {
    super.updateFocus(fromRight, true, true);
    if (typeof this.focusedItem !== "undefined") {
      this.scrollableElement.setScrollPosition({
        scrollTop: Math.round(this.menuElement.scrollTop)
      });
    }
  }
  doGetActionViewItem(action, options2, parentData) {
    if (action instanceof Separator) {
      return new MenuSeparatorActionViewItem(options2.context, action, { icon: true }, this.menuStyles);
    } else if (action instanceof SubmenuAction) {
      const menuActionViewItem = new SubmenuMenuActionViewItem(action, action.actions, parentData, { ...options2, submenuIds: /* @__PURE__ */ new Set([...options2.submenuIds || [], action.id]) }, this.menuStyles);
      if (options2.enableMnemonics) {
        const mnemonic = menuActionViewItem.getMnemonic();
        if (mnemonic && menuActionViewItem.isEnabled()) {
          let actionViewItems = [];
          if (this.mnemonics.has(mnemonic)) {
            actionViewItems = this.mnemonics.get(mnemonic);
          }
          actionViewItems.push(menuActionViewItem);
          this.mnemonics.set(mnemonic, actionViewItems);
        }
      }
      return menuActionViewItem;
    } else {
      const menuItemOptions = { enableMnemonics: options2.enableMnemonics, useEventAsContext: options2.useEventAsContext };
      if (options2.getKeyBinding) {
        const keybinding = options2.getKeyBinding(action);
        if (keybinding) {
          const keybindingLabel = keybinding.getLabel();
          if (keybindingLabel) {
            menuItemOptions.keybinding = keybindingLabel;
          }
        }
      }
      const menuActionViewItem = new BaseMenuActionViewItem(options2.context, action, menuItemOptions, this.menuStyles);
      if (options2.enableMnemonics) {
        const mnemonic = menuActionViewItem.getMnemonic();
        if (mnemonic && menuActionViewItem.isEnabled()) {
          let actionViewItems = [];
          if (this.mnemonics.has(mnemonic)) {
            actionViewItems = this.mnemonics.get(mnemonic);
          }
          actionViewItems.push(menuActionViewItem);
          this.mnemonics.set(mnemonic, actionViewItems);
        }
      }
      return menuActionViewItem;
    }
  }
};
var BaseMenuActionViewItem = class extends BaseActionViewItem {
  constructor(ctx, action, options2, menuStyle) {
    options2.isMenu = true;
    super(action, action, options2);
    this.menuStyle = menuStyle;
    this.options = options2;
    this.options.icon = options2.icon !== void 0 ? options2.icon : false;
    this.options.label = options2.label !== void 0 ? options2.label : true;
    this.cssClass = "";
    if (this.options.label && options2.enableMnemonics) {
      const label = this.action.label;
      if (label) {
        const matches = MENU_MNEMONIC_REGEX.exec(label);
        if (matches) {
          this.mnemonic = (!!matches[1] ? matches[1] : matches[3]).toLocaleLowerCase();
        }
      }
    }
    this.runOnceToEnableMouseUp = new RunOnceScheduler(() => {
      if (!this.element) {
        return;
      }
      this._register(addDisposableListener(this.element, EventType.MOUSE_UP, (e) => {
        EventHelper.stop(e, true);
        if (isFirefox2) {
          const mouseEvent = new StandardMouseEvent(getWindow(this.element), e);
          if (mouseEvent.rightButton) {
            return;
          }
          this.onClick(e);
        } else {
          setTimeout(() => {
            this.onClick(e);
          }, 0);
        }
      }));
      this._register(addDisposableListener(this.element, EventType.CONTEXT_MENU, (e) => {
        EventHelper.stop(e, true);
      }));
    }, 100);
    this._register(this.runOnceToEnableMouseUp);
  }
  render(container) {
    super.render(container);
    if (!this.element) {
      return;
    }
    this.container = container;
    this.item = append(this.element, $("a.action-menu-item"));
    if (this._action.id === Separator.ID) {
      this.item.setAttribute("role", "presentation");
    } else {
      this.item.setAttribute("role", "menuitem");
      if (this.mnemonic) {
        this.item.setAttribute("aria-keyshortcuts", `${this.mnemonic}`);
      }
    }
    this.check = append(this.item, $("span.menu-item-check" + ThemeIcon.asCSSSelector(Codicon.menuSelection)));
    this.check.setAttribute("role", "none");
    this.label = append(this.item, $("span.action-label"));
    if (this.options.label && this.options.keybinding) {
      append(this.item, $("span.keybinding")).textContent = this.options.keybinding;
    }
    this.runOnceToEnableMouseUp.schedule();
    this.updateClass();
    this.updateLabel();
    this.updateTooltip();
    this.updateEnabled();
    this.updateChecked();
    this.applyStyle();
  }
  blur() {
    super.blur();
    this.applyStyle();
  }
  focus() {
    var _a2;
    super.focus();
    (_a2 = this.item) === null || _a2 === void 0 ? void 0 : _a2.focus();
    this.applyStyle();
  }
  updatePositionInSet(pos, setSize) {
    if (this.item) {
      this.item.setAttribute("aria-posinset", `${pos}`);
      this.item.setAttribute("aria-setsize", `${setSize}`);
    }
  }
  updateLabel() {
    var _a2;
    if (!this.label) {
      return;
    }
    if (this.options.label) {
      clearNode(this.label);
      let label = stripIcons(this.action.label);
      if (label) {
        const cleanLabel = cleanMnemonic(label);
        if (!this.options.enableMnemonics) {
          label = cleanLabel;
        }
        this.label.setAttribute("aria-label", cleanLabel.replace(/&&/g, "&"));
        const matches = MENU_MNEMONIC_REGEX.exec(label);
        if (matches) {
          label = escape(label);
          MENU_ESCAPED_MNEMONIC_REGEX.lastIndex = 0;
          let escMatch = MENU_ESCAPED_MNEMONIC_REGEX.exec(label);
          while (escMatch && escMatch[1]) {
            escMatch = MENU_ESCAPED_MNEMONIC_REGEX.exec(label);
          }
          const replaceDoubleEscapes = (str) => str.replace(/&amp;&amp;/g, "&amp;");
          if (escMatch) {
            this.label.append(ltrim(replaceDoubleEscapes(label.substr(0, escMatch.index)), " "), $("u", { "aria-hidden": "true" }, escMatch[3]), rtrim(replaceDoubleEscapes(label.substr(escMatch.index + escMatch[0].length)), " "));
          } else {
            this.label.innerText = replaceDoubleEscapes(label).trim();
          }
          (_a2 = this.item) === null || _a2 === void 0 ? void 0 : _a2.setAttribute("aria-keyshortcuts", (!!matches[1] ? matches[1] : matches[3]).toLocaleLowerCase());
        } else {
          this.label.innerText = label.replace(/&&/g, "&").trim();
        }
      }
    }
  }
  updateTooltip() {
  }
  updateClass() {
    if (this.cssClass && this.item) {
      this.item.classList.remove(...this.cssClass.split(" "));
    }
    if (this.options.icon && this.label) {
      this.cssClass = this.action.class || "";
      this.label.classList.add("icon");
      if (this.cssClass) {
        this.label.classList.add(...this.cssClass.split(" "));
      }
      this.updateEnabled();
    } else if (this.label) {
      this.label.classList.remove("icon");
    }
  }
  updateEnabled() {
    if (this.action.enabled) {
      if (this.element) {
        this.element.classList.remove("disabled");
        this.element.removeAttribute("aria-disabled");
      }
      if (this.item) {
        this.item.classList.remove("disabled");
        this.item.removeAttribute("aria-disabled");
        this.item.tabIndex = 0;
      }
    } else {
      if (this.element) {
        this.element.classList.add("disabled");
        this.element.setAttribute("aria-disabled", "true");
      }
      if (this.item) {
        this.item.classList.add("disabled");
        this.item.setAttribute("aria-disabled", "true");
      }
    }
  }
  updateChecked() {
    if (!this.item) {
      return;
    }
    const checked = this.action.checked;
    this.item.classList.toggle("checked", !!checked);
    if (checked !== void 0) {
      this.item.setAttribute("role", "menuitemcheckbox");
      this.item.setAttribute("aria-checked", checked ? "true" : "false");
    } else {
      this.item.setAttribute("role", "menuitem");
      this.item.setAttribute("aria-checked", "");
    }
  }
  getMnemonic() {
    return this.mnemonic;
  }
  applyStyle() {
    const isSelected = this.element && this.element.classList.contains("focused");
    const fgColor = isSelected && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
    const bgColor = isSelected && this.menuStyle.selectionBackgroundColor ? this.menuStyle.selectionBackgroundColor : void 0;
    const outline = isSelected && this.menuStyle.selectionBorderColor ? `1px solid ${this.menuStyle.selectionBorderColor}` : "";
    const outlineOffset = isSelected && this.menuStyle.selectionBorderColor ? `-1px` : "";
    if (this.item) {
      this.item.style.color = fgColor !== null && fgColor !== void 0 ? fgColor : "";
      this.item.style.backgroundColor = bgColor !== null && bgColor !== void 0 ? bgColor : "";
      this.item.style.outline = outline;
      this.item.style.outlineOffset = outlineOffset;
    }
    if (this.check) {
      this.check.style.color = fgColor !== null && fgColor !== void 0 ? fgColor : "";
    }
  }
};
var SubmenuMenuActionViewItem = class extends BaseMenuActionViewItem {
  constructor(action, submenuActions, parentData, submenuOptions, menuStyles) {
    super(action, action, submenuOptions, menuStyles);
    this.submenuActions = submenuActions;
    this.parentData = parentData;
    this.submenuOptions = submenuOptions;
    this.mysubmenu = null;
    this.submenuDisposables = this._register(new DisposableStore());
    this.mouseOver = false;
    this.expandDirection = submenuOptions && submenuOptions.expandDirection !== void 0 ? submenuOptions.expandDirection : Direction.Right;
    this.showScheduler = new RunOnceScheduler(() => {
      if (this.mouseOver) {
        this.cleanupExistingSubmenu(false);
        this.createSubmenu(false);
      }
    }, 250);
    this.hideScheduler = new RunOnceScheduler(() => {
      if (this.element && (!isAncestor(getActiveElement(), this.element) && this.parentData.submenu === this.mysubmenu)) {
        this.parentData.parent.focus(false);
        this.cleanupExistingSubmenu(true);
      }
    }, 750);
  }
  render(container) {
    super.render(container);
    if (!this.element) {
      return;
    }
    if (this.item) {
      this.item.classList.add("monaco-submenu-item");
      this.item.tabIndex = 0;
      this.item.setAttribute("aria-haspopup", "true");
      this.updateAriaExpanded("false");
      this.submenuIndicator = append(this.item, $("span.submenu-indicator" + ThemeIcon.asCSSSelector(Codicon.menuSubmenu)));
      this.submenuIndicator.setAttribute("aria-hidden", "true");
    }
    this._register(addDisposableListener(this.element, EventType.KEY_UP, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(
        17
        /* KeyCode.RightArrow */
      ) || event.equals(
        3
        /* KeyCode.Enter */
      )) {
        EventHelper.stop(e, true);
        this.createSubmenu(true);
      }
    }));
    this._register(addDisposableListener(this.element, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (getActiveElement() === this.item) {
        if (event.equals(
          17
          /* KeyCode.RightArrow */
        ) || event.equals(
          3
          /* KeyCode.Enter */
        )) {
          EventHelper.stop(e, true);
        }
      }
    }));
    this._register(addDisposableListener(this.element, EventType.MOUSE_OVER, (e) => {
      if (!this.mouseOver) {
        this.mouseOver = true;
        this.showScheduler.schedule();
      }
    }));
    this._register(addDisposableListener(this.element, EventType.MOUSE_LEAVE, (e) => {
      this.mouseOver = false;
    }));
    this._register(addDisposableListener(this.element, EventType.FOCUS_OUT, (e) => {
      if (this.element && !isAncestor(getActiveElement(), this.element)) {
        this.hideScheduler.schedule();
      }
    }));
    this._register(this.parentData.parent.onScroll(() => {
      if (this.parentData.submenu === this.mysubmenu) {
        this.parentData.parent.focus(false);
        this.cleanupExistingSubmenu(true);
      }
    }));
  }
  updateEnabled() {
  }
  onClick(e) {
    EventHelper.stop(e, true);
    this.cleanupExistingSubmenu(false);
    this.createSubmenu(true);
  }
  cleanupExistingSubmenu(force) {
    if (this.parentData.submenu && (force || this.parentData.submenu !== this.mysubmenu)) {
      try {
        this.parentData.submenu.dispose();
      } catch (_a2) {
      }
      this.parentData.submenu = void 0;
      this.updateAriaExpanded("false");
      if (this.submenuContainer) {
        this.submenuDisposables.clear();
        this.submenuContainer = void 0;
      }
    }
  }
  calculateSubmenuMenuLayout(windowDimensions, submenu, entry, expandDirection) {
    const ret = { top: 0, left: 0 };
    ret.left = layout(windowDimensions.width, submenu.width, { position: expandDirection === Direction.Right ? 0 : 1, offset: entry.left, size: entry.width });
    if (ret.left >= entry.left && ret.left < entry.left + entry.width) {
      if (entry.left + 10 + submenu.width <= windowDimensions.width) {
        ret.left = entry.left + 10;
      }
      entry.top += 10;
      entry.height = 0;
    }
    ret.top = layout(windowDimensions.height, submenu.height, { position: 0, offset: entry.top, size: 0 });
    if (ret.top + submenu.height === entry.top && ret.top + entry.height + submenu.height <= windowDimensions.height) {
      ret.top += entry.height;
    }
    return ret;
  }
  createSubmenu(selectFirstItem = true) {
    if (!this.element) {
      return;
    }
    if (!this.parentData.submenu) {
      this.updateAriaExpanded("true");
      this.submenuContainer = append(this.element, $("div.monaco-submenu"));
      this.submenuContainer.classList.add("menubar-menu-items-holder", "context-view");
      const computedStyles = getWindow(this.parentData.parent.domNode).getComputedStyle(this.parentData.parent.domNode);
      const paddingTop = parseFloat(computedStyles.paddingTop || "0") || 0;
      this.submenuContainer.style.zIndex = "1";
      this.submenuContainer.style.position = "fixed";
      this.submenuContainer.style.top = "0";
      this.submenuContainer.style.left = "0";
      this.parentData.submenu = new Menu(this.submenuContainer, this.submenuActions.length ? this.submenuActions : [new EmptySubmenuAction()], this.submenuOptions, this.menuStyle);
      const entryBox = this.element.getBoundingClientRect();
      const entryBoxUpdated = {
        top: entryBox.top - paddingTop,
        left: entryBox.left,
        height: entryBox.height + 2 * paddingTop,
        width: entryBox.width
      };
      const viewBox = this.submenuContainer.getBoundingClientRect();
      const window = getWindow(this.element);
      const { top, left } = this.calculateSubmenuMenuLayout(new Dimension(window.innerWidth, window.innerHeight), Dimension.lift(viewBox), entryBoxUpdated, this.expandDirection);
      this.submenuContainer.style.left = `${left - viewBox.left}px`;
      this.submenuContainer.style.top = `${top - viewBox.top}px`;
      this.submenuDisposables.add(addDisposableListener(this.submenuContainer, EventType.KEY_UP, (e) => {
        const event = new StandardKeyboardEvent(e);
        if (event.equals(
          15
          /* KeyCode.LeftArrow */
        )) {
          EventHelper.stop(e, true);
          this.parentData.parent.focus();
          this.cleanupExistingSubmenu(true);
        }
      }));
      this.submenuDisposables.add(addDisposableListener(this.submenuContainer, EventType.KEY_DOWN, (e) => {
        const event = new StandardKeyboardEvent(e);
        if (event.equals(
          15
          /* KeyCode.LeftArrow */
        )) {
          EventHelper.stop(e, true);
        }
      }));
      this.submenuDisposables.add(this.parentData.submenu.onDidCancel(() => {
        this.parentData.parent.focus();
        this.cleanupExistingSubmenu(true);
      }));
      this.parentData.submenu.focus(selectFirstItem);
      this.mysubmenu = this.parentData.submenu;
    } else {
      this.parentData.submenu.focus(false);
    }
  }
  updateAriaExpanded(value) {
    var _a2;
    if (this.item) {
      (_a2 = this.item) === null || _a2 === void 0 ? void 0 : _a2.setAttribute("aria-expanded", value);
    }
  }
  applyStyle() {
    super.applyStyle();
    const isSelected = this.element && this.element.classList.contains("focused");
    const fgColor = isSelected && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
    if (this.submenuIndicator) {
      this.submenuIndicator.style.color = fgColor !== null && fgColor !== void 0 ? fgColor : "";
    }
  }
  dispose() {
    super.dispose();
    this.hideScheduler.dispose();
    if (this.mysubmenu) {
      this.mysubmenu.dispose();
      this.mysubmenu = null;
    }
    if (this.submenuContainer) {
      this.submenuContainer = void 0;
    }
  }
};
var MenuSeparatorActionViewItem = class extends ActionViewItem {
  constructor(context, action, options2, menuStyles) {
    super(context, action, options2);
    this.menuStyles = menuStyles;
  }
  render(container) {
    super.render(container);
    if (this.label) {
      this.label.style.borderBottomColor = this.menuStyles.separatorColor ? `${this.menuStyles.separatorColor}` : "";
    }
  }
};
function cleanMnemonic(label) {
  const regex = MENU_MNEMONIC_REGEX;
  const matches = regex.exec(label);
  if (!matches) {
    return label;
  }
  const mnemonicInText = !matches[1];
  return label.replace(regex, mnemonicInText ? "$2$3" : "").trim();
}
function formatRule(c) {
  const fontCharacter = getCodiconFontCharacters()[c.id];
  return `.codicon-${c.id}:before { content: '\\${fontCharacter.toString(16)}'; }`;
}
function getMenuWidgetCSS(style, isForShadowDom) {
  let result = (
    /* css */
    `
.monaco-menu {
	font-size: 13px;
	border-radius: 5px;
	min-width: 160px;
}

${formatRule(Codicon.menuSelection)}
${formatRule(Codicon.menuSubmenu)}

.monaco-menu .monaco-action-bar {
	text-align: right;
	overflow: hidden;
	white-space: nowrap;
}

.monaco-menu .monaco-action-bar .actions-container {
	display: flex;
	margin: 0 auto;
	padding: 0;
	width: 100%;
	justify-content: flex-end;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: inline-block;
}

.monaco-menu .monaco-action-bar.reverse .actions-container {
	flex-direction: row-reverse;
}

.monaco-menu .monaco-action-bar .action-item {
	cursor: pointer;
	display: inline-block;
	transition: transform 50ms ease;
	position: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */
}

.monaco-menu .monaco-action-bar .action-item.disabled {
	cursor: default;
}

.monaco-menu .monaco-action-bar .action-item .icon,
.monaco-menu .monaco-action-bar .action-item .codicon {
	display: inline-block;
}

.monaco-menu .monaco-action-bar .action-item .codicon {
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar .action-label {
	font-size: 11px;
	margin-right: 4px;
}

.monaco-menu .monaco-action-bar .action-item.disabled .action-label,
.monaco-menu .monaco-action-bar .action-item.disabled .action-label:hover {
	color: var(--vscode-disabledForeground);
}

/* Vertical actions */

.monaco-menu .monaco-action-bar.vertical {
	text-align: left;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	display: block;
	border-bottom: 1px solid var(--vscode-menu-separatorBackground);
	padding-top: 1px;
	padding: 30px;
}

.monaco-menu .secondary-actions .monaco-action-bar .action-label {
	margin-left: 6px;
}

/* Action Items */
.monaco-menu .monaco-action-bar .action-item.select-container {
	overflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */
	flex: 1;
	max-width: 170px;
	min-width: 60px;
	display: flex;
	align-items: center;
	justify-content: center;
	margin-right: 10px;
}

.monaco-menu .monaco-action-bar.vertical {
	margin-left: 0;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	padding: 0;
	transform: none;
	display: flex;
}

.monaco-menu .monaco-action-bar.vertical .action-item.active {
	transform: none;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	flex: 1 1 auto;
	display: flex;
	height: 2em;
	align-items: center;
	position: relative;
	margin: 0 4px;
	border-radius: 4px;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item:hover .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-menu-item:focus .keybinding {
	opacity: unset;
}

.monaco-menu .monaco-action-bar.vertical .action-label {
	flex: 1 1 auto;
	text-decoration: none;
	padding: 0 1em;
	background: none;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .keybinding,
.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	display: inline-block;
	flex: 2 1 auto;
	padding: 0 1em;
	text-align: right;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon {
	font-size: 16px !important;
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon::before {
	margin-left: auto;
	margin-right: -20px;
}

.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-item.disabled .submenu-indicator {
	opacity: 0.4;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {
	display: inline-block;
	box-sizing: border-box;
	margin: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	position: static;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .action-item .monaco-submenu {
	position: absolute;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	width: 100%;
	height: 0px !important;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {
	padding: 0.7em 1em 0.1em 1em;
	font-weight: bold;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label:hover {
	color: inherit;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	position: absolute;
	visibility: hidden;
	width: 1em;
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item.checked .menu-item-check {
	visibility: visible;
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Context Menu */

.context-view.monaco-menu-container {
	outline: 0;
	border: none;
	animation: fadeIn 0.083s linear;
	-webkit-app-region: no-drag;
}

.context-view.monaco-menu-container :focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical:focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical :focus {
	outline: 0;
}

.hc-black .context-view.monaco-menu-container,
.hc-light .context-view.monaco-menu-container,
:host-context(.hc-black) .context-view.monaco-menu-container,
:host-context(.hc-light) .context-view.monaco-menu-container {
	box-shadow: none;
}

.hc-black .monaco-menu .monaco-action-bar.vertical .action-item.focused,
.hc-light .monaco-menu .monaco-action-bar.vertical .action-item.focused,
:host-context(.hc-black) .monaco-menu .monaco-action-bar.vertical .action-item.focused,
:host-context(.hc-light) .monaco-menu .monaco-action-bar.vertical .action-item.focused {
	background: none;
}

/* Vertical Action Bar Styles */

.monaco-menu .monaco-action-bar.vertical {
	padding: 4px 0;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	height: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator),
.monaco-menu .monaco-action-bar.vertical .keybinding {
	font-size: inherit;
	padding: 0 2em;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	font-size: inherit;
	width: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	font-size: inherit;
	margin: 5px 0 !important;
	padding: 0;
	border-radius: 0;
}

.linux .monaco-menu .monaco-action-bar.vertical .action-label.separator,
:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .action-label.separator {
	margin-left: 0;
	margin-right: 0;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	font-size: 60%;
	padding: 0 1.8em;
}

.linux .monaco-menu .monaco-action-bar.vertical .submenu-indicator,
:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
	mask-size: 10px 10px;
	-webkit-mask-size: 10px 10px;
}

.monaco-menu .action-item {
	cursor: default;
}`
  );
  if (isForShadowDom) {
    result += `
			/* Arrows */
			.monaco-scrollable-element > .scrollbar > .scra {
				cursor: pointer;
				font-size: 11px !important;
			}

			.monaco-scrollable-element > .visible {
				opacity: 1;

				/* Background rule added for IE9 - to allow clicks on dom node */
				background:rgba(0,0,0,0);

				transition: opacity 100ms linear;
			}
			.monaco-scrollable-element > .invisible {
				opacity: 0;
				pointer-events: none;
			}
			.monaco-scrollable-element > .invisible.fade {
				transition: opacity 800ms linear;
			}

			/* Scrollable Content Inset Shadow */
			.monaco-scrollable-element > .shadow {
				position: absolute;
				display: none;
			}
			.monaco-scrollable-element > .shadow.top {
				display: block;
				top: 0;
				left: 3px;
				height: 3px;
				width: 100%;
			}
			.monaco-scrollable-element > .shadow.left {
				display: block;
				top: 3px;
				left: 0;
				height: 100%;
				width: 3px;
			}
			.monaco-scrollable-element > .shadow.top-left-corner {
				display: block;
				top: 0;
				left: 0;
				height: 3px;
				width: 3px;
			}
		`;
    const scrollbarShadowColor = style.scrollbarShadow;
    if (scrollbarShadowColor) {
      result += `
				.monaco-scrollable-element > .shadow.top {
					box-shadow: ${scrollbarShadowColor} 0 6px 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.left {
					box-shadow: ${scrollbarShadowColor} 6px 0 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.top.left {
					box-shadow: ${scrollbarShadowColor} 6px 6px 6px -6px inset;
				}
			`;
    }
    const scrollbarSliderBackgroundColor = style.scrollbarSliderBackground;
    if (scrollbarSliderBackgroundColor) {
      result += `
				.monaco-scrollable-element > .scrollbar > .slider {
					background: ${scrollbarSliderBackgroundColor};
				}
			`;
    }
    const scrollbarSliderHoverBackgroundColor = style.scrollbarSliderHoverBackground;
    if (scrollbarSliderHoverBackgroundColor) {
      result += `
				.monaco-scrollable-element > .scrollbar > .slider:hover {
					background: ${scrollbarSliderHoverBackgroundColor};
				}
			`;
    }
    const scrollbarSliderActiveBackgroundColor = style.scrollbarSliderActiveBackground;
    if (scrollbarSliderActiveBackgroundColor) {
      result += `
				.monaco-scrollable-element > .scrollbar > .slider.active {
					background: ${scrollbarSliderActiveBackgroundColor};
				}
			`;
    }
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextMenuHandler.js
init_actions();
init_errors();
init_lifecycle();
var ContextMenuHandler = class {
  constructor(contextViewService, telemetryService, notificationService, keybindingService) {
    this.contextViewService = contextViewService;
    this.telemetryService = telemetryService;
    this.notificationService = notificationService;
    this.keybindingService = keybindingService;
    this.focusToReturn = null;
    this.lastContainer = null;
    this.block = null;
    this.blockDisposable = null;
    this.options = { blockMouse: true };
  }
  configure(options2) {
    this.options = options2;
  }
  showContextMenu(delegate) {
    const actions = delegate.getActions();
    if (!actions.length) {
      return;
    }
    this.focusToReturn = getActiveElement();
    let menu;
    const shadowRootElement = delegate.domForShadowRoot instanceof HTMLElement ? delegate.domForShadowRoot : void 0;
    this.contextViewService.showContextView({
      getAnchor: () => delegate.getAnchor(),
      canRelayout: false,
      anchorAlignment: delegate.anchorAlignment,
      anchorAxisAlignment: delegate.anchorAxisAlignment,
      render: (container) => {
        var _a2;
        this.lastContainer = container;
        const className = delegate.getMenuClassName ? delegate.getMenuClassName() : "";
        if (className) {
          container.className += " " + className;
        }
        if (this.options.blockMouse) {
          this.block = container.appendChild($(".context-view-block"));
          this.block.style.position = "fixed";
          this.block.style.cursor = "initial";
          this.block.style.left = "0";
          this.block.style.top = "0";
          this.block.style.width = "100%";
          this.block.style.height = "100%";
          this.block.style.zIndex = "-1";
          (_a2 = this.blockDisposable) === null || _a2 === void 0 ? void 0 : _a2.dispose();
          this.blockDisposable = addDisposableListener(this.block, EventType.MOUSE_DOWN, (e) => e.stopPropagation());
        }
        const menuDisposables = new DisposableStore();
        const actionRunner = delegate.actionRunner || new ActionRunner();
        actionRunner.onWillRun((evt) => this.onActionRun(evt, !delegate.skipTelemetry), this, menuDisposables);
        actionRunner.onDidRun(this.onDidActionRun, this, menuDisposables);
        menu = new Menu(container, actions, {
          actionViewItemProvider: delegate.getActionViewItem,
          context: delegate.getActionsContext ? delegate.getActionsContext() : null,
          actionRunner,
          getKeyBinding: delegate.getKeyBinding ? delegate.getKeyBinding : (action) => this.keybindingService.lookupKeybinding(action.id)
        }, defaultMenuStyles);
        menu.onDidCancel(() => this.contextViewService.hideContextView(true), null, menuDisposables);
        menu.onDidBlur(() => this.contextViewService.hideContextView(true), null, menuDisposables);
        const targetWindow = getWindow(container);
        menuDisposables.add(addDisposableListener(targetWindow, EventType.BLUR, () => this.contextViewService.hideContextView(true)));
        menuDisposables.add(addDisposableListener(targetWindow, EventType.MOUSE_DOWN, (e) => {
          if (e.defaultPrevented) {
            return;
          }
          const event = new StandardMouseEvent(targetWindow, e);
          let element = event.target;
          if (event.rightButton) {
            return;
          }
          while (element) {
            if (element === container) {
              return;
            }
            element = element.parentElement;
          }
          this.contextViewService.hideContextView(true);
        }));
        return combinedDisposable(menuDisposables, menu);
      },
      focus: () => {
        menu === null || menu === void 0 ? void 0 : menu.focus(!!delegate.autoSelectFirstItem);
      },
      onHide: (didCancel) => {
        var _a2, _b2, _c;
        (_a2 = delegate.onHide) === null || _a2 === void 0 ? void 0 : _a2.call(delegate, !!didCancel);
        if (this.block) {
          this.block.remove();
          this.block = null;
        }
        (_b2 = this.blockDisposable) === null || _b2 === void 0 ? void 0 : _b2.dispose();
        this.blockDisposable = null;
        if (!!this.lastContainer && (getActiveElement() === this.lastContainer || isAncestor(getActiveElement(), this.lastContainer))) {
          (_c = this.focusToReturn) === null || _c === void 0 ? void 0 : _c.focus();
        }
        this.lastContainer = null;
      }
    }, shadowRootElement, !!shadowRootElement);
  }
  onActionRun(e, logTelemetry) {
    if (logTelemetry) {
      this.telemetryService.publicLog2("workbenchActionExecuted", { id: e.action.id, from: "contextMenu" });
    }
    this.contextViewService.hideContextView(false);
  }
  onDidActionRun(e) {
    if (e.error && !isCancellationError(e.error)) {
      this.notificationService.error(e.error);
    }
  }
};

// node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextMenuService.js
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param15 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ContextMenuService = class ContextMenuService2 extends Disposable {
  get contextMenuHandler() {
    if (!this._contextMenuHandler) {
      this._contextMenuHandler = new ContextMenuHandler(this.contextViewService, this.telemetryService, this.notificationService, this.keybindingService);
    }
    return this._contextMenuHandler;
  }
  constructor(telemetryService, notificationService, contextViewService, keybindingService, menuService, contextKeyService) {
    super();
    this.telemetryService = telemetryService;
    this.notificationService = notificationService;
    this.contextViewService = contextViewService;
    this.keybindingService = keybindingService;
    this.menuService = menuService;
    this.contextKeyService = contextKeyService;
    this._contextMenuHandler = void 0;
    this._onDidShowContextMenu = this._store.add(new Emitter());
    this.onDidShowContextMenu = this._onDidShowContextMenu.event;
    this._onDidHideContextMenu = this._store.add(new Emitter());
  }
  configure(options2) {
    this.contextMenuHandler.configure(options2);
  }
  // ContextMenu
  showContextMenu(delegate) {
    delegate = ContextMenuMenuDelegate.transform(delegate, this.menuService, this.contextKeyService);
    this.contextMenuHandler.showContextMenu({
      ...delegate,
      onHide: (didCancel) => {
        var _a2;
        (_a2 = delegate.onHide) === null || _a2 === void 0 ? void 0 : _a2.call(delegate, didCancel);
        this._onDidHideContextMenu.fire();
      }
    });
    ModifierKeyEmitter.getInstance().resetKeyStatus();
    this._onDidShowContextMenu.fire();
  }
};
ContextMenuService = __decorate18([
  __param15(0, ITelemetryService),
  __param15(1, INotificationService),
  __param15(2, IContextViewService),
  __param15(3, IKeybindingService),
  __param15(4, IMenuService),
  __param15(5, IContextKeyService)
], ContextMenuService);
var ContextMenuMenuDelegate;
(function(ContextMenuMenuDelegate2) {
  function is(thing) {
    return thing && thing.menuId instanceof MenuId;
  }
  function transform(delegate, menuService, globalContextKeyService) {
    if (!is(delegate)) {
      return delegate;
    }
    const { menuId, menuActionOptions, contextKeyService } = delegate;
    return {
      ...delegate,
      getActions: () => {
        const target = [];
        if (menuId) {
          const menu = menuService.createMenu(menuId, contextKeyService !== null && contextKeyService !== void 0 ? contextKeyService : globalContextKeyService);
          createAndFillInContextMenuActions(menu, menuActionOptions, target);
          menu.dispose();
        }
        if (!delegate.getActions) {
          return target;
        } else {
          return Separator.join(delegate.getActions(), target);
        }
      }
    };
  }
  ContextMenuMenuDelegate2.transform = transform;
})(ContextMenuMenuDelegate || (ContextMenuMenuDelegate = {}));

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
init_extensions();

// node_modules/monaco-editor/esm/vs/editor/browser/services/openerService.js
init_dom();
init_window();
init_cancellation();
init_linkedList();
init_map();
init_network();
init_resources();
init_uri();
init_codeEditorService();
init_commands();

// node_modules/monaco-editor/esm/vs/platform/editor/common/editor.js
var EditorOpenSource;
(function(EditorOpenSource2) {
  EditorOpenSource2[EditorOpenSource2["API"] = 0] = "API";
  EditorOpenSource2[EditorOpenSource2["USER"] = 1] = "USER";
})(EditorOpenSource || (EditorOpenSource = {}));

// node_modules/monaco-editor/esm/vs/editor/browser/services/openerService.js
var __decorate19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param16 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var CommandOpener = class CommandOpener2 {
  constructor(_commandService) {
    this._commandService = _commandService;
  }
  async open(target, options2) {
    if (!matchesScheme(target, Schemas.command)) {
      return false;
    }
    if (!(options2 === null || options2 === void 0 ? void 0 : options2.allowCommands)) {
      return true;
    }
    if (typeof target === "string") {
      target = URI.parse(target);
    }
    if (Array.isArray(options2.allowCommands)) {
      if (!options2.allowCommands.includes(target.path)) {
        return true;
      }
    }
    let args = [];
    try {
      args = parse3(decodeURIComponent(target.query));
    } catch (_a2) {
      try {
        args = parse3(target.query);
      } catch (_b2) {
      }
    }
    if (!Array.isArray(args)) {
      args = [args];
    }
    await this._commandService.executeCommand(target.path, ...args);
    return true;
  }
};
CommandOpener = __decorate19([
  __param16(0, ICommandService)
], CommandOpener);
var EditorOpener = class EditorOpener2 {
  constructor(_editorService) {
    this._editorService = _editorService;
  }
  async open(target, options2) {
    if (typeof target === "string") {
      target = URI.parse(target);
    }
    const { selection, uri } = extractSelection(target);
    target = uri;
    if (target.scheme === Schemas.file) {
      target = normalizePath(target);
    }
    await this._editorService.openCodeEditor({
      resource: target,
      options: {
        selection,
        source: (options2 === null || options2 === void 0 ? void 0 : options2.fromUserGesture) ? EditorOpenSource.USER : EditorOpenSource.API,
        ...options2 === null || options2 === void 0 ? void 0 : options2.editorOptions
      }
    }, this._editorService.getFocusedCodeEditor(), options2 === null || options2 === void 0 ? void 0 : options2.openToSide);
    return true;
  }
};
EditorOpener = __decorate19([
  __param16(0, ICodeEditorService)
], EditorOpener);
var OpenerService = class OpenerService2 {
  constructor(editorService, commandService) {
    this._openers = new LinkedList();
    this._validators = new LinkedList();
    this._resolvers = new LinkedList();
    this._resolvedUriTargets = new ResourceMap((uri) => uri.with({ path: null, fragment: null, query: null }).toString());
    this._externalOpeners = new LinkedList();
    this._defaultExternalOpener = {
      openExternal: async (href) => {
        if (matchesSomeScheme(href, Schemas.http, Schemas.https)) {
          windowOpenNoOpener(href);
        } else {
          mainWindow.location.href = href;
        }
        return true;
      }
    };
    this._openers.push({
      open: async (target, options2) => {
        if ((options2 === null || options2 === void 0 ? void 0 : options2.openExternal) || matchesSomeScheme(target, Schemas.mailto, Schemas.http, Schemas.https, Schemas.vsls)) {
          await this._doOpenExternal(target, options2);
          return true;
        }
        return false;
      }
    });
    this._openers.push(new CommandOpener(commandService));
    this._openers.push(new EditorOpener(editorService));
  }
  registerOpener(opener) {
    const remove = this._openers.unshift(opener);
    return { dispose: remove };
  }
  async open(target, options2) {
    var _a2;
    const targetURI = typeof target === "string" ? URI.parse(target) : target;
    const validationTarget = (_a2 = this._resolvedUriTargets.get(targetURI)) !== null && _a2 !== void 0 ? _a2 : target;
    for (const validator of this._validators) {
      if (!await validator.shouldOpen(validationTarget, options2)) {
        return false;
      }
    }
    for (const opener of this._openers) {
      const handled = await opener.open(target, options2);
      if (handled) {
        return true;
      }
    }
    return false;
  }
  async resolveExternalUri(resource, options2) {
    for (const resolver of this._resolvers) {
      try {
        const result = await resolver.resolveExternalUri(resource, options2);
        if (result) {
          if (!this._resolvedUriTargets.has(result.resolved)) {
            this._resolvedUriTargets.set(result.resolved, resource);
          }
          return result;
        }
      } catch (_a2) {
      }
    }
    throw new Error("Could not resolve external URI: " + resource.toString());
  }
  async _doOpenExternal(resource, options2) {
    const uri = typeof resource === "string" ? URI.parse(resource) : resource;
    let externalUri;
    try {
      externalUri = (await this.resolveExternalUri(uri, options2)).resolved;
    } catch (_a2) {
      externalUri = uri;
    }
    let href;
    if (typeof resource === "string" && uri.toString() === externalUri.toString()) {
      href = resource;
    } else {
      href = encodeURI(externalUri.toString(true));
    }
    if (options2 === null || options2 === void 0 ? void 0 : options2.allowContributedOpeners) {
      const preferredOpenerId = typeof (options2 === null || options2 === void 0 ? void 0 : options2.allowContributedOpeners) === "string" ? options2 === null || options2 === void 0 ? void 0 : options2.allowContributedOpeners : void 0;
      for (const opener of this._externalOpeners) {
        const didOpen = await opener.openExternal(href, {
          sourceUri: uri,
          preferredOpenerId
        }, CancellationToken.None);
        if (didOpen) {
          return true;
        }
      }
    }
    return this._defaultExternalOpener.openExternal(href, { sourceUri: uri }, CancellationToken.None);
  }
  dispose() {
    this._validators.clear();
  }
};
OpenerService = __decorate19([
  __param16(0, ICodeEditorService),
  __param16(1, ICommandService)
], OpenerService);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
init_editorWorker();

// node_modules/monaco-editor/esm/vs/editor/browser/services/editorWorkerService.js
init_async();
init_lifecycle();

// node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js
init_errors();
init_event();
init_lifecycle();
init_objects();
init_platform();
init_strings();
var INITIALIZE = "$initialize";
var webWorkerWarningLogged = false;
function logOnceWebWorkerWarning(err) {
  if (!isWeb) {
    return;
  }
  if (!webWorkerWarningLogged) {
    webWorkerWarningLogged = true;
    console.warn("Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq");
  }
  console.warn(err.message);
}
var RequestMessage = class {
  constructor(vsWorker, req, method, args) {
    this.vsWorker = vsWorker;
    this.req = req;
    this.method = method;
    this.args = args;
    this.type = 0;
  }
};
var ReplyMessage = class {
  constructor(vsWorker, seq, res, err) {
    this.vsWorker = vsWorker;
    this.seq = seq;
    this.res = res;
    this.err = err;
    this.type = 1;
  }
};
var SubscribeEventMessage = class {
  constructor(vsWorker, req, eventName, arg) {
    this.vsWorker = vsWorker;
    this.req = req;
    this.eventName = eventName;
    this.arg = arg;
    this.type = 2;
  }
};
var EventMessage = class {
  constructor(vsWorker, req, event) {
    this.vsWorker = vsWorker;
    this.req = req;
    this.event = event;
    this.type = 3;
  }
};
var UnsubscribeEventMessage = class {
  constructor(vsWorker, req) {
    this.vsWorker = vsWorker;
    this.req = req;
    this.type = 4;
  }
};
var SimpleWorkerProtocol = class {
  constructor(handler) {
    this._workerId = -1;
    this._handler = handler;
    this._lastSentReq = 0;
    this._pendingReplies = /* @__PURE__ */ Object.create(null);
    this._pendingEmitters = /* @__PURE__ */ new Map();
    this._pendingEvents = /* @__PURE__ */ new Map();
  }
  setWorkerId(workerId) {
    this._workerId = workerId;
  }
  sendMessage(method, args) {
    const req = String(++this._lastSentReq);
    return new Promise((resolve2, reject) => {
      this._pendingReplies[req] = {
        resolve: resolve2,
        reject
      };
      this._send(new RequestMessage(this._workerId, req, method, args));
    });
  }
  listen(eventName, arg) {
    let req = null;
    const emitter = new Emitter({
      onWillAddFirstListener: () => {
        req = String(++this._lastSentReq);
        this._pendingEmitters.set(req, emitter);
        this._send(new SubscribeEventMessage(this._workerId, req, eventName, arg));
      },
      onDidRemoveLastListener: () => {
        this._pendingEmitters.delete(req);
        this._send(new UnsubscribeEventMessage(this._workerId, req));
        req = null;
      }
    });
    return emitter.event;
  }
  handleMessage(message) {
    if (!message || !message.vsWorker) {
      return;
    }
    if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
      return;
    }
    this._handleMessage(message);
  }
  _handleMessage(msg) {
    switch (msg.type) {
      case 1:
        return this._handleReplyMessage(msg);
      case 0:
        return this._handleRequestMessage(msg);
      case 2:
        return this._handleSubscribeEventMessage(msg);
      case 3:
        return this._handleEventMessage(msg);
      case 4:
        return this._handleUnsubscribeEventMessage(msg);
    }
  }
  _handleReplyMessage(replyMessage) {
    if (!this._pendingReplies[replyMessage.seq]) {
      console.warn("Got reply to unknown seq");
      return;
    }
    const reply = this._pendingReplies[replyMessage.seq];
    delete this._pendingReplies[replyMessage.seq];
    if (replyMessage.err) {
      let err = replyMessage.err;
      if (replyMessage.err.$isError) {
        err = new Error();
        err.name = replyMessage.err.name;
        err.message = replyMessage.err.message;
        err.stack = replyMessage.err.stack;
      }
      reply.reject(err);
      return;
    }
    reply.resolve(replyMessage.res);
  }
  _handleRequestMessage(requestMessage) {
    const req = requestMessage.req;
    const result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
    result.then((r) => {
      this._send(new ReplyMessage(this._workerId, req, r, void 0));
    }, (e) => {
      if (e.detail instanceof Error) {
        e.detail = transformErrorForSerialization(e.detail);
      }
      this._send(new ReplyMessage(this._workerId, req, void 0, transformErrorForSerialization(e)));
    });
  }
  _handleSubscribeEventMessage(msg) {
    const req = msg.req;
    const disposable = this._handler.handleEvent(msg.eventName, msg.arg)((event) => {
      this._send(new EventMessage(this._workerId, req, event));
    });
    this._pendingEvents.set(req, disposable);
  }
  _handleEventMessage(msg) {
    if (!this._pendingEmitters.has(msg.req)) {
      console.warn("Got event for unknown req");
      return;
    }
    this._pendingEmitters.get(msg.req).fire(msg.event);
  }
  _handleUnsubscribeEventMessage(msg) {
    if (!this._pendingEvents.has(msg.req)) {
      console.warn("Got unsubscribe for unknown req");
      return;
    }
    this._pendingEvents.get(msg.req).dispose();
    this._pendingEvents.delete(msg.req);
  }
  _send(msg) {
    const transfer = [];
    if (msg.type === 0) {
      for (let i = 0; i < msg.args.length; i++) {
        if (msg.args[i] instanceof ArrayBuffer) {
          transfer.push(msg.args[i]);
        }
      }
    } else if (msg.type === 1) {
      if (msg.res instanceof ArrayBuffer) {
        transfer.push(msg.res);
      }
    }
    this._handler.sendMessage(msg, transfer);
  }
};
var SimpleWorkerClient = class extends Disposable {
  constructor(workerFactory, moduleId, host) {
    super();
    let lazyProxyReject = null;
    this._worker = this._register(workerFactory.create("vs/base/common/worker/simpleWorker", (msg) => {
      this._protocol.handleMessage(msg);
    }, (err) => {
      lazyProxyReject === null || lazyProxyReject === void 0 ? void 0 : lazyProxyReject(err);
    }));
    this._protocol = new SimpleWorkerProtocol({
      sendMessage: (msg, transfer) => {
        this._worker.postMessage(msg, transfer);
      },
      handleMessage: (method, args) => {
        if (typeof host[method] !== "function") {
          return Promise.reject(new Error("Missing method " + method + " on main thread host."));
        }
        try {
          return Promise.resolve(host[method].apply(host, args));
        } catch (e) {
          return Promise.reject(e);
        }
      },
      handleEvent: (eventName, arg) => {
        if (propertyIsDynamicEvent(eventName)) {
          const event = host[eventName].call(host, arg);
          if (typeof event !== "function") {
            throw new Error(`Missing dynamic event ${eventName} on main thread host.`);
          }
          return event;
        }
        if (propertyIsEvent(eventName)) {
          const event = host[eventName];
          if (typeof event !== "function") {
            throw new Error(`Missing event ${eventName} on main thread host.`);
          }
          return event;
        }
        throw new Error(`Malformed event name ${eventName}`);
      }
    });
    this._protocol.setWorkerId(this._worker.getId());
    let loaderConfiguration = null;
    const globalRequire = globalThis.require;
    if (typeof globalRequire !== "undefined" && typeof globalRequire.getConfig === "function") {
      loaderConfiguration = globalRequire.getConfig();
    } else if (typeof globalThis.requirejs !== "undefined") {
      loaderConfiguration = globalThis.requirejs.s.contexts._.config;
    }
    const hostMethods = getAllMethodNames(host);
    this._onModuleLoaded = this._protocol.sendMessage(INITIALIZE, [
      this._worker.getId(),
      JSON.parse(JSON.stringify(loaderConfiguration)),
      moduleId,
      hostMethods
    ]);
    const proxyMethodRequest = (method, args) => {
      return this._request(method, args);
    };
    const proxyListen = (eventName, arg) => {
      return this._protocol.listen(eventName, arg);
    };
    this._lazyProxy = new Promise((resolve2, reject) => {
      lazyProxyReject = reject;
      this._onModuleLoaded.then((availableMethods) => {
        resolve2(createProxyObject2(availableMethods, proxyMethodRequest, proxyListen));
      }, (e) => {
        reject(e);
        this._onError("Worker failed to load " + moduleId, e);
      });
    });
  }
  getProxyObject() {
    return this._lazyProxy;
  }
  _request(method, args) {
    return new Promise((resolve2, reject) => {
      this._onModuleLoaded.then(() => {
        this._protocol.sendMessage(method, args).then(resolve2, reject);
      }, reject);
    });
  }
  _onError(message, error) {
    console.error(message);
    console.info(error);
  }
};
function propertyIsEvent(name) {
  return name[0] === "o" && name[1] === "n" && isUpperAsciiLetter(name.charCodeAt(2));
}
function propertyIsDynamicEvent(name) {
  return /^onDynamic/.test(name) && isUpperAsciiLetter(name.charCodeAt(9));
}
function createProxyObject2(methodNames, invoke, proxyListen) {
  const createProxyMethod = (method) => {
    return function() {
      const args = Array.prototype.slice.call(arguments, 0);
      return invoke(method, args);
    };
  };
  const createProxyDynamicEvent = (eventName) => {
    return function(arg) {
      return proxyListen(eventName, arg);
    };
  };
  const result = {};
  for (const methodName of methodNames) {
    if (propertyIsDynamicEvent(methodName)) {
      result[methodName] = createProxyDynamicEvent(methodName);
      continue;
    }
    if (propertyIsEvent(methodName)) {
      result[methodName] = proxyListen(methodName, void 0);
      continue;
    }
    result[methodName] = createProxyMethod(methodName);
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/base/browser/defaultWorkerFactory.js
init_errors();
init_lifecycle();
var ttPolicy = createTrustedTypesPolicy("defaultWorkerFactory", { createScriptURL: (value) => value });
function getWorker(label) {
  const monacoEnvironment = globalThis.MonacoEnvironment;
  if (monacoEnvironment) {
    if (typeof monacoEnvironment.getWorker === "function") {
      return monacoEnvironment.getWorker("workerMain.js", label);
    }
    if (typeof monacoEnvironment.getWorkerUrl === "function") {
      const workerUrl = monacoEnvironment.getWorkerUrl("workerMain.js", label);
      return new Worker(ttPolicy ? ttPolicy.createScriptURL(workerUrl) : workerUrl, { name: label });
    }
  }
  throw new Error(`You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker`);
}
function isPromiseLike(obj) {
  if (typeof obj.then === "function") {
    return true;
  }
  return false;
}
var WebWorker = class extends Disposable {
  constructor(moduleId, id, label, onMessageCallback, onErrorCallback) {
    super();
    this.id = id;
    this.label = label;
    const workerOrPromise = getWorker(label);
    if (isPromiseLike(workerOrPromise)) {
      this.worker = workerOrPromise;
    } else {
      this.worker = Promise.resolve(workerOrPromise);
    }
    this.postMessage(moduleId, []);
    this.worker.then((w) => {
      w.onmessage = function(ev) {
        onMessageCallback(ev.data);
      };
      w.onmessageerror = onErrorCallback;
      if (typeof w.addEventListener === "function") {
        w.addEventListener("error", onErrorCallback);
      }
    });
    this._register(toDisposable(() => {
      var _a2;
      (_a2 = this.worker) === null || _a2 === void 0 ? void 0 : _a2.then((w) => {
        w.onmessage = null;
        w.onmessageerror = null;
        w.removeEventListener("error", onErrorCallback);
        w.terminate();
      });
      this.worker = null;
    }));
  }
  getId() {
    return this.id;
  }
  postMessage(message, transfer) {
    var _a2;
    (_a2 = this.worker) === null || _a2 === void 0 ? void 0 : _a2.then((w) => {
      try {
        w.postMessage(message, transfer);
      } catch (err) {
        onUnexpectedError(err);
        onUnexpectedError(new Error(`FAILED to post message to '${this.label}'-worker`, { cause: err }));
      }
    });
  }
};
var DefaultWorkerFactory = class _DefaultWorkerFactory {
  constructor(label) {
    this._label = label;
    this._webWorkerFailedBeforeError = false;
  }
  create(moduleId, onMessageCallback, onErrorCallback) {
    const workerId = ++_DefaultWorkerFactory.LAST_WORKER_ID;
    if (this._webWorkerFailedBeforeError) {
      throw this._webWorkerFailedBeforeError;
    }
    return new WebWorker(moduleId, workerId, this._label || "anonymous" + workerId, onMessageCallback, (err) => {
      logOnceWebWorkerWarning(err);
      this._webWorkerFailedBeforeError = err;
      onErrorCallback(err);
    });
  }
};
DefaultWorkerFactory.LAST_WORKER_ID = 0;

// node_modules/monaco-editor/esm/vs/editor/browser/services/editorWorkerService.js
init_range();
init_languageConfigurationRegistry();

// node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js
var DiffChange = class {
  /**
   * Constructs a new DiffChange with the given sequence information
   * and content.
   */
  constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
    this.originalStart = originalStart;
    this.originalLength = originalLength;
    this.modifiedStart = modifiedStart;
    this.modifiedLength = modifiedLength;
  }
  /**
   * The end point (exclusive) of the change in the original sequence.
   */
  getOriginalEnd() {
    return this.originalStart + this.originalLength;
  }
  /**
   * The end point (exclusive) of the change in the modified sequence.
   */
  getModifiedEnd() {
    return this.modifiedStart + this.modifiedLength;
  }
};

// node_modules/monaco-editor/esm/vs/base/common/diff/diff.js
init_hash();
var StringDiffSequence = class {
  constructor(source) {
    this.source = source;
  }
  getElements() {
    const source = this.source;
    const characters = new Int32Array(source.length);
    for (let i = 0, len = source.length; i < len; i++) {
      characters[i] = source.charCodeAt(i);
    }
    return characters;
  }
};
function stringDiff(original, modified, pretty) {
  return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
}
var Debug = class {
  static Assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
};
var MyArray = class {
  /**
   * Copies a range of elements from an Array starting at the specified source index and pastes
   * them to another Array starting at the specified destination index. The length and the indexes
   * are specified as 64-bit integers.
   * sourceArray:
   *		The Array that contains the data to copy.
   * sourceIndex:
   *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
   * destinationArray:
   *		The Array that receives the data.
   * destinationIndex:
   *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
   * length:
   *		A 64-bit integer that represents the number of elements to copy.
   */
  static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
    }
  }
  static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
    }
  }
};
var DiffChangeHelper = class {
  /**
   * Constructs a new DiffChangeHelper for the given DiffSequences.
   */
  constructor() {
    this.m_changes = [];
    this.m_originalStart = 1073741824;
    this.m_modifiedStart = 1073741824;
    this.m_originalCount = 0;
    this.m_modifiedCount = 0;
  }
  /**
   * Marks the beginning of the next change in the set of differences.
   */
  MarkNextChange() {
    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
      this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
    }
    this.m_originalCount = 0;
    this.m_modifiedCount = 0;
    this.m_originalStart = 1073741824;
    this.m_modifiedStart = 1073741824;
  }
  /**
   * Adds the original element at the given position to the elements
   * affected by the current change. The modified index gives context
   * to the change position with respect to the original sequence.
   * @param originalIndex The index of the original element to add.
   * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
   */
  AddOriginalElement(originalIndex, modifiedIndex) {
    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
    this.m_originalCount++;
  }
  /**
   * Adds the modified element at the given position to the elements
   * affected by the current change. The original index gives context
   * to the change position with respect to the modified sequence.
   * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
   * @param modifiedIndex The index of the modified element to add.
   */
  AddModifiedElement(originalIndex, modifiedIndex) {
    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
    this.m_modifiedCount++;
  }
  /**
   * Retrieves all of the changes marked by the class.
   */
  getChanges() {
    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
      this.MarkNextChange();
    }
    return this.m_changes;
  }
  /**
   * Retrieves all of the changes marked by the class in the reverse order
   */
  getReverseChanges() {
    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
      this.MarkNextChange();
    }
    this.m_changes.reverse();
    return this.m_changes;
  }
};
var LcsDiff = class _LcsDiff {
  /**
   * Constructs the DiffFinder
   */
  constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
    this.ContinueProcessingPredicate = continueProcessingPredicate;
    this._originalSequence = originalSequence;
    this._modifiedSequence = modifiedSequence;
    const [originalStringElements, originalElementsOrHash, originalHasStrings] = _LcsDiff._getElements(originalSequence);
    const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = _LcsDiff._getElements(modifiedSequence);
    this._hasStrings = originalHasStrings && modifiedHasStrings;
    this._originalStringElements = originalStringElements;
    this._originalElementsOrHash = originalElementsOrHash;
    this._modifiedStringElements = modifiedStringElements;
    this._modifiedElementsOrHash = modifiedElementsOrHash;
    this.m_forwardHistory = [];
    this.m_reverseHistory = [];
  }
  static _isStringArray(arr) {
    return arr.length > 0 && typeof arr[0] === "string";
  }
  static _getElements(sequence) {
    const elements = sequence.getElements();
    if (_LcsDiff._isStringArray(elements)) {
      const hashes = new Int32Array(elements.length);
      for (let i = 0, len = elements.length; i < len; i++) {
        hashes[i] = stringHash(elements[i], 0);
      }
      return [elements, hashes, true];
    }
    if (elements instanceof Int32Array) {
      return [[], elements, false];
    }
    return [[], new Int32Array(elements), false];
  }
  ElementsAreEqual(originalIndex, newIndex) {
    if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
      return false;
    }
    return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;
  }
  ElementsAreStrictEqual(originalIndex, newIndex) {
    if (!this.ElementsAreEqual(originalIndex, newIndex)) {
      return false;
    }
    const originalElement = _LcsDiff._getStrictElement(this._originalSequence, originalIndex);
    const modifiedElement = _LcsDiff._getStrictElement(this._modifiedSequence, newIndex);
    return originalElement === modifiedElement;
  }
  static _getStrictElement(sequence, index) {
    if (typeof sequence.getStrictElement === "function") {
      return sequence.getStrictElement(index);
    }
    return null;
  }
  OriginalElementsAreEqual(index1, index2) {
    if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
      return false;
    }
    return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;
  }
  ModifiedElementsAreEqual(index1, index2) {
    if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
      return false;
    }
    return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;
  }
  ComputeDiff(pretty) {
    return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
  }
  /**
   * Computes the differences between the original and modified input
   * sequences on the bounded range.
   * @returns An array of the differences between the two input sequences.
   */
  _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
    const quitEarlyArr = [false];
    let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
    if (pretty) {
      changes = this.PrettifyChanges(changes);
    }
    return {
      quitEarly: quitEarlyArr[0],
      changes
    };
  }
  /**
   * Private helper method which computes the differences on the bounded range
   * recursively.
   * @returns An array of the differences between the two input sequences.
   */
  ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
    quitEarlyArr[0] = false;
    while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
      originalStart++;
      modifiedStart++;
    }
    while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
      originalEnd--;
      modifiedEnd--;
    }
    if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
      let changes;
      if (modifiedStart <= modifiedEnd) {
        Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
        changes = [
          new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
        ];
      } else if (originalStart <= originalEnd) {
        Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
        changes = [
          new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
        ];
      } else {
        Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
        Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
        changes = [];
      }
      return changes;
    }
    const midOriginalArr = [0];
    const midModifiedArr = [0];
    const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
    const midOriginal = midOriginalArr[0];
    const midModified = midModifiedArr[0];
    if (result !== null) {
      return result;
    } else if (!quitEarlyArr[0]) {
      const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
      let rightChanges = [];
      if (!quitEarlyArr[0]) {
        rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
      } else {
        rightChanges = [
          new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
        ];
      }
      return this.ConcatenateChanges(leftChanges, rightChanges);
    }
    return [
      new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
    ];
  }
  WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
    let forwardChanges = null;
    let reverseChanges = null;
    let changeHelper = new DiffChangeHelper();
    let diagonalMin = diagonalForwardStart;
    let diagonalMax = diagonalForwardEnd;
    let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;
    let lastOriginalIndex = -1073741824;
    let historyIndex = this.m_forwardHistory.length - 1;
    do {
      const diagonal = diagonalRelative + diagonalForwardBase;
      if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
        originalIndex = forwardPoints[diagonal + 1];
        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
        if (originalIndex < lastOriginalIndex) {
          changeHelper.MarkNextChange();
        }
        lastOriginalIndex = originalIndex;
        changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
        diagonalRelative = diagonal + 1 - diagonalForwardBase;
      } else {
        originalIndex = forwardPoints[diagonal - 1] + 1;
        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
        if (originalIndex < lastOriginalIndex) {
          changeHelper.MarkNextChange();
        }
        lastOriginalIndex = originalIndex - 1;
        changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
        diagonalRelative = diagonal - 1 - diagonalForwardBase;
      }
      if (historyIndex >= 0) {
        forwardPoints = this.m_forwardHistory[historyIndex];
        diagonalForwardBase = forwardPoints[0];
        diagonalMin = 1;
        diagonalMax = forwardPoints.length - 1;
      }
    } while (--historyIndex >= -1);
    forwardChanges = changeHelper.getReverseChanges();
    if (quitEarlyArr[0]) {
      let originalStartPoint = midOriginalArr[0] + 1;
      let modifiedStartPoint = midModifiedArr[0] + 1;
      if (forwardChanges !== null && forwardChanges.length > 0) {
        const lastForwardChange = forwardChanges[forwardChanges.length - 1];
        originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
        modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
      }
      reverseChanges = [
        new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
      ];
    } else {
      changeHelper = new DiffChangeHelper();
      diagonalMin = diagonalReverseStart;
      diagonalMax = diagonalReverseEnd;
      diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;
      lastOriginalIndex = 1073741824;
      historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
      do {
        const diagonal = diagonalRelative + diagonalReverseBase;
        if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
          originalIndex = reversePoints[diagonal + 1] - 1;
          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
          if (originalIndex > lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }
          lastOriginalIndex = originalIndex + 1;
          changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
          diagonalRelative = diagonal + 1 - diagonalReverseBase;
        } else {
          originalIndex = reversePoints[diagonal - 1];
          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
          if (originalIndex > lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }
          lastOriginalIndex = originalIndex;
          changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
          diagonalRelative = diagonal - 1 - diagonalReverseBase;
        }
        if (historyIndex >= 0) {
          reversePoints = this.m_reverseHistory[historyIndex];
          diagonalReverseBase = reversePoints[0];
          diagonalMin = 1;
          diagonalMax = reversePoints.length - 1;
        }
      } while (--historyIndex >= -1);
      reverseChanges = changeHelper.getChanges();
    }
    return this.ConcatenateChanges(forwardChanges, reverseChanges);
  }
  /**
   * Given the range to compute the diff on, this method finds the point:
   * (midOriginal, midModified)
   * that exists in the middle of the LCS of the two sequences and
   * is the point at which the LCS problem may be broken down recursively.
   * This method will try to keep the LCS trace in memory. If the LCS recursion
   * point is calculated and the full trace is available in memory, then this method
   * will return the change list.
   * @param originalStart The start bound of the original sequence range
   * @param originalEnd The end bound of the original sequence range
   * @param modifiedStart The start bound of the modified sequence range
   * @param modifiedEnd The end bound of the modified sequence range
   * @param midOriginal The middle point of the original sequence range
   * @param midModified The middle point of the modified sequence range
   * @returns The diff changes, if available, otherwise null
   */
  ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
    let originalIndex = 0, modifiedIndex = 0;
    let diagonalForwardStart = 0, diagonalForwardEnd = 0;
    let diagonalReverseStart = 0, diagonalReverseEnd = 0;
    originalStart--;
    modifiedStart--;
    midOriginalArr[0] = 0;
    midModifiedArr[0] = 0;
    this.m_forwardHistory = [];
    this.m_reverseHistory = [];
    const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);
    const numDiagonals = maxDifferences + 1;
    const forwardPoints = new Int32Array(numDiagonals);
    const reversePoints = new Int32Array(numDiagonals);
    const diagonalForwardBase = modifiedEnd - modifiedStart;
    const diagonalReverseBase = originalEnd - originalStart;
    const diagonalForwardOffset = originalStart - modifiedStart;
    const diagonalReverseOffset = originalEnd - modifiedEnd;
    const delta = diagonalReverseBase - diagonalForwardBase;
    const deltaIsEven = delta % 2 === 0;
    forwardPoints[diagonalForwardBase] = originalStart;
    reversePoints[diagonalReverseBase] = originalEnd;
    quitEarlyArr[0] = false;
    for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {
      let furthestOriginalIndex = 0;
      let furthestModifiedIndex = 0;
      diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
      diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
      for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
        if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
          originalIndex = forwardPoints[diagonal + 1];
        } else {
          originalIndex = forwardPoints[diagonal - 1] + 1;
        }
        modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
        const tempOriginalIndex = originalIndex;
        while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
          originalIndex++;
          modifiedIndex++;
        }
        forwardPoints[diagonal] = originalIndex;
        if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
          furthestOriginalIndex = originalIndex;
          furthestModifiedIndex = modifiedIndex;
        }
        if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {
          if (originalIndex >= reversePoints[diagonal]) {
            midOriginalArr[0] = originalIndex;
            midModifiedArr[0] = modifiedIndex;
            if (tempOriginalIndex <= reversePoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
            } else {
              return null;
            }
          }
        }
      }
      const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
      if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
        quitEarlyArr[0] = true;
        midOriginalArr[0] = furthestOriginalIndex;
        midModifiedArr[0] = furthestModifiedIndex;
        if (matchLengthOfLongest > 0 && 1447 > 0 && numDifferences <= 1447 + 1) {
          return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
        } else {
          originalStart++;
          modifiedStart++;
          return [
            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
          ];
        }
      }
      diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
      diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
      for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
        if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
          originalIndex = reversePoints[diagonal + 1] - 1;
        } else {
          originalIndex = reversePoints[diagonal - 1];
        }
        modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
        const tempOriginalIndex = originalIndex;
        while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
          originalIndex--;
          modifiedIndex--;
        }
        reversePoints[diagonal] = originalIndex;
        if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
          if (originalIndex <= forwardPoints[diagonal]) {
            midOriginalArr[0] = originalIndex;
            midModifiedArr[0] = modifiedIndex;
            if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
            } else {
              return null;
            }
          }
        }
      }
      if (numDifferences <= 1447) {
        let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
        temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
        MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
        this.m_forwardHistory.push(temp);
        temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
        temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
        MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
        this.m_reverseHistory.push(temp);
      }
    }
    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
  }
  /**
   * Shifts the given changes to provide a more intuitive diff.
   * While the first element in a diff matches the first element after the diff,
   * we shift the diff down.
   *
   * @param changes The list of changes to shift
   * @returns The shifted changes
   */
  PrettifyChanges(changes) {
    for (let i = 0; i < changes.length; i++) {
      const change = changes[i];
      const originalStop = i < changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;
      const modifiedStop = i < changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;
      const checkOriginal = change.originalLength > 0;
      const checkModified = change.modifiedLength > 0;
      while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
        const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);
        const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);
        if (endStrictEqual && !startStrictEqual) {
          break;
        }
        change.originalStart++;
        change.modifiedStart++;
      }
      const mergedChangeArr = [null];
      if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {
        changes[i] = mergedChangeArr[0];
        changes.splice(i + 1, 1);
        i--;
        continue;
      }
    }
    for (let i = changes.length - 1; i >= 0; i--) {
      const change = changes[i];
      let originalStop = 0;
      let modifiedStop = 0;
      if (i > 0) {
        const prevChange = changes[i - 1];
        originalStop = prevChange.originalStart + prevChange.originalLength;
        modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
      }
      const checkOriginal = change.originalLength > 0;
      const checkModified = change.modifiedLength > 0;
      let bestDelta = 0;
      let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
      for (let delta = 1; ; delta++) {
        const originalStart = change.originalStart - delta;
        const modifiedStart = change.modifiedStart - delta;
        if (originalStart < originalStop || modifiedStart < modifiedStop) {
          break;
        }
        if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
          break;
        }
        if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
          break;
        }
        const touchingPreviousChange = originalStart === originalStop && modifiedStart === modifiedStop;
        const score3 = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);
        if (score3 > bestScore) {
          bestScore = score3;
          bestDelta = delta;
        }
      }
      change.originalStart -= bestDelta;
      change.modifiedStart -= bestDelta;
      const mergedChangeArr = [null];
      if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {
        changes[i - 1] = mergedChangeArr[0];
        changes.splice(i, 1);
        i++;
        continue;
      }
    }
    if (this._hasStrings) {
      for (let i = 1, len = changes.length; i < len; i++) {
        const aChange = changes[i - 1];
        const bChange = changes[i];
        const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;
        const aOriginalStart = aChange.originalStart;
        const bOriginalEnd = bChange.originalStart + bChange.originalLength;
        const abOriginalLength = bOriginalEnd - aOriginalStart;
        const aModifiedStart = aChange.modifiedStart;
        const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;
        const abModifiedLength = bModifiedEnd - aModifiedStart;
        if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {
          const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);
          if (t) {
            const [originalMatchStart, modifiedMatchStart] = t;
            if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {
              aChange.originalLength = originalMatchStart - aChange.originalStart;
              aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;
              bChange.originalStart = originalMatchStart + matchedLength;
              bChange.modifiedStart = modifiedMatchStart + matchedLength;
              bChange.originalLength = bOriginalEnd - bChange.originalStart;
              bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;
            }
          }
        }
      }
    }
    return changes;
  }
  _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {
    if (originalLength < desiredLength || modifiedLength < desiredLength) {
      return null;
    }
    const originalMax = originalStart + originalLength - desiredLength + 1;
    const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;
    let bestScore = 0;
    let bestOriginalStart = 0;
    let bestModifiedStart = 0;
    for (let i = originalStart; i < originalMax; i++) {
      for (let j = modifiedStart; j < modifiedMax; j++) {
        const score3 = this._contiguousSequenceScore(i, j, desiredLength);
        if (score3 > 0 && score3 > bestScore) {
          bestScore = score3;
          bestOriginalStart = i;
          bestModifiedStart = j;
        }
      }
    }
    if (bestScore > 0) {
      return [bestOriginalStart, bestModifiedStart];
    }
    return null;
  }
  _contiguousSequenceScore(originalStart, modifiedStart, length) {
    let score3 = 0;
    for (let l = 0; l < length; l++) {
      if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {
        return 0;
      }
      score3 += this._originalStringElements[originalStart + l].length;
    }
    return score3;
  }
  _OriginalIsBoundary(index) {
    if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {
      return true;
    }
    return this._hasStrings && /^\s*$/.test(this._originalStringElements[index]);
  }
  _OriginalRegionIsBoundary(originalStart, originalLength) {
    if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
      return true;
    }
    if (originalLength > 0) {
      const originalEnd = originalStart + originalLength;
      if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
        return true;
      }
    }
    return false;
  }
  _ModifiedIsBoundary(index) {
    if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {
      return true;
    }
    return this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index]);
  }
  _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
    if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
      return true;
    }
    if (modifiedLength > 0) {
      const modifiedEnd = modifiedStart + modifiedLength;
      if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
        return true;
      }
    }
    return false;
  }
  _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
    const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;
    const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;
    return originalScore + modifiedScore;
  }
  /**
   * Concatenates the two input DiffChange lists and returns the resulting
   * list.
   * @param The left changes
   * @param The right changes
   * @returns The concatenated list
   */
  ConcatenateChanges(left, right) {
    const mergedChangeArr = [];
    if (left.length === 0 || right.length === 0) {
      return right.length > 0 ? right : left;
    } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
      const result = new Array(left.length + right.length - 1);
      MyArray.Copy(left, 0, result, 0, left.length - 1);
      result[left.length - 1] = mergedChangeArr[0];
      MyArray.Copy(right, 1, result, left.length, right.length - 1);
      return result;
    } else {
      const result = new Array(left.length + right.length);
      MyArray.Copy(left, 0, result, 0, left.length);
      MyArray.Copy(right, 0, result, left.length, right.length);
      return result;
    }
  }
  /**
   * Returns true if the two changes overlap and can be merged into a single
   * change
   * @param left The left change
   * @param right The right change
   * @param mergedChange The merged change if the two overlap, null otherwise
   * @returns True if the two changes overlap
   */
  ChangesOverlap(left, right, mergedChangeArr) {
    Debug.Assert(left.originalStart <= right.originalStart, "Left change is not less than or equal to right change");
    Debug.Assert(left.modifiedStart <= right.modifiedStart, "Left change is not less than or equal to right change");
    if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
      const originalStart = left.originalStart;
      let originalLength = left.originalLength;
      const modifiedStart = left.modifiedStart;
      let modifiedLength = left.modifiedLength;
      if (left.originalStart + left.originalLength >= right.originalStart) {
        originalLength = right.originalStart + right.originalLength - left.originalStart;
      }
      if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
        modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
      }
      mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
      return true;
    } else {
      mergedChangeArr[0] = null;
      return false;
    }
  }
  /**
   * Helper method used to clip a diagonal index to the range of valid
   * diagonals. This also decides whether or not the diagonal index,
   * if it exceeds the boundary, should be clipped to the boundary or clipped
   * one inside the boundary depending on the Even/Odd status of the boundary
   * and numDifferences.
   * @param diagonal The index of the diagonal to clip.
   * @param numDifferences The current number of differences being iterated upon.
   * @param diagonalBaseIndex The base reference diagonal.
   * @param numDiagonals The total number of diagonals.
   * @returns The clipped diagonal index.
   */
  ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
    if (diagonal >= 0 && diagonal < numDiagonals) {
      return diagonal;
    }
    const diagonalsBelow = diagonalBaseIndex;
    const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
    const diffEven = numDifferences % 2 === 0;
    if (diagonal < 0) {
      const lowerBoundEven = diagonalsBelow % 2 === 0;
      return diffEven === lowerBoundEven ? 0 : 1;
    } else {
      const upperBoundEven = diagonalsAbove % 2 === 0;
      return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
init_uri();
init_position();
init_range();

// node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js
init_strings();
init_position();

// node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js
init_arrays();
init_uint();
var PrefixSumComputer = class {
  constructor(values) {
    this.values = values;
    this.prefixSum = new Uint32Array(values.length);
    this.prefixSumValidIndex = new Int32Array(1);
    this.prefixSumValidIndex[0] = -1;
  }
  insertValues(insertIndex, insertValues) {
    insertIndex = toUint32(insertIndex);
    const oldValues = this.values;
    const oldPrefixSum = this.prefixSum;
    const insertValuesLen = insertValues.length;
    if (insertValuesLen === 0) {
      return false;
    }
    this.values = new Uint32Array(oldValues.length + insertValuesLen);
    this.values.set(oldValues.subarray(0, insertIndex), 0);
    this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
    this.values.set(insertValues, insertIndex);
    if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
      this.prefixSumValidIndex[0] = insertIndex - 1;
    }
    this.prefixSum = new Uint32Array(this.values.length);
    if (this.prefixSumValidIndex[0] >= 0) {
      this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
    }
    return true;
  }
  setValue(index, value) {
    index = toUint32(index);
    value = toUint32(value);
    if (this.values[index] === value) {
      return false;
    }
    this.values[index] = value;
    if (index - 1 < this.prefixSumValidIndex[0]) {
      this.prefixSumValidIndex[0] = index - 1;
    }
    return true;
  }
  removeValues(startIndex, count) {
    startIndex = toUint32(startIndex);
    count = toUint32(count);
    const oldValues = this.values;
    const oldPrefixSum = this.prefixSum;
    if (startIndex >= oldValues.length) {
      return false;
    }
    const maxCount = oldValues.length - startIndex;
    if (count >= maxCount) {
      count = maxCount;
    }
    if (count === 0) {
      return false;
    }
    this.values = new Uint32Array(oldValues.length - count);
    this.values.set(oldValues.subarray(0, startIndex), 0);
    this.values.set(oldValues.subarray(startIndex + count), startIndex);
    this.prefixSum = new Uint32Array(this.values.length);
    if (startIndex - 1 < this.prefixSumValidIndex[0]) {
      this.prefixSumValidIndex[0] = startIndex - 1;
    }
    if (this.prefixSumValidIndex[0] >= 0) {
      this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
    }
    return true;
  }
  getTotalSum() {
    if (this.values.length === 0) {
      return 0;
    }
    return this._getPrefixSum(this.values.length - 1);
  }
  /**
   * Returns the sum of the first `index + 1` many items.
   * @returns `SUM(0 <= j <= index, values[j])`.
   */
  getPrefixSum(index) {
    if (index < 0) {
      return 0;
    }
    index = toUint32(index);
    return this._getPrefixSum(index);
  }
  _getPrefixSum(index) {
    if (index <= this.prefixSumValidIndex[0]) {
      return this.prefixSum[index];
    }
    let startIndex = this.prefixSumValidIndex[0] + 1;
    if (startIndex === 0) {
      this.prefixSum[0] = this.values[0];
      startIndex++;
    }
    if (index >= this.values.length) {
      index = this.values.length - 1;
    }
    for (let i = startIndex; i <= index; i++) {
      this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
    }
    this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
    return this.prefixSum[index];
  }
  getIndexOf(sum) {
    sum = Math.floor(sum);
    this.getTotalSum();
    let low = 0;
    let high = this.values.length - 1;
    let mid = 0;
    let midStop = 0;
    let midStart = 0;
    while (low <= high) {
      mid = low + (high - low) / 2 | 0;
      midStop = this.prefixSum[mid];
      midStart = midStop - this.values[mid];
      if (sum < midStart) {
        high = mid - 1;
      } else if (sum >= midStop) {
        low = mid + 1;
      } else {
        break;
      }
    }
    return new PrefixSumIndexOfResult(mid, sum - midStart);
  }
};
var ConstantTimePrefixSumComputer = class {
  constructor(values) {
    this._values = values;
    this._isValid = false;
    this._validEndIndex = -1;
    this._prefixSum = [];
    this._indexBySum = [];
  }
  /**
   * @returns SUM(0 <= j < values.length, values[j])
   */
  getTotalSum() {
    this._ensureValid();
    return this._indexBySum.length;
  }
  /**
   * Returns the sum of the first `count` many items.
   * @returns `SUM(0 <= j < count, values[j])`.
   */
  getPrefixSum(count) {
    this._ensureValid();
    if (count === 0) {
      return 0;
    }
    return this._prefixSum[count - 1];
  }
  /**
   * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`
   */
  getIndexOf(sum) {
    this._ensureValid();
    const idx = this._indexBySum[sum];
    const viewLinesAbove = idx > 0 ? this._prefixSum[idx - 1] : 0;
    return new PrefixSumIndexOfResult(idx, sum - viewLinesAbove);
  }
  removeValues(start, deleteCount) {
    this._values.splice(start, deleteCount);
    this._invalidate(start);
  }
  insertValues(insertIndex, insertArr) {
    this._values = arrayInsert(this._values, insertIndex, insertArr);
    this._invalidate(insertIndex);
  }
  _invalidate(index) {
    this._isValid = false;
    this._validEndIndex = Math.min(this._validEndIndex, index - 1);
  }
  _ensureValid() {
    if (this._isValid) {
      return;
    }
    for (let i = this._validEndIndex + 1, len = this._values.length; i < len; i++) {
      const value = this._values[i];
      const sumAbove = i > 0 ? this._prefixSum[i - 1] : 0;
      this._prefixSum[i] = sumAbove + value;
      for (let j = 0; j < value; j++) {
        this._indexBySum[sumAbove + j] = i;
      }
    }
    this._prefixSum.length = this._values.length;
    this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1];
    this._isValid = true;
    this._validEndIndex = this._values.length - 1;
  }
  setValue(index, value) {
    if (this._values[index] === value) {
      return;
    }
    this._values[index] = value;
    this._invalidate(index);
  }
};
var PrefixSumIndexOfResult = class {
  constructor(index, remainder) {
    this.index = index;
    this.remainder = remainder;
    this._prefixSumIndexOfResultBrand = void 0;
    this.index = index;
    this.remainder = remainder;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js
var MirrorTextModel = class {
  constructor(uri, lines, eol, versionId) {
    this._uri = uri;
    this._lines = lines;
    this._eol = eol;
    this._versionId = versionId;
    this._lineStarts = null;
    this._cachedTextValue = null;
  }
  dispose() {
    this._lines.length = 0;
  }
  get version() {
    return this._versionId;
  }
  getText() {
    if (this._cachedTextValue === null) {
      this._cachedTextValue = this._lines.join(this._eol);
    }
    return this._cachedTextValue;
  }
  onEvents(e) {
    if (e.eol && e.eol !== this._eol) {
      this._eol = e.eol;
      this._lineStarts = null;
    }
    const changes = e.changes;
    for (const change of changes) {
      this._acceptDeleteRange(change.range);
      this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);
    }
    this._versionId = e.versionId;
    this._cachedTextValue = null;
  }
  _ensureLineStarts() {
    if (!this._lineStarts) {
      const eolLength = this._eol.length;
      const linesLength = this._lines.length;
      const lineStartValues = new Uint32Array(linesLength);
      for (let i = 0; i < linesLength; i++) {
        lineStartValues[i] = this._lines[i].length + eolLength;
      }
      this._lineStarts = new PrefixSumComputer(lineStartValues);
    }
  }
  /**
   * All changes to a line's text go through this method
   */
  _setLineText(lineIndex, newValue) {
    this._lines[lineIndex] = newValue;
    if (this._lineStarts) {
      this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
    }
  }
  _acceptDeleteRange(range2) {
    if (range2.startLineNumber === range2.endLineNumber) {
      if (range2.startColumn === range2.endColumn) {
        return;
      }
      this._setLineText(range2.startLineNumber - 1, this._lines[range2.startLineNumber - 1].substring(0, range2.startColumn - 1) + this._lines[range2.startLineNumber - 1].substring(range2.endColumn - 1));
      return;
    }
    this._setLineText(range2.startLineNumber - 1, this._lines[range2.startLineNumber - 1].substring(0, range2.startColumn - 1) + this._lines[range2.endLineNumber - 1].substring(range2.endColumn - 1));
    this._lines.splice(range2.startLineNumber, range2.endLineNumber - range2.startLineNumber);
    if (this._lineStarts) {
      this._lineStarts.removeValues(range2.startLineNumber, range2.endLineNumber - range2.startLineNumber);
    }
  }
  _acceptInsertText(position, insertText) {
    if (insertText.length === 0) {
      return;
    }
    const insertLines = splitLines(insertText);
    if (insertLines.length === 1) {
      this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0] + this._lines[position.lineNumber - 1].substring(position.column - 1));
      return;
    }
    insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
    this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0]);
    const newLengths = new Uint32Array(insertLines.length - 1);
    for (let i = 1; i < insertLines.length; i++) {
      this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
      newLengths[i - 1] = insertLines[i].length + this._eol.length;
    }
    if (this._lineStarts) {
      this._lineStarts.insertValues(position.lineNumber, newLengths);
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
init_wordHelper();

// node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js
init_characterClassifier();
var Uint8Matrix = class {
  constructor(rows, cols, defaultValue) {
    const data = new Uint8Array(rows * cols);
    for (let i = 0, len = rows * cols; i < len; i++) {
      data[i] = defaultValue;
    }
    this._data = data;
    this.rows = rows;
    this.cols = cols;
  }
  get(row, col) {
    return this._data[row * this.cols + col];
  }
  set(row, col, value) {
    this._data[row * this.cols + col] = value;
  }
};
var StateMachine = class {
  constructor(edges) {
    let maxCharCode = 0;
    let maxState = 0;
    for (let i = 0, len = edges.length; i < len; i++) {
      const [from, chCode, to] = edges[i];
      if (chCode > maxCharCode) {
        maxCharCode = chCode;
      }
      if (from > maxState) {
        maxState = from;
      }
      if (to > maxState) {
        maxState = to;
      }
    }
    maxCharCode++;
    maxState++;
    const states = new Uint8Matrix(
      maxState,
      maxCharCode,
      0
      /* State.Invalid */
    );
    for (let i = 0, len = edges.length; i < len; i++) {
      const [from, chCode, to] = edges[i];
      states.set(from, chCode, to);
    }
    this._states = states;
    this._maxCharCode = maxCharCode;
  }
  nextState(currentState, chCode) {
    if (chCode < 0 || chCode >= this._maxCharCode) {
      return 0;
    }
    return this._states.get(currentState, chCode);
  }
};
var _stateMachine = null;
function getStateMachine() {
  if (_stateMachine === null) {
    _stateMachine = new StateMachine([
      [
        1,
        104,
        2
        /* State.H */
      ],
      [
        1,
        72,
        2
        /* State.H */
      ],
      [
        1,
        102,
        6
        /* State.F */
      ],
      [
        1,
        70,
        6
        /* State.F */
      ],
      [
        2,
        116,
        3
        /* State.HT */
      ],
      [
        2,
        84,
        3
        /* State.HT */
      ],
      [
        3,
        116,
        4
        /* State.HTT */
      ],
      [
        3,
        84,
        4
        /* State.HTT */
      ],
      [
        4,
        112,
        5
        /* State.HTTP */
      ],
      [
        4,
        80,
        5
        /* State.HTTP */
      ],
      [
        5,
        115,
        9
        /* State.BeforeColon */
      ],
      [
        5,
        83,
        9
        /* State.BeforeColon */
      ],
      [
        5,
        58,
        10
        /* State.AfterColon */
      ],
      [
        6,
        105,
        7
        /* State.FI */
      ],
      [
        6,
        73,
        7
        /* State.FI */
      ],
      [
        7,
        108,
        8
        /* State.FIL */
      ],
      [
        7,
        76,
        8
        /* State.FIL */
      ],
      [
        8,
        101,
        9
        /* State.BeforeColon */
      ],
      [
        8,
        69,
        9
        /* State.BeforeColon */
      ],
      [
        9,
        58,
        10
        /* State.AfterColon */
      ],
      [
        10,
        47,
        11
        /* State.AlmostThere */
      ],
      [
        11,
        47,
        12
        /* State.End */
      ]
    ]);
  }
  return _stateMachine;
}
var _classifier = null;
function getClassifier() {
  if (_classifier === null) {
    _classifier = new CharacterClassifier(
      0
      /* CharacterClass.None */
    );
    const FORCE_TERMINATION_CHARACTERS = ` 	<>'"`;
    for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
      _classifier.set(
        FORCE_TERMINATION_CHARACTERS.charCodeAt(i),
        1
        /* CharacterClass.ForceTermination */
      );
    }
    const CANNOT_END_WITH_CHARACTERS = ".,;:";
    for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
      _classifier.set(
        CANNOT_END_WITH_CHARACTERS.charCodeAt(i),
        2
        /* CharacterClass.CannotEndIn */
      );
    }
  }
  return _classifier;
}
var LinkComputer = class _LinkComputer {
  static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
    let lastIncludedCharIndex = linkEndIndex - 1;
    do {
      const chCode = line.charCodeAt(lastIncludedCharIndex);
      const chClass = classifier.get(chCode);
      if (chClass !== 2) {
        break;
      }
      lastIncludedCharIndex--;
    } while (lastIncludedCharIndex > linkBeginIndex);
    if (linkBeginIndex > 0) {
      const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
      const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
      if (charCodeBeforeLink === 40 && lastCharCodeInLink === 41 || charCodeBeforeLink === 91 && lastCharCodeInLink === 93 || charCodeBeforeLink === 123 && lastCharCodeInLink === 125) {
        lastIncludedCharIndex--;
      }
    }
    return {
      range: {
        startLineNumber: lineNumber,
        startColumn: linkBeginIndex + 1,
        endLineNumber: lineNumber,
        endColumn: lastIncludedCharIndex + 2
      },
      url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
    };
  }
  static computeLinks(model, stateMachine = getStateMachine()) {
    const classifier = getClassifier();
    const result = [];
    for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
      const line = model.getLineContent(i);
      const len = line.length;
      let j = 0;
      let linkBeginIndex = 0;
      let linkBeginChCode = 0;
      let state = 1;
      let hasOpenParens = false;
      let hasOpenSquareBracket = false;
      let inSquareBrackets = false;
      let hasOpenCurlyBracket = false;
      while (j < len) {
        let resetStateMachine = false;
        const chCode = line.charCodeAt(j);
        if (state === 13) {
          let chClass;
          switch (chCode) {
            case 40:
              hasOpenParens = true;
              chClass = 0;
              break;
            case 41:
              chClass = hasOpenParens ? 0 : 1;
              break;
            case 91:
              inSquareBrackets = true;
              hasOpenSquareBracket = true;
              chClass = 0;
              break;
            case 93:
              inSquareBrackets = false;
              chClass = hasOpenSquareBracket ? 0 : 1;
              break;
            case 123:
              hasOpenCurlyBracket = true;
              chClass = 0;
              break;
            case 125:
              chClass = hasOpenCurlyBracket ? 0 : 1;
              break;
            case 39:
            case 34:
            case 96:
              if (linkBeginChCode === chCode) {
                chClass = 1;
              } else if (linkBeginChCode === 39 || linkBeginChCode === 34 || linkBeginChCode === 96) {
                chClass = 0;
              } else {
                chClass = 1;
              }
              break;
            case 42:
              chClass = linkBeginChCode === 42 ? 1 : 0;
              break;
            case 124:
              chClass = linkBeginChCode === 124 ? 1 : 0;
              break;
            case 32:
              chClass = inSquareBrackets ? 0 : 1;
              break;
            default:
              chClass = classifier.get(chCode);
          }
          if (chClass === 1) {
            result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
            resetStateMachine = true;
          }
        } else if (state === 12) {
          let chClass;
          if (chCode === 91) {
            hasOpenSquareBracket = true;
            chClass = 0;
          } else {
            chClass = classifier.get(chCode);
          }
          if (chClass === 1) {
            resetStateMachine = true;
          } else {
            state = 13;
          }
        } else {
          state = stateMachine.nextState(state, chCode);
          if (state === 0) {
            resetStateMachine = true;
          }
        }
        if (resetStateMachine) {
          state = 1;
          hasOpenParens = false;
          hasOpenSquareBracket = false;
          hasOpenCurlyBracket = false;
          linkBeginIndex = j + 1;
          linkBeginChCode = chCode;
        }
        j++;
      }
      if (state === 13) {
        result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
      }
    }
    return result;
  }
};
function computeLinks(model) {
  if (!model || typeof model.getLineCount !== "function" || typeof model.getLineContent !== "function") {
    return [];
  }
  return LinkComputer.computeLinks(model);
}

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js
var BasicInplaceReplace = class {
  constructor() {
    this._defaultValueSet = [
      ["true", "false"],
      ["True", "False"],
      ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
      ["public", "protected", "private"]
    ];
  }
  navigateValueSet(range1, text1, range2, text2, up) {
    if (range1 && text1) {
      const result = this.doNavigateValueSet(text1, up);
      if (result) {
        return {
          range: range1,
          value: result
        };
      }
    }
    if (range2 && text2) {
      const result = this.doNavigateValueSet(text2, up);
      if (result) {
        return {
          range: range2,
          value: result
        };
      }
    }
    return null;
  }
  doNavigateValueSet(text, up) {
    const numberResult = this.numberReplace(text, up);
    if (numberResult !== null) {
      return numberResult;
    }
    return this.textReplace(text, up);
  }
  numberReplace(value, up) {
    const precision = Math.pow(10, value.length - (value.lastIndexOf(".") + 1));
    let n1 = Number(value);
    const n2 = parseFloat(value);
    if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
      if (n1 === 0 && !up) {
        return null;
      } else {
        n1 = Math.floor(n1 * precision);
        n1 += up ? precision : -precision;
        return String(n1 / precision);
      }
    }
    return null;
  }
  textReplace(value, up) {
    return this.valueSetsReplace(this._defaultValueSet, value, up);
  }
  valueSetsReplace(valueSets, value, up) {
    let result = null;
    for (let i = 0, len = valueSets.length; result === null && i < len; i++) {
      result = this.valueSetReplace(valueSets[i], value, up);
    }
    return result;
  }
  valueSetReplace(valueSet, value, up) {
    let idx = valueSet.indexOf(value);
    if (idx >= 0) {
      idx += up ? 1 : -1;
      if (idx < 0) {
        idx = valueSet.length - 1;
      } else {
        idx %= valueSet.length;
      }
      return valueSet[idx];
    }
    return null;
  }
};
BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();

// node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js
init_cancellation();
init_event();
init_keyCodes();
init_uri();
init_position();
init_range();
init_selection();
init_languages();

// node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js
var AccessibilitySupport;
(function(AccessibilitySupport2) {
  AccessibilitySupport2[AccessibilitySupport2["Unknown"] = 0] = "Unknown";
  AccessibilitySupport2[AccessibilitySupport2["Disabled"] = 1] = "Disabled";
  AccessibilitySupport2[AccessibilitySupport2["Enabled"] = 2] = "Enabled";
})(AccessibilitySupport || (AccessibilitySupport = {}));
var CodeActionTriggerType;
(function(CodeActionTriggerType2) {
  CodeActionTriggerType2[CodeActionTriggerType2["Invoke"] = 1] = "Invoke";
  CodeActionTriggerType2[CodeActionTriggerType2["Auto"] = 2] = "Auto";
})(CodeActionTriggerType || (CodeActionTriggerType = {}));
var CompletionItemInsertTextRule;
(function(CompletionItemInsertTextRule2) {
  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["None"] = 0] = "None";
  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["KeepWhitespace"] = 1] = "KeepWhitespace";
  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["InsertAsSnippet"] = 4] = "InsertAsSnippet";
})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
var CompletionItemKind;
(function(CompletionItemKind2) {
  CompletionItemKind2[CompletionItemKind2["Method"] = 0] = "Method";
  CompletionItemKind2[CompletionItemKind2["Function"] = 1] = "Function";
  CompletionItemKind2[CompletionItemKind2["Constructor"] = 2] = "Constructor";
  CompletionItemKind2[CompletionItemKind2["Field"] = 3] = "Field";
  CompletionItemKind2[CompletionItemKind2["Variable"] = 4] = "Variable";
  CompletionItemKind2[CompletionItemKind2["Class"] = 5] = "Class";
  CompletionItemKind2[CompletionItemKind2["Struct"] = 6] = "Struct";
  CompletionItemKind2[CompletionItemKind2["Interface"] = 7] = "Interface";
  CompletionItemKind2[CompletionItemKind2["Module"] = 8] = "Module";
  CompletionItemKind2[CompletionItemKind2["Property"] = 9] = "Property";
  CompletionItemKind2[CompletionItemKind2["Event"] = 10] = "Event";
  CompletionItemKind2[CompletionItemKind2["Operator"] = 11] = "Operator";
  CompletionItemKind2[CompletionItemKind2["Unit"] = 12] = "Unit";
  CompletionItemKind2[CompletionItemKind2["Value"] = 13] = "Value";
  CompletionItemKind2[CompletionItemKind2["Constant"] = 14] = "Constant";
  CompletionItemKind2[CompletionItemKind2["Enum"] = 15] = "Enum";
  CompletionItemKind2[CompletionItemKind2["EnumMember"] = 16] = "EnumMember";
  CompletionItemKind2[CompletionItemKind2["Keyword"] = 17] = "Keyword";
  CompletionItemKind2[CompletionItemKind2["Text"] = 18] = "Text";
  CompletionItemKind2[CompletionItemKind2["Color"] = 19] = "Color";
  CompletionItemKind2[CompletionItemKind2["File"] = 20] = "File";
  CompletionItemKind2[CompletionItemKind2["Reference"] = 21] = "Reference";
  CompletionItemKind2[CompletionItemKind2["Customcolor"] = 22] = "Customcolor";
  CompletionItemKind2[CompletionItemKind2["Folder"] = 23] = "Folder";
  CompletionItemKind2[CompletionItemKind2["TypeParameter"] = 24] = "TypeParameter";
  CompletionItemKind2[CompletionItemKind2["User"] = 25] = "User";
  CompletionItemKind2[CompletionItemKind2["Issue"] = 26] = "Issue";
  CompletionItemKind2[CompletionItemKind2["Snippet"] = 27] = "Snippet";
})(CompletionItemKind || (CompletionItemKind = {}));
var CompletionItemTag;
(function(CompletionItemTag2) {
  CompletionItemTag2[CompletionItemTag2["Deprecated"] = 1] = "Deprecated";
})(CompletionItemTag || (CompletionItemTag = {}));
var CompletionTriggerKind;
(function(CompletionTriggerKind2) {
  CompletionTriggerKind2[CompletionTriggerKind2["Invoke"] = 0] = "Invoke";
  CompletionTriggerKind2[CompletionTriggerKind2["TriggerCharacter"] = 1] = "TriggerCharacter";
  CompletionTriggerKind2[CompletionTriggerKind2["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
})(CompletionTriggerKind || (CompletionTriggerKind = {}));
var ContentWidgetPositionPreference;
(function(ContentWidgetPositionPreference2) {
  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["EXACT"] = 0] = "EXACT";
  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["ABOVE"] = 1] = "ABOVE";
  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["BELOW"] = 2] = "BELOW";
})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
var CursorChangeReason;
(function(CursorChangeReason2) {
  CursorChangeReason2[CursorChangeReason2["NotSet"] = 0] = "NotSet";
  CursorChangeReason2[CursorChangeReason2["ContentFlush"] = 1] = "ContentFlush";
  CursorChangeReason2[CursorChangeReason2["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
  CursorChangeReason2[CursorChangeReason2["Explicit"] = 3] = "Explicit";
  CursorChangeReason2[CursorChangeReason2["Paste"] = 4] = "Paste";
  CursorChangeReason2[CursorChangeReason2["Undo"] = 5] = "Undo";
  CursorChangeReason2[CursorChangeReason2["Redo"] = 6] = "Redo";
})(CursorChangeReason || (CursorChangeReason = {}));
var DefaultEndOfLine;
(function(DefaultEndOfLine2) {
  DefaultEndOfLine2[DefaultEndOfLine2["LF"] = 1] = "LF";
  DefaultEndOfLine2[DefaultEndOfLine2["CRLF"] = 2] = "CRLF";
})(DefaultEndOfLine || (DefaultEndOfLine = {}));
var DocumentHighlightKind2;
(function(DocumentHighlightKind3) {
  DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
  DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
  DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
})(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));
var EditorAutoIndentStrategy;
(function(EditorAutoIndentStrategy2) {
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["None"] = 0] = "None";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Keep"] = 1] = "Keep";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Brackets"] = 2] = "Brackets";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Advanced"] = 3] = "Advanced";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Full"] = 4] = "Full";
})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
var EditorOption;
(function(EditorOption2) {
  EditorOption2[EditorOption2["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
  EditorOption2[EditorOption2["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
  EditorOption2[EditorOption2["accessibilitySupport"] = 2] = "accessibilitySupport";
  EditorOption2[EditorOption2["accessibilityPageSize"] = 3] = "accessibilityPageSize";
  EditorOption2[EditorOption2["ariaLabel"] = 4] = "ariaLabel";
  EditorOption2[EditorOption2["ariaRequired"] = 5] = "ariaRequired";
  EditorOption2[EditorOption2["autoClosingBrackets"] = 6] = "autoClosingBrackets";
  EditorOption2[EditorOption2["autoClosingComments"] = 7] = "autoClosingComments";
  EditorOption2[EditorOption2["screenReaderAnnounceInlineSuggestion"] = 8] = "screenReaderAnnounceInlineSuggestion";
  EditorOption2[EditorOption2["autoClosingDelete"] = 9] = "autoClosingDelete";
  EditorOption2[EditorOption2["autoClosingOvertype"] = 10] = "autoClosingOvertype";
  EditorOption2[EditorOption2["autoClosingQuotes"] = 11] = "autoClosingQuotes";
  EditorOption2[EditorOption2["autoIndent"] = 12] = "autoIndent";
  EditorOption2[EditorOption2["automaticLayout"] = 13] = "automaticLayout";
  EditorOption2[EditorOption2["autoSurround"] = 14] = "autoSurround";
  EditorOption2[EditorOption2["bracketPairColorization"] = 15] = "bracketPairColorization";
  EditorOption2[EditorOption2["guides"] = 16] = "guides";
  EditorOption2[EditorOption2["codeLens"] = 17] = "codeLens";
  EditorOption2[EditorOption2["codeLensFontFamily"] = 18] = "codeLensFontFamily";
  EditorOption2[EditorOption2["codeLensFontSize"] = 19] = "codeLensFontSize";
  EditorOption2[EditorOption2["colorDecorators"] = 20] = "colorDecorators";
  EditorOption2[EditorOption2["colorDecoratorsLimit"] = 21] = "colorDecoratorsLimit";
  EditorOption2[EditorOption2["columnSelection"] = 22] = "columnSelection";
  EditorOption2[EditorOption2["comments"] = 23] = "comments";
  EditorOption2[EditorOption2["contextmenu"] = 24] = "contextmenu";
  EditorOption2[EditorOption2["copyWithSyntaxHighlighting"] = 25] = "copyWithSyntaxHighlighting";
  EditorOption2[EditorOption2["cursorBlinking"] = 26] = "cursorBlinking";
  EditorOption2[EditorOption2["cursorSmoothCaretAnimation"] = 27] = "cursorSmoothCaretAnimation";
  EditorOption2[EditorOption2["cursorStyle"] = 28] = "cursorStyle";
  EditorOption2[EditorOption2["cursorSurroundingLines"] = 29] = "cursorSurroundingLines";
  EditorOption2[EditorOption2["cursorSurroundingLinesStyle"] = 30] = "cursorSurroundingLinesStyle";
  EditorOption2[EditorOption2["cursorWidth"] = 31] = "cursorWidth";
  EditorOption2[EditorOption2["disableLayerHinting"] = 32] = "disableLayerHinting";
  EditorOption2[EditorOption2["disableMonospaceOptimizations"] = 33] = "disableMonospaceOptimizations";
  EditorOption2[EditorOption2["domReadOnly"] = 34] = "domReadOnly";
  EditorOption2[EditorOption2["dragAndDrop"] = 35] = "dragAndDrop";
  EditorOption2[EditorOption2["dropIntoEditor"] = 36] = "dropIntoEditor";
  EditorOption2[EditorOption2["emptySelectionClipboard"] = 37] = "emptySelectionClipboard";
  EditorOption2[EditorOption2["experimentalWhitespaceRendering"] = 38] = "experimentalWhitespaceRendering";
  EditorOption2[EditorOption2["extraEditorClassName"] = 39] = "extraEditorClassName";
  EditorOption2[EditorOption2["fastScrollSensitivity"] = 40] = "fastScrollSensitivity";
  EditorOption2[EditorOption2["find"] = 41] = "find";
  EditorOption2[EditorOption2["fixedOverflowWidgets"] = 42] = "fixedOverflowWidgets";
  EditorOption2[EditorOption2["folding"] = 43] = "folding";
  EditorOption2[EditorOption2["foldingStrategy"] = 44] = "foldingStrategy";
  EditorOption2[EditorOption2["foldingHighlight"] = 45] = "foldingHighlight";
  EditorOption2[EditorOption2["foldingImportsByDefault"] = 46] = "foldingImportsByDefault";
  EditorOption2[EditorOption2["foldingMaximumRegions"] = 47] = "foldingMaximumRegions";
  EditorOption2[EditorOption2["unfoldOnClickAfterEndOfLine"] = 48] = "unfoldOnClickAfterEndOfLine";
  EditorOption2[EditorOption2["fontFamily"] = 49] = "fontFamily";
  EditorOption2[EditorOption2["fontInfo"] = 50] = "fontInfo";
  EditorOption2[EditorOption2["fontLigatures"] = 51] = "fontLigatures";
  EditorOption2[EditorOption2["fontSize"] = 52] = "fontSize";
  EditorOption2[EditorOption2["fontWeight"] = 53] = "fontWeight";
  EditorOption2[EditorOption2["fontVariations"] = 54] = "fontVariations";
  EditorOption2[EditorOption2["formatOnPaste"] = 55] = "formatOnPaste";
  EditorOption2[EditorOption2["formatOnType"] = 56] = "formatOnType";
  EditorOption2[EditorOption2["glyphMargin"] = 57] = "glyphMargin";
  EditorOption2[EditorOption2["gotoLocation"] = 58] = "gotoLocation";
  EditorOption2[EditorOption2["hideCursorInOverviewRuler"] = 59] = "hideCursorInOverviewRuler";
  EditorOption2[EditorOption2["hover"] = 60] = "hover";
  EditorOption2[EditorOption2["inDiffEditor"] = 61] = "inDiffEditor";
  EditorOption2[EditorOption2["inlineSuggest"] = 62] = "inlineSuggest";
  EditorOption2[EditorOption2["inlineEdit"] = 63] = "inlineEdit";
  EditorOption2[EditorOption2["letterSpacing"] = 64] = "letterSpacing";
  EditorOption2[EditorOption2["lightbulb"] = 65] = "lightbulb";
  EditorOption2[EditorOption2["lineDecorationsWidth"] = 66] = "lineDecorationsWidth";
  EditorOption2[EditorOption2["lineHeight"] = 67] = "lineHeight";
  EditorOption2[EditorOption2["lineNumbers"] = 68] = "lineNumbers";
  EditorOption2[EditorOption2["lineNumbersMinChars"] = 69] = "lineNumbersMinChars";
  EditorOption2[EditorOption2["linkedEditing"] = 70] = "linkedEditing";
  EditorOption2[EditorOption2["links"] = 71] = "links";
  EditorOption2[EditorOption2["matchBrackets"] = 72] = "matchBrackets";
  EditorOption2[EditorOption2["minimap"] = 73] = "minimap";
  EditorOption2[EditorOption2["mouseStyle"] = 74] = "mouseStyle";
  EditorOption2[EditorOption2["mouseWheelScrollSensitivity"] = 75] = "mouseWheelScrollSensitivity";
  EditorOption2[EditorOption2["mouseWheelZoom"] = 76] = "mouseWheelZoom";
  EditorOption2[EditorOption2["multiCursorMergeOverlapping"] = 77] = "multiCursorMergeOverlapping";
  EditorOption2[EditorOption2["multiCursorModifier"] = 78] = "multiCursorModifier";
  EditorOption2[EditorOption2["multiCursorPaste"] = 79] = "multiCursorPaste";
  EditorOption2[EditorOption2["multiCursorLimit"] = 80] = "multiCursorLimit";
  EditorOption2[EditorOption2["occurrencesHighlight"] = 81] = "occurrencesHighlight";
  EditorOption2[EditorOption2["overviewRulerBorder"] = 82] = "overviewRulerBorder";
  EditorOption2[EditorOption2["overviewRulerLanes"] = 83] = "overviewRulerLanes";
  EditorOption2[EditorOption2["padding"] = 84] = "padding";
  EditorOption2[EditorOption2["pasteAs"] = 85] = "pasteAs";
  EditorOption2[EditorOption2["parameterHints"] = 86] = "parameterHints";
  EditorOption2[EditorOption2["peekWidgetDefaultFocus"] = 87] = "peekWidgetDefaultFocus";
  EditorOption2[EditorOption2["definitionLinkOpensInPeek"] = 88] = "definitionLinkOpensInPeek";
  EditorOption2[EditorOption2["quickSuggestions"] = 89] = "quickSuggestions";
  EditorOption2[EditorOption2["quickSuggestionsDelay"] = 90] = "quickSuggestionsDelay";
  EditorOption2[EditorOption2["readOnly"] = 91] = "readOnly";
  EditorOption2[EditorOption2["readOnlyMessage"] = 92] = "readOnlyMessage";
  EditorOption2[EditorOption2["renameOnType"] = 93] = "renameOnType";
  EditorOption2[EditorOption2["renderControlCharacters"] = 94] = "renderControlCharacters";
  EditorOption2[EditorOption2["renderFinalNewline"] = 95] = "renderFinalNewline";
  EditorOption2[EditorOption2["renderLineHighlight"] = 96] = "renderLineHighlight";
  EditorOption2[EditorOption2["renderLineHighlightOnlyWhenFocus"] = 97] = "renderLineHighlightOnlyWhenFocus";
  EditorOption2[EditorOption2["renderValidationDecorations"] = 98] = "renderValidationDecorations";
  EditorOption2[EditorOption2["renderWhitespace"] = 99] = "renderWhitespace";
  EditorOption2[EditorOption2["revealHorizontalRightPadding"] = 100] = "revealHorizontalRightPadding";
  EditorOption2[EditorOption2["roundedSelection"] = 101] = "roundedSelection";
  EditorOption2[EditorOption2["rulers"] = 102] = "rulers";
  EditorOption2[EditorOption2["scrollbar"] = 103] = "scrollbar";
  EditorOption2[EditorOption2["scrollBeyondLastColumn"] = 104] = "scrollBeyondLastColumn";
  EditorOption2[EditorOption2["scrollBeyondLastLine"] = 105] = "scrollBeyondLastLine";
  EditorOption2[EditorOption2["scrollPredominantAxis"] = 106] = "scrollPredominantAxis";
  EditorOption2[EditorOption2["selectionClipboard"] = 107] = "selectionClipboard";
  EditorOption2[EditorOption2["selectionHighlight"] = 108] = "selectionHighlight";
  EditorOption2[EditorOption2["selectOnLineNumbers"] = 109] = "selectOnLineNumbers";
  EditorOption2[EditorOption2["showFoldingControls"] = 110] = "showFoldingControls";
  EditorOption2[EditorOption2["showUnused"] = 111] = "showUnused";
  EditorOption2[EditorOption2["snippetSuggestions"] = 112] = "snippetSuggestions";
  EditorOption2[EditorOption2["smartSelect"] = 113] = "smartSelect";
  EditorOption2[EditorOption2["smoothScrolling"] = 114] = "smoothScrolling";
  EditorOption2[EditorOption2["stickyScroll"] = 115] = "stickyScroll";
  EditorOption2[EditorOption2["stickyTabStops"] = 116] = "stickyTabStops";
  EditorOption2[EditorOption2["stopRenderingLineAfter"] = 117] = "stopRenderingLineAfter";
  EditorOption2[EditorOption2["suggest"] = 118] = "suggest";
  EditorOption2[EditorOption2["suggestFontSize"] = 119] = "suggestFontSize";
  EditorOption2[EditorOption2["suggestLineHeight"] = 120] = "suggestLineHeight";
  EditorOption2[EditorOption2["suggestOnTriggerCharacters"] = 121] = "suggestOnTriggerCharacters";
  EditorOption2[EditorOption2["suggestSelection"] = 122] = "suggestSelection";
  EditorOption2[EditorOption2["tabCompletion"] = 123] = "tabCompletion";
  EditorOption2[EditorOption2["tabIndex"] = 124] = "tabIndex";
  EditorOption2[EditorOption2["unicodeHighlighting"] = 125] = "unicodeHighlighting";
  EditorOption2[EditorOption2["unusualLineTerminators"] = 126] = "unusualLineTerminators";
  EditorOption2[EditorOption2["useShadowDOM"] = 127] = "useShadowDOM";
  EditorOption2[EditorOption2["useTabStops"] = 128] = "useTabStops";
  EditorOption2[EditorOption2["wordBreak"] = 129] = "wordBreak";
  EditorOption2[EditorOption2["wordSeparators"] = 130] = "wordSeparators";
  EditorOption2[EditorOption2["wordWrap"] = 131] = "wordWrap";
  EditorOption2[EditorOption2["wordWrapBreakAfterCharacters"] = 132] = "wordWrapBreakAfterCharacters";
  EditorOption2[EditorOption2["wordWrapBreakBeforeCharacters"] = 133] = "wordWrapBreakBeforeCharacters";
  EditorOption2[EditorOption2["wordWrapColumn"] = 134] = "wordWrapColumn";
  EditorOption2[EditorOption2["wordWrapOverride1"] = 135] = "wordWrapOverride1";
  EditorOption2[EditorOption2["wordWrapOverride2"] = 136] = "wordWrapOverride2";
  EditorOption2[EditorOption2["wrappingIndent"] = 137] = "wrappingIndent";
  EditorOption2[EditorOption2["wrappingStrategy"] = 138] = "wrappingStrategy";
  EditorOption2[EditorOption2["showDeprecated"] = 139] = "showDeprecated";
  EditorOption2[EditorOption2["inlayHints"] = 140] = "inlayHints";
  EditorOption2[EditorOption2["editorClassName"] = 141] = "editorClassName";
  EditorOption2[EditorOption2["pixelRatio"] = 142] = "pixelRatio";
  EditorOption2[EditorOption2["tabFocusMode"] = 143] = "tabFocusMode";
  EditorOption2[EditorOption2["layoutInfo"] = 144] = "layoutInfo";
  EditorOption2[EditorOption2["wrappingInfo"] = 145] = "wrappingInfo";
  EditorOption2[EditorOption2["defaultColorDecorators"] = 146] = "defaultColorDecorators";
  EditorOption2[EditorOption2["colorDecoratorsActivatedOn"] = 147] = "colorDecoratorsActivatedOn";
  EditorOption2[EditorOption2["inlineCompletionsAccessibilityVerbose"] = 148] = "inlineCompletionsAccessibilityVerbose";
})(EditorOption || (EditorOption = {}));
var EndOfLinePreference;
(function(EndOfLinePreference2) {
  EndOfLinePreference2[EndOfLinePreference2["TextDefined"] = 0] = "TextDefined";
  EndOfLinePreference2[EndOfLinePreference2["LF"] = 1] = "LF";
  EndOfLinePreference2[EndOfLinePreference2["CRLF"] = 2] = "CRLF";
})(EndOfLinePreference || (EndOfLinePreference = {}));
var EndOfLineSequence;
(function(EndOfLineSequence2) {
  EndOfLineSequence2[EndOfLineSequence2["LF"] = 0] = "LF";
  EndOfLineSequence2[EndOfLineSequence2["CRLF"] = 1] = "CRLF";
})(EndOfLineSequence || (EndOfLineSequence = {}));
var GlyphMarginLane2;
(function(GlyphMarginLane3) {
  GlyphMarginLane3[GlyphMarginLane3["Left"] = 1] = "Left";
  GlyphMarginLane3[GlyphMarginLane3["Center"] = 2] = "Center";
  GlyphMarginLane3[GlyphMarginLane3["Right"] = 3] = "Right";
})(GlyphMarginLane2 || (GlyphMarginLane2 = {}));
var IndentAction2;
(function(IndentAction3) {
  IndentAction3[IndentAction3["None"] = 0] = "None";
  IndentAction3[IndentAction3["Indent"] = 1] = "Indent";
  IndentAction3[IndentAction3["IndentOutdent"] = 2] = "IndentOutdent";
  IndentAction3[IndentAction3["Outdent"] = 3] = "Outdent";
})(IndentAction2 || (IndentAction2 = {}));
var InjectedTextCursorStops2;
(function(InjectedTextCursorStops3) {
  InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
  InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
  InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
  InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
})(InjectedTextCursorStops2 || (InjectedTextCursorStops2 = {}));
var InlayHintKind2;
(function(InlayHintKind3) {
  InlayHintKind3[InlayHintKind3["Type"] = 1] = "Type";
  InlayHintKind3[InlayHintKind3["Parameter"] = 2] = "Parameter";
})(InlayHintKind2 || (InlayHintKind2 = {}));
var InlineCompletionTriggerKind2;
(function(InlineCompletionTriggerKind3) {
  InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 0] = "Automatic";
  InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Explicit"] = 1] = "Explicit";
})(InlineCompletionTriggerKind2 || (InlineCompletionTriggerKind2 = {}));
var InlineEditTriggerKind2;
(function(InlineEditTriggerKind3) {
  InlineEditTriggerKind3[InlineEditTriggerKind3["Invoke"] = 0] = "Invoke";
  InlineEditTriggerKind3[InlineEditTriggerKind3["Automatic"] = 1] = "Automatic";
})(InlineEditTriggerKind2 || (InlineEditTriggerKind2 = {}));
var KeyCode;
(function(KeyCode2) {
  KeyCode2[KeyCode2["DependsOnKbLayout"] = -1] = "DependsOnKbLayout";
  KeyCode2[KeyCode2["Unknown"] = 0] = "Unknown";
  KeyCode2[KeyCode2["Backspace"] = 1] = "Backspace";
  KeyCode2[KeyCode2["Tab"] = 2] = "Tab";
  KeyCode2[KeyCode2["Enter"] = 3] = "Enter";
  KeyCode2[KeyCode2["Shift"] = 4] = "Shift";
  KeyCode2[KeyCode2["Ctrl"] = 5] = "Ctrl";
  KeyCode2[KeyCode2["Alt"] = 6] = "Alt";
  KeyCode2[KeyCode2["PauseBreak"] = 7] = "PauseBreak";
  KeyCode2[KeyCode2["CapsLock"] = 8] = "CapsLock";
  KeyCode2[KeyCode2["Escape"] = 9] = "Escape";
  KeyCode2[KeyCode2["Space"] = 10] = "Space";
  KeyCode2[KeyCode2["PageUp"] = 11] = "PageUp";
  KeyCode2[KeyCode2["PageDown"] = 12] = "PageDown";
  KeyCode2[KeyCode2["End"] = 13] = "End";
  KeyCode2[KeyCode2["Home"] = 14] = "Home";
  KeyCode2[KeyCode2["LeftArrow"] = 15] = "LeftArrow";
  KeyCode2[KeyCode2["UpArrow"] = 16] = "UpArrow";
  KeyCode2[KeyCode2["RightArrow"] = 17] = "RightArrow";
  KeyCode2[KeyCode2["DownArrow"] = 18] = "DownArrow";
  KeyCode2[KeyCode2["Insert"] = 19] = "Insert";
  KeyCode2[KeyCode2["Delete"] = 20] = "Delete";
  KeyCode2[KeyCode2["Digit0"] = 21] = "Digit0";
  KeyCode2[KeyCode2["Digit1"] = 22] = "Digit1";
  KeyCode2[KeyCode2["Digit2"] = 23] = "Digit2";
  KeyCode2[KeyCode2["Digit3"] = 24] = "Digit3";
  KeyCode2[KeyCode2["Digit4"] = 25] = "Digit4";
  KeyCode2[KeyCode2["Digit5"] = 26] = "Digit5";
  KeyCode2[KeyCode2["Digit6"] = 27] = "Digit6";
  KeyCode2[KeyCode2["Digit7"] = 28] = "Digit7";
  KeyCode2[KeyCode2["Digit8"] = 29] = "Digit8";
  KeyCode2[KeyCode2["Digit9"] = 30] = "Digit9";
  KeyCode2[KeyCode2["KeyA"] = 31] = "KeyA";
  KeyCode2[KeyCode2["KeyB"] = 32] = "KeyB";
  KeyCode2[KeyCode2["KeyC"] = 33] = "KeyC";
  KeyCode2[KeyCode2["KeyD"] = 34] = "KeyD";
  KeyCode2[KeyCode2["KeyE"] = 35] = "KeyE";
  KeyCode2[KeyCode2["KeyF"] = 36] = "KeyF";
  KeyCode2[KeyCode2["KeyG"] = 37] = "KeyG";
  KeyCode2[KeyCode2["KeyH"] = 38] = "KeyH";
  KeyCode2[KeyCode2["KeyI"] = 39] = "KeyI";
  KeyCode2[KeyCode2["KeyJ"] = 40] = "KeyJ";
  KeyCode2[KeyCode2["KeyK"] = 41] = "KeyK";
  KeyCode2[KeyCode2["KeyL"] = 42] = "KeyL";
  KeyCode2[KeyCode2["KeyM"] = 43] = "KeyM";
  KeyCode2[KeyCode2["KeyN"] = 44] = "KeyN";
  KeyCode2[KeyCode2["KeyO"] = 45] = "KeyO";
  KeyCode2[KeyCode2["KeyP"] = 46] = "KeyP";
  KeyCode2[KeyCode2["KeyQ"] = 47] = "KeyQ";
  KeyCode2[KeyCode2["KeyR"] = 48] = "KeyR";
  KeyCode2[KeyCode2["KeyS"] = 49] = "KeyS";
  KeyCode2[KeyCode2["KeyT"] = 50] = "KeyT";
  KeyCode2[KeyCode2["KeyU"] = 51] = "KeyU";
  KeyCode2[KeyCode2["KeyV"] = 52] = "KeyV";
  KeyCode2[KeyCode2["KeyW"] = 53] = "KeyW";
  KeyCode2[KeyCode2["KeyX"] = 54] = "KeyX";
  KeyCode2[KeyCode2["KeyY"] = 55] = "KeyY";
  KeyCode2[KeyCode2["KeyZ"] = 56] = "KeyZ";
  KeyCode2[KeyCode2["Meta"] = 57] = "Meta";
  KeyCode2[KeyCode2["ContextMenu"] = 58] = "ContextMenu";
  KeyCode2[KeyCode2["F1"] = 59] = "F1";
  KeyCode2[KeyCode2["F2"] = 60] = "F2";
  KeyCode2[KeyCode2["F3"] = 61] = "F3";
  KeyCode2[KeyCode2["F4"] = 62] = "F4";
  KeyCode2[KeyCode2["F5"] = 63] = "F5";
  KeyCode2[KeyCode2["F6"] = 64] = "F6";
  KeyCode2[KeyCode2["F7"] = 65] = "F7";
  KeyCode2[KeyCode2["F8"] = 66] = "F8";
  KeyCode2[KeyCode2["F9"] = 67] = "F9";
  KeyCode2[KeyCode2["F10"] = 68] = "F10";
  KeyCode2[KeyCode2["F11"] = 69] = "F11";
  KeyCode2[KeyCode2["F12"] = 70] = "F12";
  KeyCode2[KeyCode2["F13"] = 71] = "F13";
  KeyCode2[KeyCode2["F14"] = 72] = "F14";
  KeyCode2[KeyCode2["F15"] = 73] = "F15";
  KeyCode2[KeyCode2["F16"] = 74] = "F16";
  KeyCode2[KeyCode2["F17"] = 75] = "F17";
  KeyCode2[KeyCode2["F18"] = 76] = "F18";
  KeyCode2[KeyCode2["F19"] = 77] = "F19";
  KeyCode2[KeyCode2["F20"] = 78] = "F20";
  KeyCode2[KeyCode2["F21"] = 79] = "F21";
  KeyCode2[KeyCode2["F22"] = 80] = "F22";
  KeyCode2[KeyCode2["F23"] = 81] = "F23";
  KeyCode2[KeyCode2["F24"] = 82] = "F24";
  KeyCode2[KeyCode2["NumLock"] = 83] = "NumLock";
  KeyCode2[KeyCode2["ScrollLock"] = 84] = "ScrollLock";
  KeyCode2[KeyCode2["Semicolon"] = 85] = "Semicolon";
  KeyCode2[KeyCode2["Equal"] = 86] = "Equal";
  KeyCode2[KeyCode2["Comma"] = 87] = "Comma";
  KeyCode2[KeyCode2["Minus"] = 88] = "Minus";
  KeyCode2[KeyCode2["Period"] = 89] = "Period";
  KeyCode2[KeyCode2["Slash"] = 90] = "Slash";
  KeyCode2[KeyCode2["Backquote"] = 91] = "Backquote";
  KeyCode2[KeyCode2["BracketLeft"] = 92] = "BracketLeft";
  KeyCode2[KeyCode2["Backslash"] = 93] = "Backslash";
  KeyCode2[KeyCode2["BracketRight"] = 94] = "BracketRight";
  KeyCode2[KeyCode2["Quote"] = 95] = "Quote";
  KeyCode2[KeyCode2["OEM_8"] = 96] = "OEM_8";
  KeyCode2[KeyCode2["IntlBackslash"] = 97] = "IntlBackslash";
  KeyCode2[KeyCode2["Numpad0"] = 98] = "Numpad0";
  KeyCode2[KeyCode2["Numpad1"] = 99] = "Numpad1";
  KeyCode2[KeyCode2["Numpad2"] = 100] = "Numpad2";
  KeyCode2[KeyCode2["Numpad3"] = 101] = "Numpad3";
  KeyCode2[KeyCode2["Numpad4"] = 102] = "Numpad4";
  KeyCode2[KeyCode2["Numpad5"] = 103] = "Numpad5";
  KeyCode2[KeyCode2["Numpad6"] = 104] = "Numpad6";
  KeyCode2[KeyCode2["Numpad7"] = 105] = "Numpad7";
  KeyCode2[KeyCode2["Numpad8"] = 106] = "Numpad8";
  KeyCode2[KeyCode2["Numpad9"] = 107] = "Numpad9";
  KeyCode2[KeyCode2["NumpadMultiply"] = 108] = "NumpadMultiply";
  KeyCode2[KeyCode2["NumpadAdd"] = 109] = "NumpadAdd";
  KeyCode2[KeyCode2["NUMPAD_SEPARATOR"] = 110] = "NUMPAD_SEPARATOR";
  KeyCode2[KeyCode2["NumpadSubtract"] = 111] = "NumpadSubtract";
  KeyCode2[KeyCode2["NumpadDecimal"] = 112] = "NumpadDecimal";
  KeyCode2[KeyCode2["NumpadDivide"] = 113] = "NumpadDivide";
  KeyCode2[KeyCode2["KEY_IN_COMPOSITION"] = 114] = "KEY_IN_COMPOSITION";
  KeyCode2[KeyCode2["ABNT_C1"] = 115] = "ABNT_C1";
  KeyCode2[KeyCode2["ABNT_C2"] = 116] = "ABNT_C2";
  KeyCode2[KeyCode2["AudioVolumeMute"] = 117] = "AudioVolumeMute";
  KeyCode2[KeyCode2["AudioVolumeUp"] = 118] = "AudioVolumeUp";
  KeyCode2[KeyCode2["AudioVolumeDown"] = 119] = "AudioVolumeDown";
  KeyCode2[KeyCode2["BrowserSearch"] = 120] = "BrowserSearch";
  KeyCode2[KeyCode2["BrowserHome"] = 121] = "BrowserHome";
  KeyCode2[KeyCode2["BrowserBack"] = 122] = "BrowserBack";
  KeyCode2[KeyCode2["BrowserForward"] = 123] = "BrowserForward";
  KeyCode2[KeyCode2["MediaTrackNext"] = 124] = "MediaTrackNext";
  KeyCode2[KeyCode2["MediaTrackPrevious"] = 125] = "MediaTrackPrevious";
  KeyCode2[KeyCode2["MediaStop"] = 126] = "MediaStop";
  KeyCode2[KeyCode2["MediaPlayPause"] = 127] = "MediaPlayPause";
  KeyCode2[KeyCode2["LaunchMediaPlayer"] = 128] = "LaunchMediaPlayer";
  KeyCode2[KeyCode2["LaunchMail"] = 129] = "LaunchMail";
  KeyCode2[KeyCode2["LaunchApp2"] = 130] = "LaunchApp2";
  KeyCode2[KeyCode2["Clear"] = 131] = "Clear";
  KeyCode2[KeyCode2["MAX_VALUE"] = 132] = "MAX_VALUE";
})(KeyCode || (KeyCode = {}));
var MarkerSeverity;
(function(MarkerSeverity3) {
  MarkerSeverity3[MarkerSeverity3["Hint"] = 1] = "Hint";
  MarkerSeverity3[MarkerSeverity3["Info"] = 2] = "Info";
  MarkerSeverity3[MarkerSeverity3["Warning"] = 4] = "Warning";
  MarkerSeverity3[MarkerSeverity3["Error"] = 8] = "Error";
})(MarkerSeverity || (MarkerSeverity = {}));
var MarkerTag;
(function(MarkerTag2) {
  MarkerTag2[MarkerTag2["Unnecessary"] = 1] = "Unnecessary";
  MarkerTag2[MarkerTag2["Deprecated"] = 2] = "Deprecated";
})(MarkerTag || (MarkerTag = {}));
var MinimapPosition2;
(function(MinimapPosition3) {
  MinimapPosition3[MinimapPosition3["Inline"] = 1] = "Inline";
  MinimapPosition3[MinimapPosition3["Gutter"] = 2] = "Gutter";
})(MinimapPosition2 || (MinimapPosition2 = {}));
var MouseTargetType;
(function(MouseTargetType2) {
  MouseTargetType2[MouseTargetType2["UNKNOWN"] = 0] = "UNKNOWN";
  MouseTargetType2[MouseTargetType2["TEXTAREA"] = 1] = "TEXTAREA";
  MouseTargetType2[MouseTargetType2["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
  MouseTargetType2[MouseTargetType2["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
  MouseTargetType2[MouseTargetType2["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
  MouseTargetType2[MouseTargetType2["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
  MouseTargetType2[MouseTargetType2["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
  MouseTargetType2[MouseTargetType2["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
  MouseTargetType2[MouseTargetType2["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
  MouseTargetType2[MouseTargetType2["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
  MouseTargetType2[MouseTargetType2["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
  MouseTargetType2[MouseTargetType2["SCROLLBAR"] = 11] = "SCROLLBAR";
  MouseTargetType2[MouseTargetType2["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
  MouseTargetType2[MouseTargetType2["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
})(MouseTargetType || (MouseTargetType = {}));
var NewSymbolNameTag2;
(function(NewSymbolNameTag3) {
  NewSymbolNameTag3[NewSymbolNameTag3["AIGenerated"] = 1] = "AIGenerated";
})(NewSymbolNameTag2 || (NewSymbolNameTag2 = {}));
var OverlayWidgetPositionPreference;
(function(OverlayWidgetPositionPreference2) {
  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_CENTER"] = 2] = "TOP_CENTER";
})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
var OverviewRulerLane2;
(function(OverviewRulerLane3) {
  OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
  OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
  OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
  OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
})(OverviewRulerLane2 || (OverviewRulerLane2 = {}));
var PositionAffinity;
(function(PositionAffinity2) {
  PositionAffinity2[PositionAffinity2["Left"] = 0] = "Left";
  PositionAffinity2[PositionAffinity2["Right"] = 1] = "Right";
  PositionAffinity2[PositionAffinity2["None"] = 2] = "None";
  PositionAffinity2[PositionAffinity2["LeftOfInjectedText"] = 3] = "LeftOfInjectedText";
  PositionAffinity2[PositionAffinity2["RightOfInjectedText"] = 4] = "RightOfInjectedText";
})(PositionAffinity || (PositionAffinity = {}));
var RenderLineNumbersType;
(function(RenderLineNumbersType2) {
  RenderLineNumbersType2[RenderLineNumbersType2["Off"] = 0] = "Off";
  RenderLineNumbersType2[RenderLineNumbersType2["On"] = 1] = "On";
  RenderLineNumbersType2[RenderLineNumbersType2["Relative"] = 2] = "Relative";
  RenderLineNumbersType2[RenderLineNumbersType2["Interval"] = 3] = "Interval";
  RenderLineNumbersType2[RenderLineNumbersType2["Custom"] = 4] = "Custom";
})(RenderLineNumbersType || (RenderLineNumbersType = {}));
var RenderMinimap;
(function(RenderMinimap2) {
  RenderMinimap2[RenderMinimap2["None"] = 0] = "None";
  RenderMinimap2[RenderMinimap2["Text"] = 1] = "Text";
  RenderMinimap2[RenderMinimap2["Blocks"] = 2] = "Blocks";
})(RenderMinimap || (RenderMinimap = {}));
var ScrollType;
(function(ScrollType2) {
  ScrollType2[ScrollType2["Smooth"] = 0] = "Smooth";
  ScrollType2[ScrollType2["Immediate"] = 1] = "Immediate";
})(ScrollType || (ScrollType = {}));
var ScrollbarVisibility;
(function(ScrollbarVisibility2) {
  ScrollbarVisibility2[ScrollbarVisibility2["Auto"] = 1] = "Auto";
  ScrollbarVisibility2[ScrollbarVisibility2["Hidden"] = 2] = "Hidden";
  ScrollbarVisibility2[ScrollbarVisibility2["Visible"] = 3] = "Visible";
})(ScrollbarVisibility || (ScrollbarVisibility = {}));
var SelectionDirection;
(function(SelectionDirection2) {
  SelectionDirection2[SelectionDirection2["LTR"] = 0] = "LTR";
  SelectionDirection2[SelectionDirection2["RTL"] = 1] = "RTL";
})(SelectionDirection || (SelectionDirection = {}));
var ShowLightbulbIconMode2;
(function(ShowLightbulbIconMode3) {
  ShowLightbulbIconMode3["Off"] = "off";
  ShowLightbulbIconMode3["OnCode"] = "onCode";
  ShowLightbulbIconMode3["On"] = "on";
})(ShowLightbulbIconMode2 || (ShowLightbulbIconMode2 = {}));
var SignatureHelpTriggerKind2;
(function(SignatureHelpTriggerKind3) {
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind2 || (SignatureHelpTriggerKind2 = {}));
var SymbolKind;
(function(SymbolKind2) {
  SymbolKind2[SymbolKind2["File"] = 0] = "File";
  SymbolKind2[SymbolKind2["Module"] = 1] = "Module";
  SymbolKind2[SymbolKind2["Namespace"] = 2] = "Namespace";
  SymbolKind2[SymbolKind2["Package"] = 3] = "Package";
  SymbolKind2[SymbolKind2["Class"] = 4] = "Class";
  SymbolKind2[SymbolKind2["Method"] = 5] = "Method";
  SymbolKind2[SymbolKind2["Property"] = 6] = "Property";
  SymbolKind2[SymbolKind2["Field"] = 7] = "Field";
  SymbolKind2[SymbolKind2["Constructor"] = 8] = "Constructor";
  SymbolKind2[SymbolKind2["Enum"] = 9] = "Enum";
  SymbolKind2[SymbolKind2["Interface"] = 10] = "Interface";
  SymbolKind2[SymbolKind2["Function"] = 11] = "Function";
  SymbolKind2[SymbolKind2["Variable"] = 12] = "Variable";
  SymbolKind2[SymbolKind2["Constant"] = 13] = "Constant";
  SymbolKind2[SymbolKind2["String"] = 14] = "String";
  SymbolKind2[SymbolKind2["Number"] = 15] = "Number";
  SymbolKind2[SymbolKind2["Boolean"] = 16] = "Boolean";
  SymbolKind2[SymbolKind2["Array"] = 17] = "Array";
  SymbolKind2[SymbolKind2["Object"] = 18] = "Object";
  SymbolKind2[SymbolKind2["Key"] = 19] = "Key";
  SymbolKind2[SymbolKind2["Null"] = 20] = "Null";
  SymbolKind2[SymbolKind2["EnumMember"] = 21] = "EnumMember";
  SymbolKind2[SymbolKind2["Struct"] = 22] = "Struct";
  SymbolKind2[SymbolKind2["Event"] = 23] = "Event";
  SymbolKind2[SymbolKind2["Operator"] = 24] = "Operator";
  SymbolKind2[SymbolKind2["TypeParameter"] = 25] = "TypeParameter";
})(SymbolKind || (SymbolKind = {}));
var SymbolTag;
(function(SymbolTag2) {
  SymbolTag2[SymbolTag2["Deprecated"] = 1] = "Deprecated";
})(SymbolTag || (SymbolTag = {}));
var TextEditorCursorBlinkingStyle;
(function(TextEditorCursorBlinkingStyle2) {
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Hidden"] = 0] = "Hidden";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Blink"] = 1] = "Blink";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Smooth"] = 2] = "Smooth";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Phase"] = 3] = "Phase";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Expand"] = 4] = "Expand";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Solid"] = 5] = "Solid";
})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
var TextEditorCursorStyle2;
(function(TextEditorCursorStyle3) {
  TextEditorCursorStyle3[TextEditorCursorStyle3["Line"] = 1] = "Line";
  TextEditorCursorStyle3[TextEditorCursorStyle3["Block"] = 2] = "Block";
  TextEditorCursorStyle3[TextEditorCursorStyle3["Underline"] = 3] = "Underline";
  TextEditorCursorStyle3[TextEditorCursorStyle3["LineThin"] = 4] = "LineThin";
  TextEditorCursorStyle3[TextEditorCursorStyle3["BlockOutline"] = 5] = "BlockOutline";
  TextEditorCursorStyle3[TextEditorCursorStyle3["UnderlineThin"] = 6] = "UnderlineThin";
})(TextEditorCursorStyle2 || (TextEditorCursorStyle2 = {}));
var TrackedRangeStickiness;
(function(TrackedRangeStickiness2) {
  TrackedRangeStickiness2[TrackedRangeStickiness2["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
  TrackedRangeStickiness2[TrackedRangeStickiness2["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
  TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
  TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
var WrappingIndent;
(function(WrappingIndent2) {
  WrappingIndent2[WrappingIndent2["None"] = 0] = "None";
  WrappingIndent2[WrappingIndent2["Same"] = 1] = "Same";
  WrappingIndent2[WrappingIndent2["Indent"] = 2] = "Indent";
  WrappingIndent2[WrappingIndent2["DeepIndent"] = 3] = "DeepIndent";
})(WrappingIndent || (WrappingIndent = {}));

// node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js
var KeyMod = class {
  static chord(firstPart, secondPart) {
    return KeyChord(firstPart, secondPart);
  }
};
KeyMod.CtrlCmd = 2048;
KeyMod.Shift = 1024;
KeyMod.Alt = 512;
KeyMod.WinCtrl = 256;
function createMonacoBaseAPI() {
  return {
    editor: void 0,
    // undefined override expected here
    languages: void 0,
    // undefined override expected here
    CancellationTokenSource,
    Emitter,
    KeyCode,
    KeyMod,
    Position,
    Range: Range2,
    Selection,
    SelectionDirection,
    MarkerSeverity,
    MarkerTag,
    Uri: URI,
    Token
  };
}

// node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
init_stopwatch();

// node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js
init_range();
init_textModelSearch();
init_strings();
init_assert();
init_wordHelper();
var UnicodeTextModelHighlighter = class {
  static computeUnicodeHighlights(model, options2, range2) {
    const startLine = range2 ? range2.startLineNumber : 1;
    const endLine = range2 ? range2.endLineNumber : model.getLineCount();
    const codePointHighlighter = new CodePointHighlighter(options2);
    const candidates = codePointHighlighter.getCandidateCodePoints();
    let regex;
    if (candidates === "allNonBasicAscii") {
      regex = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g");
    } else {
      regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, "g");
    }
    const searcher = new Searcher(null, regex);
    const ranges = [];
    let hasMore = false;
    let m;
    let ambiguousCharacterCount = 0;
    let invisibleCharacterCount = 0;
    let nonBasicAsciiCharacterCount = 0;
    forLoop:
      for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {
        const lineContent = model.getLineContent(lineNumber);
        const lineLength = lineContent.length;
        searcher.reset(0);
        do {
          m = searcher.next(lineContent);
          if (m) {
            let startIndex = m.index;
            let endIndex = m.index + m[0].length;
            if (startIndex > 0) {
              const charCodeBefore = lineContent.charCodeAt(startIndex - 1);
              if (isHighSurrogate(charCodeBefore)) {
                startIndex--;
              }
            }
            if (endIndex + 1 < lineLength) {
              const charCodeBefore = lineContent.charCodeAt(endIndex - 1);
              if (isHighSurrogate(charCodeBefore)) {
                endIndex++;
              }
            }
            const str = lineContent.substring(startIndex, endIndex);
            let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);
            if (word && word.endColumn <= startIndex + 1) {
              word = null;
            }
            const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);
            if (highlightReason !== 0) {
              if (highlightReason === 3) {
                ambiguousCharacterCount++;
              } else if (highlightReason === 2) {
                invisibleCharacterCount++;
              } else if (highlightReason === 1) {
                nonBasicAsciiCharacterCount++;
              } else {
                assertNever(highlightReason);
              }
              const MAX_RESULT_LENGTH = 1e3;
              if (ranges.length >= MAX_RESULT_LENGTH) {
                hasMore = true;
                break forLoop;
              }
              ranges.push(new Range2(lineNumber, startIndex + 1, lineNumber, endIndex + 1));
            }
          }
        } while (m);
      }
    return {
      ranges,
      hasMore,
      ambiguousCharacterCount,
      invisibleCharacterCount,
      nonBasicAsciiCharacterCount
    };
  }
  static computeUnicodeHighlightReason(char, options2) {
    const codePointHighlighter = new CodePointHighlighter(options2);
    const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);
    switch (reason) {
      case 0:
        return null;
      case 2:
        return {
          kind: 1
          /* UnicodeHighlighterReasonKind.Invisible */
        };
      case 3: {
        const codePoint = char.codePointAt(0);
        const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);
        const notAmbiguousInLocales = AmbiguousCharacters.getLocales().filter((l) => !AmbiguousCharacters.getInstance(/* @__PURE__ */ new Set([...options2.allowedLocales, l])).isAmbiguous(codePoint));
        return { kind: 0, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };
      }
      case 1:
        return {
          kind: 2
          /* UnicodeHighlighterReasonKind.NonBasicAscii */
        };
    }
  }
};
function buildRegExpCharClassExpr(codePoints, flags) {
  const src = `[${escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(""))}]`;
  return src;
}
var CodePointHighlighter = class {
  constructor(options2) {
    this.options = options2;
    this.allowedCodePoints = new Set(options2.allowedCodePoints);
    this.ambiguousCharacters = AmbiguousCharacters.getInstance(new Set(options2.allowedLocales));
  }
  getCandidateCodePoints() {
    if (this.options.nonBasicASCII) {
      return "allNonBasicAscii";
    }
    const set = /* @__PURE__ */ new Set();
    if (this.options.invisibleCharacters) {
      for (const cp of InvisibleCharacters.codePoints) {
        if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {
          set.add(cp);
        }
      }
    }
    if (this.options.ambiguousCharacters) {
      for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {
        set.add(cp);
      }
    }
    for (const cp of this.allowedCodePoints) {
      set.delete(cp);
    }
    return set;
  }
  shouldHighlightNonBasicASCII(character, wordContext) {
    const codePoint = character.codePointAt(0);
    if (this.allowedCodePoints.has(codePoint)) {
      return 0;
    }
    if (this.options.nonBasicASCII) {
      return 1;
    }
    let hasBasicASCIICharacters = false;
    let hasNonConfusableNonBasicAsciiCharacter = false;
    if (wordContext) {
      for (const char of wordContext) {
        const codePoint2 = char.codePointAt(0);
        const isBasicASCII2 = isBasicASCII(char);
        hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII2;
        if (!isBasicASCII2 && !this.ambiguousCharacters.isAmbiguous(codePoint2) && !InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
          hasNonConfusableNonBasicAsciiCharacter = true;
        }
      }
    }
    if (
      /* Don't allow mixing weird looking characters with ASCII */
      !hasBasicASCIICharacters && /* Is there an obviously weird looking character? */
      hasNonConfusableNonBasicAsciiCharacter
    ) {
      return 0;
    }
    if (this.options.invisibleCharacters) {
      if (!isAllowedInvisibleCharacter(character) && InvisibleCharacters.isInvisibleCharacter(codePoint)) {
        return 2;
      }
    }
    if (this.options.ambiguousCharacters) {
      if (this.ambiguousCharacters.isAmbiguous(codePoint)) {
        return 3;
      }
    }
    return 0;
  }
};
function isAllowedInvisibleCharacter(character) {
  return character === " " || character === "\n" || character === "	";
}

// node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js
var LinesDiff = class {
  constructor(changes, moves, hitTimeout) {
    this.changes = changes;
    this.moves = moves;
    this.hitTimeout = hitTimeout;
  }
};
var MovedText = class {
  constructor(lineRangeMapping, changes) {
    this.lineRangeMapping = lineRangeMapping;
    this.changes = changes;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js
init_lineRange();
var LineRangeMapping = class _LineRangeMapping {
  static inverse(mapping, originalLineCount, modifiedLineCount) {
    const result = [];
    let lastOriginalEndLineNumber = 1;
    let lastModifiedEndLineNumber = 1;
    for (const m of mapping) {
      const r2 = new _LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));
      if (!r2.modified.isEmpty) {
        result.push(r2);
      }
      lastOriginalEndLineNumber = m.original.endLineNumberExclusive;
      lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;
    }
    const r = new _LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));
    if (!r.modified.isEmpty) {
      result.push(r);
    }
    return result;
  }
  static clip(mapping, originalRange, modifiedRange) {
    const result = [];
    for (const m of mapping) {
      const original = m.original.intersect(originalRange);
      const modified = m.modified.intersect(modifiedRange);
      if (original && !original.isEmpty && modified && !modified.isEmpty) {
        result.push(new _LineRangeMapping(original, modified));
      }
    }
    return result;
  }
  constructor(originalRange, modifiedRange) {
    this.original = originalRange;
    this.modified = modifiedRange;
  }
  toString() {
    return `{${this.original.toString()}->${this.modified.toString()}}`;
  }
  flip() {
    return new _LineRangeMapping(this.modified, this.original);
  }
  join(other) {
    return new _LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));
  }
};
var DetailedLineRangeMapping = class _DetailedLineRangeMapping extends LineRangeMapping {
  constructor(originalRange, modifiedRange, innerChanges) {
    super(originalRange, modifiedRange);
    this.innerChanges = innerChanges;
  }
  flip() {
    var _a2;
    return new _DetailedLineRangeMapping(this.modified, this.original, (_a2 = this.innerChanges) === null || _a2 === void 0 ? void 0 : _a2.map((c) => c.flip()));
  }
};
var RangeMapping = class _RangeMapping {
  constructor(originalRange, modifiedRange) {
    this.originalRange = originalRange;
    this.modifiedRange = modifiedRange;
  }
  toString() {
    return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
  }
  flip() {
    return new _RangeMapping(this.modifiedRange, this.originalRange);
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js
init_strings();
init_range();
init_assert();
init_lineRange();
var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
var LegacyLinesDiffComputer = class {
  computeDiff(originalLines, modifiedLines, options2) {
    var _a2;
    const diffComputer = new DiffComputer(originalLines, modifiedLines, {
      maxComputationTime: options2.maxComputationTimeMs,
      shouldIgnoreTrimWhitespace: options2.ignoreTrimWhitespace,
      shouldComputeCharChanges: true,
      shouldMakePrettyDiff: true,
      shouldPostProcessCharChanges: true
    });
    const result = diffComputer.computeDiff();
    const changes = [];
    let lastChange = null;
    for (const c of result.changes) {
      let originalRange;
      if (c.originalEndLineNumber === 0) {
        originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);
      } else {
        originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);
      }
      let modifiedRange;
      if (c.modifiedEndLineNumber === 0) {
        modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);
      } else {
        modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);
      }
      let change = new DetailedLineRangeMapping(originalRange, modifiedRange, (_a2 = c.charChanges) === null || _a2 === void 0 ? void 0 : _a2.map((c2) => new RangeMapping(new Range2(c2.originalStartLineNumber, c2.originalStartColumn, c2.originalEndLineNumber, c2.originalEndColumn), new Range2(c2.modifiedStartLineNumber, c2.modifiedStartColumn, c2.modifiedEndLineNumber, c2.modifiedEndColumn))));
      if (lastChange) {
        if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {
          change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ? lastChange.innerChanges.concat(change.innerChanges) : void 0);
          changes.pop();
        }
      }
      changes.push(change);
      lastChange = change;
    }
    assertFn(() => {
      return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
      m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);
    });
    return new LinesDiff(changes, [], result.quitEarly);
  }
};
function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
  const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
  return diffAlgo.ComputeDiff(pretty);
}
var LineSequence = class {
  constructor(lines) {
    const startColumns = [];
    const endColumns = [];
    for (let i = 0, length = lines.length; i < length; i++) {
      startColumns[i] = getFirstNonBlankColumn(lines[i], 1);
      endColumns[i] = getLastNonBlankColumn(lines[i], 1);
    }
    this.lines = lines;
    this._startColumns = startColumns;
    this._endColumns = endColumns;
  }
  getElements() {
    const elements = [];
    for (let i = 0, len = this.lines.length; i < len; i++) {
      elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
    }
    return elements;
  }
  getStrictElement(index) {
    return this.lines[index];
  }
  getStartLineNumber(i) {
    return i + 1;
  }
  getEndLineNumber(i) {
    return i + 1;
  }
  createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
    const charCodes = [];
    const lineNumbers = [];
    const columns = [];
    let len = 0;
    for (let index = startIndex; index <= endIndex; index++) {
      const lineContent = this.lines[index];
      const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;
      const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;
      for (let col = startColumn; col < endColumn; col++) {
        charCodes[len] = lineContent.charCodeAt(col - 1);
        lineNumbers[len] = index + 1;
        columns[len] = col;
        len++;
      }
      if (!shouldIgnoreTrimWhitespace && index < endIndex) {
        charCodes[len] = 10;
        lineNumbers[len] = index + 1;
        columns[len] = lineContent.length + 1;
        len++;
      }
    }
    return new CharSequence(charCodes, lineNumbers, columns);
  }
};
var CharSequence = class {
  constructor(charCodes, lineNumbers, columns) {
    this._charCodes = charCodes;
    this._lineNumbers = lineNumbers;
    this._columns = columns;
  }
  toString() {
    return "[" + this._charCodes.map((s, idx) => (s === 10 ? "\\n" : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(", ") + "]";
  }
  _assertIndex(index, arr) {
    if (index < 0 || index >= arr.length) {
      throw new Error(`Illegal index`);
    }
  }
  getElements() {
    return this._charCodes;
  }
  getStartLineNumber(i) {
    if (i > 0 && i === this._lineNumbers.length) {
      return this.getEndLineNumber(i - 1);
    }
    this._assertIndex(i, this._lineNumbers);
    return this._lineNumbers[i];
  }
  getEndLineNumber(i) {
    if (i === -1) {
      return this.getStartLineNumber(i + 1);
    }
    this._assertIndex(i, this._lineNumbers);
    if (this._charCodes[i] === 10) {
      return this._lineNumbers[i] + 1;
    }
    return this._lineNumbers[i];
  }
  getStartColumn(i) {
    if (i > 0 && i === this._columns.length) {
      return this.getEndColumn(i - 1);
    }
    this._assertIndex(i, this._columns);
    return this._columns[i];
  }
  getEndColumn(i) {
    if (i === -1) {
      return this.getStartColumn(i + 1);
    }
    this._assertIndex(i, this._columns);
    if (this._charCodes[i] === 10) {
      return 1;
    }
    return this._columns[i] + 1;
  }
};
var CharChange = class _CharChange {
  constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
    this.originalStartLineNumber = originalStartLineNumber;
    this.originalStartColumn = originalStartColumn;
    this.originalEndLineNumber = originalEndLineNumber;
    this.originalEndColumn = originalEndColumn;
    this.modifiedStartLineNumber = modifiedStartLineNumber;
    this.modifiedStartColumn = modifiedStartColumn;
    this.modifiedEndLineNumber = modifiedEndLineNumber;
    this.modifiedEndColumn = modifiedEndColumn;
  }
  static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
    const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
    const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
    const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
    const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
    const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
    const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
    const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
    const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
    return new _CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
  }
};
function postProcessCharChanges(rawChanges) {
  if (rawChanges.length <= 1) {
    return rawChanges;
  }
  const result = [rawChanges[0]];
  let prevChange = result[0];
  for (let i = 1, len = rawChanges.length; i < len; i++) {
    const currChange = rawChanges[i];
    const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
    const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
    const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
    if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
      prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;
      prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;
    } else {
      result.push(currChange);
      prevChange = currChange;
    }
  }
  return result;
}
var LineChange = class _LineChange {
  constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
    this.originalStartLineNumber = originalStartLineNumber;
    this.originalEndLineNumber = originalEndLineNumber;
    this.modifiedStartLineNumber = modifiedStartLineNumber;
    this.modifiedEndLineNumber = modifiedEndLineNumber;
    this.charChanges = charChanges;
  }
  static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
    let originalStartLineNumber;
    let originalEndLineNumber;
    let modifiedStartLineNumber;
    let modifiedEndLineNumber;
    let charChanges = void 0;
    if (diffChange.originalLength === 0) {
      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
      originalEndLineNumber = 0;
    } else {
      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
      originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
    }
    if (diffChange.modifiedLength === 0) {
      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
      modifiedEndLineNumber = 0;
    } else {
      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
      modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
    }
    if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
      const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
      const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
      if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {
        let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
        if (shouldPostProcessCharChanges) {
          rawChanges = postProcessCharChanges(rawChanges);
        }
        charChanges = [];
        for (let i = 0, length = rawChanges.length; i < length; i++) {
          charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
        }
      }
    }
    return new _LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
  }
};
var DiffComputer = class {
  constructor(originalLines, modifiedLines, opts) {
    this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
    this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
    this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
    this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
    this.originalLines = originalLines;
    this.modifiedLines = modifiedLines;
    this.original = new LineSequence(originalLines);
    this.modified = new LineSequence(modifiedLines);
    this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
    this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));
  }
  computeDiff() {
    if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
        return {
          quitEarly: false,
          changes: []
        };
      }
      return {
        quitEarly: false,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: 1,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: this.modified.lines.length,
          charChanges: void 0
        }]
      };
    }
    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
      return {
        quitEarly: false,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: this.original.lines.length,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: 1,
          charChanges: void 0
        }]
      };
    }
    const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
    const rawChanges = diffResult.changes;
    const quitEarly = diffResult.quitEarly;
    if (this.shouldIgnoreTrimWhitespace) {
      const lineChanges = [];
      for (let i = 0, length = rawChanges.length; i < length; i++) {
        lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
      }
      return {
        quitEarly,
        changes: lineChanges
      };
    }
    const result = [];
    let originalLineIndex = 0;
    let modifiedLineIndex = 0;
    for (let i = -1, len = rawChanges.length; i < len; i++) {
      const nextChange = i + 1 < len ? rawChanges[i + 1] : null;
      const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;
      const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;
      while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
        const originalLine = this.originalLines[originalLineIndex];
        const modifiedLine = this.modifiedLines[modifiedLineIndex];
        if (originalLine !== modifiedLine) {
          {
            let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
            let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
            while (originalStartColumn > 1 && modifiedStartColumn > 1) {
              const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
              const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
              if (originalChar !== modifiedChar) {
                break;
              }
              originalStartColumn--;
              modifiedStartColumn--;
            }
            if (originalStartColumn > 1 || modifiedStartColumn > 1) {
              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
            }
          }
          {
            let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
            let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
            const originalMaxColumn = originalLine.length + 1;
            const modifiedMaxColumn = modifiedLine.length + 1;
            while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
              const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
              const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
              if (originalChar !== modifiedChar) {
                break;
              }
              originalEndColumn++;
              modifiedEndColumn++;
            }
            if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
            }
          }
        }
        originalLineIndex++;
        modifiedLineIndex++;
      }
      if (nextChange) {
        result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
        originalLineIndex += nextChange.originalLength;
        modifiedLineIndex += nextChange.modifiedLength;
      }
    }
    return {
      quitEarly,
      changes: result
    };
  }
  _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
    if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
      return;
    }
    let charChanges = void 0;
    if (this.shouldComputeCharChanges) {
      charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
    }
    result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
  }
  _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
    const len = result.length;
    if (len === 0) {
      return false;
    }
    const prevChange = result[len - 1];
    if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
      return false;
    }
    if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {
      if (this.shouldComputeCharChanges && prevChange.charChanges) {
        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
      }
      return true;
    }
    if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
      prevChange.originalEndLineNumber = originalLineNumber;
      prevChange.modifiedEndLineNumber = modifiedLineNumber;
      if (this.shouldComputeCharChanges && prevChange.charChanges) {
        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
      }
      return true;
    }
    return false;
  }
};
function getFirstNonBlankColumn(txt, defaultValue) {
  const r = firstNonWhitespaceIndex(txt);
  if (r === -1) {
    return defaultValue;
  }
  return r + 1;
}
function getLastNonBlankColumn(txt, defaultValue) {
  const r = lastNonWhitespaceIndex(txt);
  if (r === -1) {
    return defaultValue;
  }
  return r + 2;
}
function createContinueProcessingPredicate(maximumRuntime) {
  if (maximumRuntime === 0) {
    return () => true;
  }
  const startTime = Date.now();
  return () => {
    return Date.now() - startTime < maximumRuntime;
  };
}

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js
init_arrays();
init_assert();
init_lineRange();
init_offsetRange();
init_range();

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js
init_arrays();
init_errors();
init_offsetRange();
var DiffAlgorithmResult = class _DiffAlgorithmResult {
  static trivial(seq1, seq2) {
    return new _DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);
  }
  static trivialTimedOut(seq1, seq2) {
    return new _DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);
  }
  constructor(diffs, hitTimeout) {
    this.diffs = diffs;
    this.hitTimeout = hitTimeout;
  }
};
var SequenceDiff = class _SequenceDiff {
  static invert(sequenceDiffs, doc1Length) {
    const result = [];
    forEachAdjacent(sequenceDiffs, (a, b) => {
      result.push(_SequenceDiff.fromOffsetPairs(a ? a.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)));
    });
    return result;
  }
  static fromOffsetPairs(start, endExclusive) {
    return new _SequenceDiff(new OffsetRange(start.offset1, endExclusive.offset1), new OffsetRange(start.offset2, endExclusive.offset2));
  }
  constructor(seq1Range, seq2Range) {
    this.seq1Range = seq1Range;
    this.seq2Range = seq2Range;
  }
  swap() {
    return new _SequenceDiff(this.seq2Range, this.seq1Range);
  }
  toString() {
    return `${this.seq1Range} <-> ${this.seq2Range}`;
  }
  join(other) {
    return new _SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));
  }
  delta(offset) {
    if (offset === 0) {
      return this;
    }
    return new _SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));
  }
  deltaStart(offset) {
    if (offset === 0) {
      return this;
    }
    return new _SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));
  }
  deltaEnd(offset) {
    if (offset === 0) {
      return this;
    }
    return new _SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));
  }
  intersect(other) {
    const i1 = this.seq1Range.intersect(other.seq1Range);
    const i2 = this.seq2Range.intersect(other.seq2Range);
    if (!i1 || !i2) {
      return void 0;
    }
    return new _SequenceDiff(i1, i2);
  }
  getStarts() {
    return new OffsetPair(this.seq1Range.start, this.seq2Range.start);
  }
  getEndExclusives() {
    return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);
  }
};
var OffsetPair = class _OffsetPair {
  constructor(offset1, offset2) {
    this.offset1 = offset1;
    this.offset2 = offset2;
  }
  toString() {
    return `${this.offset1} <-> ${this.offset2}`;
  }
  delta(offset) {
    if (offset === 0) {
      return this;
    }
    return new _OffsetPair(this.offset1 + offset, this.offset2 + offset);
  }
  equals(other) {
    return this.offset1 === other.offset1 && this.offset2 === other.offset2;
  }
};
OffsetPair.zero = new OffsetPair(0, 0);
OffsetPair.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
var InfiniteTimeout = class {
  isValid() {
    return true;
  }
};
InfiniteTimeout.instance = new InfiniteTimeout();
var DateTimeout = class {
  constructor(timeout2) {
    this.timeout = timeout2;
    this.startTime = Date.now();
    this.valid = true;
    if (timeout2 <= 0) {
      throw new BugIndicatingError("timeout must be positive");
    }
  }
  // Recommendation: Set a log-point `{this.disable()}` in the body
  isValid() {
    const valid = Date.now() - this.startTime < this.timeout;
    if (!valid && this.valid) {
      this.valid = false;
      debugger;
    }
    return this.valid;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js
init_offsetRange();

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js
var Array2D = class {
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.array = [];
    this.array = new Array(width * height);
  }
  get(x, y) {
    return this.array[x + y * this.width];
  }
  set(x, y, value) {
    this.array[x + y * this.width] = value;
  }
};
function isSpace(charCode) {
  return charCode === 32 || charCode === 9;
}
var LineRangeFragment = class _LineRangeFragment {
  static getKey(chr) {
    let key = this.chrKeys.get(chr);
    if (key === void 0) {
      key = this.chrKeys.size;
      this.chrKeys.set(chr, key);
    }
    return key;
  }
  constructor(range2, lines, source) {
    this.range = range2;
    this.lines = lines;
    this.source = source;
    this.histogram = [];
    let counter = 0;
    for (let i = range2.startLineNumber - 1; i < range2.endLineNumberExclusive - 1; i++) {
      const line = lines[i];
      for (let j = 0; j < line.length; j++) {
        counter++;
        const chr = line[j];
        const key2 = _LineRangeFragment.getKey(chr);
        this.histogram[key2] = (this.histogram[key2] || 0) + 1;
      }
      counter++;
      const key = _LineRangeFragment.getKey("\n");
      this.histogram[key] = (this.histogram[key] || 0) + 1;
    }
    this.totalCount = counter;
  }
  computeSimilarity(other) {
    var _a2, _b2;
    let sumDifferences = 0;
    const maxLength = Math.max(this.histogram.length, other.histogram.length);
    for (let i = 0; i < maxLength; i++) {
      sumDifferences += Math.abs(((_a2 = this.histogram[i]) !== null && _a2 !== void 0 ? _a2 : 0) - ((_b2 = other.histogram[i]) !== null && _b2 !== void 0 ? _b2 : 0));
    }
    return 1 - sumDifferences / (this.totalCount + other.totalCount);
  }
};
LineRangeFragment.chrKeys = /* @__PURE__ */ new Map();

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js
var DynamicProgrammingDiffing = class {
  compute(sequence1, sequence2, timeout2 = InfiniteTimeout.instance, equalityScore) {
    if (sequence1.length === 0 || sequence2.length === 0) {
      return DiffAlgorithmResult.trivial(sequence1, sequence2);
    }
    const lcsLengths = new Array2D(sequence1.length, sequence2.length);
    const directions = new Array2D(sequence1.length, sequence2.length);
    const lengths = new Array2D(sequence1.length, sequence2.length);
    for (let s12 = 0; s12 < sequence1.length; s12++) {
      for (let s22 = 0; s22 < sequence2.length; s22++) {
        if (!timeout2.isValid()) {
          return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);
        }
        const horizontalLen = s12 === 0 ? 0 : lcsLengths.get(s12 - 1, s22);
        const verticalLen = s22 === 0 ? 0 : lcsLengths.get(s12, s22 - 1);
        let extendedSeqScore;
        if (sequence1.getElement(s12) === sequence2.getElement(s22)) {
          if (s12 === 0 || s22 === 0) {
            extendedSeqScore = 0;
          } else {
            extendedSeqScore = lcsLengths.get(s12 - 1, s22 - 1);
          }
          if (s12 > 0 && s22 > 0 && directions.get(s12 - 1, s22 - 1) === 3) {
            extendedSeqScore += lengths.get(s12 - 1, s22 - 1);
          }
          extendedSeqScore += equalityScore ? equalityScore(s12, s22) : 1;
        } else {
          extendedSeqScore = -1;
        }
        const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);
        if (newValue === extendedSeqScore) {
          const prevLen = s12 > 0 && s22 > 0 ? lengths.get(s12 - 1, s22 - 1) : 0;
          lengths.set(s12, s22, prevLen + 1);
          directions.set(s12, s22, 3);
        } else if (newValue === horizontalLen) {
          lengths.set(s12, s22, 0);
          directions.set(s12, s22, 1);
        } else if (newValue === verticalLen) {
          lengths.set(s12, s22, 0);
          directions.set(s12, s22, 2);
        }
        lcsLengths.set(s12, s22, newValue);
      }
    }
    const result = [];
    let lastAligningPosS1 = sequence1.length;
    let lastAligningPosS2 = sequence2.length;
    function reportDecreasingAligningPositions(s12, s22) {
      if (s12 + 1 !== lastAligningPosS1 || s22 + 1 !== lastAligningPosS2) {
        result.push(new SequenceDiff(new OffsetRange(s12 + 1, lastAligningPosS1), new OffsetRange(s22 + 1, lastAligningPosS2)));
      }
      lastAligningPosS1 = s12;
      lastAligningPosS2 = s22;
    }
    let s1 = sequence1.length - 1;
    let s2 = sequence2.length - 1;
    while (s1 >= 0 && s2 >= 0) {
      if (directions.get(s1, s2) === 3) {
        reportDecreasingAligningPositions(s1, s2);
        s1--;
        s2--;
      } else {
        if (directions.get(s1, s2) === 1) {
          s1--;
        } else {
          s2--;
        }
      }
    }
    reportDecreasingAligningPositions(-1, -1);
    result.reverse();
    return new DiffAlgorithmResult(result, false);
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js
init_offsetRange();
var MyersDiffAlgorithm = class {
  compute(seq1, seq2, timeout2 = InfiniteTimeout.instance) {
    if (seq1.length === 0 || seq2.length === 0) {
      return DiffAlgorithmResult.trivial(seq1, seq2);
    }
    const seqX = seq1;
    const seqY = seq2;
    function getXAfterSnake(x, y) {
      while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {
        x++;
        y++;
      }
      return x;
    }
    let d = 0;
    const V = new FastInt32Array();
    V.set(0, getXAfterSnake(0, 0));
    const paths = new FastArrayNegativeIndices();
    paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));
    let k = 0;
    loop:
      while (true) {
        d++;
        if (!timeout2.isValid()) {
          return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);
        }
        const lowerBound = -Math.min(d, seqY.length + d % 2);
        const upperBound = Math.min(d, seqX.length + d % 2);
        for (k = lowerBound; k <= upperBound; k += 2) {
          let step = 0;
          const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1);
          const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1;
          step++;
          const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);
          const y = x - k;
          step++;
          if (x > seqX.length || y > seqY.length) {
            continue;
          }
          const newMaxX = getXAfterSnake(x, y);
          V.set(k, newMaxX);
          const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);
          paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);
          if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {
            break loop;
          }
        }
      }
    let path = paths.get(k);
    const result = [];
    let lastAligningPosS1 = seqX.length;
    let lastAligningPosS2 = seqY.length;
    while (true) {
      const endX = path ? path.x + path.length : 0;
      const endY = path ? path.y + path.length : 0;
      if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {
        result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));
      }
      if (!path) {
        break;
      }
      lastAligningPosS1 = path.x;
      lastAligningPosS2 = path.y;
      path = path.prev;
    }
    result.reverse();
    return new DiffAlgorithmResult(result, false);
  }
};
var SnakePath = class {
  constructor(prev, x, y, length) {
    this.prev = prev;
    this.x = x;
    this.y = y;
    this.length = length;
  }
};
var FastInt32Array = class {
  constructor() {
    this.positiveArr = new Int32Array(10);
    this.negativeArr = new Int32Array(10);
  }
  get(idx) {
    if (idx < 0) {
      idx = -idx - 1;
      return this.negativeArr[idx];
    } else {
      return this.positiveArr[idx];
    }
  }
  set(idx, value) {
    if (idx < 0) {
      idx = -idx - 1;
      if (idx >= this.negativeArr.length) {
        const arr = this.negativeArr;
        this.negativeArr = new Int32Array(arr.length * 2);
        this.negativeArr.set(arr);
      }
      this.negativeArr[idx] = value;
    } else {
      if (idx >= this.positiveArr.length) {
        const arr = this.positiveArr;
        this.positiveArr = new Int32Array(arr.length * 2);
        this.positiveArr.set(arr);
      }
      this.positiveArr[idx] = value;
    }
  }
};
var FastArrayNegativeIndices = class {
  constructor() {
    this.positiveArr = [];
    this.negativeArr = [];
  }
  get(idx) {
    if (idx < 0) {
      idx = -idx - 1;
      return this.negativeArr[idx];
    } else {
      return this.positiveArr[idx];
    }
  }
  set(idx, value) {
    if (idx < 0) {
      idx = -idx - 1;
      this.negativeArr[idx] = value;
    } else {
      this.positiveArr[idx] = value;
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js
init_arrays();
init_arraysFind();
init_map();
init_lineRange();
init_offsetRange();

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js
init_arraysFind();
init_offsetRange();
init_position();
init_range();
var LinesSliceCharSequence = class {
  constructor(lines, lineRange, considerWhitespaceChanges) {
    this.lines = lines;
    this.considerWhitespaceChanges = considerWhitespaceChanges;
    this.elements = [];
    this.firstCharOffsetByLine = [];
    this.additionalOffsetByLine = [];
    let trimFirstLineFully = false;
    if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {
      lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);
      trimFirstLineFully = true;
    }
    this.lineRange = lineRange;
    this.firstCharOffsetByLine[0] = 0;
    for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {
      let line = lines[i];
      let offset = 0;
      if (trimFirstLineFully) {
        offset = line.length;
        line = "";
        trimFirstLineFully = false;
      } else if (!considerWhitespaceChanges) {
        const trimmedStartLine = line.trimStart();
        offset = line.length - trimmedStartLine.length;
        line = trimmedStartLine.trimEnd();
      }
      this.additionalOffsetByLine.push(offset);
      for (let i2 = 0; i2 < line.length; i2++) {
        this.elements.push(line.charCodeAt(i2));
      }
      if (i < lines.length - 1) {
        this.elements.push("\n".charCodeAt(0));
        this.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;
      }
    }
    this.additionalOffsetByLine.push(0);
  }
  toString() {
    return `Slice: "${this.text}"`;
  }
  get text() {
    return this.getText(new OffsetRange(0, this.length));
  }
  getText(range2) {
    return this.elements.slice(range2.start, range2.endExclusive).map((e) => String.fromCharCode(e)).join("");
  }
  getElement(offset) {
    return this.elements[offset];
  }
  get length() {
    return this.elements.length;
  }
  getBoundaryScore(length) {
    const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);
    const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);
    if (prevCategory === 7 && nextCategory === 8) {
      return 0;
    }
    if (prevCategory === 8) {
      return 150;
    }
    let score3 = 0;
    if (prevCategory !== nextCategory) {
      score3 += 10;
      if (prevCategory === 0 && nextCategory === 1) {
        score3 += 1;
      }
    }
    score3 += getCategoryBoundaryScore(prevCategory);
    score3 += getCategoryBoundaryScore(nextCategory);
    return score3;
  }
  translateOffset(offset) {
    if (this.lineRange.isEmpty) {
      return new Position(this.lineRange.start + 1, 1);
    }
    const i = findLastIdxMonotonous(this.firstCharOffsetByLine, (value) => value <= offset);
    return new Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);
  }
  translateRange(range2) {
    return Range2.fromPositions(this.translateOffset(range2.start), this.translateOffset(range2.endExclusive));
  }
  /**
   * Finds the word that contains the character at the given offset
   */
  findWordContaining(offset) {
    if (offset < 0 || offset >= this.elements.length) {
      return void 0;
    }
    if (!isWordChar(this.elements[offset])) {
      return void 0;
    }
    let start = offset;
    while (start > 0 && isWordChar(this.elements[start - 1])) {
      start--;
    }
    let end = offset;
    while (end < this.elements.length && isWordChar(this.elements[end])) {
      end++;
    }
    return new OffsetRange(start, end);
  }
  countLinesIn(range2) {
    return this.translateOffset(range2.endExclusive).lineNumber - this.translateOffset(range2.start).lineNumber;
  }
  isStronglyEqual(offset1, offset2) {
    return this.elements[offset1] === this.elements[offset2];
  }
  extendToFullLines(range2) {
    var _a2, _b2;
    const start = (_a2 = findLastMonotonous(this.firstCharOffsetByLine, (x) => x <= range2.start)) !== null && _a2 !== void 0 ? _a2 : 0;
    const end = (_b2 = findFirstMonotonous(this.firstCharOffsetByLine, (x) => range2.endExclusive <= x)) !== null && _b2 !== void 0 ? _b2 : this.elements.length;
    return new OffsetRange(start, end);
  }
};
function isWordChar(charCode) {
  return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90 || charCode >= 48 && charCode <= 57;
}
var score2 = {
  [
    0
    /* CharBoundaryCategory.WordLower */
  ]: 0,
  [
    1
    /* CharBoundaryCategory.WordUpper */
  ]: 0,
  [
    2
    /* CharBoundaryCategory.WordNumber */
  ]: 0,
  [
    3
    /* CharBoundaryCategory.End */
  ]: 10,
  [
    4
    /* CharBoundaryCategory.Other */
  ]: 2,
  [
    5
    /* CharBoundaryCategory.Separator */
  ]: 30,
  [
    6
    /* CharBoundaryCategory.Space */
  ]: 3,
  [
    7
    /* CharBoundaryCategory.LineBreakCR */
  ]: 10,
  [
    8
    /* CharBoundaryCategory.LineBreakLF */
  ]: 10
};
function getCategoryBoundaryScore(category) {
  return score2[category];
}
function getCategory(charCode) {
  if (charCode === 10) {
    return 8;
  } else if (charCode === 13) {
    return 7;
  } else if (isSpace(charCode)) {
    return 6;
  } else if (charCode >= 97 && charCode <= 122) {
    return 0;
  } else if (charCode >= 65 && charCode <= 90) {
    return 1;
  } else if (charCode >= 48 && charCode <= 57) {
    return 2;
  } else if (charCode === -1) {
    return 3;
  } else if (charCode === 44 || charCode === 59) {
    return 5;
  } else {
    return 4;
  }
}

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js
function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout2) {
  let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout2);
  if (!timeout2.isValid()) {
    return [];
  }
  const filteredChanges = changes.filter((c) => !excludedChanges.has(c));
  const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout2);
  pushMany(moves, unchangedMoves);
  moves = joinCloseConsecutiveMoves(moves);
  moves = moves.filter((current) => {
    const lines = current.original.toOffsetRange().slice(originalLines).map((l) => l.trim());
    const originalText = lines.join("\n");
    return originalText.length >= 15 && countWhere(lines, (l) => l.length >= 2) >= 2;
  });
  moves = removeMovesInSameDiff(changes, moves);
  return moves;
}
function countWhere(arr, predicate) {
  let count = 0;
  for (const t of arr) {
    if (predicate(t)) {
      count++;
    }
  }
  return count;
}
function computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout2) {
  const moves = [];
  const deletions = changes.filter((c) => c.modified.isEmpty && c.original.length >= 3).map((d) => new LineRangeFragment(d.original, originalLines, d));
  const insertions = new Set(changes.filter((c) => c.original.isEmpty && c.modified.length >= 3).map((d) => new LineRangeFragment(d.modified, modifiedLines, d)));
  const excludedChanges = /* @__PURE__ */ new Set();
  for (const deletion of deletions) {
    let highestSimilarity = -1;
    let best;
    for (const insertion of insertions) {
      const similarity = deletion.computeSimilarity(insertion);
      if (similarity > highestSimilarity) {
        highestSimilarity = similarity;
        best = insertion;
      }
    }
    if (highestSimilarity > 0.9 && best) {
      insertions.delete(best);
      moves.push(new LineRangeMapping(deletion.range, best.range));
      excludedChanges.add(deletion.source);
      excludedChanges.add(best.source);
    }
    if (!timeout2.isValid()) {
      return { moves, excludedChanges };
    }
  }
  return { moves, excludedChanges };
}
function computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout2) {
  const moves = [];
  const original3LineHashes = new SetMap();
  for (const change of changes) {
    for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {
      const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;
      original3LineHashes.add(key, { range: new LineRange(i, i + 3) });
    }
  }
  const possibleMappings = [];
  changes.sort(compareBy((c) => c.modified.startLineNumber, numberComparator));
  for (const change of changes) {
    let lastMappings = [];
    for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {
      const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;
      const currentModifiedRange = new LineRange(i, i + 3);
      const nextMappings = [];
      original3LineHashes.forEach(key, ({ range: range2 }) => {
        for (const lastMapping of lastMappings) {
          if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range2.endLineNumberExclusive && lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {
            lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range2.endLineNumberExclusive);
            lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);
            nextMappings.push(lastMapping);
            return;
          }
        }
        const mapping = {
          modifiedLineRange: currentModifiedRange,
          originalLineRange: range2
        };
        possibleMappings.push(mapping);
        nextMappings.push(mapping);
      });
      lastMappings = nextMappings;
    }
    if (!timeout2.isValid()) {
      return [];
    }
  }
  possibleMappings.sort(reverseOrder(compareBy((m) => m.modifiedLineRange.length, numberComparator)));
  const modifiedSet = new LineRangeSet();
  const originalSet = new LineRangeSet();
  for (const mapping of possibleMappings) {
    const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;
    const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);
    const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);
    const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);
    for (const s of modifiedIntersectedSections.ranges) {
      if (s.length < 3) {
        continue;
      }
      const modifiedLineRange = s;
      const originalLineRange = s.delta(-diffOrigToMod);
      moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));
      modifiedSet.addRange(modifiedLineRange);
      originalSet.addRange(originalLineRange);
    }
  }
  moves.sort(compareBy((m) => m.original.startLineNumber, numberComparator));
  const monotonousChanges = new MonotonousArray(changes);
  for (let i = 0; i < moves.length; i++) {
    const move = moves[i];
    const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous((c) => c.original.startLineNumber <= move.original.startLineNumber);
    const firstTouchingChangeMod = findLastMonotonous(changes, (c) => c.modified.startLineNumber <= move.modified.startLineNumber);
    const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);
    const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous((c) => c.original.startLineNumber < move.original.endLineNumberExclusive);
    const lastTouchingChangeMod = findLastMonotonous(changes, (c) => c.modified.startLineNumber < move.modified.endLineNumberExclusive);
    const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);
    let extendToTop;
    for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {
      const origLine = move.original.startLineNumber - extendToTop - 1;
      const modLine = move.modified.startLineNumber - extendToTop - 1;
      if (origLine > originalLines.length || modLine > modifiedLines.length) {
        break;
      }
      if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {
        break;
      }
      if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout2)) {
        break;
      }
    }
    if (extendToTop > 0) {
      originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));
      modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));
    }
    let extendToBottom;
    for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {
      const origLine = move.original.endLineNumberExclusive + extendToBottom;
      const modLine = move.modified.endLineNumberExclusive + extendToBottom;
      if (origLine > originalLines.length || modLine > modifiedLines.length) {
        break;
      }
      if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {
        break;
      }
      if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout2)) {
        break;
      }
    }
    if (extendToBottom > 0) {
      originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));
      modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));
    }
    if (extendToTop > 0 || extendToBottom > 0) {
      moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));
    }
  }
  return moves;
}
function areLinesSimilar(line1, line2, timeout2) {
  if (line1.trim() === line2.trim()) {
    return true;
  }
  if (line1.length > 300 && line2.length > 300) {
    return false;
  }
  const myersDiffingAlgorithm = new MyersDiffAlgorithm();
  const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new OffsetRange(0, 1), false), new LinesSliceCharSequence([line2], new OffsetRange(0, 1), false), timeout2);
  let commonNonSpaceCharCount = 0;
  const inverted = SequenceDiff.invert(result.diffs, line1.length);
  for (const seq of inverted) {
    seq.seq1Range.forEach((idx) => {
      if (!isSpace(line1.charCodeAt(idx))) {
        commonNonSpaceCharCount++;
      }
    });
  }
  function countNonWsChars(str) {
    let count = 0;
    for (let i = 0; i < line1.length; i++) {
      if (!isSpace(str.charCodeAt(i))) {
        count++;
      }
    }
    return count;
  }
  const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);
  const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;
  return r;
}
function joinCloseConsecutiveMoves(moves) {
  if (moves.length === 0) {
    return moves;
  }
  moves.sort(compareBy((m) => m.original.startLineNumber, numberComparator));
  const result = [moves[0]];
  for (let i = 1; i < moves.length; i++) {
    const last = result[result.length - 1];
    const current = moves[i];
    const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;
    const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;
    const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;
    if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {
      result[result.length - 1] = last.join(current);
      continue;
    }
    result.push(current);
  }
  return result;
}
function removeMovesInSameDiff(changes, moves) {
  const changesMonotonous = new MonotonousArray(changes);
  moves = moves.filter((m) => {
    const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous((c) => c.original.startLineNumber < m.original.endLineNumberExclusive) || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));
    const diffBeforeEndOfMoveModified = findLastMonotonous(changes, (c) => c.modified.startLineNumber < m.modified.endLineNumberExclusive);
    const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;
    return differentDiffs;
  });
  return moves;
}

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js
init_arrays();
init_offsetRange();
function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
  let result = sequenceDiffs;
  result = joinSequenceDiffsByShifting(sequence1, sequence2, result);
  result = joinSequenceDiffsByShifting(sequence1, sequence2, result);
  result = shiftSequenceDiffs(sequence1, sequence2, result);
  return result;
}
function joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {
  if (sequenceDiffs.length === 0) {
    return sequenceDiffs;
  }
  const result = [];
  result.push(sequenceDiffs[0]);
  for (let i = 1; i < sequenceDiffs.length; i++) {
    const prevResult = result[result.length - 1];
    let cur = sequenceDiffs[i];
    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
      const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;
      let d;
      for (d = 1; d <= length; d++) {
        if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) || sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {
          break;
        }
      }
      d--;
      if (d === length) {
        result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));
        continue;
      }
      cur = cur.delta(-d);
    }
    result.push(cur);
  }
  const result2 = [];
  for (let i = 0; i < result.length - 1; i++) {
    const nextResult = result[i + 1];
    let cur = result[i];
    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
      const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;
      let d;
      for (d = 0; d < length; d++) {
        if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) || !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {
          break;
        }
      }
      if (d === length) {
        result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));
        continue;
      }
      if (d > 0) {
        cur = cur.delta(d);
      }
    }
    result2.push(cur);
  }
  if (result.length > 0) {
    result2.push(result[result.length - 1]);
  }
  return result2;
}
function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
  if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {
    return sequenceDiffs;
  }
  for (let i = 0; i < sequenceDiffs.length; i++) {
    const prevDiff = i > 0 ? sequenceDiffs[i - 1] : void 0;
    const diff = sequenceDiffs[i];
    const nextDiff = i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : void 0;
    const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);
    const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);
    if (diff.seq1Range.isEmpty) {
      sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);
    } else if (diff.seq2Range.isEmpty) {
      sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();
    }
  }
  return sequenceDiffs;
}
function shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {
  const maxShiftLimit = 100;
  let deltaBefore = 1;
  while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start && diff.seq2Range.start - deltaBefore >= seq2ValidRange.start && sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {
    deltaBefore++;
  }
  deltaBefore--;
  let deltaAfter = 0;
  while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive && diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive && sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {
    deltaAfter++;
  }
  if (deltaBefore === 0 && deltaAfter === 0) {
    return diff;
  }
  let bestDelta = 0;
  let bestScore = -1;
  for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {
    const seq2OffsetStart = diff.seq2Range.start + delta;
    const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;
    const seq1Offset = diff.seq1Range.start + delta;
    const score3 = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);
    if (score3 > bestScore) {
      bestScore = score3;
      bestDelta = delta;
    }
  }
  return diff.delta(bestDelta);
}
function removeShortMatches(sequence1, sequence2, sequenceDiffs) {
  const result = [];
  for (const s of sequenceDiffs) {
    const last = result[result.length - 1];
    if (!last) {
      result.push(s);
      continue;
    }
    if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {
      result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));
    } else {
      result.push(s);
    }
  }
  return result;
}
function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {
  const equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);
  const additional = [];
  let lastPoint = new OffsetPair(0, 0);
  function scanWord(pair, equalMapping) {
    if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {
      return;
    }
    const w1 = sequence1.findWordContaining(pair.offset1);
    const w2 = sequence2.findWordContaining(pair.offset2);
    if (!w1 || !w2) {
      return;
    }
    let w = new SequenceDiff(w1, w2);
    const equalPart = w.intersect(equalMapping);
    let equalChars1 = equalPart.seq1Range.length;
    let equalChars2 = equalPart.seq2Range.length;
    while (equalMappings.length > 0) {
      const next = equalMappings[0];
      const intersects2 = next.seq1Range.intersects(w1) || next.seq2Range.intersects(w2);
      if (!intersects2) {
        break;
      }
      const v1 = sequence1.findWordContaining(next.seq1Range.start);
      const v2 = sequence2.findWordContaining(next.seq2Range.start);
      const v = new SequenceDiff(v1, v2);
      const equalPart2 = v.intersect(next);
      equalChars1 += equalPart2.seq1Range.length;
      equalChars2 += equalPart2.seq2Range.length;
      w = w.join(v);
      if (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {
        equalMappings.shift();
      } else {
        break;
      }
    }
    if (equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {
      additional.push(w);
    }
    lastPoint = w.getEndExclusives();
  }
  while (equalMappings.length > 0) {
    const next = equalMappings.shift();
    if (next.seq1Range.isEmpty) {
      continue;
    }
    scanWord(next.getStarts(), next);
    scanWord(next.getEndExclusives().delta(-1), next);
  }
  const merged = mergeSequenceDiffs(sequenceDiffs, additional);
  return merged;
}
function mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {
  const result = [];
  while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {
    const sd1 = sequenceDiffs1[0];
    const sd2 = sequenceDiffs2[0];
    let next;
    if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {
      next = sequenceDiffs1.shift();
    } else {
      next = sequenceDiffs2.shift();
    }
    if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {
      result[result.length - 1] = result[result.length - 1].join(next);
    } else {
      result.push(next);
    }
  }
  return result;
}
function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {
  let diffs = sequenceDiffs;
  if (diffs.length === 0) {
    return diffs;
  }
  let counter = 0;
  let shouldRepeat;
  do {
    shouldRepeat = false;
    const result = [
      diffs[0]
    ];
    for (let i = 1; i < diffs.length; i++) {
      let shouldJoinDiffs = function(before, after2) {
        const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
        const unchangedText = sequence1.getText(unchangedRange);
        const unchangedTextWithoutWs = unchangedText.replace(/\s/g, "");
        if (unchangedTextWithoutWs.length <= 4 && (before.seq1Range.length + before.seq2Range.length > 5 || after2.seq1Range.length + after2.seq2Range.length > 5)) {
          return true;
        }
        return false;
      };
      const cur = diffs[i];
      const lastResult = result[result.length - 1];
      const shouldJoin = shouldJoinDiffs(lastResult, cur);
      if (shouldJoin) {
        shouldRepeat = true;
        result[result.length - 1] = result[result.length - 1].join(cur);
      } else {
        result.push(cur);
      }
    }
    diffs = result;
  } while (counter++ < 10 && shouldRepeat);
  return diffs;
}
function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {
  let diffs = sequenceDiffs;
  if (diffs.length === 0) {
    return diffs;
  }
  let counter = 0;
  let shouldRepeat;
  do {
    shouldRepeat = false;
    const result = [
      diffs[0]
    ];
    for (let i = 1; i < diffs.length; i++) {
      let shouldJoinDiffs = function(before, after2) {
        const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
        const unchangedLineCount = sequence1.countLinesIn(unchangedRange);
        if (unchangedLineCount > 5 || unchangedRange.length > 500) {
          return false;
        }
        const unchangedText = sequence1.getText(unchangedRange).trim();
        if (unchangedText.length > 20 || unchangedText.split(/\r\n|\r|\n/).length > 1) {
          return false;
        }
        const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);
        const beforeSeq1Length = before.seq1Range.length;
        const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);
        const beforeSeq2Length = before.seq2Range.length;
        const afterLineCount1 = sequence1.countLinesIn(after2.seq1Range);
        const afterSeq1Length = after2.seq1Range.length;
        const afterLineCount2 = sequence2.countLinesIn(after2.seq2Range);
        const afterSeq2Length = after2.seq2Range.length;
        const max = 2 * 40 + 50;
        function cap(v) {
          return Math.min(v, max);
        }
        if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5) + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > (max ** 1.5) ** 1.5 * 1.3) {
          return true;
        }
        return false;
      };
      const cur = diffs[i];
      const lastResult = result[result.length - 1];
      const shouldJoin = shouldJoinDiffs(lastResult, cur);
      if (shouldJoin) {
        shouldRepeat = true;
        result[result.length - 1] = result[result.length - 1].join(cur);
      } else {
        result.push(cur);
      }
    }
    diffs = result;
  } while (counter++ < 10 && shouldRepeat);
  const newDiffs = [];
  forEachWithNeighbors(diffs, (prev, cur, next) => {
    let newDiff = cur;
    function shouldMarkAsChanged(text) {
      return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;
    }
    const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);
    const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));
    if (shouldMarkAsChanged(prefix)) {
      newDiff = newDiff.deltaStart(-prefix.length);
    }
    const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));
    if (shouldMarkAsChanged(suffix)) {
      newDiff = newDiff.deltaEnd(suffix.length);
    }
    const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);
    const result = newDiff.intersect(availableSpace);
    if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {
      newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);
    } else {
      newDiffs.push(result);
    }
  });
  return newDiffs;
}

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js
var LineSequence2 = class {
  constructor(trimmedHash, lines) {
    this.trimmedHash = trimmedHash;
    this.lines = lines;
  }
  getElement(offset) {
    return this.trimmedHash[offset];
  }
  get length() {
    return this.trimmedHash.length;
  }
  getBoundaryScore(length) {
    const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);
    const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);
    return 1e3 - (indentationBefore + indentationAfter);
  }
  getText(range2) {
    return this.lines.slice(range2.start, range2.endExclusive).join("\n");
  }
  isStronglyEqual(offset1, offset2) {
    return this.lines[offset1] === this.lines[offset2];
  }
};
function getIndentation(str) {
  let i = 0;
  while (i < str.length && (str.charCodeAt(i) === 32 || str.charCodeAt(i) === 9)) {
    i++;
  }
  return i;
}

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js
var DefaultLinesDiffComputer = class {
  constructor() {
    this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();
    this.myersDiffingAlgorithm = new MyersDiffAlgorithm();
  }
  computeDiff(originalLines, modifiedLines, options2) {
    if (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {
      return new LinesDiff([], [], false);
    }
    if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {
      return new LinesDiff([
        new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [
          new RangeMapping(new Range2(1, 1, originalLines.length, originalLines[0].length + 1), new Range2(1, 1, modifiedLines.length, modifiedLines[0].length + 1))
        ])
      ], [], false);
    }
    const timeout2 = options2.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options2.maxComputationTimeMs);
    const considerWhitespaceChanges = !options2.ignoreTrimWhitespace;
    const perfectHashes = /* @__PURE__ */ new Map();
    function getOrCreateHash(text) {
      let hash2 = perfectHashes.get(text);
      if (hash2 === void 0) {
        hash2 = perfectHashes.size;
        perfectHashes.set(text, hash2);
      }
      return hash2;
    }
    const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));
    const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));
    const sequence1 = new LineSequence2(originalLinesHashes, originalLines);
    const sequence2 = new LineSequence2(modifiedLinesHashes, modifiedLines);
    const lineAlignmentResult = (() => {
      if (sequence1.length + sequence2.length < 1700) {
        return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout2, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99);
      }
      return this.myersDiffingAlgorithm.compute(sequence1, sequence2);
    })();
    let lineAlignments = lineAlignmentResult.diffs;
    let hitTimeout = lineAlignmentResult.hitTimeout;
    lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);
    lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);
    const alignments = [];
    const scanForWhitespaceChanges = (equalLinesCount) => {
      if (!considerWhitespaceChanges) {
        return;
      }
      for (let i = 0; i < equalLinesCount; i++) {
        const seq1Offset = seq1LastStart + i;
        const seq2Offset = seq2LastStart + i;
        if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {
          const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout2, considerWhitespaceChanges);
          for (const a of characterDiffs.mappings) {
            alignments.push(a);
          }
          if (characterDiffs.hitTimeout) {
            hitTimeout = true;
          }
        }
      }
    };
    let seq1LastStart = 0;
    let seq2LastStart = 0;
    for (const diff of lineAlignments) {
      assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);
      const equalLinesCount = diff.seq1Range.start - seq1LastStart;
      scanForWhitespaceChanges(equalLinesCount);
      seq1LastStart = diff.seq1Range.endExclusive;
      seq2LastStart = diff.seq2Range.endExclusive;
      const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout2, considerWhitespaceChanges);
      if (characterDiffs.hitTimeout) {
        hitTimeout = true;
      }
      for (const a of characterDiffs.mappings) {
        alignments.push(a);
      }
    }
    scanForWhitespaceChanges(originalLines.length - seq1LastStart);
    const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);
    let moves = [];
    if (options2.computeMoves) {
      moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout2, considerWhitespaceChanges);
    }
    assertFn(() => {
      function validatePosition(pos, lines) {
        if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {
          return false;
        }
        const line = lines[pos.lineNumber - 1];
        if (pos.column < 1 || pos.column > line.length + 1) {
          return false;
        }
        return true;
      }
      function validateRange(range2, lines) {
        if (range2.startLineNumber < 1 || range2.startLineNumber > lines.length + 1) {
          return false;
        }
        if (range2.endLineNumberExclusive < 1 || range2.endLineNumberExclusive > lines.length + 1) {
          return false;
        }
        return true;
      }
      for (const c of changes) {
        if (!c.innerChanges) {
          return false;
        }
        for (const ic of c.innerChanges) {
          const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) && validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);
          if (!valid) {
            return false;
          }
        }
        if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {
          return false;
        }
      }
      return true;
    });
    return new LinesDiff(changes, moves, hitTimeout);
  }
  computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout2, considerWhitespaceChanges) {
    const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout2);
    const movesWithDiffs = moves.map((m) => {
      const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout2, considerWhitespaceChanges);
      const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);
      return new MovedText(m, mappings);
    });
    return movesWithDiffs;
  }
  refineDiff(originalLines, modifiedLines, diff, timeout2, considerWhitespaceChanges) {
    const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);
    const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);
    const diffResult = slice1.length + slice2.length < 500 ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout2) : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout2);
    let diffs = diffResult.diffs;
    diffs = optimizeSequenceDiffs(slice1, slice2, diffs);
    diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);
    diffs = removeShortMatches(slice1, slice2, diffs);
    diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);
    const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));
    return {
      mappings: result,
      hitTimeout: diffResult.hitTimeout
    };
  }
};
function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {
  const changes = [];
  for (const g of groupAdjacentBy(alignments.map((a) => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original) || a1.modified.overlapOrTouch(a2.modified))) {
    const first = g[0];
    const last = g[g.length - 1];
    changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map((a) => a.innerChanges[0])));
  }
  assertFn(() => {
    if (!dontAssertStartLine) {
      if (changes.length > 0 && changes[0].original.startLineNumber !== changes[0].modified.startLineNumber) {
        return false;
      }
    }
    return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
    m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);
  });
  return changes;
}
function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {
  let lineStartDelta = 0;
  let lineEndDelta = 0;
  if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1 && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {
    lineEndDelta = -1;
  }
  if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {
    lineStartDelta = 1;
  }
  const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);
  const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);
  return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);
}

// node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js
var linesDiffComputers = {
  getLegacy: () => new LegacyLinesDiffComputer(),
  getDefault: () => new DefaultLinesDiffComputer()
};

// node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
init_objects();

// node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js
init_color();
function _parseCaptureGroups(captureGroups) {
  const values = [];
  for (const captureGroup of captureGroups) {
    const parsedNumber = Number(captureGroup);
    if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\s/g, "") !== "") {
      values.push(parsedNumber);
    }
  }
  return values;
}
function _toIColor(r, g, b, a) {
  return {
    red: r / 255,
    blue: b / 255,
    green: g / 255,
    alpha: a
  };
}
function _findRange(model, match2) {
  const index = match2.index;
  const length = match2[0].length;
  if (!index) {
    return;
  }
  const startPosition = model.positionAt(index);
  const range2 = {
    startLineNumber: startPosition.lineNumber,
    startColumn: startPosition.column,
    endLineNumber: startPosition.lineNumber,
    endColumn: startPosition.column + length
  };
  return range2;
}
function _findHexColorInformation(range2, hexValue) {
  if (!range2) {
    return;
  }
  const parsedHexColor = Color.Format.CSS.parseHex(hexValue);
  if (!parsedHexColor) {
    return;
  }
  return {
    range: range2,
    color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)
  };
}
function _findRGBColorInformation(range2, matches, isAlpha) {
  if (!range2 || matches.length !== 1) {
    return;
  }
  const match2 = matches[0];
  const captureGroups = match2.values();
  const parsedRegex = _parseCaptureGroups(captureGroups);
  return {
    range: range2,
    color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)
  };
}
function _findHSLColorInformation(range2, matches, isAlpha) {
  if (!range2 || matches.length !== 1) {
    return;
  }
  const match2 = matches[0];
  const captureGroups = match2.values();
  const parsedRegex = _parseCaptureGroups(captureGroups);
  const colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));
  return {
    range: range2,
    color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)
  };
}
function _findMatches(model, regex) {
  if (typeof model === "string") {
    return [...model.matchAll(regex)];
  } else {
    return model.findMatches(regex);
  }
}
function computeColors(model) {
  const result = [];
  const initialValidationRegex = /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm;
  const initialValidationMatches = _findMatches(model, initialValidationRegex);
  if (initialValidationMatches.length > 0) {
    for (const initialMatch of initialValidationMatches) {
      const initialCaptureGroups = initialMatch.filter((captureGroup) => captureGroup !== void 0);
      const colorScheme = initialCaptureGroups[1];
      const colorParameters = initialCaptureGroups[2];
      if (!colorParameters) {
        continue;
      }
      let colorInformation;
      if (colorScheme === "rgb") {
        const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm;
        colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
      } else if (colorScheme === "rgba") {
        const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
        colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
      } else if (colorScheme === "hsl") {
        const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm;
        colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
      } else if (colorScheme === "hsla") {
        const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
        colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
      } else if (colorScheme === "#") {
        colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);
      }
      if (colorInformation) {
        result.push(colorInformation);
      }
    }
  }
  return result;
}
function computeDefaultDocumentColors(model) {
  if (!model || typeof model.getValue !== "function" || typeof model.positionAt !== "function") {
    return [];
  }
  return computeColors(model);
}

// node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
var MirrorModel = class extends MirrorTextModel {
  get uri() {
    return this._uri;
  }
  get eol() {
    return this._eol;
  }
  getValue() {
    return this.getText();
  }
  findMatches(regex) {
    const matches = [];
    for (let i = 0; i < this._lines.length; i++) {
      const line = this._lines[i];
      const offsetToAdd = this.offsetAt(new Position(i + 1, 1));
      const iteratorOverMatches = line.matchAll(regex);
      for (const match2 of iteratorOverMatches) {
        if (match2.index || match2.index === 0) {
          match2.index = match2.index + offsetToAdd;
        }
        matches.push(match2);
      }
    }
    return matches;
  }
  getLinesContent() {
    return this._lines.slice(0);
  }
  getLineCount() {
    return this._lines.length;
  }
  getLineContent(lineNumber) {
    return this._lines[lineNumber - 1];
  }
  getWordAtPosition(position, wordDefinition) {
    const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);
    if (wordAtText) {
      return new Range2(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);
    }
    return null;
  }
  words(wordDefinition) {
    const lines = this._lines;
    const wordenize = this._wordenize.bind(this);
    let lineNumber = 0;
    let lineText = "";
    let wordRangesIdx = 0;
    let wordRanges = [];
    return {
      *[Symbol.iterator]() {
        while (true) {
          if (wordRangesIdx < wordRanges.length) {
            const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
            wordRangesIdx += 1;
            yield value;
          } else {
            if (lineNumber < lines.length) {
              lineText = lines[lineNumber];
              wordRanges = wordenize(lineText, wordDefinition);
              wordRangesIdx = 0;
              lineNumber += 1;
            } else {
              break;
            }
          }
        }
      }
    };
  }
  getLineWords(lineNumber, wordDefinition) {
    const content = this._lines[lineNumber - 1];
    const ranges = this._wordenize(content, wordDefinition);
    const words = [];
    for (const range2 of ranges) {
      words.push({
        word: content.substring(range2.start, range2.end),
        startColumn: range2.start + 1,
        endColumn: range2.end + 1
      });
    }
    return words;
  }
  _wordenize(content, wordDefinition) {
    const result = [];
    let match2;
    wordDefinition.lastIndex = 0;
    while (match2 = wordDefinition.exec(content)) {
      if (match2[0].length === 0) {
        break;
      }
      result.push({ start: match2.index, end: match2.index + match2[0].length });
    }
    return result;
  }
  getValueInRange(range2) {
    range2 = this._validateRange(range2);
    if (range2.startLineNumber === range2.endLineNumber) {
      return this._lines[range2.startLineNumber - 1].substring(range2.startColumn - 1, range2.endColumn - 1);
    }
    const lineEnding = this._eol;
    const startLineIndex = range2.startLineNumber - 1;
    const endLineIndex = range2.endLineNumber - 1;
    const resultLines = [];
    resultLines.push(this._lines[startLineIndex].substring(range2.startColumn - 1));
    for (let i = startLineIndex + 1; i < endLineIndex; i++) {
      resultLines.push(this._lines[i]);
    }
    resultLines.push(this._lines[endLineIndex].substring(0, range2.endColumn - 1));
    return resultLines.join(lineEnding);
  }
  offsetAt(position) {
    position = this._validatePosition(position);
    this._ensureLineStarts();
    return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);
  }
  positionAt(offset) {
    offset = Math.floor(offset);
    offset = Math.max(0, offset);
    this._ensureLineStarts();
    const out = this._lineStarts.getIndexOf(offset);
    const lineLength = this._lines[out.index].length;
    return {
      lineNumber: 1 + out.index,
      column: 1 + Math.min(out.remainder, lineLength)
    };
  }
  _validateRange(range2) {
    const start = this._validatePosition({ lineNumber: range2.startLineNumber, column: range2.startColumn });
    const end = this._validatePosition({ lineNumber: range2.endLineNumber, column: range2.endColumn });
    if (start.lineNumber !== range2.startLineNumber || start.column !== range2.startColumn || end.lineNumber !== range2.endLineNumber || end.column !== range2.endColumn) {
      return {
        startLineNumber: start.lineNumber,
        startColumn: start.column,
        endLineNumber: end.lineNumber,
        endColumn: end.column
      };
    }
    return range2;
  }
  _validatePosition(position) {
    if (!Position.isIPosition(position)) {
      throw new Error("bad position");
    }
    let { lineNumber, column } = position;
    let hasChanged = false;
    if (lineNumber < 1) {
      lineNumber = 1;
      column = 1;
      hasChanged = true;
    } else if (lineNumber > this._lines.length) {
      lineNumber = this._lines.length;
      column = this._lines[lineNumber - 1].length + 1;
      hasChanged = true;
    } else {
      const maxCharacter = this._lines[lineNumber - 1].length + 1;
      if (column < 1) {
        column = 1;
        hasChanged = true;
      } else if (column > maxCharacter) {
        column = maxCharacter;
        hasChanged = true;
      }
    }
    if (!hasChanged) {
      return position;
    } else {
      return { lineNumber, column };
    }
  }
};
var EditorSimpleWorker = class _EditorSimpleWorker {
  constructor(host, foreignModuleFactory) {
    this._host = host;
    this._models = /* @__PURE__ */ Object.create(null);
    this._foreignModuleFactory = foreignModuleFactory;
    this._foreignModule = null;
  }
  dispose() {
    this._models = /* @__PURE__ */ Object.create(null);
  }
  _getModel(uri) {
    return this._models[uri];
  }
  _getModels() {
    const all = [];
    Object.keys(this._models).forEach((key) => all.push(this._models[key]));
    return all;
  }
  acceptNewModel(data) {
    this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);
  }
  acceptModelChanged(strURL, e) {
    if (!this._models[strURL]) {
      return;
    }
    const model = this._models[strURL];
    model.onEvents(e);
  }
  acceptRemovedModel(strURL) {
    if (!this._models[strURL]) {
      return;
    }
    delete this._models[strURL];
  }
  async computeUnicodeHighlights(url, options2, range2) {
    const model = this._getModel(url);
    if (!model) {
      return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
    }
    return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options2, range2);
  }
  // ---- BEGIN diff --------------------------------------------------------------------------
  async computeDiff(originalUrl, modifiedUrl, options2, algorithm) {
    const original = this._getModel(originalUrl);
    const modified = this._getModel(modifiedUrl);
    if (!original || !modified) {
      return null;
    }
    const result = _EditorSimpleWorker.computeDiff(original, modified, options2, algorithm);
    return result;
  }
  static computeDiff(originalTextModel, modifiedTextModel, options2, algorithm) {
    const diffAlgorithm = algorithm === "advanced" ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();
    const originalLines = originalTextModel.getLinesContent();
    const modifiedLines = modifiedTextModel.getLinesContent();
    const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options2);
    const identical = result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel);
    function getLineChanges(changes) {
      return changes.map((m) => {
        var _a2;
        return [m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, (_a2 = m.innerChanges) === null || _a2 === void 0 ? void 0 : _a2.map((m2) => [
          m2.originalRange.startLineNumber,
          m2.originalRange.startColumn,
          m2.originalRange.endLineNumber,
          m2.originalRange.endColumn,
          m2.modifiedRange.startLineNumber,
          m2.modifiedRange.startColumn,
          m2.modifiedRange.endLineNumber,
          m2.modifiedRange.endColumn
        ])];
      });
    }
    return {
      identical,
      quitEarly: result.hitTimeout,
      changes: getLineChanges(result.changes),
      moves: result.moves.map((m) => [
        m.lineRangeMapping.original.startLineNumber,
        m.lineRangeMapping.original.endLineNumberExclusive,
        m.lineRangeMapping.modified.startLineNumber,
        m.lineRangeMapping.modified.endLineNumberExclusive,
        getLineChanges(m.changes)
      ])
    };
  }
  static _modelsAreIdentical(original, modified) {
    const originalLineCount = original.getLineCount();
    const modifiedLineCount = modified.getLineCount();
    if (originalLineCount !== modifiedLineCount) {
      return false;
    }
    for (let line = 1; line <= originalLineCount; line++) {
      const originalLine = original.getLineContent(line);
      const modifiedLine = modified.getLineContent(line);
      if (originalLine !== modifiedLine) {
        return false;
      }
    }
    return true;
  }
  async computeMoreMinimalEdits(modelUrl, edits, pretty) {
    const model = this._getModel(modelUrl);
    if (!model) {
      return edits;
    }
    const result = [];
    let lastEol = void 0;
    edits = edits.slice(0).sort((a, b) => {
      if (a.range && b.range) {
        return Range2.compareRangesUsingStarts(a.range, b.range);
      }
      const aRng = a.range ? 0 : 1;
      const bRng = b.range ? 0 : 1;
      return aRng - bRng;
    });
    let writeIndex = 0;
    for (let readIndex = 1; readIndex < edits.length; readIndex++) {
      if (Range2.getEndPosition(edits[writeIndex].range).equals(Range2.getStartPosition(edits[readIndex].range))) {
        edits[writeIndex].range = Range2.fromPositions(Range2.getStartPosition(edits[writeIndex].range), Range2.getEndPosition(edits[readIndex].range));
        edits[writeIndex].text += edits[readIndex].text;
      } else {
        writeIndex++;
        edits[writeIndex] = edits[readIndex];
      }
    }
    edits.length = writeIndex + 1;
    for (let { range: range2, text, eol } of edits) {
      if (typeof eol === "number") {
        lastEol = eol;
      }
      if (Range2.isEmpty(range2) && !text) {
        continue;
      }
      const original = model.getValueInRange(range2);
      text = text.replace(/\r\n|\n|\r/g, model.eol);
      if (original === text) {
        continue;
      }
      if (Math.max(text.length, original.length) > _EditorSimpleWorker._diffLimit) {
        result.push({ range: range2, text });
        continue;
      }
      const changes = stringDiff(original, text, pretty);
      const editOffset = model.offsetAt(Range2.lift(range2).getStartPosition());
      for (const change of changes) {
        const start = model.positionAt(editOffset + change.originalStart);
        const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
        const newEdit = {
          text: text.substr(change.modifiedStart, change.modifiedLength),
          range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
        };
        if (model.getValueInRange(newEdit.range) !== newEdit.text) {
          result.push(newEdit);
        }
      }
    }
    if (typeof lastEol === "number") {
      result.push({ eol: lastEol, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
    }
    return result;
  }
  // ---- END minimal edits ---------------------------------------------------------------
  async computeLinks(modelUrl) {
    const model = this._getModel(modelUrl);
    if (!model) {
      return null;
    }
    return computeLinks(model);
  }
  // --- BEGIN default document colors -----------------------------------------------------------
  async computeDefaultDocumentColors(modelUrl) {
    const model = this._getModel(modelUrl);
    if (!model) {
      return null;
    }
    return computeDefaultDocumentColors(model);
  }
  async textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
    const sw = new StopWatch();
    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
    const seen = /* @__PURE__ */ new Set();
    outer:
      for (const url of modelUrls) {
        const model = this._getModel(url);
        if (!model) {
          continue;
        }
        for (const word of model.words(wordDefRegExp)) {
          if (word === leadingWord || !isNaN(Number(word))) {
            continue;
          }
          seen.add(word);
          if (seen.size > _EditorSimpleWorker._suggestionsLimit) {
            break outer;
          }
        }
      }
    return { words: Array.from(seen), duration: sw.elapsed() };
  }
  // ---- END suggest --------------------------------------------------------------------------
  //#region -- word ranges --
  async computeWordRanges(modelUrl, range2, wordDef, wordDefFlags) {
    const model = this._getModel(modelUrl);
    if (!model) {
      return /* @__PURE__ */ Object.create(null);
    }
    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
    const result = /* @__PURE__ */ Object.create(null);
    for (let line = range2.startLineNumber; line < range2.endLineNumber; line++) {
      const words = model.getLineWords(line, wordDefRegExp);
      for (const word of words) {
        if (!isNaN(Number(word.word))) {
          continue;
        }
        let array = result[word.word];
        if (!array) {
          array = [];
          result[word.word] = array;
        }
        array.push({
          startLineNumber: line,
          startColumn: word.startColumn,
          endLineNumber: line,
          endColumn: word.endColumn
        });
      }
    }
    return result;
  }
  //#endregion
  async navigateValueSet(modelUrl, range2, up, wordDef, wordDefFlags) {
    const model = this._getModel(modelUrl);
    if (!model) {
      return null;
    }
    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
    if (range2.startColumn === range2.endColumn) {
      range2 = {
        startLineNumber: range2.startLineNumber,
        startColumn: range2.startColumn,
        endLineNumber: range2.endLineNumber,
        endColumn: range2.endColumn + 1
      };
    }
    const selectionText = model.getValueInRange(range2);
    const wordRange = model.getWordAtPosition({ lineNumber: range2.startLineNumber, column: range2.startColumn }, wordDefRegExp);
    if (!wordRange) {
      return null;
    }
    const word = model.getValueInRange(wordRange);
    const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range2, selectionText, wordRange, word, up);
    return result;
  }
  // ---- BEGIN foreign module support --------------------------------------------------------------------------
  loadForeignModule(moduleId, createData, foreignHostMethods) {
    const proxyMethodRequest = (method, args) => {
      return this._host.fhr(method, args);
    };
    const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);
    const ctx = {
      host: foreignHost,
      getMirrorModels: () => {
        return this._getModels();
      }
    };
    if (this._foreignModuleFactory) {
      this._foreignModule = this._foreignModuleFactory(ctx, createData);
      return Promise.resolve(getAllMethodNames(this._foreignModule));
    }
    return Promise.reject(new Error(`Unexpected usage`));
  }
  // foreign method request
  fmr(method, args) {
    if (!this._foreignModule || typeof this._foreignModule[method] !== "function") {
      return Promise.reject(new Error("Missing requestHandler or method: " + method));
    }
    try {
      return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
    } catch (e) {
      return Promise.reject(e);
    }
  }
};
EditorSimpleWorker._diffLimit = 1e5;
EditorSimpleWorker._suggestionsLimit = 1e4;
if (typeof importScripts === "function") {
  globalThis.monaco = createMonacoBaseAPI();
}

// node_modules/monaco-editor/esm/vs/editor/browser/services/editorWorkerService.js
init_model2();
init_arrays();
init_log();
init_stopwatch();
init_errors();
init_languageFeatures();
init_lineRange();
init_window();
init_dom();
var __decorate20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param17 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var STOP_SYNC_MODEL_DELTA_TIME_MS = 60 * 1e3;
var STOP_WORKER_DELTA_TIME_MS = 5 * 60 * 1e3;
function canSyncModel(modelService, resource) {
  const model = modelService.getModel(resource);
  if (!model) {
    return false;
  }
  if (model.isTooLargeForSyncing()) {
    return false;
  }
  return true;
}
var EditorWorkerService = class EditorWorkerService2 extends Disposable {
  constructor(modelService, configurationService, logService, languageConfigurationService, languageFeaturesService) {
    super();
    this._modelService = modelService;
    this._workerManager = this._register(new WorkerManager(this._modelService, languageConfigurationService));
    this._logService = logService;
    this._register(languageFeaturesService.linkProvider.register({ language: "*", hasAccessToAllModels: true }, {
      provideLinks: (model, token) => {
        if (!canSyncModel(this._modelService, model.uri)) {
          return Promise.resolve({ links: [] });
        }
        return this._workerManager.withWorker().then((client) => client.computeLinks(model.uri)).then((links) => {
          return links && { links };
        });
      }
    }));
    this._register(languageFeaturesService.completionProvider.register("*", new WordBasedCompletionItemProvider(this._workerManager, configurationService, this._modelService, languageConfigurationService)));
  }
  dispose() {
    super.dispose();
  }
  canComputeUnicodeHighlights(uri) {
    return canSyncModel(this._modelService, uri);
  }
  computedUnicodeHighlights(uri, options2, range2) {
    return this._workerManager.withWorker().then((client) => client.computedUnicodeHighlights(uri, options2, range2));
  }
  async computeDiff(original, modified, options2, algorithm) {
    const result = await this._workerManager.withWorker().then((client) => client.computeDiff(original, modified, options2, algorithm));
    if (!result) {
      return null;
    }
    const diff = {
      identical: result.identical,
      quitEarly: result.quitEarly,
      changes: toLineRangeMappings(result.changes),
      moves: result.moves.map((m) => new MovedText(new LineRangeMapping(new LineRange(m[0], m[1]), new LineRange(m[2], m[3])), toLineRangeMappings(m[4])))
    };
    return diff;
    function toLineRangeMappings(changes) {
      return changes.map((c) => {
        var _a2;
        return new DetailedLineRangeMapping(new LineRange(c[0], c[1]), new LineRange(c[2], c[3]), (_a2 = c[4]) === null || _a2 === void 0 ? void 0 : _a2.map((c2) => new RangeMapping(new Range2(c2[0], c2[1], c2[2], c2[3]), new Range2(c2[4], c2[5], c2[6], c2[7]))));
      });
    }
  }
  computeMoreMinimalEdits(resource, edits, pretty = false) {
    if (isNonEmptyArray(edits)) {
      if (!canSyncModel(this._modelService, resource)) {
        return Promise.resolve(edits);
      }
      const sw = StopWatch.create();
      const result = this._workerManager.withWorker().then((client) => client.computeMoreMinimalEdits(resource, edits, pretty));
      result.finally(() => this._logService.trace("FORMAT#computeMoreMinimalEdits", resource.toString(true), sw.elapsed()));
      return Promise.race([result, timeout(1e3).then(() => edits)]);
    } else {
      return Promise.resolve(void 0);
    }
  }
  canNavigateValueSet(resource) {
    return canSyncModel(this._modelService, resource);
  }
  navigateValueSet(resource, range2, up) {
    return this._workerManager.withWorker().then((client) => client.navigateValueSet(resource, range2, up));
  }
  canComputeWordRanges(resource) {
    return canSyncModel(this._modelService, resource);
  }
  computeWordRanges(resource, range2) {
    return this._workerManager.withWorker().then((client) => client.computeWordRanges(resource, range2));
  }
};
EditorWorkerService = __decorate20([
  __param17(0, IModelService),
  __param17(1, ITextResourceConfigurationService),
  __param17(2, ILogService),
  __param17(3, ILanguageConfigurationService),
  __param17(4, ILanguageFeaturesService)
], EditorWorkerService);
var WordBasedCompletionItemProvider = class {
  constructor(workerManager, configurationService, modelService, languageConfigurationService) {
    this.languageConfigurationService = languageConfigurationService;
    this._debugDisplayName = "wordbasedCompletions";
    this._workerManager = workerManager;
    this._configurationService = configurationService;
    this._modelService = modelService;
  }
  async provideCompletionItems(model, position) {
    const config = this._configurationService.getValue(model.uri, position, "editor");
    if (config.wordBasedSuggestions === "off") {
      return void 0;
    }
    const models = [];
    if (config.wordBasedSuggestions === "currentDocument") {
      if (canSyncModel(this._modelService, model.uri)) {
        models.push(model.uri);
      }
    } else {
      for (const candidate of this._modelService.getModels()) {
        if (!canSyncModel(this._modelService, candidate.uri)) {
          continue;
        }
        if (candidate === model) {
          models.unshift(candidate.uri);
        } else if (config.wordBasedSuggestions === "allDocuments" || candidate.getLanguageId() === model.getLanguageId()) {
          models.push(candidate.uri);
        }
      }
    }
    if (models.length === 0) {
      return void 0;
    }
    const wordDefRegExp = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();
    const word = model.getWordAtPosition(position);
    const replace = !word ? Range2.fromPositions(position) : new Range2(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
    const insert = replace.setEndPosition(position.lineNumber, position.column);
    const client = await this._workerManager.withWorker();
    const data = await client.textualSuggest(models, word === null || word === void 0 ? void 0 : word.word, wordDefRegExp);
    if (!data) {
      return void 0;
    }
    return {
      duration: data.duration,
      suggestions: data.words.map((word2) => {
        return {
          kind: 18,
          label: word2,
          insertText: word2,
          range: { insert, replace }
        };
      })
    };
  }
};
var WorkerManager = class extends Disposable {
  constructor(modelService, languageConfigurationService) {
    super();
    this.languageConfigurationService = languageConfigurationService;
    this._modelService = modelService;
    this._editorWorkerClient = null;
    this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime();
    const stopWorkerInterval = this._register(new WindowIntervalTimer());
    stopWorkerInterval.cancelAndSet(() => this._checkStopIdleWorker(), Math.round(STOP_WORKER_DELTA_TIME_MS / 2), $window);
    this._register(this._modelService.onModelRemoved((_) => this._checkStopEmptyWorker()));
  }
  dispose() {
    if (this._editorWorkerClient) {
      this._editorWorkerClient.dispose();
      this._editorWorkerClient = null;
    }
    super.dispose();
  }
  /**
   * Check if the model service has no more models and stop the worker if that is the case.
   */
  _checkStopEmptyWorker() {
    if (!this._editorWorkerClient) {
      return;
    }
    const models = this._modelService.getModels();
    if (models.length === 0) {
      this._editorWorkerClient.dispose();
      this._editorWorkerClient = null;
    }
  }
  /**
   * Check if the worker has been idle for a while and then stop it.
   */
  _checkStopIdleWorker() {
    if (!this._editorWorkerClient) {
      return;
    }
    const timeSinceLastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime() - this._lastWorkerUsedTime;
    if (timeSinceLastWorkerUsedTime > STOP_WORKER_DELTA_TIME_MS) {
      this._editorWorkerClient.dispose();
      this._editorWorkerClient = null;
    }
  }
  withWorker() {
    this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime();
    if (!this._editorWorkerClient) {
      this._editorWorkerClient = new EditorWorkerClient(this._modelService, false, "editorWorkerService", this.languageConfigurationService);
    }
    return Promise.resolve(this._editorWorkerClient);
  }
};
var EditorModelManager = class extends Disposable {
  constructor(proxy, modelService, keepIdleModels) {
    super();
    this._syncedModels = /* @__PURE__ */ Object.create(null);
    this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null);
    this._proxy = proxy;
    this._modelService = modelService;
    if (!keepIdleModels) {
      const timer = new IntervalTimer();
      timer.cancelAndSet(() => this._checkStopModelSync(), Math.round(STOP_SYNC_MODEL_DELTA_TIME_MS / 2));
      this._register(timer);
    }
  }
  dispose() {
    for (const modelUrl in this._syncedModels) {
      dispose(this._syncedModels[modelUrl]);
    }
    this._syncedModels = /* @__PURE__ */ Object.create(null);
    this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null);
    super.dispose();
  }
  ensureSyncedResources(resources, forceLargeModels) {
    for (const resource of resources) {
      const resourceStr = resource.toString();
      if (!this._syncedModels[resourceStr]) {
        this._beginModelSync(resource, forceLargeModels);
      }
      if (this._syncedModels[resourceStr]) {
        this._syncedModelsLastUsedTime[resourceStr] = (/* @__PURE__ */ new Date()).getTime();
      }
    }
  }
  _checkStopModelSync() {
    const currentTime = (/* @__PURE__ */ new Date()).getTime();
    const toRemove = [];
    for (const modelUrl in this._syncedModelsLastUsedTime) {
      const elapsedTime = currentTime - this._syncedModelsLastUsedTime[modelUrl];
      if (elapsedTime > STOP_SYNC_MODEL_DELTA_TIME_MS) {
        toRemove.push(modelUrl);
      }
    }
    for (const e of toRemove) {
      this._stopModelSync(e);
    }
  }
  _beginModelSync(resource, forceLargeModels) {
    const model = this._modelService.getModel(resource);
    if (!model) {
      return;
    }
    if (!forceLargeModels && model.isTooLargeForSyncing()) {
      return;
    }
    const modelUrl = resource.toString();
    this._proxy.acceptNewModel({
      url: model.uri.toString(),
      lines: model.getLinesContent(),
      EOL: model.getEOL(),
      versionId: model.getVersionId()
    });
    const toDispose = new DisposableStore();
    toDispose.add(model.onDidChangeContent((e) => {
      this._proxy.acceptModelChanged(modelUrl.toString(), e);
    }));
    toDispose.add(model.onWillDispose(() => {
      this._stopModelSync(modelUrl);
    }));
    toDispose.add(toDisposable(() => {
      this._proxy.acceptRemovedModel(modelUrl);
    }));
    this._syncedModels[modelUrl] = toDispose;
  }
  _stopModelSync(modelUrl) {
    const toDispose = this._syncedModels[modelUrl];
    delete this._syncedModels[modelUrl];
    delete this._syncedModelsLastUsedTime[modelUrl];
    dispose(toDispose);
  }
};
var SynchronousWorkerClient = class {
  constructor(instance) {
    this._instance = instance;
    this._proxyObj = Promise.resolve(this._instance);
  }
  dispose() {
    this._instance.dispose();
  }
  getProxyObject() {
    return this._proxyObj;
  }
};
var EditorWorkerHost = class {
  constructor(workerClient) {
    this._workerClient = workerClient;
  }
  // foreign host request
  fhr(method, args) {
    return this._workerClient.fhr(method, args);
  }
};
var EditorWorkerClient = class extends Disposable {
  constructor(modelService, keepIdleModels, label, languageConfigurationService) {
    super();
    this.languageConfigurationService = languageConfigurationService;
    this._disposed = false;
    this._modelService = modelService;
    this._keepIdleModels = keepIdleModels;
    this._workerFactory = new DefaultWorkerFactory(label);
    this._worker = null;
    this._modelManager = null;
  }
  // foreign host request
  fhr(method, args) {
    throw new Error(`Not implemented!`);
  }
  _getOrCreateWorker() {
    if (!this._worker) {
      try {
        this._worker = this._register(new SimpleWorkerClient(this._workerFactory, "vs/editor/common/services/editorSimpleWorker", new EditorWorkerHost(this)));
      } catch (err) {
        logOnceWebWorkerWarning(err);
        this._worker = new SynchronousWorkerClient(new EditorSimpleWorker(new EditorWorkerHost(this), null));
      }
    }
    return this._worker;
  }
  _getProxy() {
    return this._getOrCreateWorker().getProxyObject().then(void 0, (err) => {
      logOnceWebWorkerWarning(err);
      this._worker = new SynchronousWorkerClient(new EditorSimpleWorker(new EditorWorkerHost(this), null));
      return this._getOrCreateWorker().getProxyObject();
    });
  }
  _getOrCreateModelManager(proxy) {
    if (!this._modelManager) {
      this._modelManager = this._register(new EditorModelManager(proxy, this._modelService, this._keepIdleModels));
    }
    return this._modelManager;
  }
  async _withSyncedResources(resources, forceLargeModels = false) {
    if (this._disposed) {
      return Promise.reject(canceled());
    }
    return this._getProxy().then((proxy) => {
      this._getOrCreateModelManager(proxy).ensureSyncedResources(resources, forceLargeModels);
      return proxy;
    });
  }
  computedUnicodeHighlights(uri, options2, range2) {
    return this._withSyncedResources([uri]).then((proxy) => {
      return proxy.computeUnicodeHighlights(uri.toString(), options2, range2);
    });
  }
  computeDiff(original, modified, options2, algorithm) {
    return this._withSyncedResources(
      [original, modified],
      /* forceLargeModels */
      true
    ).then((proxy) => {
      return proxy.computeDiff(original.toString(), modified.toString(), options2, algorithm);
    });
  }
  computeMoreMinimalEdits(resource, edits, pretty) {
    return this._withSyncedResources([resource]).then((proxy) => {
      return proxy.computeMoreMinimalEdits(resource.toString(), edits, pretty);
    });
  }
  computeLinks(resource) {
    return this._withSyncedResources([resource]).then((proxy) => {
      return proxy.computeLinks(resource.toString());
    });
  }
  computeDefaultDocumentColors(resource) {
    return this._withSyncedResources([resource]).then((proxy) => {
      return proxy.computeDefaultDocumentColors(resource.toString());
    });
  }
  async textualSuggest(resources, leadingWord, wordDefRegExp) {
    const proxy = await this._withSyncedResources(resources);
    const wordDef = wordDefRegExp.source;
    const wordDefFlags = wordDefRegExp.flags;
    return proxy.textualSuggest(resources.map((r) => r.toString()), leadingWord, wordDef, wordDefFlags);
  }
  computeWordRanges(resource, range2) {
    return this._withSyncedResources([resource]).then((proxy) => {
      const model = this._modelService.getModel(resource);
      if (!model) {
        return Promise.resolve(null);
      }
      const wordDefRegExp = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();
      const wordDef = wordDefRegExp.source;
      const wordDefFlags = wordDefRegExp.flags;
      return proxy.computeWordRanges(resource.toString(), range2, wordDef, wordDefFlags);
    });
  }
  navigateValueSet(resource, range2, up) {
    return this._withSyncedResources([resource]).then((proxy) => {
      const model = this._modelService.getModel(resource);
      if (!model) {
        return null;
      }
      const wordDefRegExp = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();
      const wordDef = wordDefRegExp.source;
      const wordDefFlags = wordDefRegExp.flags;
      return proxy.navigateValueSet(resource.toString(), range2, up, wordDef, wordDefFlags);
    });
  }
  dispose() {
    super.dispose();
    this._disposed = true;
  }
};

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
init_language();

// node_modules/monaco-editor/esm/vs/platform/markers/common/markers.js
init_nls();
init_instantiation();
var MarkerSeverity2;
(function(MarkerSeverity3) {
  MarkerSeverity3[MarkerSeverity3["Hint"] = 1] = "Hint";
  MarkerSeverity3[MarkerSeverity3["Info"] = 2] = "Info";
  MarkerSeverity3[MarkerSeverity3["Warning"] = 4] = "Warning";
  MarkerSeverity3[MarkerSeverity3["Error"] = 8] = "Error";
})(MarkerSeverity2 || (MarkerSeverity2 = {}));
(function(MarkerSeverity3) {
  function compare2(a, b) {
    return b - a;
  }
  MarkerSeverity3.compare = compare2;
  const _displayStrings = /* @__PURE__ */ Object.create(null);
  _displayStrings[MarkerSeverity3.Error] = localize("sev.error", "Error");
  _displayStrings[MarkerSeverity3.Warning] = localize("sev.warning", "Warning");
  _displayStrings[MarkerSeverity3.Info] = localize("sev.info", "Info");
  function toString(a) {
    return _displayStrings[a] || "";
  }
  MarkerSeverity3.toString = toString;
  function fromSeverity(severity) {
    switch (severity) {
      case severity_default.Error:
        return MarkerSeverity3.Error;
      case severity_default.Warning:
        return MarkerSeverity3.Warning;
      case severity_default.Info:
        return MarkerSeverity3.Info;
      case severity_default.Ignore:
        return MarkerSeverity3.Hint;
    }
  }
  MarkerSeverity3.fromSeverity = fromSeverity;
  function toSeverity(severity) {
    switch (severity) {
      case MarkerSeverity3.Error:
        return severity_default.Error;
      case MarkerSeverity3.Warning:
        return severity_default.Warning;
      case MarkerSeverity3.Info:
        return severity_default.Info;
      case MarkerSeverity3.Hint:
        return severity_default.Ignore;
    }
  }
  MarkerSeverity3.toSeverity = toSeverity;
})(MarkerSeverity2 || (MarkerSeverity2 = {}));
var IMarkerData;
(function(IMarkerData2) {
  const emptyString = "";
  function makeKey(markerData) {
    return makeKeyOptionalMessage(markerData, true);
  }
  IMarkerData2.makeKey = makeKey;
  function makeKeyOptionalMessage(markerData, useMessage) {
    const result = [emptyString];
    if (markerData.source) {
      result.push(markerData.source.replace("", "\\"));
    } else {
      result.push(emptyString);
    }
    if (markerData.code) {
      if (typeof markerData.code === "string") {
        result.push(markerData.code.replace("", "\\"));
      } else {
        result.push(markerData.code.value.replace("", "\\"));
      }
    } else {
      result.push(emptyString);
    }
    if (markerData.severity !== void 0 && markerData.severity !== null) {
      result.push(MarkerSeverity2.toString(markerData.severity));
    } else {
      result.push(emptyString);
    }
    if (markerData.message && useMessage) {
      result.push(markerData.message.replace("", "\\"));
    } else {
      result.push(emptyString);
    }
    if (markerData.startLineNumber !== void 0 && markerData.startLineNumber !== null) {
      result.push(markerData.startLineNumber.toString());
    } else {
      result.push(emptyString);
    }
    if (markerData.startColumn !== void 0 && markerData.startColumn !== null) {
      result.push(markerData.startColumn.toString());
    } else {
      result.push(emptyString);
    }
    if (markerData.endLineNumber !== void 0 && markerData.endLineNumber !== null) {
      result.push(markerData.endLineNumber.toString());
    } else {
      result.push(emptyString);
    }
    if (markerData.endColumn !== void 0 && markerData.endColumn !== null) {
      result.push(markerData.endColumn.toString());
    } else {
      result.push(emptyString);
    }
    result.push(emptyString);
    return result.join("");
  }
  IMarkerData2.makeKeyOptionalMessage = makeKeyOptionalMessage;
})(IMarkerData || (IMarkerData = {}));
var IMarkerService = createDecorator("markerService");

// node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorationsService.js
init_lifecycle();
init_model();
init_themeService();
init_editorColorRegistry();
init_model2();
init_range();
init_network();
init_event();
init_colorRegistry();
init_map();

// node_modules/monaco-editor/esm/vs/base/common/collections.js
function diffSets(before, after2) {
  const removed = [];
  const added = [];
  for (const element of before) {
    if (!after2.has(element)) {
      removed.push(element);
    }
  }
  for (const element of after2) {
    if (!before.has(element)) {
      added.push(element);
    }
  }
  return { removed, added };
}
function intersection(setA, setB) {
  const result = /* @__PURE__ */ new Set();
  for (const elem of setB) {
    if (setA.has(elem)) {
      result.add(elem);
    }
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorationsService.js
var __decorate21 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param18 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MarkerDecorationsService = class MarkerDecorationsService2 extends Disposable {
  constructor(modelService, _markerService) {
    super();
    this._markerService = _markerService;
    this._onDidChangeMarker = this._register(new Emitter());
    this._markerDecorations = new ResourceMap();
    modelService.getModels().forEach((model) => this._onModelAdded(model));
    this._register(modelService.onModelAdded(this._onModelAdded, this));
    this._register(modelService.onModelRemoved(this._onModelRemoved, this));
    this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));
  }
  dispose() {
    super.dispose();
    this._markerDecorations.forEach((value) => value.dispose());
    this._markerDecorations.clear();
  }
  getMarker(uri, decoration) {
    const markerDecorations = this._markerDecorations.get(uri);
    return markerDecorations ? markerDecorations.getMarker(decoration) || null : null;
  }
  _handleMarkerChange(changedResources) {
    changedResources.forEach((resource) => {
      const markerDecorations = this._markerDecorations.get(resource);
      if (markerDecorations) {
        this._updateDecorations(markerDecorations);
      }
    });
  }
  _onModelAdded(model) {
    const markerDecorations = new MarkerDecorations(model);
    this._markerDecorations.set(model.uri, markerDecorations);
    this._updateDecorations(markerDecorations);
  }
  _onModelRemoved(model) {
    var _a2;
    const markerDecorations = this._markerDecorations.get(model.uri);
    if (markerDecorations) {
      markerDecorations.dispose();
      this._markerDecorations.delete(model.uri);
    }
    if (model.uri.scheme === Schemas.inMemory || model.uri.scheme === Schemas.internal || model.uri.scheme === Schemas.vscode) {
      (_a2 = this._markerService) === null || _a2 === void 0 ? void 0 : _a2.read({ resource: model.uri }).map((marker) => marker.owner).forEach((owner) => this._markerService.remove(owner, [model.uri]));
    }
  }
  _updateDecorations(markerDecorations) {
    const markers = this._markerService.read({ resource: markerDecorations.model.uri, take: 500 });
    if (markerDecorations.update(markers)) {
      this._onDidChangeMarker.fire(markerDecorations.model);
    }
  }
};
MarkerDecorationsService = __decorate21([
  __param18(0, IModelService),
  __param18(1, IMarkerService)
], MarkerDecorationsService);
var MarkerDecorations = class extends Disposable {
  constructor(model) {
    super();
    this.model = model;
    this._map = new BidirectionalMap();
    this._register(toDisposable(() => {
      this.model.deltaDecorations([...this._map.values()], []);
      this._map.clear();
    }));
  }
  update(markers) {
    const { added, removed } = diffSets(new Set(this._map.keys()), new Set(markers));
    if (added.length === 0 && removed.length === 0) {
      return false;
    }
    const oldIds = removed.map((marker) => this._map.get(marker));
    const newDecorations = added.map((marker) => {
      return {
        range: this._createDecorationRange(this.model, marker),
        options: this._createDecorationOption(marker)
      };
    });
    const ids = this.model.deltaDecorations(oldIds, newDecorations);
    for (const removedMarker of removed) {
      this._map.delete(removedMarker);
    }
    for (let index = 0; index < ids.length; index++) {
      this._map.set(added[index], ids[index]);
    }
    return true;
  }
  getMarker(decoration) {
    return this._map.getKey(decoration.id);
  }
  _createDecorationRange(model, rawMarker) {
    let ret = Range2.lift(rawMarker);
    if (rawMarker.severity === MarkerSeverity2.Hint && !this._hasMarkerTag(
      rawMarker,
      1
      /* MarkerTag.Unnecessary */
    ) && !this._hasMarkerTag(
      rawMarker,
      2
      /* MarkerTag.Deprecated */
    )) {
      ret = ret.setEndPosition(ret.startLineNumber, ret.startColumn + 2);
    }
    ret = model.validateRange(ret);
    if (ret.isEmpty()) {
      const maxColumn = model.getLineLastNonWhitespaceColumn(ret.startLineNumber) || model.getLineMaxColumn(ret.startLineNumber);
      if (maxColumn === 1 || ret.endColumn >= maxColumn) {
        return ret;
      }
      const word = model.getWordAtPosition(ret.getStartPosition());
      if (word) {
        ret = new Range2(ret.startLineNumber, word.startColumn, ret.endLineNumber, word.endColumn);
      }
    } else if (rawMarker.endColumn === Number.MAX_VALUE && rawMarker.startColumn === 1 && ret.startLineNumber === ret.endLineNumber) {
      const minColumn = model.getLineFirstNonWhitespaceColumn(rawMarker.startLineNumber);
      if (minColumn < ret.endColumn) {
        ret = new Range2(ret.startLineNumber, minColumn, ret.endLineNumber, ret.endColumn);
        rawMarker.startColumn = minColumn;
      }
    }
    return ret;
  }
  _createDecorationOption(marker) {
    let className;
    let color = void 0;
    let zIndex;
    let inlineClassName = void 0;
    let minimap;
    switch (marker.severity) {
      case MarkerSeverity2.Hint:
        if (this._hasMarkerTag(
          marker,
          2
          /* MarkerTag.Deprecated */
        )) {
          className = void 0;
        } else if (this._hasMarkerTag(
          marker,
          1
          /* MarkerTag.Unnecessary */
        )) {
          className = "squiggly-unnecessary";
        } else {
          className = "squiggly-hint";
        }
        zIndex = 0;
        break;
      case MarkerSeverity2.Info:
        className = "squiggly-info";
        color = themeColorFromId(overviewRulerInfo);
        zIndex = 10;
        minimap = {
          color: themeColorFromId(minimapInfo),
          position: MinimapPosition.Inline
        };
        break;
      case MarkerSeverity2.Warning:
        className = "squiggly-warning";
        color = themeColorFromId(overviewRulerWarning);
        zIndex = 20;
        minimap = {
          color: themeColorFromId(minimapWarning),
          position: MinimapPosition.Inline
        };
        break;
      case MarkerSeverity2.Error:
      default:
        className = "squiggly-error";
        color = themeColorFromId(overviewRulerError);
        zIndex = 30;
        minimap = {
          color: themeColorFromId(minimapError),
          position: MinimapPosition.Inline
        };
        break;
    }
    if (marker.tags) {
      if (marker.tags.indexOf(
        1
        /* MarkerTag.Unnecessary */
      ) !== -1) {
        inlineClassName = "squiggly-inline-unnecessary";
      }
      if (marker.tags.indexOf(
        2
        /* MarkerTag.Deprecated */
      ) !== -1) {
        inlineClassName = "squiggly-inline-deprecated";
      }
    }
    return {
      description: "marker-decoration",
      stickiness: 1,
      className,
      showIfCollapsed: true,
      overviewRuler: {
        color,
        position: OverviewRulerLane.Right
      },
      minimap,
      zIndex,
      inlineClassName
    };
  }
  _hasMarkerTag(marker, tag) {
    if (marker.tags) {
      return marker.tags.indexOf(tag) >= 0;
    }
    return false;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorations.js
init_instantiation();
var IMarkerDecorationsService = createDecorator("markerDecorationsService");

// node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js
init_event();
init_lifecycle();
init_platform();
init_textModel();
init_textModelDefaults();
init_modesRegistry();
init_language();
init_configuration();
init_undoRedo();
init_hash();
init_editStack();
init_network();
init_objects();
init_languageConfigurationRegistry();
var __decorate23 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param20 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ModelService_1;
function MODEL_ID2(resource) {
  return resource.toString();
}
var ModelData = class {
  constructor(model, onWillDispose, onDidChangeLanguage) {
    this.model = model;
    this._modelEventListeners = new DisposableStore();
    this.model = model;
    this._modelEventListeners.add(model.onWillDispose(() => onWillDispose(model)));
    this._modelEventListeners.add(model.onDidChangeLanguage((e) => onDidChangeLanguage(model, e)));
  }
  dispose() {
    this._modelEventListeners.dispose();
  }
};
var DEFAULT_EOL = isLinux || isMacintosh ? 1 : 2;
var DisposedModelInfo = class {
  constructor(uri, initialUndoRedoSnapshot, time, sharesUndoRedoStack, heapSize, sha1, versionId, alternativeVersionId) {
    this.uri = uri;
    this.initialUndoRedoSnapshot = initialUndoRedoSnapshot;
    this.time = time;
    this.sharesUndoRedoStack = sharesUndoRedoStack;
    this.heapSize = heapSize;
    this.sha1 = sha1;
    this.versionId = versionId;
    this.alternativeVersionId = alternativeVersionId;
  }
};
var ModelService = ModelService_1 = class ModelService2 extends Disposable {
  constructor(_configurationService, _resourcePropertiesService, _undoRedoService, _languageService, _languageConfigurationService) {
    super();
    this._configurationService = _configurationService;
    this._resourcePropertiesService = _resourcePropertiesService;
    this._undoRedoService = _undoRedoService;
    this._languageService = _languageService;
    this._languageConfigurationService = _languageConfigurationService;
    this._onModelAdded = this._register(new Emitter());
    this.onModelAdded = this._onModelAdded.event;
    this._onModelRemoved = this._register(new Emitter());
    this.onModelRemoved = this._onModelRemoved.event;
    this._onModelModeChanged = this._register(new Emitter());
    this.onModelLanguageChanged = this._onModelModeChanged.event;
    this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null);
    this._models = {};
    this._disposedModels = /* @__PURE__ */ new Map();
    this._disposedModelsHeapSize = 0;
    this._register(this._configurationService.onDidChangeConfiguration((e) => this._updateModelOptions(e)));
    this._updateModelOptions(void 0);
  }
  static _readModelOptions(config, isForSimpleWidget) {
    var _a2;
    let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;
    if (config.editor && typeof config.editor.tabSize !== "undefined") {
      const parsedTabSize = parseInt(config.editor.tabSize, 10);
      if (!isNaN(parsedTabSize)) {
        tabSize = parsedTabSize;
      }
      if (tabSize < 1) {
        tabSize = 1;
      }
    }
    let indentSize = "tabSize";
    if (config.editor && typeof config.editor.indentSize !== "undefined" && config.editor.indentSize !== "tabSize") {
      const parsedIndentSize = parseInt(config.editor.indentSize, 10);
      if (!isNaN(parsedIndentSize)) {
        indentSize = Math.max(parsedIndentSize, 1);
      }
    }
    let insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;
    if (config.editor && typeof config.editor.insertSpaces !== "undefined") {
      insertSpaces = config.editor.insertSpaces === "false" ? false : Boolean(config.editor.insertSpaces);
    }
    let newDefaultEOL = DEFAULT_EOL;
    const eol = config.eol;
    if (eol === "\r\n") {
      newDefaultEOL = 2;
    } else if (eol === "\n") {
      newDefaultEOL = 1;
    }
    let trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;
    if (config.editor && typeof config.editor.trimAutoWhitespace !== "undefined") {
      trimAutoWhitespace = config.editor.trimAutoWhitespace === "false" ? false : Boolean(config.editor.trimAutoWhitespace);
    }
    let detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;
    if (config.editor && typeof config.editor.detectIndentation !== "undefined") {
      detectIndentation = config.editor.detectIndentation === "false" ? false : Boolean(config.editor.detectIndentation);
    }
    let largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;
    if (config.editor && typeof config.editor.largeFileOptimizations !== "undefined") {
      largeFileOptimizations = config.editor.largeFileOptimizations === "false" ? false : Boolean(config.editor.largeFileOptimizations);
    }
    let bracketPairColorizationOptions = EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions;
    if (((_a2 = config.editor) === null || _a2 === void 0 ? void 0 : _a2.bracketPairColorization) && typeof config.editor.bracketPairColorization === "object") {
      bracketPairColorizationOptions = {
        enabled: !!config.editor.bracketPairColorization.enabled,
        independentColorPoolPerBracketType: !!config.editor.bracketPairColorization.independentColorPoolPerBracketType
      };
    }
    return {
      isForSimpleWidget,
      tabSize,
      indentSize,
      insertSpaces,
      detectIndentation,
      defaultEOL: newDefaultEOL,
      trimAutoWhitespace,
      largeFileOptimizations,
      bracketPairColorizationOptions
    };
  }
  _getEOL(resource, language) {
    if (resource) {
      return this._resourcePropertiesService.getEOL(resource, language);
    }
    const eol = this._configurationService.getValue("files.eol", { overrideIdentifier: language });
    if (eol && typeof eol === "string" && eol !== "auto") {
      return eol;
    }
    return OS === 3 || OS === 2 ? "\n" : "\r\n";
  }
  _shouldRestoreUndoStack() {
    const result = this._configurationService.getValue("files.restoreUndoStack");
    if (typeof result === "boolean") {
      return result;
    }
    return true;
  }
  getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget) {
    const language = typeof languageIdOrSelection === "string" ? languageIdOrSelection : languageIdOrSelection.languageId;
    let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];
    if (!creationOptions) {
      const editor = this._configurationService.getValue("editor", { overrideIdentifier: language, resource });
      const eol = this._getEOL(resource, language);
      creationOptions = ModelService_1._readModelOptions({ editor, eol }, isForSimpleWidget);
      this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;
    }
    return creationOptions;
  }
  _updateModelOptions(e) {
    const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;
    this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(this._models);
    for (let i = 0, len = keys.length; i < len; i++) {
      const modelId = keys[i];
      const modelData = this._models[modelId];
      const language = modelData.model.getLanguageId();
      const uri = modelData.model.uri;
      if (e && !e.affectsConfiguration("editor", { overrideIdentifier: language, resource: uri }) && !e.affectsConfiguration("files.eol", { overrideIdentifier: language, resource: uri })) {
        continue;
      }
      const oldOptions = oldOptionsByLanguageAndResource[language + uri];
      const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);
      ModelService_1._setModelOptionsForModel(modelData.model, newOptions, oldOptions);
    }
  }
  static _setModelOptionsForModel(model, newOptions, currentOptions) {
    if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model.getLineCount() === 1) {
      model.setEOL(
        newOptions.defaultEOL === 1 ? 0 : 1
        /* EndOfLineSequence.CRLF */
      );
    }
    if (currentOptions && currentOptions.detectIndentation === newOptions.detectIndentation && currentOptions.insertSpaces === newOptions.insertSpaces && currentOptions.tabSize === newOptions.tabSize && currentOptions.indentSize === newOptions.indentSize && currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace && equals2(currentOptions.bracketPairColorizationOptions, newOptions.bracketPairColorizationOptions)) {
      return;
    }
    if (newOptions.detectIndentation) {
      model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);
      model.updateOptions({
        trimAutoWhitespace: newOptions.trimAutoWhitespace,
        bracketColorizationOptions: newOptions.bracketPairColorizationOptions
      });
    } else {
      model.updateOptions({
        insertSpaces: newOptions.insertSpaces,
        tabSize: newOptions.tabSize,
        indentSize: newOptions.indentSize,
        trimAutoWhitespace: newOptions.trimAutoWhitespace,
        bracketColorizationOptions: newOptions.bracketPairColorizationOptions
      });
    }
  }
  // --- begin IModelService
  _insertDisposedModel(disposedModelData) {
    this._disposedModels.set(MODEL_ID2(disposedModelData.uri), disposedModelData);
    this._disposedModelsHeapSize += disposedModelData.heapSize;
  }
  _removeDisposedModel(resource) {
    const disposedModelData = this._disposedModels.get(MODEL_ID2(resource));
    if (disposedModelData) {
      this._disposedModelsHeapSize -= disposedModelData.heapSize;
    }
    this._disposedModels.delete(MODEL_ID2(resource));
    return disposedModelData;
  }
  _ensureDisposedModelsHeapSize(maxModelsHeapSize) {
    if (this._disposedModelsHeapSize > maxModelsHeapSize) {
      const disposedModels = [];
      this._disposedModels.forEach((entry) => {
        if (!entry.sharesUndoRedoStack) {
          disposedModels.push(entry);
        }
      });
      disposedModels.sort((a, b) => a.time - b.time);
      while (disposedModels.length > 0 && this._disposedModelsHeapSize > maxModelsHeapSize) {
        const disposedModel = disposedModels.shift();
        this._removeDisposedModel(disposedModel.uri);
        if (disposedModel.initialUndoRedoSnapshot !== null) {
          this._undoRedoService.restoreSnapshot(disposedModel.initialUndoRedoSnapshot);
        }
      }
    }
  }
  _createModelData(value, languageIdOrSelection, resource, isForSimpleWidget) {
    const options2 = this.getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget);
    const model = new TextModel(value, languageIdOrSelection, options2, resource, this._undoRedoService, this._languageService, this._languageConfigurationService);
    if (resource && this._disposedModels.has(MODEL_ID2(resource))) {
      const disposedModelData = this._removeDisposedModel(resource);
      const elements = this._undoRedoService.getElements(resource);
      const sha1Computer = this._getSHA1Computer();
      const sha1IsEqual = sha1Computer.canComputeSHA1(model) ? sha1Computer.computeSHA1(model) === disposedModelData.sha1 : false;
      if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {
        for (const element of elements.past) {
          if (isEditStackElement(element) && element.matchesResource(resource)) {
            element.setModel(model);
          }
        }
        for (const element of elements.future) {
          if (isEditStackElement(element) && element.matchesResource(resource)) {
            element.setModel(model);
          }
        }
        this._undoRedoService.setElementsValidFlag(resource, true, (element) => isEditStackElement(element) && element.matchesResource(resource));
        if (sha1IsEqual) {
          model._overwriteVersionId(disposedModelData.versionId);
          model._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);
          model._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);
        }
      } else {
        if (disposedModelData.initialUndoRedoSnapshot !== null) {
          this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);
        }
      }
    }
    const modelId = MODEL_ID2(model.uri);
    if (this._models[modelId]) {
      throw new Error("ModelService: Cannot add model because it already exists!");
    }
    const modelData = new ModelData(model, (model2) => this._onWillDispose(model2), (model2, e) => this._onDidChangeLanguage(model2, e));
    this._models[modelId] = modelData;
    return modelData;
  }
  createModel(value, languageSelection, resource, isForSimpleWidget = false) {
    let modelData;
    if (languageSelection) {
      modelData = this._createModelData(value, languageSelection, resource, isForSimpleWidget);
    } else {
      modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_ID, resource, isForSimpleWidget);
    }
    this._onModelAdded.fire(modelData.model);
    return modelData.model;
  }
  getModels() {
    const ret = [];
    const keys = Object.keys(this._models);
    for (let i = 0, len = keys.length; i < len; i++) {
      const modelId = keys[i];
      ret.push(this._models[modelId].model);
    }
    return ret;
  }
  getModel(resource) {
    const modelId = MODEL_ID2(resource);
    const modelData = this._models[modelId];
    if (!modelData) {
      return null;
    }
    return modelData.model;
  }
  // --- end IModelService
  _schemaShouldMaintainUndoRedoElements(resource) {
    return resource.scheme === Schemas.file || resource.scheme === Schemas.vscodeRemote || resource.scheme === Schemas.vscodeUserData || resource.scheme === Schemas.vscodeNotebookCell || resource.scheme === "fake-fs";
  }
  _onWillDispose(model) {
    const modelId = MODEL_ID2(model.uri);
    const modelData = this._models[modelId];
    const sharesUndoRedoStack = this._undoRedoService.getUriComparisonKey(model.uri) !== model.uri.toString();
    let maintainUndoRedoStack = false;
    let heapSize = 0;
    if (sharesUndoRedoStack || this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(model.uri)) {
      const elements = this._undoRedoService.getElements(model.uri);
      if (elements.past.length > 0 || elements.future.length > 0) {
        for (const element of elements.past) {
          if (isEditStackElement(element) && element.matchesResource(model.uri)) {
            maintainUndoRedoStack = true;
            heapSize += element.heapSize(model.uri);
            element.setModel(model.uri);
          }
        }
        for (const element of elements.future) {
          if (isEditStackElement(element) && element.matchesResource(model.uri)) {
            maintainUndoRedoStack = true;
            heapSize += element.heapSize(model.uri);
            element.setModel(model.uri);
          }
        }
      }
    }
    const maxMemory = ModelService_1.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;
    const sha1Computer = this._getSHA1Computer();
    if (!maintainUndoRedoStack) {
      if (!sharesUndoRedoStack) {
        const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();
        if (initialUndoRedoSnapshot !== null) {
          this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);
        }
      }
    } else if (!sharesUndoRedoStack && (heapSize > maxMemory || !sha1Computer.canComputeSHA1(model))) {
      const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();
      if (initialUndoRedoSnapshot !== null) {
        this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);
      }
    } else {
      this._ensureDisposedModelsHeapSize(maxMemory - heapSize);
      this._undoRedoService.setElementsValidFlag(model.uri, false, (element) => isEditStackElement(element) && element.matchesResource(model.uri));
      this._insertDisposedModel(new DisposedModelInfo(model.uri, modelData.model.getInitialUndoRedoSnapshot(), Date.now(), sharesUndoRedoStack, heapSize, sha1Computer.computeSHA1(model), model.getVersionId(), model.getAlternativeVersionId()));
    }
    delete this._models[modelId];
    modelData.dispose();
    delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageId() + model.uri];
    this._onModelRemoved.fire(model);
  }
  _onDidChangeLanguage(model, e) {
    const oldLanguageId = e.oldLanguage;
    const newLanguageId = model.getLanguageId();
    const oldOptions = this.getCreationOptions(oldLanguageId, model.uri, model.isForSimpleWidget);
    const newOptions = this.getCreationOptions(newLanguageId, model.uri, model.isForSimpleWidget);
    ModelService_1._setModelOptionsForModel(model, newOptions, oldOptions);
    this._onModelModeChanged.fire({ model, oldLanguageId });
  }
  _getSHA1Computer() {
    return new DefaultModelSHA1Computer();
  }
};
ModelService.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024;
ModelService = ModelService_1 = __decorate23([
  __param20(0, IConfigurationService),
  __param20(1, ITextResourcePropertiesService),
  __param20(2, IUndoRedoService),
  __param20(3, ILanguageService),
  __param20(4, ILanguageConfigurationService)
], ModelService);
var DefaultModelSHA1Computer = class _DefaultModelSHA1Computer {
  canComputeSHA1(model) {
    return model.getValueLength() <= _DefaultModelSHA1Computer.MAX_MODEL_SIZE;
  }
  computeSHA1(model) {
    const shaComputer = new StringSHA1();
    const snapshot = model.createSnapshot();
    let text;
    while (text = snapshot.read()) {
      shaComputer.update(text);
    }
    return shaComputer.digest();
  }
};
DefaultModelSHA1Computer.MAX_MODEL_SIZE = 10 * 1024 * 1024;

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickInput/standaloneQuickInputService.js
init_event();
init_editorExtensions();
init_themeService();
init_cancellation();
init_instantiation();
init_contextkey();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickInput/standaloneQuickInput.css";
init_codeEditorService();

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputService.js
init_cancellation();
init_event();
init_contextkey();
init_instantiation();

// node_modules/monaco-editor/esm/vs/platform/list/browser/listService.js
init_dom();

// node_modules/monaco-editor/esm/vs/base/browser/ui/list/listPaging.js
init_arrays();
init_cancellation();
init_event();
init_lifecycle();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/list/list.css";
var PagedRenderer = class {
  get templateId() {
    return this.renderer.templateId;
  }
  constructor(renderer, modelProvider) {
    this.renderer = renderer;
    this.modelProvider = modelProvider;
  }
  renderTemplate(container) {
    const data = this.renderer.renderTemplate(container);
    return { data, disposable: Disposable.None };
  }
  renderElement(index, _, data, height) {
    var _a2;
    (_a2 = data.disposable) === null || _a2 === void 0 ? void 0 : _a2.dispose();
    if (!data.data) {
      return;
    }
    const model = this.modelProvider();
    if (model.isResolved(index)) {
      return this.renderer.renderElement(model.get(index), index, data.data, height);
    }
    const cts = new CancellationTokenSource();
    const promise = model.resolve(index, cts.token);
    data.disposable = { dispose: () => cts.cancel() };
    this.renderer.renderPlaceholder(index, data.data);
    promise.then((entry) => this.renderer.renderElement(entry, index, data.data, height));
  }
  disposeTemplate(data) {
    if (data.disposable) {
      data.disposable.dispose();
      data.disposable = void 0;
    }
    if (data.data) {
      this.renderer.disposeTemplate(data.data);
      data.data = void 0;
    }
  }
};
var PagedAccessibilityProvider = class {
  constructor(modelProvider, accessibilityProvider) {
    this.modelProvider = modelProvider;
    this.accessibilityProvider = accessibilityProvider;
  }
  getWidgetAriaLabel() {
    return this.accessibilityProvider.getWidgetAriaLabel();
  }
  getAriaLabel(index) {
    const model = this.modelProvider();
    if (!model.isResolved(index)) {
      return null;
    }
    return this.accessibilityProvider.getAriaLabel(model.get(index));
  }
};
function fromPagedListOptions(modelProvider, options2) {
  return {
    ...options2,
    accessibilityProvider: options2.accessibilityProvider && new PagedAccessibilityProvider(modelProvider, options2.accessibilityProvider)
  };
}
var PagedList = class {
  constructor(user, container, virtualDelegate, renderers, options2 = {}) {
    const modelProvider = () => this.model;
    const pagedRenderers = renderers.map((r) => new PagedRenderer(r, modelProvider));
    this.list = new List(user, container, virtualDelegate, pagedRenderers, fromPagedListOptions(modelProvider, options2));
  }
  updateOptions(options2) {
    this.list.updateOptions(options2);
  }
  getHTMLElement() {
    return this.list.getHTMLElement();
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get widget() {
    return this.list;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  get onMouseDblClick() {
    return Event.map(this.list.onMouseDblClick, ({ element, index, browserEvent }) => ({ element: element === void 0 ? void 0 : this._model.get(element), index, browserEvent }));
  }
  get onPointer() {
    return Event.map(this.list.onPointer, ({ element, index, browserEvent }) => ({ element: element === void 0 ? void 0 : this._model.get(element), index, browserEvent }));
  }
  get onDidChangeSelection() {
    return Event.map(this.list.onDidChangeSelection, ({ elements, indexes, browserEvent }) => ({ elements: elements.map((e) => this._model.get(e)), indexes, browserEvent }));
  }
  get model() {
    return this._model;
  }
  set model(model) {
    this._model = model;
    this.list.splice(0, this.list.length, range(model.length));
  }
  getFocus() {
    return this.list.getFocus();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getSelectedElements() {
    return this.getSelection().map((i) => this.model.get(i));
  }
  style(styles) {
    this.list.style(styles);
  }
  dispose() {
    this.list.dispose();
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/table/tableWidget.js
init_dom();

// node_modules/monaco-editor/esm/vs/base/browser/ui/splitview/splitview.js
init_dom();

// node_modules/monaco-editor/esm/vs/base/browser/ui/sash/sash.js
init_dom();
init_async();
init_event();
init_lifecycle();
init_platform();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/sash/sash.css";
var __decorate24 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DEBUG2 = false;
var OrthogonalEdge;
(function(OrthogonalEdge2) {
  OrthogonalEdge2["North"] = "north";
  OrthogonalEdge2["South"] = "south";
  OrthogonalEdge2["East"] = "east";
  OrthogonalEdge2["West"] = "west";
})(OrthogonalEdge || (OrthogonalEdge = {}));
var globalSize = 4;
var onDidChangeGlobalSize = new Emitter();
var globalHoverDelay = 300;
var onDidChangeHoverDelay = new Emitter();
var MouseEventFactory = class {
  constructor(el) {
    this.el = el;
    this.disposables = new DisposableStore();
  }
  get onPointerMove() {
    return this.disposables.add(new DomEmitter(getWindow(this.el), "mousemove")).event;
  }
  get onPointerUp() {
    return this.disposables.add(new DomEmitter(getWindow(this.el), "mouseup")).event;
  }
  dispose() {
    this.disposables.dispose();
  }
};
__decorate24([
  memoize
], MouseEventFactory.prototype, "onPointerMove", null);
__decorate24([
  memoize
], MouseEventFactory.prototype, "onPointerUp", null);
var GestureEventFactory = class {
  get onPointerMove() {
    return this.disposables.add(new DomEmitter(this.el, EventType2.Change)).event;
  }
  get onPointerUp() {
    return this.disposables.add(new DomEmitter(this.el, EventType2.End)).event;
  }
  constructor(el) {
    this.el = el;
    this.disposables = new DisposableStore();
  }
  dispose() {
    this.disposables.dispose();
  }
};
__decorate24([
  memoize
], GestureEventFactory.prototype, "onPointerMove", null);
__decorate24([
  memoize
], GestureEventFactory.prototype, "onPointerUp", null);
var OrthogonalPointerEventFactory = class {
  get onPointerMove() {
    return this.factory.onPointerMove;
  }
  get onPointerUp() {
    return this.factory.onPointerUp;
  }
  constructor(factory) {
    this.factory = factory;
  }
  dispose() {
  }
};
__decorate24([
  memoize
], OrthogonalPointerEventFactory.prototype, "onPointerMove", null);
__decorate24([
  memoize
], OrthogonalPointerEventFactory.prototype, "onPointerUp", null);
var PointerEventsDisabledCssClass = "pointer-events-disabled";
var Sash = class _Sash extends Disposable {
  get state() {
    return this._state;
  }
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  /**
   * The state of a sash defines whether it can be interacted with by the user
   * as well as what mouse cursor to use, when hovered.
   */
  set state(state) {
    if (this._state === state) {
      return;
    }
    this.el.classList.toggle(
      "disabled",
      state === 0
      /* SashState.Disabled */
    );
    this.el.classList.toggle(
      "minimum",
      state === 1
      /* SashState.AtMinimum */
    );
    this.el.classList.toggle(
      "maximum",
      state === 2
      /* SashState.AtMaximum */
    );
    this._state = state;
    this.onDidEnablementChange.fire(state);
  }
  /**
   * A reference to another sash, perpendicular to this one, which
   * aligns at the start of this one. A corner sash will be created
   * automatically at that location.
   *
   * The start of a horizontal sash is its left-most position.
   * The start of a vertical sash is its top-most position.
   */
  set orthogonalStartSash(sash) {
    if (this._orthogonalStartSash === sash) {
      return;
    }
    this.orthogonalStartDragHandleDisposables.clear();
    this.orthogonalStartSashDisposables.clear();
    if (sash) {
      const onChange = (state) => {
        this.orthogonalStartDragHandleDisposables.clear();
        if (state !== 0) {
          this._orthogonalStartDragHandle = append(this.el, $(".orthogonal-drag-handle.start"));
          this.orthogonalStartDragHandleDisposables.add(toDisposable(() => this._orthogonalStartDragHandle.remove()));
          this.orthogonalStartDragHandleDisposables.add(new DomEmitter(this._orthogonalStartDragHandle, "mouseenter")).event(() => _Sash.onMouseEnter(sash), void 0, this.orthogonalStartDragHandleDisposables);
          this.orthogonalStartDragHandleDisposables.add(new DomEmitter(this._orthogonalStartDragHandle, "mouseleave")).event(() => _Sash.onMouseLeave(sash), void 0, this.orthogonalStartDragHandleDisposables);
        }
      };
      this.orthogonalStartSashDisposables.add(sash.onDidEnablementChange.event(onChange, this));
      onChange(sash.state);
    }
    this._orthogonalStartSash = sash;
  }
  /**
   * A reference to another sash, perpendicular to this one, which
   * aligns at the end of this one. A corner sash will be created
   * automatically at that location.
   *
   * The end of a horizontal sash is its right-most position.
   * The end of a vertical sash is its bottom-most position.
   */
  set orthogonalEndSash(sash) {
    if (this._orthogonalEndSash === sash) {
      return;
    }
    this.orthogonalEndDragHandleDisposables.clear();
    this.orthogonalEndSashDisposables.clear();
    if (sash) {
      const onChange = (state) => {
        this.orthogonalEndDragHandleDisposables.clear();
        if (state !== 0) {
          this._orthogonalEndDragHandle = append(this.el, $(".orthogonal-drag-handle.end"));
          this.orthogonalEndDragHandleDisposables.add(toDisposable(() => this._orthogonalEndDragHandle.remove()));
          this.orthogonalEndDragHandleDisposables.add(new DomEmitter(this._orthogonalEndDragHandle, "mouseenter")).event(() => _Sash.onMouseEnter(sash), void 0, this.orthogonalEndDragHandleDisposables);
          this.orthogonalEndDragHandleDisposables.add(new DomEmitter(this._orthogonalEndDragHandle, "mouseleave")).event(() => _Sash.onMouseLeave(sash), void 0, this.orthogonalEndDragHandleDisposables);
        }
      };
      this.orthogonalEndSashDisposables.add(sash.onDidEnablementChange.event(onChange, this));
      onChange(sash.state);
    }
    this._orthogonalEndSash = sash;
  }
  constructor(container, layoutProvider, options2) {
    super();
    this.hoverDelay = globalHoverDelay;
    this.hoverDelayer = this._register(new Delayer(this.hoverDelay));
    this._state = 3;
    this.onDidEnablementChange = this._register(new Emitter());
    this._onDidStart = this._register(new Emitter());
    this._onDidChange = this._register(new Emitter());
    this._onDidReset = this._register(new Emitter());
    this._onDidEnd = this._register(new Emitter());
    this.orthogonalStartSashDisposables = this._register(new DisposableStore());
    this.orthogonalStartDragHandleDisposables = this._register(new DisposableStore());
    this.orthogonalEndSashDisposables = this._register(new DisposableStore());
    this.orthogonalEndDragHandleDisposables = this._register(new DisposableStore());
    this.onDidStart = this._onDidStart.event;
    this.onDidChange = this._onDidChange.event;
    this.onDidReset = this._onDidReset.event;
    this.onDidEnd = this._onDidEnd.event;
    this.linkedSash = void 0;
    this.el = append(container, $(".monaco-sash"));
    if (options2.orthogonalEdge) {
      this.el.classList.add(`orthogonal-edge-${options2.orthogonalEdge}`);
    }
    if (isMacintosh) {
      this.el.classList.add("mac");
    }
    const onMouseDown = this._register(new DomEmitter(this.el, "mousedown")).event;
    this._register(onMouseDown((e) => this.onPointerStart(e, new MouseEventFactory(container)), this));
    const onMouseDoubleClick = this._register(new DomEmitter(this.el, "dblclick")).event;
    this._register(onMouseDoubleClick(this.onPointerDoublePress, this));
    const onMouseEnter = this._register(new DomEmitter(this.el, "mouseenter")).event;
    this._register(onMouseEnter(() => _Sash.onMouseEnter(this)));
    const onMouseLeave = this._register(new DomEmitter(this.el, "mouseleave")).event;
    this._register(onMouseLeave(() => _Sash.onMouseLeave(this)));
    this._register(Gesture.addTarget(this.el));
    const onTouchStart = this._register(new DomEmitter(this.el, EventType2.Start)).event;
    this._register(onTouchStart((e) => this.onPointerStart(e, new GestureEventFactory(this.el)), this));
    const onTap = this._register(new DomEmitter(this.el, EventType2.Tap)).event;
    let doubleTapTimeout = void 0;
    this._register(onTap((event) => {
      if (doubleTapTimeout) {
        clearTimeout(doubleTapTimeout);
        doubleTapTimeout = void 0;
        this.onPointerDoublePress(event);
        return;
      }
      clearTimeout(doubleTapTimeout);
      doubleTapTimeout = setTimeout(() => doubleTapTimeout = void 0, 250);
    }, this));
    if (typeof options2.size === "number") {
      this.size = options2.size;
      if (options2.orientation === 0) {
        this.el.style.width = `${this.size}px`;
      } else {
        this.el.style.height = `${this.size}px`;
      }
    } else {
      this.size = globalSize;
      this._register(onDidChangeGlobalSize.event((size) => {
        this.size = size;
        this.layout();
      }));
    }
    this._register(onDidChangeHoverDelay.event((delay) => this.hoverDelay = delay));
    this.layoutProvider = layoutProvider;
    this.orthogonalStartSash = options2.orthogonalStartSash;
    this.orthogonalEndSash = options2.orthogonalEndSash;
    this.orientation = options2.orientation || 0;
    if (this.orientation === 1) {
      this.el.classList.add("horizontal");
      this.el.classList.remove("vertical");
    } else {
      this.el.classList.remove("horizontal");
      this.el.classList.add("vertical");
    }
    this.el.classList.toggle("debug", DEBUG2);
    this.layout();
  }
  onPointerStart(event, pointerEventFactory) {
    EventHelper.stop(event);
    let isMultisashResize = false;
    if (!event.__orthogonalSashEvent) {
      const orthogonalSash = this.getOrthogonalSash(event);
      if (orthogonalSash) {
        isMultisashResize = true;
        event.__orthogonalSashEvent = true;
        orthogonalSash.onPointerStart(event, new OrthogonalPointerEventFactory(pointerEventFactory));
      }
    }
    if (this.linkedSash && !event.__linkedSashEvent) {
      event.__linkedSashEvent = true;
      this.linkedSash.onPointerStart(event, new OrthogonalPointerEventFactory(pointerEventFactory));
    }
    if (!this.state) {
      return;
    }
    const iframes = this.el.ownerDocument.getElementsByTagName("iframe");
    for (const iframe of iframes) {
      iframe.classList.add(PointerEventsDisabledCssClass);
    }
    const startX = event.pageX;
    const startY = event.pageY;
    const altKey = event.altKey;
    const startEvent = { startX, currentX: startX, startY, currentY: startY, altKey };
    this.el.classList.add("active");
    this._onDidStart.fire(startEvent);
    const style = createStyleSheet(this.el);
    const updateStyle = () => {
      let cursor = "";
      if (isMultisashResize) {
        cursor = "all-scroll";
      } else if (this.orientation === 1) {
        if (this.state === 1) {
          cursor = "s-resize";
        } else if (this.state === 2) {
          cursor = "n-resize";
        } else {
          cursor = isMacintosh ? "row-resize" : "ns-resize";
        }
      } else {
        if (this.state === 1) {
          cursor = "e-resize";
        } else if (this.state === 2) {
          cursor = "w-resize";
        } else {
          cursor = isMacintosh ? "col-resize" : "ew-resize";
        }
      }
      style.textContent = `* { cursor: ${cursor} !important; }`;
    };
    const disposables = new DisposableStore();
    updateStyle();
    if (!isMultisashResize) {
      this.onDidEnablementChange.event(updateStyle, null, disposables);
    }
    const onPointerMove = (e) => {
      EventHelper.stop(e, false);
      const event2 = { startX, currentX: e.pageX, startY, currentY: e.pageY, altKey };
      this._onDidChange.fire(event2);
    };
    const onPointerUp = (e) => {
      EventHelper.stop(e, false);
      this.el.removeChild(style);
      this.el.classList.remove("active");
      this._onDidEnd.fire();
      disposables.dispose();
      for (const iframe of iframes) {
        iframe.classList.remove(PointerEventsDisabledCssClass);
      }
    };
    pointerEventFactory.onPointerMove(onPointerMove, null, disposables);
    pointerEventFactory.onPointerUp(onPointerUp, null, disposables);
    disposables.add(pointerEventFactory);
  }
  onPointerDoublePress(e) {
    const orthogonalSash = this.getOrthogonalSash(e);
    if (orthogonalSash) {
      orthogonalSash._onDidReset.fire();
    }
    if (this.linkedSash) {
      this.linkedSash._onDidReset.fire();
    }
    this._onDidReset.fire();
  }
  static onMouseEnter(sash, fromLinkedSash = false) {
    if (sash.el.classList.contains("active")) {
      sash.hoverDelayer.cancel();
      sash.el.classList.add("hover");
    } else {
      sash.hoverDelayer.trigger(() => sash.el.classList.add("hover"), sash.hoverDelay).then(void 0, () => {
      });
    }
    if (!fromLinkedSash && sash.linkedSash) {
      _Sash.onMouseEnter(sash.linkedSash, true);
    }
  }
  static onMouseLeave(sash, fromLinkedSash = false) {
    sash.hoverDelayer.cancel();
    sash.el.classList.remove("hover");
    if (!fromLinkedSash && sash.linkedSash) {
      _Sash.onMouseLeave(sash.linkedSash, true);
    }
  }
  /**
   * Forcefully stop any user interactions with this sash.
   * Useful when hiding a parent component, while the user is still
   * interacting with the sash.
   */
  clearSashHoverState() {
    _Sash.onMouseLeave(this);
  }
  /**
   * Layout the sash. The sash will size and position itself
   * based on its provided {@link ISashLayoutProvider layout provider}.
   */
  layout() {
    if (this.orientation === 0) {
      const verticalProvider = this.layoutProvider;
      this.el.style.left = verticalProvider.getVerticalSashLeft(this) - this.size / 2 + "px";
      if (verticalProvider.getVerticalSashTop) {
        this.el.style.top = verticalProvider.getVerticalSashTop(this) + "px";
      }
      if (verticalProvider.getVerticalSashHeight) {
        this.el.style.height = verticalProvider.getVerticalSashHeight(this) + "px";
      }
    } else {
      const horizontalProvider = this.layoutProvider;
      this.el.style.top = horizontalProvider.getHorizontalSashTop(this) - this.size / 2 + "px";
      if (horizontalProvider.getHorizontalSashLeft) {
        this.el.style.left = horizontalProvider.getHorizontalSashLeft(this) + "px";
      }
      if (horizontalProvider.getHorizontalSashWidth) {
        this.el.style.width = horizontalProvider.getHorizontalSashWidth(this) + "px";
      }
    }
  }
  getOrthogonalSash(e) {
    var _a2;
    const target = (_a2 = e.initialTarget) !== null && _a2 !== void 0 ? _a2 : e.target;
    if (!target || !(target instanceof HTMLElement)) {
      return void 0;
    }
    if (target.classList.contains("orthogonal-drag-handle")) {
      return target.classList.contains("start") ? this.orthogonalStartSash : this.orthogonalEndSash;
    }
    return void 0;
  }
  dispose() {
    super.dispose();
    this.el.remove();
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/splitview/splitview.js
init_arrays();
init_color();
init_event();
init_lifecycle();
init_numbers();
init_types();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/splitview/splitview.css";
var defaultStyles = {
  separatorBorder: Color.transparent
};
var ViewItem = class {
  set size(size) {
    this._size = size;
  }
  get size() {
    return this._size;
  }
  get visible() {
    return typeof this._cachedVisibleSize === "undefined";
  }
  setVisible(visible, size) {
    var _a2, _b2;
    if (visible === this.visible) {
      return;
    }
    if (visible) {
      this.size = clamp(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize);
      this._cachedVisibleSize = void 0;
    } else {
      this._cachedVisibleSize = typeof size === "number" ? size : this.size;
      this.size = 0;
    }
    this.container.classList.toggle("visible", visible);
    try {
      (_b2 = (_a2 = this.view).setVisible) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, visible);
    } catch (e) {
      console.error("Splitview: Failed to set visible view");
      console.error(e);
    }
  }
  get minimumSize() {
    return this.visible ? this.view.minimumSize : 0;
  }
  get viewMinimumSize() {
    return this.view.minimumSize;
  }
  get maximumSize() {
    return this.visible ? this.view.maximumSize : 0;
  }
  get viewMaximumSize() {
    return this.view.maximumSize;
  }
  get priority() {
    return this.view.priority;
  }
  get proportionalLayout() {
    var _a2;
    return (_a2 = this.view.proportionalLayout) !== null && _a2 !== void 0 ? _a2 : true;
  }
  get snap() {
    return !!this.view.snap;
  }
  set enabled(enabled) {
    this.container.style.pointerEvents = enabled ? "" : "none";
  }
  constructor(container, view, size, disposable) {
    this.container = container;
    this.view = view;
    this.disposable = disposable;
    this._cachedVisibleSize = void 0;
    if (typeof size === "number") {
      this._size = size;
      this._cachedVisibleSize = void 0;
      container.classList.add("visible");
    } else {
      this._size = 0;
      this._cachedVisibleSize = size.cachedVisibleSize;
    }
  }
  layout(offset, layoutContext) {
    this.layoutContainer(offset);
    try {
      this.view.layout(this.size, offset, layoutContext);
    } catch (e) {
      console.error("Splitview: Failed to layout view");
      console.error(e);
    }
  }
  dispose() {
    this.disposable.dispose();
  }
};
var VerticalViewItem = class extends ViewItem {
  layoutContainer(offset) {
    this.container.style.top = `${offset}px`;
    this.container.style.height = `${this.size}px`;
  }
};
var HorizontalViewItem = class extends ViewItem {
  layoutContainer(offset) {
    this.container.style.left = `${offset}px`;
    this.container.style.width = `${this.size}px`;
  }
};
var State;
(function(State2) {
  State2[State2["Idle"] = 0] = "Idle";
  State2[State2["Busy"] = 1] = "Busy";
})(State || (State = {}));
var Sizing;
(function(Sizing2) {
  Sizing2.Distribute = { type: "distribute" };
  function Split(index) {
    return { type: "split", index };
  }
  Sizing2.Split = Split;
  function Auto(index) {
    return { type: "auto", index };
  }
  Sizing2.Auto = Auto;
  function Invisible(cachedVisibleSize) {
    return { type: "invisible", cachedVisibleSize };
  }
  Sizing2.Invisible = Invisible;
})(Sizing || (Sizing = {}));
var SplitView = class extends Disposable {
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  get startSnappingEnabled() {
    return this._startSnappingEnabled;
  }
  get endSnappingEnabled() {
    return this._endSnappingEnabled;
  }
  /**
   * A reference to a sash, perpendicular to all sashes in this {@link SplitView},
   * located at the left- or top-most side of the SplitView.
   * Corner sashes will be created automatically at the intersections.
   */
  set orthogonalStartSash(sash) {
    for (const sashItem of this.sashItems) {
      sashItem.sash.orthogonalStartSash = sash;
    }
    this._orthogonalStartSash = sash;
  }
  /**
   * A reference to a sash, perpendicular to all sashes in this {@link SplitView},
   * located at the right- or bottom-most side of the SplitView.
   * Corner sashes will be created automatically at the intersections.
   */
  set orthogonalEndSash(sash) {
    for (const sashItem of this.sashItems) {
      sashItem.sash.orthogonalEndSash = sash;
    }
    this._orthogonalEndSash = sash;
  }
  /**
   * Enable/disable snapping at the beginning of this {@link SplitView}.
   */
  set startSnappingEnabled(startSnappingEnabled) {
    if (this._startSnappingEnabled === startSnappingEnabled) {
      return;
    }
    this._startSnappingEnabled = startSnappingEnabled;
    this.updateSashEnablement();
  }
  /**
   * Enable/disable snapping at the end of this {@link SplitView}.
   */
  set endSnappingEnabled(endSnappingEnabled) {
    if (this._endSnappingEnabled === endSnappingEnabled) {
      return;
    }
    this._endSnappingEnabled = endSnappingEnabled;
    this.updateSashEnablement();
  }
  /**
   * Create a new {@link SplitView} instance.
   */
  constructor(container, options2 = {}) {
    var _a2, _b2, _c, _d, _e;
    super();
    this.size = 0;
    this._contentSize = 0;
    this.proportions = void 0;
    this.viewItems = [];
    this.sashItems = [];
    this.state = State.Idle;
    this._onDidSashChange = this._register(new Emitter());
    this._onDidSashReset = this._register(new Emitter());
    this._startSnappingEnabled = true;
    this._endSnappingEnabled = true;
    this.onDidSashChange = this._onDidSashChange.event;
    this.onDidSashReset = this._onDidSashReset.event;
    this.orientation = (_a2 = options2.orientation) !== null && _a2 !== void 0 ? _a2 : 0;
    this.inverseAltBehavior = (_b2 = options2.inverseAltBehavior) !== null && _b2 !== void 0 ? _b2 : false;
    this.proportionalLayout = (_c = options2.proportionalLayout) !== null && _c !== void 0 ? _c : true;
    this.getSashOrthogonalSize = options2.getSashOrthogonalSize;
    this.el = document.createElement("div");
    this.el.classList.add("monaco-split-view2");
    this.el.classList.add(this.orientation === 0 ? "vertical" : "horizontal");
    container.appendChild(this.el);
    this.sashContainer = append(this.el, $(".sash-container"));
    this.viewContainer = $(".split-view-container");
    this.scrollable = this._register(new Scrollable({
      forceIntegerValues: true,
      smoothScrollDuration: 125,
      scheduleAtNextAnimationFrame: (callback) => scheduleAtNextAnimationFrame(getWindow(this.el), callback)
    }));
    this.scrollableElement = this._register(new SmoothScrollableElement(this.viewContainer, {
      vertical: this.orientation === 0 ? (_d = options2.scrollbarVisibility) !== null && _d !== void 0 ? _d : 1 : 2,
      horizontal: this.orientation === 1 ? (_e = options2.scrollbarVisibility) !== null && _e !== void 0 ? _e : 1 : 2
      /* ScrollbarVisibility.Hidden */
    }, this.scrollable));
    const onDidScrollViewContainer = this._register(new DomEmitter(this.viewContainer, "scroll")).event;
    this._register(onDidScrollViewContainer((_) => {
      const position = this.scrollableElement.getScrollPosition();
      const scrollLeft = Math.abs(this.viewContainer.scrollLeft - position.scrollLeft) <= 1 ? void 0 : this.viewContainer.scrollLeft;
      const scrollTop = Math.abs(this.viewContainer.scrollTop - position.scrollTop) <= 1 ? void 0 : this.viewContainer.scrollTop;
      if (scrollLeft !== void 0 || scrollTop !== void 0) {
        this.scrollableElement.setScrollPosition({ scrollLeft, scrollTop });
      }
    }));
    this.onDidScroll = this.scrollableElement.onScroll;
    this._register(this.onDidScroll((e) => {
      if (e.scrollTopChanged) {
        this.viewContainer.scrollTop = e.scrollTop;
      }
      if (e.scrollLeftChanged) {
        this.viewContainer.scrollLeft = e.scrollLeft;
      }
    }));
    append(this.el, this.scrollableElement.getDomNode());
    this.style(options2.styles || defaultStyles);
    if (options2.descriptor) {
      this.size = options2.descriptor.size;
      options2.descriptor.views.forEach((viewDescriptor, index) => {
        const sizing = isUndefined(viewDescriptor.visible) || viewDescriptor.visible ? viewDescriptor.size : { type: "invisible", cachedVisibleSize: viewDescriptor.size };
        const view = viewDescriptor.view;
        this.doAddView(view, sizing, index, true);
      });
      this._contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
      this.saveProportions();
    }
  }
  style(styles) {
    if (styles.separatorBorder.isTransparent()) {
      this.el.classList.remove("separator-border");
      this.el.style.removeProperty("--separator-border");
    } else {
      this.el.classList.add("separator-border");
      this.el.style.setProperty("--separator-border", styles.separatorBorder.toString());
    }
  }
  /**
   * Add a {@link IView view} to this {@link SplitView}.
   *
   * @param view The view to add.
   * @param size Either a fixed size, or a dynamic {@link Sizing} strategy.
   * @param index The index to insert the view on.
   * @param skipLayout Whether layout should be skipped.
   */
  addView(view, size, index = this.viewItems.length, skipLayout) {
    this.doAddView(view, size, index, skipLayout);
  }
  /**
   * Layout the {@link SplitView}.
   *
   * @param size The entire size of the {@link SplitView}.
   * @param layoutContext An optional layout context to pass along to {@link IView views}.
   */
  layout(size, layoutContext) {
    const previousSize = Math.max(this.size, this._contentSize);
    this.size = size;
    this.layoutContext = layoutContext;
    if (!this.proportions) {
      const indexes = range(this.viewItems.length);
      const lowPriorityIndexes = indexes.filter(
        (i) => this.viewItems[i].priority === 1
        /* LayoutPriority.Low */
      );
      const highPriorityIndexes = indexes.filter(
        (i) => this.viewItems[i].priority === 2
        /* LayoutPriority.High */
      );
      this.resize(this.viewItems.length - 1, size - previousSize, void 0, lowPriorityIndexes, highPriorityIndexes);
    } else {
      let total = 0;
      for (let i = 0; i < this.viewItems.length; i++) {
        const item = this.viewItems[i];
        const proportion = this.proportions[i];
        if (typeof proportion === "number") {
          total += proportion;
        } else {
          size -= item.size;
        }
      }
      for (let i = 0; i < this.viewItems.length; i++) {
        const item = this.viewItems[i];
        const proportion = this.proportions[i];
        if (typeof proportion === "number" && total > 0) {
          item.size = clamp(Math.round(proportion * size / total), item.minimumSize, item.maximumSize);
        }
      }
    }
    this.distributeEmptySpace();
    this.layoutViews();
  }
  saveProportions() {
    if (this.proportionalLayout && this._contentSize > 0) {
      this.proportions = this.viewItems.map((v) => v.proportionalLayout && v.visible ? v.size / this._contentSize : void 0);
    }
  }
  onSashStart({ sash, start, alt }) {
    for (const item of this.viewItems) {
      item.enabled = false;
    }
    const index = this.sashItems.findIndex((item) => item.sash === sash);
    const disposable = combinedDisposable(addDisposableListener(this.el.ownerDocument.body, "keydown", (e) => resetSashDragState(this.sashDragState.current, e.altKey)), addDisposableListener(this.el.ownerDocument.body, "keyup", () => resetSashDragState(this.sashDragState.current, false)));
    const resetSashDragState = (start2, alt2) => {
      const sizes = this.viewItems.map((i) => i.size);
      let minDelta = Number.NEGATIVE_INFINITY;
      let maxDelta = Number.POSITIVE_INFINITY;
      if (this.inverseAltBehavior) {
        alt2 = !alt2;
      }
      if (alt2) {
        const isLastSash = index === this.sashItems.length - 1;
        if (isLastSash) {
          const viewItem = this.viewItems[index];
          minDelta = (viewItem.minimumSize - viewItem.size) / 2;
          maxDelta = (viewItem.maximumSize - viewItem.size) / 2;
        } else {
          const viewItem = this.viewItems[index + 1];
          minDelta = (viewItem.size - viewItem.maximumSize) / 2;
          maxDelta = (viewItem.size - viewItem.minimumSize) / 2;
        }
      }
      let snapBefore;
      let snapAfter;
      if (!alt2) {
        const upIndexes = range(index, -1);
        const downIndexes = range(index + 1, this.viewItems.length);
        const minDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].minimumSize - sizes[i]), 0);
        const maxDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].viewMaximumSize - sizes[i]), 0);
        const maxDeltaDown = downIndexes.length === 0 ? Number.POSITIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].minimumSize), 0);
        const minDeltaDown = downIndexes.length === 0 ? Number.NEGATIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].viewMaximumSize), 0);
        const minDelta2 = Math.max(minDeltaUp, minDeltaDown);
        const maxDelta2 = Math.min(maxDeltaDown, maxDeltaUp);
        const snapBeforeIndex = this.findFirstSnapIndex(upIndexes);
        const snapAfterIndex = this.findFirstSnapIndex(downIndexes);
        if (typeof snapBeforeIndex === "number") {
          const viewItem = this.viewItems[snapBeforeIndex];
          const halfSize = Math.floor(viewItem.viewMinimumSize / 2);
          snapBefore = {
            index: snapBeforeIndex,
            limitDelta: viewItem.visible ? minDelta2 - halfSize : minDelta2 + halfSize,
            size: viewItem.size
          };
        }
        if (typeof snapAfterIndex === "number") {
          const viewItem = this.viewItems[snapAfterIndex];
          const halfSize = Math.floor(viewItem.viewMinimumSize / 2);
          snapAfter = {
            index: snapAfterIndex,
            limitDelta: viewItem.visible ? maxDelta2 + halfSize : maxDelta2 - halfSize,
            size: viewItem.size
          };
        }
      }
      this.sashDragState = { start: start2, current: start2, index, sizes, minDelta, maxDelta, alt: alt2, snapBefore, snapAfter, disposable };
    };
    resetSashDragState(start, alt);
  }
  onSashChange({ current }) {
    const { index, start, sizes, alt, minDelta, maxDelta, snapBefore, snapAfter } = this.sashDragState;
    this.sashDragState.current = current;
    const delta = current - start;
    const newDelta = this.resize(index, delta, sizes, void 0, void 0, minDelta, maxDelta, snapBefore, snapAfter);
    if (alt) {
      const isLastSash = index === this.sashItems.length - 1;
      const newSizes = this.viewItems.map((i) => i.size);
      const viewItemIndex = isLastSash ? index : index + 1;
      const viewItem = this.viewItems[viewItemIndex];
      const newMinDelta = viewItem.size - viewItem.maximumSize;
      const newMaxDelta = viewItem.size - viewItem.minimumSize;
      const resizeIndex = isLastSash ? index - 1 : index + 1;
      this.resize(resizeIndex, -newDelta, newSizes, void 0, void 0, newMinDelta, newMaxDelta);
    }
    this.distributeEmptySpace();
    this.layoutViews();
  }
  onSashEnd(index) {
    this._onDidSashChange.fire(index);
    this.sashDragState.disposable.dispose();
    this.saveProportions();
    for (const item of this.viewItems) {
      item.enabled = true;
    }
  }
  onViewChange(item, size) {
    const index = this.viewItems.indexOf(item);
    if (index < 0 || index >= this.viewItems.length) {
      return;
    }
    size = typeof size === "number" ? size : item.size;
    size = clamp(size, item.minimumSize, item.maximumSize);
    if (this.inverseAltBehavior && index > 0) {
      this.resize(index - 1, Math.floor((item.size - size) / 2));
      this.distributeEmptySpace();
      this.layoutViews();
    } else {
      item.size = size;
      this.relayout([index], void 0);
    }
  }
  /**
   * Resize a {@link IView view} within the {@link SplitView}.
   *
   * @param index The {@link IView view} index.
   * @param size The {@link IView view} size.
   */
  resizeView(index, size) {
    if (index < 0 || index >= this.viewItems.length) {
      return;
    }
    if (this.state !== State.Idle) {
      throw new Error("Cant modify splitview");
    }
    this.state = State.Busy;
    try {
      const indexes = range(this.viewItems.length).filter((i) => i !== index);
      const lowPriorityIndexes = [...indexes.filter(
        (i) => this.viewItems[i].priority === 1
        /* LayoutPriority.Low */
      ), index];
      const highPriorityIndexes = indexes.filter(
        (i) => this.viewItems[i].priority === 2
        /* LayoutPriority.High */
      );
      const item = this.viewItems[index];
      size = Math.round(size);
      size = clamp(size, item.minimumSize, Math.min(item.maximumSize, this.size));
      item.size = size;
      this.relayout(lowPriorityIndexes, highPriorityIndexes);
    } finally {
      this.state = State.Idle;
    }
  }
  /**
   * Distribute the entire {@link SplitView} size among all {@link IView views}.
   */
  distributeViewSizes() {
    const flexibleViewItems = [];
    let flexibleSize = 0;
    for (const item of this.viewItems) {
      if (item.maximumSize - item.minimumSize > 0) {
        flexibleViewItems.push(item);
        flexibleSize += item.size;
      }
    }
    const size = Math.floor(flexibleSize / flexibleViewItems.length);
    for (const item of flexibleViewItems) {
      item.size = clamp(size, item.minimumSize, item.maximumSize);
    }
    const indexes = range(this.viewItems.length);
    const lowPriorityIndexes = indexes.filter(
      (i) => this.viewItems[i].priority === 1
      /* LayoutPriority.Low */
    );
    const highPriorityIndexes = indexes.filter(
      (i) => this.viewItems[i].priority === 2
      /* LayoutPriority.High */
    );
    this.relayout(lowPriorityIndexes, highPriorityIndexes);
  }
  /**
   * Returns the size of a {@link IView view}.
   */
  getViewSize(index) {
    if (index < 0 || index >= this.viewItems.length) {
      return -1;
    }
    return this.viewItems[index].size;
  }
  doAddView(view, size, index = this.viewItems.length, skipLayout) {
    if (this.state !== State.Idle) {
      throw new Error("Cant modify splitview");
    }
    this.state = State.Busy;
    try {
      const container = $(".split-view-view");
      if (index === this.viewItems.length) {
        this.viewContainer.appendChild(container);
      } else {
        this.viewContainer.insertBefore(container, this.viewContainer.children.item(index));
      }
      const onChangeDisposable = view.onDidChange((size2) => this.onViewChange(item, size2));
      const containerDisposable = toDisposable(() => this.viewContainer.removeChild(container));
      const disposable = combinedDisposable(onChangeDisposable, containerDisposable);
      let viewSize;
      if (typeof size === "number") {
        viewSize = size;
      } else {
        if (size.type === "auto") {
          if (this.areViewsDistributed()) {
            size = { type: "distribute" };
          } else {
            size = { type: "split", index: size.index };
          }
        }
        if (size.type === "split") {
          viewSize = this.getViewSize(size.index) / 2;
        } else if (size.type === "invisible") {
          viewSize = { cachedVisibleSize: size.cachedVisibleSize };
        } else {
          viewSize = view.minimumSize;
        }
      }
      const item = this.orientation === 0 ? new VerticalViewItem(container, view, viewSize, disposable) : new HorizontalViewItem(container, view, viewSize, disposable);
      this.viewItems.splice(index, 0, item);
      if (this.viewItems.length > 1) {
        const opts = { orthogonalStartSash: this.orthogonalStartSash, orthogonalEndSash: this.orthogonalEndSash };
        const sash = this.orientation === 0 ? new Sash(this.sashContainer, { getHorizontalSashTop: (s) => this.getSashPosition(s), getHorizontalSashWidth: this.getSashOrthogonalSize }, {
          ...opts,
          orientation: 1
          /* Orientation.HORIZONTAL */
        }) : new Sash(this.sashContainer, { getVerticalSashLeft: (s) => this.getSashPosition(s), getVerticalSashHeight: this.getSashOrthogonalSize }, {
          ...opts,
          orientation: 0
          /* Orientation.VERTICAL */
        });
        const sashEventMapper = this.orientation === 0 ? (e) => ({ sash, start: e.startY, current: e.currentY, alt: e.altKey }) : (e) => ({ sash, start: e.startX, current: e.currentX, alt: e.altKey });
        const onStart = Event.map(sash.onDidStart, sashEventMapper);
        const onStartDisposable = onStart(this.onSashStart, this);
        const onChange = Event.map(sash.onDidChange, sashEventMapper);
        const onChangeDisposable2 = onChange(this.onSashChange, this);
        const onEnd = Event.map(sash.onDidEnd, () => this.sashItems.findIndex((item2) => item2.sash === sash));
        const onEndDisposable = onEnd(this.onSashEnd, this);
        const onDidResetDisposable = sash.onDidReset(() => {
          const index2 = this.sashItems.findIndex((item2) => item2.sash === sash);
          const upIndexes = range(index2, -1);
          const downIndexes = range(index2 + 1, this.viewItems.length);
          const snapBeforeIndex = this.findFirstSnapIndex(upIndexes);
          const snapAfterIndex = this.findFirstSnapIndex(downIndexes);
          if (typeof snapBeforeIndex === "number" && !this.viewItems[snapBeforeIndex].visible) {
            return;
          }
          if (typeof snapAfterIndex === "number" && !this.viewItems[snapAfterIndex].visible) {
            return;
          }
          this._onDidSashReset.fire(index2);
        });
        const disposable2 = combinedDisposable(onStartDisposable, onChangeDisposable2, onEndDisposable, onDidResetDisposable, sash);
        const sashItem = { sash, disposable: disposable2 };
        this.sashItems.splice(index - 1, 0, sashItem);
      }
      container.appendChild(view.element);
      let highPriorityIndexes;
      if (typeof size !== "number" && size.type === "split") {
        highPriorityIndexes = [size.index];
      }
      if (!skipLayout) {
        this.relayout([index], highPriorityIndexes);
      }
      if (!skipLayout && typeof size !== "number" && size.type === "distribute") {
        this.distributeViewSizes();
      }
    } finally {
      this.state = State.Idle;
    }
  }
  relayout(lowPriorityIndexes, highPriorityIndexes) {
    const contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
    this.resize(this.viewItems.length - 1, this.size - contentSize, void 0, lowPriorityIndexes, highPriorityIndexes);
    this.distributeEmptySpace();
    this.layoutViews();
    this.saveProportions();
  }
  resize(index, delta, sizes = this.viewItems.map((i) => i.size), lowPriorityIndexes, highPriorityIndexes, overloadMinDelta = Number.NEGATIVE_INFINITY, overloadMaxDelta = Number.POSITIVE_INFINITY, snapBefore, snapAfter) {
    if (index < 0 || index >= this.viewItems.length) {
      return 0;
    }
    const upIndexes = range(index, -1);
    const downIndexes = range(index + 1, this.viewItems.length);
    if (highPriorityIndexes) {
      for (const index2 of highPriorityIndexes) {
        pushToStart(upIndexes, index2);
        pushToStart(downIndexes, index2);
      }
    }
    if (lowPriorityIndexes) {
      for (const index2 of lowPriorityIndexes) {
        pushToEnd(upIndexes, index2);
        pushToEnd(downIndexes, index2);
      }
    }
    const upItems = upIndexes.map((i) => this.viewItems[i]);
    const upSizes = upIndexes.map((i) => sizes[i]);
    const downItems = downIndexes.map((i) => this.viewItems[i]);
    const downSizes = downIndexes.map((i) => sizes[i]);
    const minDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].minimumSize - sizes[i]), 0);
    const maxDeltaUp = upIndexes.reduce((r, i) => r + (this.viewItems[i].maximumSize - sizes[i]), 0);
    const maxDeltaDown = downIndexes.length === 0 ? Number.POSITIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].minimumSize), 0);
    const minDeltaDown = downIndexes.length === 0 ? Number.NEGATIVE_INFINITY : downIndexes.reduce((r, i) => r + (sizes[i] - this.viewItems[i].maximumSize), 0);
    const minDelta = Math.max(minDeltaUp, minDeltaDown, overloadMinDelta);
    const maxDelta = Math.min(maxDeltaDown, maxDeltaUp, overloadMaxDelta);
    let snapped = false;
    if (snapBefore) {
      const snapView = this.viewItems[snapBefore.index];
      const visible = delta >= snapBefore.limitDelta;
      snapped = visible !== snapView.visible;
      snapView.setVisible(visible, snapBefore.size);
    }
    if (!snapped && snapAfter) {
      const snapView = this.viewItems[snapAfter.index];
      const visible = delta < snapAfter.limitDelta;
      snapped = visible !== snapView.visible;
      snapView.setVisible(visible, snapAfter.size);
    }
    if (snapped) {
      return this.resize(index, delta, sizes, lowPriorityIndexes, highPriorityIndexes, overloadMinDelta, overloadMaxDelta);
    }
    delta = clamp(delta, minDelta, maxDelta);
    for (let i = 0, deltaUp = delta; i < upItems.length; i++) {
      const item = upItems[i];
      const size = clamp(upSizes[i] + deltaUp, item.minimumSize, item.maximumSize);
      const viewDelta = size - upSizes[i];
      deltaUp -= viewDelta;
      item.size = size;
    }
    for (let i = 0, deltaDown = delta; i < downItems.length; i++) {
      const item = downItems[i];
      const size = clamp(downSizes[i] - deltaDown, item.minimumSize, item.maximumSize);
      const viewDelta = size - downSizes[i];
      deltaDown += viewDelta;
      item.size = size;
    }
    return delta;
  }
  distributeEmptySpace(lowPriorityIndex) {
    const contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
    let emptyDelta = this.size - contentSize;
    const indexes = range(this.viewItems.length - 1, -1);
    const lowPriorityIndexes = indexes.filter(
      (i) => this.viewItems[i].priority === 1
      /* LayoutPriority.Low */
    );
    const highPriorityIndexes = indexes.filter(
      (i) => this.viewItems[i].priority === 2
      /* LayoutPriority.High */
    );
    for (const index of highPriorityIndexes) {
      pushToStart(indexes, index);
    }
    for (const index of lowPriorityIndexes) {
      pushToEnd(indexes, index);
    }
    if (typeof lowPriorityIndex === "number") {
      pushToEnd(indexes, lowPriorityIndex);
    }
    for (let i = 0; emptyDelta !== 0 && i < indexes.length; i++) {
      const item = this.viewItems[indexes[i]];
      const size = clamp(item.size + emptyDelta, item.minimumSize, item.maximumSize);
      const viewDelta = size - item.size;
      emptyDelta -= viewDelta;
      item.size = size;
    }
  }
  layoutViews() {
    this._contentSize = this.viewItems.reduce((r, i) => r + i.size, 0);
    let offset = 0;
    for (const viewItem of this.viewItems) {
      viewItem.layout(offset, this.layoutContext);
      offset += viewItem.size;
    }
    this.sashItems.forEach((item) => item.sash.layout());
    this.updateSashEnablement();
    this.updateScrollableElement();
  }
  updateScrollableElement() {
    if (this.orientation === 0) {
      this.scrollableElement.setScrollDimensions({
        height: this.size,
        scrollHeight: this._contentSize
      });
    } else {
      this.scrollableElement.setScrollDimensions({
        width: this.size,
        scrollWidth: this._contentSize
      });
    }
  }
  updateSashEnablement() {
    let previous = false;
    const collapsesDown = this.viewItems.map((i) => previous = i.size - i.minimumSize > 0 || previous);
    previous = false;
    const expandsDown = this.viewItems.map((i) => previous = i.maximumSize - i.size > 0 || previous);
    const reverseViews = [...this.viewItems].reverse();
    previous = false;
    const collapsesUp = reverseViews.map((i) => previous = i.size - i.minimumSize > 0 || previous).reverse();
    previous = false;
    const expandsUp = reverseViews.map((i) => previous = i.maximumSize - i.size > 0 || previous).reverse();
    let position = 0;
    for (let index = 0; index < this.sashItems.length; index++) {
      const { sash } = this.sashItems[index];
      const viewItem = this.viewItems[index];
      position += viewItem.size;
      const min = !(collapsesDown[index] && expandsUp[index + 1]);
      const max = !(expandsDown[index] && collapsesUp[index + 1]);
      if (min && max) {
        const upIndexes = range(index, -1);
        const downIndexes = range(index + 1, this.viewItems.length);
        const snapBeforeIndex = this.findFirstSnapIndex(upIndexes);
        const snapAfterIndex = this.findFirstSnapIndex(downIndexes);
        const snappedBefore = typeof snapBeforeIndex === "number" && !this.viewItems[snapBeforeIndex].visible;
        const snappedAfter = typeof snapAfterIndex === "number" && !this.viewItems[snapAfterIndex].visible;
        if (snappedBefore && collapsesUp[index] && (position > 0 || this.startSnappingEnabled)) {
          sash.state = 1;
        } else if (snappedAfter && collapsesDown[index] && (position < this._contentSize || this.endSnappingEnabled)) {
          sash.state = 2;
        } else {
          sash.state = 0;
        }
      } else if (min && !max) {
        sash.state = 1;
      } else if (!min && max) {
        sash.state = 2;
      } else {
        sash.state = 3;
      }
    }
  }
  getSashPosition(sash) {
    let position = 0;
    for (let i = 0; i < this.sashItems.length; i++) {
      position += this.viewItems[i].size;
      if (this.sashItems[i].sash === sash) {
        return position;
      }
    }
    return 0;
  }
  findFirstSnapIndex(indexes) {
    for (const index of indexes) {
      const viewItem = this.viewItems[index];
      if (!viewItem.visible) {
        continue;
      }
      if (viewItem.snap) {
        return index;
      }
    }
    for (const index of indexes) {
      const viewItem = this.viewItems[index];
      if (viewItem.visible && viewItem.maximumSize - viewItem.minimumSize > 0) {
        return void 0;
      }
      if (!viewItem.visible && viewItem.snap) {
        return index;
      }
    }
    return void 0;
  }
  areViewsDistributed() {
    let min = void 0, max = void 0;
    for (const view of this.viewItems) {
      min = min === void 0 ? view.size : Math.min(min, view.size);
      max = max === void 0 ? view.size : Math.max(max, view.size);
      if (max - min > 2) {
        return false;
      }
    }
    return true;
  }
  dispose() {
    var _a2;
    (_a2 = this.sashDragState) === null || _a2 === void 0 ? void 0 : _a2.disposable.dispose();
    dispose(this.viewItems);
    this.viewItems = [];
    this.sashItems.forEach((i) => i.disposable.dispose());
    this.sashItems = [];
    super.dispose();
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/table/tableWidget.js
init_event();
init_lifecycle();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/table/table.css";
var TableListRenderer = class _TableListRenderer {
  constructor(columns, renderers, getColumnSize) {
    this.columns = columns;
    this.getColumnSize = getColumnSize;
    this.templateId = _TableListRenderer.TemplateId;
    this.renderedTemplates = /* @__PURE__ */ new Set();
    const rendererMap = new Map(renderers.map((r) => [r.templateId, r]));
    this.renderers = [];
    for (const column of columns) {
      const renderer = rendererMap.get(column.templateId);
      if (!renderer) {
        throw new Error(`Table cell renderer for template id ${column.templateId} not found.`);
      }
      this.renderers.push(renderer);
    }
  }
  renderTemplate(container) {
    const rowContainer = append(container, $(".monaco-table-tr"));
    const cellContainers = [];
    const cellTemplateData = [];
    for (let i = 0; i < this.columns.length; i++) {
      const renderer = this.renderers[i];
      const cellContainer = append(rowContainer, $(".monaco-table-td", { "data-col-index": i }));
      cellContainer.style.width = `${this.getColumnSize(i)}px`;
      cellContainers.push(cellContainer);
      cellTemplateData.push(renderer.renderTemplate(cellContainer));
    }
    const result = { container, cellContainers, cellTemplateData };
    this.renderedTemplates.add(result);
    return result;
  }
  renderElement(element, index, templateData, height) {
    for (let i = 0; i < this.columns.length; i++) {
      const column = this.columns[i];
      const cell = column.project(element);
      const renderer = this.renderers[i];
      renderer.renderElement(cell, index, templateData.cellTemplateData[i], height);
    }
  }
  disposeElement(element, index, templateData, height) {
    for (let i = 0; i < this.columns.length; i++) {
      const renderer = this.renderers[i];
      if (renderer.disposeElement) {
        const column = this.columns[i];
        const cell = column.project(element);
        renderer.disposeElement(cell, index, templateData.cellTemplateData[i], height);
      }
    }
  }
  disposeTemplate(templateData) {
    for (let i = 0; i < this.columns.length; i++) {
      const renderer = this.renderers[i];
      renderer.disposeTemplate(templateData.cellTemplateData[i]);
    }
    clearNode(templateData.container);
    this.renderedTemplates.delete(templateData);
  }
  layoutColumn(index, size) {
    for (const { cellContainers } of this.renderedTemplates) {
      cellContainers[index].style.width = `${size}px`;
    }
  }
};
TableListRenderer.TemplateId = "row";
function asListVirtualDelegate(delegate) {
  return {
    getHeight(row) {
      return delegate.getHeight(row);
    },
    getTemplateId() {
      return TableListRenderer.TemplateId;
    }
  };
}
var ColumnHeader = class extends Disposable {
  get minimumSize() {
    var _a2;
    return (_a2 = this.column.minimumWidth) !== null && _a2 !== void 0 ? _a2 : 120;
  }
  get maximumSize() {
    var _a2;
    return (_a2 = this.column.maximumWidth) !== null && _a2 !== void 0 ? _a2 : Number.POSITIVE_INFINITY;
  }
  get onDidChange() {
    var _a2;
    return (_a2 = this.column.onDidChangeWidthConstraints) !== null && _a2 !== void 0 ? _a2 : Event.None;
  }
  constructor(column, index) {
    super();
    this.column = column;
    this.index = index;
    this._onDidLayout = new Emitter();
    this.onDidLayout = this._onDidLayout.event;
    this.element = $(".monaco-table-th", { "data-col-index": index }, column.label);
    this._register(setupCustomHover(getDefaultHoverDelegate("mouse"), this.element, column.tooltip));
  }
  layout(size) {
    this._onDidLayout.fire([this.index, size]);
  }
};
var Table = class _Table {
  get onDidChangeFocus() {
    return this.list.onDidChangeFocus;
  }
  get onDidChangeSelection() {
    return this.list.onDidChangeSelection;
  }
  get onDidScroll() {
    return this.list.onDidScroll;
  }
  get onMouseDblClick() {
    return this.list.onMouseDblClick;
  }
  get onPointer() {
    return this.list.onPointer;
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get scrollTop() {
    return this.list.scrollTop;
  }
  set scrollTop(scrollTop) {
    this.list.scrollTop = scrollTop;
  }
  get scrollHeight() {
    return this.list.scrollHeight;
  }
  get renderHeight() {
    return this.list.renderHeight;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  constructor(user, container, virtualDelegate, columns, renderers, _options) {
    this.virtualDelegate = virtualDelegate;
    this.domId = `table_id_${++_Table.InstanceCount}`;
    this.disposables = new DisposableStore();
    this.cachedWidth = 0;
    this.cachedHeight = 0;
    this.domNode = append(container, $(`.monaco-table.${this.domId}`));
    const headers = columns.map((c, i) => this.disposables.add(new ColumnHeader(c, i)));
    const descriptor = {
      size: headers.reduce((a, b) => a + b.column.weight, 0),
      views: headers.map((view) => ({ size: view.column.weight, view }))
    };
    this.splitview = this.disposables.add(new SplitView(this.domNode, {
      orientation: 1,
      scrollbarVisibility: 2,
      getSashOrthogonalSize: () => this.cachedHeight,
      descriptor
    }));
    this.splitview.el.style.height = `${virtualDelegate.headerRowHeight}px`;
    this.splitview.el.style.lineHeight = `${virtualDelegate.headerRowHeight}px`;
    const renderer = new TableListRenderer(columns, renderers, (i) => this.splitview.getViewSize(i));
    this.list = this.disposables.add(new List(user, this.domNode, asListVirtualDelegate(virtualDelegate), [renderer], _options));
    Event.any(...headers.map((h2) => h2.onDidLayout))(([index, size]) => renderer.layoutColumn(index, size), null, this.disposables);
    this.splitview.onDidSashReset((index) => {
      const totalWeight = columns.reduce((r, c) => r + c.weight, 0);
      const size = columns[index].weight / totalWeight * this.cachedWidth;
      this.splitview.resizeView(index, size);
    }, null, this.disposables);
    this.styleElement = createStyleSheet(this.domNode);
    this.style(unthemedListStyles);
  }
  updateOptions(options2) {
    this.list.updateOptions(options2);
  }
  splice(start, deleteCount, elements = []) {
    this.list.splice(start, deleteCount, elements);
  }
  getHTMLElement() {
    return this.domNode;
  }
  style(styles) {
    const content = [];
    content.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {
			top: ${this.virtualDelegate.headerRowHeight + 1}px;
			height: calc(100% - ${this.virtualDelegate.headerRowHeight}px);
		}`);
    this.styleElement.textContent = content.join("\n");
    this.list.style(styles);
  }
  getSelectedElements() {
    return this.list.getSelectedElements();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getFocus() {
    return this.list.getFocus();
  }
  dispose() {
    this.disposables.dispose();
  }
};
Table.InstanceCount = 0;

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/abstractTree.js
init_dom();
init_keyboardEvent();

// node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInput.js
init_dom();

// node_modules/monaco-editor/esm/vs/base/browser/ui/toggle/toggle.js
init_themables();
init_event();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/toggle/toggle.css";
var Toggle = class extends Widget {
  constructor(opts) {
    super();
    this._onChange = this._register(new Emitter());
    this.onChange = this._onChange.event;
    this._onKeyDown = this._register(new Emitter());
    this.onKeyDown = this._onKeyDown.event;
    this._opts = opts;
    this._checked = this._opts.isChecked;
    const classes = ["monaco-custom-toggle"];
    if (this._opts.icon) {
      this._icon = this._opts.icon;
      classes.push(...ThemeIcon.asClassNameArray(this._icon));
    }
    if (this._opts.actionClassName) {
      classes.push(...this._opts.actionClassName.split(" "));
    }
    if (this._checked) {
      classes.push("checked");
    }
    this.domNode = document.createElement("div");
    this._hover = this._register(setupCustomHover(getDefaultHoverDelegate("mouse"), this.domNode, this._opts.title));
    this.domNode.classList.add(...classes);
    if (!this._opts.notFocusable) {
      this.domNode.tabIndex = 0;
    }
    this.domNode.setAttribute("role", "checkbox");
    this.domNode.setAttribute("aria-checked", String(this._checked));
    this.domNode.setAttribute("aria-label", this._opts.title);
    this.applyStyles();
    this.onclick(this.domNode, (ev) => {
      if (this.enabled) {
        this.checked = !this._checked;
        this._onChange.fire(false);
        ev.preventDefault();
      }
    });
    this._register(this.ignoreGesture(this.domNode));
    this.onkeydown(this.domNode, (keyboardEvent) => {
      if (keyboardEvent.keyCode === 10 || keyboardEvent.keyCode === 3) {
        this.checked = !this._checked;
        this._onChange.fire(true);
        keyboardEvent.preventDefault();
        keyboardEvent.stopPropagation();
        return;
      }
      this._onKeyDown.fire(keyboardEvent);
    });
  }
  get enabled() {
    return this.domNode.getAttribute("aria-disabled") !== "true";
  }
  focus() {
    this.domNode.focus();
  }
  get checked() {
    return this._checked;
  }
  set checked(newIsChecked) {
    this._checked = newIsChecked;
    this.domNode.setAttribute("aria-checked", String(this._checked));
    this.domNode.classList.toggle("checked", this._checked);
    this.applyStyles();
  }
  width() {
    return 2 + 2 + 2 + 16;
  }
  applyStyles() {
    if (this.domNode) {
      this.domNode.style.borderColor = this._checked && this._opts.inputActiveOptionBorder || "";
      this.domNode.style.color = this._checked && this._opts.inputActiveOptionForeground || "inherit";
      this.domNode.style.backgroundColor = this._checked && this._opts.inputActiveOptionBackground || "";
    }
  }
  enable() {
    this.domNode.setAttribute("aria-disabled", String(false));
  }
  disable() {
    this.domNode.setAttribute("aria-disabled", String(true));
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInputToggles.js
init_codicons();
init_nls();
var NLS_CASE_SENSITIVE_TOGGLE_LABEL = localize("caseDescription", "Match Case");
var NLS_WHOLE_WORD_TOGGLE_LABEL = localize("wordsDescription", "Match Whole Word");
var NLS_REGEX_TOGGLE_LABEL = localize("regexDescription", "Use Regular Expression");
var CaseSensitiveToggle = class extends Toggle {
  constructor(opts) {
    super({
      icon: Codicon.caseSensitive,
      title: NLS_CASE_SENSITIVE_TOGGLE_LABEL + opts.appendTitle,
      isChecked: opts.isChecked,
      inputActiveOptionBorder: opts.inputActiveOptionBorder,
      inputActiveOptionForeground: opts.inputActiveOptionForeground,
      inputActiveOptionBackground: opts.inputActiveOptionBackground
    });
  }
};
var WholeWordsToggle = class extends Toggle {
  constructor(opts) {
    super({
      icon: Codicon.wholeWord,
      title: NLS_WHOLE_WORD_TOGGLE_LABEL + opts.appendTitle,
      isChecked: opts.isChecked,
      inputActiveOptionBorder: opts.inputActiveOptionBorder,
      inputActiveOptionForeground: opts.inputActiveOptionForeground,
      inputActiveOptionBackground: opts.inputActiveOptionBackground
    });
  }
};
var RegexToggle = class extends Toggle {
  constructor(opts) {
    super({
      icon: Codicon.regex,
      title: NLS_REGEX_TOGGLE_LABEL + opts.appendTitle,
      isChecked: opts.isChecked,
      inputActiveOptionBorder: opts.inputActiveOptionBorder,
      inputActiveOptionForeground: opts.inputActiveOptionForeground,
      inputActiveOptionBackground: opts.inputActiveOptionBackground
    });
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.js
init_dom();
init_event();

// node_modules/monaco-editor/esm/vs/base/common/navigator.js
var ArrayNavigator = class {
  constructor(items, start = 0, end = items.length, index = start - 1) {
    this.items = items;
    this.start = start;
    this.end = end;
    this.index = index;
  }
  current() {
    if (this.index === this.start - 1 || this.index === this.end) {
      return null;
    }
    return this.items[this.index];
  }
  next() {
    this.index = Math.min(this.index + 1, this.end);
    return this.current();
  }
  previous() {
    this.index = Math.max(this.index - 1, this.start - 1);
    return this.current();
  }
  first() {
    this.index = this.start;
    return this.current();
  }
  last() {
    this.index = this.end - 1;
    return this.current();
  }
};

// node_modules/monaco-editor/esm/vs/base/common/history.js
var HistoryNavigator = class {
  constructor(history = [], limit = 10) {
    this._initialize(history);
    this._limit = limit;
    this._onChange();
  }
  getHistory() {
    return this._elements;
  }
  add(t) {
    this._history.delete(t);
    this._history.add(t);
    this._onChange();
  }
  next() {
    return this._navigator.next();
  }
  previous() {
    if (this._currentPosition() !== 0) {
      return this._navigator.previous();
    }
    return null;
  }
  current() {
    return this._navigator.current();
  }
  first() {
    return this._navigator.first();
  }
  last() {
    return this._navigator.last();
  }
  isLast() {
    return this._currentPosition() >= this._elements.length - 1;
  }
  isNowhere() {
    return this._navigator.current() === null;
  }
  has(t) {
    return this._history.has(t);
  }
  _onChange() {
    this._reduceToLimit();
    const elements = this._elements;
    this._navigator = new ArrayNavigator(elements, 0, elements.length, elements.length);
  }
  _reduceToLimit() {
    const data = this._elements;
    if (data.length > this._limit) {
      this._initialize(data.slice(data.length - this._limit));
    }
  }
  _currentPosition() {
    const currentElement = this._navigator.current();
    if (!currentElement) {
      return -1;
    }
    return this._elements.indexOf(currentElement);
  }
  _initialize(history) {
    this._history = /* @__PURE__ */ new Set();
    for (const entry of history) {
      this._history.add(entry);
    }
  }
  get _elements() {
    const elements = [];
    this._history.forEach((e) => elements.push(e));
    return elements;
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.js
init_objects();
init_nls();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.css";
var $5 = $;
var InputBox = class extends Widget {
  constructor(container, contextViewProvider, options2) {
    var _a2;
    super();
    this.state = "idle";
    this.maxHeight = Number.POSITIVE_INFINITY;
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    this._onDidHeightChange = this._register(new Emitter());
    this.onDidHeightChange = this._onDidHeightChange.event;
    this.contextViewProvider = contextViewProvider;
    this.options = options2;
    this.message = null;
    this.placeholder = this.options.placeholder || "";
    this.tooltip = (_a2 = this.options.tooltip) !== null && _a2 !== void 0 ? _a2 : this.placeholder || "";
    this.ariaLabel = this.options.ariaLabel || "";
    if (this.options.validationOptions) {
      this.validation = this.options.validationOptions.validation;
    }
    this.element = append(container, $5(".monaco-inputbox.idle"));
    const tagName = this.options.flexibleHeight ? "textarea" : "input";
    const wrapper = append(this.element, $5(".ibwrapper"));
    this.input = append(wrapper, $5(tagName + ".input.empty"));
    this.input.setAttribute("autocorrect", "off");
    this.input.setAttribute("autocapitalize", "off");
    this.input.setAttribute("spellcheck", "false");
    this.onfocus(this.input, () => this.element.classList.add("synthetic-focus"));
    this.onblur(this.input, () => this.element.classList.remove("synthetic-focus"));
    if (this.options.flexibleHeight) {
      this.maxHeight = typeof this.options.flexibleMaxHeight === "number" ? this.options.flexibleMaxHeight : Number.POSITIVE_INFINITY;
      this.mirror = append(wrapper, $5("div.mirror"));
      this.mirror.innerText = "";
      this.scrollableElement = new ScrollableElement(this.element, {
        vertical: 1
        /* ScrollbarVisibility.Auto */
      });
      if (this.options.flexibleWidth) {
        this.input.setAttribute("wrap", "off");
        this.mirror.style.whiteSpace = "pre";
        this.mirror.style.wordWrap = "initial";
      }
      append(container, this.scrollableElement.getDomNode());
      this._register(this.scrollableElement);
      this._register(this.scrollableElement.onScroll((e) => this.input.scrollTop = e.scrollTop));
      const onSelectionChange = this._register(new DomEmitter(container.ownerDocument, "selectionchange"));
      const onAnchoredSelectionChange = Event.filter(onSelectionChange.event, () => {
        const selection = container.ownerDocument.getSelection();
        return (selection === null || selection === void 0 ? void 0 : selection.anchorNode) === wrapper;
      });
      this._register(onAnchoredSelectionChange(this.updateScrollDimensions, this));
      this._register(this.onDidHeightChange(this.updateScrollDimensions, this));
    } else {
      this.input.type = this.options.type || "text";
      this.input.setAttribute("wrap", "off");
    }
    if (this.ariaLabel) {
      this.input.setAttribute("aria-label", this.ariaLabel);
    }
    if (this.placeholder && !this.options.showPlaceholderOnFocus) {
      this.setPlaceHolder(this.placeholder);
    }
    if (this.tooltip) {
      this.setTooltip(this.tooltip);
    }
    this.oninput(this.input, () => this.onValueChange());
    this.onblur(this.input, () => this.onBlur());
    this.onfocus(this.input, () => this.onFocus());
    this._register(this.ignoreGesture(this.input));
    setTimeout(() => this.updateMirror(), 0);
    if (this.options.actions) {
      this.actionbar = this._register(new ActionBar(this.element));
      this.actionbar.push(this.options.actions, { icon: true, label: false });
    }
    this.applyStyles();
  }
  onBlur() {
    this._hideMessage();
    if (this.options.showPlaceholderOnFocus) {
      this.input.setAttribute("placeholder", "");
    }
  }
  onFocus() {
    this._showMessage();
    if (this.options.showPlaceholderOnFocus) {
      this.input.setAttribute("placeholder", this.placeholder || "");
    }
  }
  setPlaceHolder(placeHolder) {
    this.placeholder = placeHolder;
    this.input.setAttribute("placeholder", placeHolder);
  }
  setTooltip(tooltip) {
    this.tooltip = tooltip;
    this.input.title = tooltip;
  }
  get inputElement() {
    return this.input;
  }
  get value() {
    return this.input.value;
  }
  set value(newValue) {
    if (this.input.value !== newValue) {
      this.input.value = newValue;
      this.onValueChange();
    }
  }
  get height() {
    return typeof this.cachedHeight === "number" ? this.cachedHeight : getTotalHeight(this.element);
  }
  focus() {
    this.input.focus();
  }
  blur() {
    this.input.blur();
  }
  hasFocus() {
    return isActiveElement(this.input);
  }
  select(range2 = null) {
    this.input.select();
    if (range2) {
      this.input.setSelectionRange(range2.start, range2.end);
      if (range2.end === this.input.value.length) {
        this.input.scrollLeft = this.input.scrollWidth;
      }
    }
  }
  isSelectionAtEnd() {
    return this.input.selectionEnd === this.input.value.length && this.input.selectionStart === this.input.selectionEnd;
  }
  enable() {
    this.input.removeAttribute("disabled");
  }
  disable() {
    this.blur();
    this.input.disabled = true;
    this._hideMessage();
  }
  set paddingRight(paddingRight) {
    this.input.style.width = `calc(100% - ${paddingRight}px)`;
    if (this.mirror) {
      this.mirror.style.paddingRight = paddingRight + "px";
    }
  }
  updateScrollDimensions() {
    if (typeof this.cachedContentHeight !== "number" || typeof this.cachedHeight !== "number" || !this.scrollableElement) {
      return;
    }
    const scrollHeight = this.cachedContentHeight;
    const height = this.cachedHeight;
    const scrollTop = this.input.scrollTop;
    this.scrollableElement.setScrollDimensions({ scrollHeight, height });
    this.scrollableElement.setScrollPosition({ scrollTop });
  }
  showMessage(message, force) {
    if (this.state === "open" && equals2(this.message, message)) {
      return;
    }
    this.message = message;
    this.element.classList.remove("idle");
    this.element.classList.remove("info");
    this.element.classList.remove("warning");
    this.element.classList.remove("error");
    this.element.classList.add(this.classForType(message.type));
    const styles = this.stylesForType(this.message.type);
    this.element.style.border = `1px solid ${asCssValueWithDefault(styles.border, "transparent")}`;
    if (this.message.content && (this.hasFocus() || force)) {
      this._showMessage();
    }
  }
  hideMessage() {
    this.message = null;
    this.element.classList.remove("info");
    this.element.classList.remove("warning");
    this.element.classList.remove("error");
    this.element.classList.add("idle");
    this._hideMessage();
    this.applyStyles();
  }
  validate() {
    let errorMsg = null;
    if (this.validation) {
      errorMsg = this.validation(this.value);
      if (errorMsg) {
        this.inputElement.setAttribute("aria-invalid", "true");
        this.showMessage(errorMsg);
      } else if (this.inputElement.hasAttribute("aria-invalid")) {
        this.inputElement.removeAttribute("aria-invalid");
        this.hideMessage();
      }
    }
    return errorMsg === null || errorMsg === void 0 ? void 0 : errorMsg.type;
  }
  stylesForType(type) {
    const styles = this.options.inputBoxStyles;
    switch (type) {
      case 1:
        return { border: styles.inputValidationInfoBorder, background: styles.inputValidationInfoBackground, foreground: styles.inputValidationInfoForeground };
      case 2:
        return { border: styles.inputValidationWarningBorder, background: styles.inputValidationWarningBackground, foreground: styles.inputValidationWarningForeground };
      default:
        return { border: styles.inputValidationErrorBorder, background: styles.inputValidationErrorBackground, foreground: styles.inputValidationErrorForeground };
    }
  }
  classForType(type) {
    switch (type) {
      case 1:
        return "info";
      case 2:
        return "warning";
      default:
        return "error";
    }
  }
  _showMessage() {
    if (!this.contextViewProvider || !this.message) {
      return;
    }
    let div;
    const layout2 = () => div.style.width = getTotalWidth(this.element) + "px";
    this.contextViewProvider.showContextView({
      getAnchor: () => this.element,
      anchorAlignment: 1,
      render: (container) => {
        var _a2, _b2;
        if (!this.message) {
          return null;
        }
        div = append(container, $5(".monaco-inputbox-container"));
        layout2();
        const renderOptions = {
          inline: true,
          className: "monaco-inputbox-message"
        };
        const spanElement = this.message.formatContent ? renderFormattedText(this.message.content, renderOptions) : renderText(this.message.content, renderOptions);
        spanElement.classList.add(this.classForType(this.message.type));
        const styles = this.stylesForType(this.message.type);
        spanElement.style.backgroundColor = (_a2 = styles.background) !== null && _a2 !== void 0 ? _a2 : "";
        spanElement.style.color = (_b2 = styles.foreground) !== null && _b2 !== void 0 ? _b2 : "";
        spanElement.style.border = styles.border ? `1px solid ${styles.border}` : "";
        append(div, spanElement);
        return null;
      },
      onHide: () => {
        this.state = "closed";
      },
      layout: layout2
    });
    let alertText;
    if (this.message.type === 3) {
      alertText = localize("alertErrorMessage", "Error: {0}", this.message.content);
    } else if (this.message.type === 2) {
      alertText = localize("alertWarningMessage", "Warning: {0}", this.message.content);
    } else {
      alertText = localize("alertInfoMessage", "Info: {0}", this.message.content);
    }
    alert(alertText);
    this.state = "open";
  }
  _hideMessage() {
    if (!this.contextViewProvider) {
      return;
    }
    if (this.state === "open") {
      this.contextViewProvider.hideContextView();
    }
    this.state = "idle";
  }
  onValueChange() {
    this._onDidChange.fire(this.value);
    this.validate();
    this.updateMirror();
    this.input.classList.toggle("empty", !this.value);
    if (this.state === "open" && this.contextViewProvider) {
      this.contextViewProvider.layout();
    }
  }
  updateMirror() {
    if (!this.mirror) {
      return;
    }
    const value = this.value;
    const lastCharCode = value.charCodeAt(value.length - 1);
    const suffix = lastCharCode === 10 ? " " : "";
    const mirrorTextContent = (value + suffix).replace(/\u000c/g, "");
    if (mirrorTextContent) {
      this.mirror.textContent = value + suffix;
    } else {
      this.mirror.innerText = "";
    }
    this.layout();
  }
  applyStyles() {
    var _a2, _b2, _c;
    const styles = this.options.inputBoxStyles;
    const background = (_a2 = styles.inputBackground) !== null && _a2 !== void 0 ? _a2 : "";
    const foreground2 = (_b2 = styles.inputForeground) !== null && _b2 !== void 0 ? _b2 : "";
    const border = (_c = styles.inputBorder) !== null && _c !== void 0 ? _c : "";
    this.element.style.backgroundColor = background;
    this.element.style.color = foreground2;
    this.input.style.backgroundColor = "inherit";
    this.input.style.color = foreground2;
    this.element.style.border = `1px solid ${asCssValueWithDefault(border, "transparent")}`;
  }
  layout() {
    if (!this.mirror) {
      return;
    }
    const previousHeight = this.cachedContentHeight;
    this.cachedContentHeight = getTotalHeight(this.mirror);
    if (previousHeight !== this.cachedContentHeight) {
      this.cachedHeight = Math.min(this.cachedContentHeight, this.maxHeight);
      this.input.style.height = this.cachedHeight + "px";
      this._onDidHeightChange.fire(this.cachedContentHeight);
    }
  }
  insertAtCursor(text) {
    const inputElement = this.inputElement;
    const start = inputElement.selectionStart;
    const end = inputElement.selectionEnd;
    const content = inputElement.value;
    if (start !== null && end !== null) {
      this.value = content.substr(0, start) + text + content.substr(end);
      inputElement.setSelectionRange(start + 1, start + 1);
      this.layout();
    }
  }
  dispose() {
    var _a2;
    this._hideMessage();
    this.message = null;
    (_a2 = this.actionbar) === null || _a2 === void 0 ? void 0 : _a2.dispose();
    super.dispose();
  }
};
var HistoryInputBox = class extends InputBox {
  constructor(container, contextViewProvider, options2) {
    const NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_NO_PARENS = localize({
      key: "history.inputbox.hint.suffix.noparens",
      comment: ['Text is the suffix of an input field placeholder coming after the action the input field performs, this will be used when the input field ends in a closing parenthesis ")", for example "Filter (e.g. text, !exclude)". The character inserted into the final string is  to represent the up and down arrow keys.']
    }, " or {0} for history", ``);
    const NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_IN_PARENS = localize({
      key: "history.inputbox.hint.suffix.inparens",
      comment: ['Text is the suffix of an input field placeholder coming after the action the input field performs, this will be used when the input field does NOT end in a closing parenthesis (eg. "Find"). The character inserted into the final string is  to represent the up and down arrow keys.']
    }, " ({0} for history)", ``);
    super(container, contextViewProvider, options2);
    this._onDidFocus = this._register(new Emitter());
    this.onDidFocus = this._onDidFocus.event;
    this._onDidBlur = this._register(new Emitter());
    this.onDidBlur = this._onDidBlur.event;
    this.history = new HistoryNavigator(options2.history, 100);
    const addSuffix = () => {
      if (options2.showHistoryHint && options2.showHistoryHint() && !this.placeholder.endsWith(NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_NO_PARENS) && !this.placeholder.endsWith(NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_IN_PARENS) && this.history.getHistory().length) {
        const suffix = this.placeholder.endsWith(")") ? NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_NO_PARENS : NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_IN_PARENS;
        const suffixedPlaceholder = this.placeholder + suffix;
        if (options2.showPlaceholderOnFocus && !isActiveElement(this.input)) {
          this.placeholder = suffixedPlaceholder;
        } else {
          this.setPlaceHolder(suffixedPlaceholder);
        }
      }
    };
    this.observer = new MutationObserver((mutationList, observer) => {
      mutationList.forEach((mutation) => {
        if (!mutation.target.textContent) {
          addSuffix();
        }
      });
    });
    this.observer.observe(this.input, { attributeFilter: ["class"] });
    this.onfocus(this.input, () => addSuffix());
    this.onblur(this.input, () => {
      const resetPlaceholder = (historyHint) => {
        if (!this.placeholder.endsWith(historyHint)) {
          return false;
        } else {
          const revertedPlaceholder = this.placeholder.slice(0, this.placeholder.length - historyHint.length);
          if (options2.showPlaceholderOnFocus) {
            this.placeholder = revertedPlaceholder;
          } else {
            this.setPlaceHolder(revertedPlaceholder);
          }
          return true;
        }
      };
      if (!resetPlaceholder(NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_IN_PARENS)) {
        resetPlaceholder(NLS_PLACEHOLDER_HISTORY_HINT_SUFFIX_NO_PARENS);
      }
    });
  }
  dispose() {
    super.dispose();
    if (this.observer) {
      this.observer.disconnect();
      this.observer = void 0;
    }
  }
  addToHistory(always) {
    if (this.value && (always || this.value !== this.getCurrentValue())) {
      this.history.add(this.value);
    }
  }
  isAtLastInHistory() {
    return this.history.isLast();
  }
  isNowhereInHistory() {
    return this.history.isNowhere();
  }
  showNextValue() {
    if (!this.history.has(this.value)) {
      this.addToHistory();
    }
    let next = this.getNextValue();
    if (next) {
      next = next === this.value ? this.getNextValue() : next;
    }
    this.value = next !== null && next !== void 0 ? next : "";
    status(this.value ? this.value : localize("clearedInput", "Cleared Input"));
  }
  showPreviousValue() {
    if (!this.history.has(this.value)) {
      this.addToHistory();
    }
    let previous = this.getPreviousValue();
    if (previous) {
      previous = previous === this.value ? this.getPreviousValue() : previous;
    }
    if (previous) {
      this.value = previous;
      status(this.value);
    }
  }
  setPlaceHolder(placeHolder) {
    super.setPlaceHolder(placeHolder);
    this.setTooltip(placeHolder);
  }
  onBlur() {
    super.onBlur();
    this._onDidBlur.fire();
  }
  onFocus() {
    super.onFocus();
    this._onDidFocus.fire();
  }
  getCurrentValue() {
    let currentValue = this.history.current();
    if (!currentValue) {
      currentValue = this.history.last();
      this.history.next();
    }
    return currentValue;
  }
  getPreviousValue() {
    return this.history.previous() || this.history.first();
  }
  getNextValue() {
    return this.history.next();
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInput.js
init_event();
init_nls();
init_lifecycle();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInput.css";
var NLS_DEFAULT_LABEL = localize("defaultLabel", "input");
var FindInput = class extends Widget {
  constructor(parent, contextViewProvider, options2) {
    super();
    this.fixFocusOnOptionClickEnabled = true;
    this.imeSessionInProgress = false;
    this.additionalTogglesDisposables = this._register(new MutableDisposable());
    this.additionalToggles = [];
    this._onDidOptionChange = this._register(new Emitter());
    this.onDidOptionChange = this._onDidOptionChange.event;
    this._onKeyDown = this._register(new Emitter());
    this.onKeyDown = this._onKeyDown.event;
    this._onMouseDown = this._register(new Emitter());
    this.onMouseDown = this._onMouseDown.event;
    this._onInput = this._register(new Emitter());
    this._onKeyUp = this._register(new Emitter());
    this._onCaseSensitiveKeyDown = this._register(new Emitter());
    this.onCaseSensitiveKeyDown = this._onCaseSensitiveKeyDown.event;
    this._onRegexKeyDown = this._register(new Emitter());
    this.onRegexKeyDown = this._onRegexKeyDown.event;
    this._lastHighlightFindOptions = 0;
    this.placeholder = options2.placeholder || "";
    this.validation = options2.validation;
    this.label = options2.label || NLS_DEFAULT_LABEL;
    this.showCommonFindToggles = !!options2.showCommonFindToggles;
    const appendCaseSensitiveLabel = options2.appendCaseSensitiveLabel || "";
    const appendWholeWordsLabel = options2.appendWholeWordsLabel || "";
    const appendRegexLabel = options2.appendRegexLabel || "";
    const history = options2.history || [];
    const flexibleHeight = !!options2.flexibleHeight;
    const flexibleWidth = !!options2.flexibleWidth;
    const flexibleMaxHeight = options2.flexibleMaxHeight;
    this.domNode = document.createElement("div");
    this.domNode.classList.add("monaco-findInput");
    this.inputBox = this._register(new HistoryInputBox(this.domNode, contextViewProvider, {
      placeholder: this.placeholder || "",
      ariaLabel: this.label || "",
      validationOptions: {
        validation: this.validation
      },
      history,
      showHistoryHint: options2.showHistoryHint,
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight,
      inputBoxStyles: options2.inputBoxStyles
    }));
    if (this.showCommonFindToggles) {
      this.regex = this._register(new RegexToggle({
        appendTitle: appendRegexLabel,
        isChecked: false,
        ...options2.toggleStyles
      }));
      this._register(this.regex.onChange((viaKeyboard) => {
        this._onDidOptionChange.fire(viaKeyboard);
        if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
          this.inputBox.focus();
        }
        this.validate();
      }));
      this._register(this.regex.onKeyDown((e) => {
        this._onRegexKeyDown.fire(e);
      }));
      this.wholeWords = this._register(new WholeWordsToggle({
        appendTitle: appendWholeWordsLabel,
        isChecked: false,
        ...options2.toggleStyles
      }));
      this._register(this.wholeWords.onChange((viaKeyboard) => {
        this._onDidOptionChange.fire(viaKeyboard);
        if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
          this.inputBox.focus();
        }
        this.validate();
      }));
      this.caseSensitive = this._register(new CaseSensitiveToggle({
        appendTitle: appendCaseSensitiveLabel,
        isChecked: false,
        ...options2.toggleStyles
      }));
      this._register(this.caseSensitive.onChange((viaKeyboard) => {
        this._onDidOptionChange.fire(viaKeyboard);
        if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
          this.inputBox.focus();
        }
        this.validate();
      }));
      this._register(this.caseSensitive.onKeyDown((e) => {
        this._onCaseSensitiveKeyDown.fire(e);
      }));
      const indexes = [this.caseSensitive.domNode, this.wholeWords.domNode, this.regex.domNode];
      this.onkeydown(this.domNode, (event) => {
        if (event.equals(
          15
          /* KeyCode.LeftArrow */
        ) || event.equals(
          17
          /* KeyCode.RightArrow */
        ) || event.equals(
          9
          /* KeyCode.Escape */
        )) {
          const index = indexes.indexOf(this.domNode.ownerDocument.activeElement);
          if (index >= 0) {
            let newIndex = -1;
            if (event.equals(
              17
              /* KeyCode.RightArrow */
            )) {
              newIndex = (index + 1) % indexes.length;
            } else if (event.equals(
              15
              /* KeyCode.LeftArrow */
            )) {
              if (index === 0) {
                newIndex = indexes.length - 1;
              } else {
                newIndex = index - 1;
              }
            }
            if (event.equals(
              9
              /* KeyCode.Escape */
            )) {
              indexes[index].blur();
              this.inputBox.focus();
            } else if (newIndex >= 0) {
              indexes[newIndex].focus();
            }
            EventHelper.stop(event, true);
          }
        }
      });
    }
    this.controls = document.createElement("div");
    this.controls.className = "controls";
    this.controls.style.display = this.showCommonFindToggles ? "" : "none";
    if (this.caseSensitive) {
      this.controls.append(this.caseSensitive.domNode);
    }
    if (this.wholeWords) {
      this.controls.appendChild(this.wholeWords.domNode);
    }
    if (this.regex) {
      this.controls.appendChild(this.regex.domNode);
    }
    this.setAdditionalToggles(options2 === null || options2 === void 0 ? void 0 : options2.additionalToggles);
    if (this.controls) {
      this.domNode.appendChild(this.controls);
    }
    parent === null || parent === void 0 ? void 0 : parent.appendChild(this.domNode);
    this._register(addDisposableListener(this.inputBox.inputElement, "compositionstart", (e) => {
      this.imeSessionInProgress = true;
    }));
    this._register(addDisposableListener(this.inputBox.inputElement, "compositionend", (e) => {
      this.imeSessionInProgress = false;
      this._onInput.fire();
    }));
    this.onkeydown(this.inputBox.inputElement, (e) => this._onKeyDown.fire(e));
    this.onkeyup(this.inputBox.inputElement, (e) => this._onKeyUp.fire(e));
    this.oninput(this.inputBox.inputElement, (e) => this._onInput.fire());
    this.onmousedown(this.inputBox.inputElement, (e) => this._onMouseDown.fire(e));
  }
  get onDidChange() {
    return this.inputBox.onDidChange;
  }
  layout(style) {
    this.inputBox.layout();
    this.updateInputBoxPadding(style.collapsedFindWidget);
  }
  enable() {
    var _a2, _b2, _c;
    this.domNode.classList.remove("disabled");
    this.inputBox.enable();
    (_a2 = this.regex) === null || _a2 === void 0 ? void 0 : _a2.enable();
    (_b2 = this.wholeWords) === null || _b2 === void 0 ? void 0 : _b2.enable();
    (_c = this.caseSensitive) === null || _c === void 0 ? void 0 : _c.enable();
    for (const toggle of this.additionalToggles) {
      toggle.enable();
    }
  }
  disable() {
    var _a2, _b2, _c;
    this.domNode.classList.add("disabled");
    this.inputBox.disable();
    (_a2 = this.regex) === null || _a2 === void 0 ? void 0 : _a2.disable();
    (_b2 = this.wholeWords) === null || _b2 === void 0 ? void 0 : _b2.disable();
    (_c = this.caseSensitive) === null || _c === void 0 ? void 0 : _c.disable();
    for (const toggle of this.additionalToggles) {
      toggle.disable();
    }
  }
  setFocusInputOnOptionClick(value) {
    this.fixFocusOnOptionClickEnabled = value;
  }
  setEnabled(enabled) {
    if (enabled) {
      this.enable();
    } else {
      this.disable();
    }
  }
  setAdditionalToggles(toggles) {
    for (const currentToggle of this.additionalToggles) {
      currentToggle.domNode.remove();
    }
    this.additionalToggles = [];
    this.additionalTogglesDisposables.value = new DisposableStore();
    for (const toggle of toggles !== null && toggles !== void 0 ? toggles : []) {
      this.additionalTogglesDisposables.value.add(toggle);
      this.controls.appendChild(toggle.domNode);
      this.additionalTogglesDisposables.value.add(toggle.onChange((viaKeyboard) => {
        this._onDidOptionChange.fire(viaKeyboard);
        if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
          this.inputBox.focus();
        }
      }));
      this.additionalToggles.push(toggle);
    }
    if (this.additionalToggles.length > 0) {
      this.controls.style.display = "";
    }
    this.updateInputBoxPadding();
  }
  updateInputBoxPadding(controlsHidden = false) {
    var _a2, _b2, _c, _d, _e, _f;
    if (controlsHidden) {
      this.inputBox.paddingRight = 0;
    } else {
      this.inputBox.paddingRight = ((_b2 = (_a2 = this.caseSensitive) === null || _a2 === void 0 ? void 0 : _a2.width()) !== null && _b2 !== void 0 ? _b2 : 0) + ((_d = (_c = this.wholeWords) === null || _c === void 0 ? void 0 : _c.width()) !== null && _d !== void 0 ? _d : 0) + ((_f = (_e = this.regex) === null || _e === void 0 ? void 0 : _e.width()) !== null && _f !== void 0 ? _f : 0) + this.additionalToggles.reduce((r, t) => r + t.width(), 0);
    }
  }
  getValue() {
    return this.inputBox.value;
  }
  setValue(value) {
    if (this.inputBox.value !== value) {
      this.inputBox.value = value;
    }
  }
  select() {
    this.inputBox.select();
  }
  focus() {
    this.inputBox.focus();
  }
  getCaseSensitive() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.caseSensitive) === null || _a2 === void 0 ? void 0 : _a2.checked) !== null && _b2 !== void 0 ? _b2 : false;
  }
  setCaseSensitive(value) {
    if (this.caseSensitive) {
      this.caseSensitive.checked = value;
    }
  }
  getWholeWords() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.wholeWords) === null || _a2 === void 0 ? void 0 : _a2.checked) !== null && _b2 !== void 0 ? _b2 : false;
  }
  setWholeWords(value) {
    if (this.wholeWords) {
      this.wholeWords.checked = value;
    }
  }
  getRegex() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.regex) === null || _a2 === void 0 ? void 0 : _a2.checked) !== null && _b2 !== void 0 ? _b2 : false;
  }
  setRegex(value) {
    if (this.regex) {
      this.regex.checked = value;
      this.validate();
    }
  }
  focusOnCaseSensitive() {
    var _a2;
    (_a2 = this.caseSensitive) === null || _a2 === void 0 ? void 0 : _a2.focus();
  }
  highlightFindOptions() {
    this.domNode.classList.remove("highlight-" + this._lastHighlightFindOptions);
    this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions;
    this.domNode.classList.add("highlight-" + this._lastHighlightFindOptions);
  }
  validate() {
    this.inputBox.validate();
  }
  showMessage(message) {
    this.inputBox.showMessage(message);
  }
  clearMessage() {
    this.inputBox.hideMessage();
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/tree.js
var ObjectTreeElementCollapseState;
(function(ObjectTreeElementCollapseState2) {
  ObjectTreeElementCollapseState2[ObjectTreeElementCollapseState2["Expanded"] = 0] = "Expanded";
  ObjectTreeElementCollapseState2[ObjectTreeElementCollapseState2["Collapsed"] = 1] = "Collapsed";
  ObjectTreeElementCollapseState2[ObjectTreeElementCollapseState2["PreserveOrExpanded"] = 2] = "PreserveOrExpanded";
  ObjectTreeElementCollapseState2[ObjectTreeElementCollapseState2["PreserveOrCollapsed"] = 3] = "PreserveOrCollapsed";
})(ObjectTreeElementCollapseState || (ObjectTreeElementCollapseState = {}));
var TreeMouseEventTarget;
(function(TreeMouseEventTarget2) {
  TreeMouseEventTarget2[TreeMouseEventTarget2["Unknown"] = 0] = "Unknown";
  TreeMouseEventTarget2[TreeMouseEventTarget2["Twistie"] = 1] = "Twistie";
  TreeMouseEventTarget2[TreeMouseEventTarget2["Element"] = 2] = "Element";
  TreeMouseEventTarget2[TreeMouseEventTarget2["Filter"] = 3] = "Filter";
})(TreeMouseEventTarget || (TreeMouseEventTarget = {}));
var TreeError = class extends Error {
  constructor(user, message) {
    super(`TreeError [${user}] ${message}`);
  }
};
var WeakMapper = class {
  constructor(fn) {
    this.fn = fn;
    this._map = /* @__PURE__ */ new WeakMap();
  }
  map(key) {
    let result = this._map.get(key);
    if (!result) {
      result = this.fn(key);
      this._map.set(key, result);
    }
    return result;
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/indexTreeModel.js
init_arrays();
init_async();
init_symbols();
init_event();
init_iterator();
function isFilterResult(obj) {
  return typeof obj === "object" && "visibility" in obj && "data" in obj;
}
function getVisibleState(visibility) {
  switch (visibility) {
    case true:
      return 1;
    case false:
      return 0;
    default:
      return visibility;
  }
}
function isCollapsibleStateUpdate(update) {
  return typeof update.collapsible === "boolean";
}
var IndexTreeModel = class {
  constructor(user, list, rootElement, options2 = {}) {
    this.user = user;
    this.list = list;
    this.rootRef = [];
    this.eventBufferer = new EventBufferer();
    this._onDidChangeCollapseState = new Emitter();
    this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);
    this._onDidChangeRenderNodeCount = new Emitter();
    this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);
    this._onDidSplice = new Emitter();
    this.onDidSplice = this._onDidSplice.event;
    this.refilterDelayer = new Delayer(MicrotaskDelay);
    this.collapseByDefault = typeof options2.collapseByDefault === "undefined" ? false : options2.collapseByDefault;
    this.filter = options2.filter;
    this.autoExpandSingleChildren = typeof options2.autoExpandSingleChildren === "undefined" ? false : options2.autoExpandSingleChildren;
    this.root = {
      parent: void 0,
      element: rootElement,
      children: [],
      depth: 0,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: false,
      collapsed: false,
      renderNodeCount: 0,
      visibility: 1,
      visible: true,
      filterData: void 0
    };
  }
  splice(location, deleteCount, toInsert = Iterable.empty(), options2 = {}) {
    if (location.length === 0) {
      throw new TreeError(this.user, "Invalid tree location");
    }
    if (options2.diffIdentityProvider) {
      this.spliceSmart(options2.diffIdentityProvider, location, deleteCount, toInsert, options2);
    } else {
      this.spliceSimple(location, deleteCount, toInsert, options2);
    }
  }
  spliceSmart(identity, location, deleteCount, toInsertIterable, options2, recurseLevels) {
    var _a2;
    if (toInsertIterable === void 0) {
      toInsertIterable = Iterable.empty();
    }
    if (recurseLevels === void 0) {
      recurseLevels = (_a2 = options2.diffDepth) !== null && _a2 !== void 0 ? _a2 : 0;
    }
    const { parentNode } = this.getParentNodeWithListIndex(location);
    if (!parentNode.lastDiffIds) {
      return this.spliceSimple(location, deleteCount, toInsertIterable, options2);
    }
    const toInsert = [...toInsertIterable];
    const index = location[location.length - 1];
    const diff = new LcsDiff({ getElements: () => parentNode.lastDiffIds }, {
      getElements: () => [
        ...parentNode.children.slice(0, index),
        ...toInsert,
        ...parentNode.children.slice(index + deleteCount)
      ].map((e) => identity.getId(e.element).toString())
    }).ComputeDiff(false);
    if (diff.quitEarly) {
      parentNode.lastDiffIds = void 0;
      return this.spliceSimple(location, deleteCount, toInsert, options2);
    }
    const locationPrefix = location.slice(0, -1);
    const recurseSplice = (fromOriginal, fromModified, count) => {
      if (recurseLevels > 0) {
        for (let i = 0; i < count; i++) {
          fromOriginal--;
          fromModified--;
          this.spliceSmart(identity, [...locationPrefix, fromOriginal, 0], Number.MAX_SAFE_INTEGER, toInsert[fromModified].children, options2, recurseLevels - 1);
        }
      }
    };
    let lastStartO = Math.min(parentNode.children.length, index + deleteCount);
    let lastStartM = toInsert.length;
    for (const change of diff.changes.sort((a, b) => b.originalStart - a.originalStart)) {
      recurseSplice(lastStartO, lastStartM, lastStartO - (change.originalStart + change.originalLength));
      lastStartO = change.originalStart;
      lastStartM = change.modifiedStart - index;
      this.spliceSimple([...locationPrefix, lastStartO], change.originalLength, Iterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength), options2);
    }
    recurseSplice(lastStartO, lastStartM, lastStartO);
  }
  spliceSimple(location, deleteCount, toInsert = Iterable.empty(), { onDidCreateNode, onDidDeleteNode, diffIdentityProvider }) {
    const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);
    const treeListElementsToInsert = [];
    const nodesToInsertIterator = Iterable.map(toInsert, (el) => this.createTreeNode(el, parentNode, parentNode.visible ? 1 : 0, revealed, treeListElementsToInsert, onDidCreateNode));
    const lastIndex = location[location.length - 1];
    let visibleChildStartIndex = 0;
    for (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {
      const child = parentNode.children[i];
      if (child.visible) {
        visibleChildStartIndex = child.visibleChildIndex;
        break;
      }
    }
    const nodesToInsert = [];
    let insertedVisibleChildrenCount = 0;
    let renderNodeCount = 0;
    for (const child of nodesToInsertIterator) {
      nodesToInsert.push(child);
      renderNodeCount += child.renderNodeCount;
      if (child.visible) {
        child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;
      }
    }
    const deletedNodes = splice(parentNode.children, lastIndex, deleteCount, nodesToInsert);
    if (!diffIdentityProvider) {
      parentNode.lastDiffIds = void 0;
    } else if (parentNode.lastDiffIds) {
      splice(parentNode.lastDiffIds, lastIndex, deleteCount, nodesToInsert.map((n) => diffIdentityProvider.getId(n.element).toString()));
    } else {
      parentNode.lastDiffIds = parentNode.children.map((n) => diffIdentityProvider.getId(n.element).toString());
    }
    let deletedVisibleChildrenCount = 0;
    for (const child of deletedNodes) {
      if (child.visible) {
        deletedVisibleChildrenCount++;
      }
    }
    if (deletedVisibleChildrenCount !== 0) {
      for (let i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {
        const child = parentNode.children[i];
        if (child.visible) {
          child.visibleChildIndex -= deletedVisibleChildrenCount;
        }
      }
    }
    parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;
    if (revealed && visible) {
      const visibleDeleteCount = deletedNodes.reduce((r, node2) => r + (node2.visible ? node2.renderNodeCount : 0), 0);
      this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);
      this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);
    }
    if (deletedNodes.length > 0 && onDidDeleteNode) {
      const visit = (node2) => {
        onDidDeleteNode(node2);
        node2.children.forEach(visit);
      };
      deletedNodes.forEach(visit);
    }
    this._onDidSplice.fire({ insertedNodes: nodesToInsert, deletedNodes });
    let node = parentNode;
    while (node) {
      if (node.visibility === 2) {
        this.refilterDelayer.trigger(() => this.refilter());
        break;
      }
      node = node.parent;
    }
  }
  rerender(location) {
    if (location.length === 0) {
      throw new TreeError(this.user, "Invalid tree location");
    }
    const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);
    if (node.visible && revealed) {
      this.list.splice(listIndex, 1, [node]);
    }
  }
  has(location) {
    return this.hasTreeNode(location);
  }
  getListIndex(location) {
    const { listIndex, visible, revealed } = this.getTreeNodeWithListIndex(location);
    return visible && revealed ? listIndex : -1;
  }
  getListRenderCount(location) {
    return this.getTreeNode(location).renderNodeCount;
  }
  isCollapsible(location) {
    return this.getTreeNode(location).collapsible;
  }
  setCollapsible(location, collapsible) {
    const node = this.getTreeNode(location);
    if (typeof collapsible === "undefined") {
      collapsible = !node.collapsible;
    }
    const update = { collapsible };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));
  }
  isCollapsed(location) {
    return this.getTreeNode(location).collapsed;
  }
  setCollapsed(location, collapsed, recursive) {
    const node = this.getTreeNode(location);
    if (typeof collapsed === "undefined") {
      collapsed = !node.collapsed;
    }
    const update = { collapsed, recursive: recursive || false };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));
  }
  _setCollapseState(location, update) {
    const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);
    const result = this._setListNodeCollapseState(node, listIndex, revealed, update);
    if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {
      let onlyVisibleChildIndex = -1;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (child.visible) {
          if (onlyVisibleChildIndex > -1) {
            onlyVisibleChildIndex = -1;
            break;
          } else {
            onlyVisibleChildIndex = i;
          }
        }
      }
      if (onlyVisibleChildIndex > -1) {
        this._setCollapseState([...location, onlyVisibleChildIndex], update);
      }
    }
    return result;
  }
  _setListNodeCollapseState(node, listIndex, revealed, update) {
    const result = this._setNodeCollapseState(node, update, false);
    if (!revealed || !node.visible || !result) {
      return result;
    }
    const previousRenderNodeCount = node.renderNodeCount;
    const toInsert = this.updateNodeAfterCollapseChange(node);
    const deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);
    this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));
    return result;
  }
  _setNodeCollapseState(node, update, deep) {
    let result;
    if (node === this.root) {
      result = false;
    } else {
      if (isCollapsibleStateUpdate(update)) {
        result = node.collapsible !== update.collapsible;
        node.collapsible = update.collapsible;
      } else if (!node.collapsible) {
        result = false;
      } else {
        result = node.collapsed !== update.collapsed;
        node.collapsed = update.collapsed;
      }
      if (result) {
        this._onDidChangeCollapseState.fire({ node, deep });
      }
    }
    if (!isCollapsibleStateUpdate(update) && update.recursive) {
      for (const child of node.children) {
        result = this._setNodeCollapseState(child, update, true) || result;
      }
    }
    return result;
  }
  expandTo(location) {
    this.eventBufferer.bufferEvents(() => {
      let node = this.getTreeNode(location);
      while (node.parent) {
        node = node.parent;
        location = location.slice(0, location.length - 1);
        if (node.collapsed) {
          this._setCollapseState(location, { collapsed: false, recursive: false });
        }
      }
    });
  }
  refilter() {
    const previousRenderNodeCount = this.root.renderNodeCount;
    const toInsert = this.updateNodeAfterFilterChange(this.root);
    this.list.splice(0, previousRenderNodeCount, toInsert);
    this.refilterDelayer.cancel();
  }
  createTreeNode(treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {
    const node = {
      parent,
      element: treeElement.element,
      children: [],
      depth: parent.depth + 1,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: typeof treeElement.collapsible === "boolean" ? treeElement.collapsible : typeof treeElement.collapsed !== "undefined",
      collapsed: typeof treeElement.collapsed === "undefined" ? this.collapseByDefault : treeElement.collapsed,
      renderNodeCount: 1,
      visibility: 1,
      visible: true,
      filterData: void 0
    };
    const visibility = this._filterNode(node, parentVisibility);
    node.visibility = visibility;
    if (revealed) {
      treeListElements.push(node);
    }
    const childElements = treeElement.children || Iterable.empty();
    const childRevealed = revealed && visibility !== 0 && !node.collapsed;
    let visibleChildrenCount = 0;
    let renderNodeCount = 1;
    for (const el of childElements) {
      const child = this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode);
      node.children.push(child);
      renderNodeCount += child.renderNodeCount;
      if (child.visible) {
        child.visibleChildIndex = visibleChildrenCount++;
      }
    }
    node.collapsible = node.collapsible || node.children.length > 0;
    node.visibleChildrenCount = visibleChildrenCount;
    node.visible = visibility === 2 ? visibleChildrenCount > 0 : visibility === 1;
    if (!node.visible) {
      node.renderNodeCount = 0;
      if (revealed) {
        treeListElements.pop();
      }
    } else if (!node.collapsed) {
      node.renderNodeCount = renderNodeCount;
    }
    onDidCreateNode === null || onDidCreateNode === void 0 ? void 0 : onDidCreateNode(node);
    return node;
  }
  updateNodeAfterCollapseChange(node) {
    const previousRenderNodeCount = node.renderNodeCount;
    const result = [];
    this._updateNodeAfterCollapseChange(node, result);
    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);
    return result;
  }
  _updateNodeAfterCollapseChange(node, result) {
    if (node.visible === false) {
      return 0;
    }
    result.push(node);
    node.renderNodeCount = 1;
    if (!node.collapsed) {
      for (const child of node.children) {
        node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);
      }
    }
    this._onDidChangeRenderNodeCount.fire(node);
    return node.renderNodeCount;
  }
  updateNodeAfterFilterChange(node) {
    const previousRenderNodeCount = node.renderNodeCount;
    const result = [];
    this._updateNodeAfterFilterChange(node, node.visible ? 1 : 0, result);
    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);
    return result;
  }
  _updateNodeAfterFilterChange(node, parentVisibility, result, revealed = true) {
    let visibility;
    if (node !== this.root) {
      visibility = this._filterNode(node, parentVisibility);
      if (visibility === 0) {
        node.visible = false;
        node.renderNodeCount = 0;
        return false;
      }
      if (revealed) {
        result.push(node);
      }
    }
    const resultStartLength = result.length;
    node.renderNodeCount = node === this.root ? 0 : 1;
    let hasVisibleDescendants = false;
    if (!node.collapsed || visibility !== 0) {
      let visibleChildIndex = 0;
      for (const child of node.children) {
        hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;
        if (child.visible) {
          child.visibleChildIndex = visibleChildIndex++;
        }
      }
      node.visibleChildrenCount = visibleChildIndex;
    } else {
      node.visibleChildrenCount = 0;
    }
    if (node !== this.root) {
      node.visible = visibility === 2 ? hasVisibleDescendants : visibility === 1;
      node.visibility = visibility;
    }
    if (!node.visible) {
      node.renderNodeCount = 0;
      if (revealed) {
        result.pop();
      }
    } else if (!node.collapsed) {
      node.renderNodeCount += result.length - resultStartLength;
    }
    this._onDidChangeRenderNodeCount.fire(node);
    return node.visible;
  }
  _updateAncestorsRenderNodeCount(node, diff) {
    if (diff === 0) {
      return;
    }
    while (node) {
      node.renderNodeCount += diff;
      this._onDidChangeRenderNodeCount.fire(node);
      node = node.parent;
    }
  }
  _filterNode(node, parentVisibility) {
    const result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1;
    if (typeof result === "boolean") {
      node.filterData = void 0;
      return result ? 1 : 0;
    } else if (isFilterResult(result)) {
      node.filterData = result.data;
      return getVisibleState(result.visibility);
    } else {
      node.filterData = void 0;
      return getVisibleState(result);
    }
  }
  // cheap
  hasTreeNode(location, node = this.root) {
    if (!location || location.length === 0) {
      return true;
    }
    const [index, ...rest] = location;
    if (index < 0 || index > node.children.length) {
      return false;
    }
    return this.hasTreeNode(rest, node.children[index]);
  }
  // cheap
  getTreeNode(location, node = this.root) {
    if (!location || location.length === 0) {
      return node;
    }
    const [index, ...rest] = location;
    if (index < 0 || index > node.children.length) {
      throw new TreeError(this.user, "Invalid tree location");
    }
    return this.getTreeNode(rest, node.children[index]);
  }
  // expensive
  getTreeNodeWithListIndex(location) {
    if (location.length === 0) {
      return { node: this.root, listIndex: -1, revealed: true, visible: false };
    }
    const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);
    const index = location[location.length - 1];
    if (index < 0 || index > parentNode.children.length) {
      throw new TreeError(this.user, "Invalid tree location");
    }
    const node = parentNode.children[index];
    return { node, listIndex, revealed, visible: visible && node.visible };
  }
  getParentNodeWithListIndex(location, node = this.root, listIndex = 0, revealed = true, visible = true) {
    const [index, ...rest] = location;
    if (index < 0 || index > node.children.length) {
      throw new TreeError(this.user, "Invalid tree location");
    }
    for (let i = 0; i < index; i++) {
      listIndex += node.children[i].renderNodeCount;
    }
    revealed = revealed && !node.collapsed;
    visible = visible && node.visible;
    if (rest.length === 0) {
      return { parentNode: node, listIndex, revealed, visible };
    }
    return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);
  }
  getNode(location = []) {
    return this.getTreeNode(location);
  }
  // TODO@joao perf!
  getNodeLocation(node) {
    const location = [];
    let indexTreeNode = node;
    while (indexTreeNode.parent) {
      location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));
      indexTreeNode = indexTreeNode.parent;
    }
    return location.reverse();
  }
  getParentNodeLocation(location) {
    if (location.length === 0) {
      return void 0;
    } else if (location.length === 1) {
      return [];
    } else {
      return tail2(location)[0];
    }
  }
  getFirstElementChild(location) {
    const node = this.getTreeNode(location);
    if (node.children.length === 0) {
      return void 0;
    }
    return node.children[0].element;
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/abstractTree.js
init_actions();
init_arrays();
init_async();
init_codicons();
init_themables();
init_map();
init_event();
init_filters();
init_lifecycle();
init_numbers();
init_types();
init_nls();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/media/tree.css";
var TreeElementsDragAndDropData = class extends ElementsDragAndDropData {
  constructor(data) {
    super(data.elements.map((node) => node.element));
    this.data = data;
  }
};
function asTreeDragAndDropData(data) {
  if (data instanceof ElementsDragAndDropData) {
    return new TreeElementsDragAndDropData(data);
  }
  return data;
}
var TreeNodeListDragAndDrop = class {
  constructor(modelProvider, dnd) {
    this.modelProvider = modelProvider;
    this.dnd = dnd;
    this.autoExpandDisposable = Disposable.None;
    this.disposables = new DisposableStore();
  }
  getDragURI(node) {
    return this.dnd.getDragURI(node.element);
  }
  getDragLabel(nodes, originalEvent) {
    if (this.dnd.getDragLabel) {
      return this.dnd.getDragLabel(nodes.map((node) => node.element), originalEvent);
    }
    return void 0;
  }
  onDragStart(data, originalEvent) {
    var _a2, _b2;
    (_b2 = (_a2 = this.dnd).onDragStart) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, asTreeDragAndDropData(data), originalEvent);
  }
  onDragOver(data, targetNode, targetIndex, targetSector, originalEvent, raw = true) {
    const result = this.dnd.onDragOver(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, targetSector, originalEvent);
    const didChangeAutoExpandNode = this.autoExpandNode !== targetNode;
    if (didChangeAutoExpandNode) {
      this.autoExpandDisposable.dispose();
      this.autoExpandNode = targetNode;
    }
    if (typeof targetNode === "undefined") {
      return result;
    }
    if (didChangeAutoExpandNode && typeof result !== "boolean" && result.autoExpand) {
      this.autoExpandDisposable = disposableTimeout(() => {
        const model2 = this.modelProvider();
        const ref2 = model2.getNodeLocation(targetNode);
        if (model2.isCollapsed(ref2)) {
          model2.setCollapsed(ref2, false);
        }
        this.autoExpandNode = void 0;
      }, 500, this.disposables);
    }
    if (typeof result === "boolean" || !result.accept || typeof result.bubble === "undefined" || result.feedback) {
      if (!raw) {
        const accept = typeof result === "boolean" ? result : result.accept;
        const effect = typeof result === "boolean" ? void 0 : result.effect;
        return { accept, effect, feedback: [targetIndex] };
      }
      return result;
    }
    if (result.bubble === 1) {
      const model2 = this.modelProvider();
      const ref2 = model2.getNodeLocation(targetNode);
      const parentRef = model2.getParentNodeLocation(ref2);
      const parentNode = model2.getNode(parentRef);
      const parentIndex = parentRef && model2.getListIndex(parentRef);
      return this.onDragOver(data, parentNode, parentIndex, targetSector, originalEvent, false);
    }
    const model = this.modelProvider();
    const ref = model.getNodeLocation(targetNode);
    const start = model.getListIndex(ref);
    const length = model.getListRenderCount(ref);
    return { ...result, feedback: range(start, start + length) };
  }
  drop(data, targetNode, targetIndex, targetSector, originalEvent) {
    this.autoExpandDisposable.dispose();
    this.autoExpandNode = void 0;
    this.dnd.drop(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, targetSector, originalEvent);
  }
  onDragEnd(originalEvent) {
    var _a2, _b2;
    (_b2 = (_a2 = this.dnd).onDragEnd) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, originalEvent);
  }
  dispose() {
    this.disposables.dispose();
    this.dnd.dispose();
  }
};
function asListOptions(modelProvider, options2) {
  return options2 && {
    ...options2,
    identityProvider: options2.identityProvider && {
      getId(el) {
        return options2.identityProvider.getId(el.element);
      }
    },
    dnd: options2.dnd && new TreeNodeListDragAndDrop(modelProvider, options2.dnd),
    multipleSelectionController: options2.multipleSelectionController && {
      isSelectionSingleChangeEvent(e) {
        return options2.multipleSelectionController.isSelectionSingleChangeEvent({ ...e, element: e.element });
      },
      isSelectionRangeChangeEvent(e) {
        return options2.multipleSelectionController.isSelectionRangeChangeEvent({ ...e, element: e.element });
      }
    },
    accessibilityProvider: options2.accessibilityProvider && {
      ...options2.accessibilityProvider,
      getSetSize(node) {
        const model = modelProvider();
        const ref = model.getNodeLocation(node);
        const parentRef = model.getParentNodeLocation(ref);
        const parentNode = model.getNode(parentRef);
        return parentNode.visibleChildrenCount;
      },
      getPosInSet(node) {
        return node.visibleChildIndex + 1;
      },
      isChecked: options2.accessibilityProvider && options2.accessibilityProvider.isChecked ? (node) => {
        return options2.accessibilityProvider.isChecked(node.element);
      } : void 0,
      getRole: options2.accessibilityProvider && options2.accessibilityProvider.getRole ? (node) => {
        return options2.accessibilityProvider.getRole(node.element);
      } : () => "treeitem",
      getAriaLabel(e) {
        return options2.accessibilityProvider.getAriaLabel(e.element);
      },
      getWidgetAriaLabel() {
        return options2.accessibilityProvider.getWidgetAriaLabel();
      },
      getWidgetRole: options2.accessibilityProvider && options2.accessibilityProvider.getWidgetRole ? () => options2.accessibilityProvider.getWidgetRole() : () => "tree",
      getAriaLevel: options2.accessibilityProvider && options2.accessibilityProvider.getAriaLevel ? (node) => options2.accessibilityProvider.getAriaLevel(node.element) : (node) => {
        return node.depth;
      },
      getActiveDescendantId: options2.accessibilityProvider.getActiveDescendantId && ((node) => {
        return options2.accessibilityProvider.getActiveDescendantId(node.element);
      })
    },
    keyboardNavigationLabelProvider: options2.keyboardNavigationLabelProvider && {
      ...options2.keyboardNavigationLabelProvider,
      getKeyboardNavigationLabel(node) {
        return options2.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(node.element);
      }
    }
  };
}
var ComposedTreeDelegate = class {
  constructor(delegate) {
    this.delegate = delegate;
  }
  getHeight(element) {
    return this.delegate.getHeight(element.element);
  }
  getTemplateId(element) {
    return this.delegate.getTemplateId(element.element);
  }
  hasDynamicHeight(element) {
    return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(element.element);
  }
  setDynamicHeight(element, height) {
    var _a2, _b2;
    (_b2 = (_a2 = this.delegate).setDynamicHeight) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, element.element, height);
  }
};
var RenderIndentGuides;
(function(RenderIndentGuides2) {
  RenderIndentGuides2["None"] = "none";
  RenderIndentGuides2["OnHover"] = "onHover";
  RenderIndentGuides2["Always"] = "always";
})(RenderIndentGuides || (RenderIndentGuides = {}));
var EventCollection = class {
  get elements() {
    return this._elements;
  }
  constructor(onDidChange, _elements = []) {
    this._elements = _elements;
    this.disposables = new DisposableStore();
    this.onDidChange = Event.forEach(onDidChange, (elements) => this._elements = elements, this.disposables);
  }
  dispose() {
    this.disposables.dispose();
  }
};
var TreeRenderer = class _TreeRenderer {
  constructor(renderer, modelProvider, onDidChangeCollapseState, activeNodes, renderedIndentGuides, options2 = {}) {
    var _a2;
    this.renderer = renderer;
    this.modelProvider = modelProvider;
    this.activeNodes = activeNodes;
    this.renderedIndentGuides = renderedIndentGuides;
    this.renderedElements = /* @__PURE__ */ new Map();
    this.renderedNodes = /* @__PURE__ */ new Map();
    this.indent = _TreeRenderer.DefaultIndent;
    this.hideTwistiesOfChildlessElements = false;
    this.shouldRenderIndentGuides = false;
    this.activeIndentNodes = /* @__PURE__ */ new Set();
    this.indentGuidesDisposable = Disposable.None;
    this.disposables = new DisposableStore();
    this.templateId = renderer.templateId;
    this.updateOptions(options2);
    Event.map(onDidChangeCollapseState, (e) => e.node)(this.onDidChangeNodeTwistieState, this, this.disposables);
    (_a2 = renderer.onDidChangeTwistieState) === null || _a2 === void 0 ? void 0 : _a2.call(renderer, this.onDidChangeTwistieState, this, this.disposables);
  }
  updateOptions(options2 = {}) {
    if (typeof options2.indent !== "undefined") {
      const indent = clamp(options2.indent, 0, 40);
      if (indent !== this.indent) {
        this.indent = indent;
        for (const [node, templateData] of this.renderedNodes) {
          this.renderTreeElement(node, templateData);
        }
      }
    }
    if (typeof options2.renderIndentGuides !== "undefined") {
      const shouldRenderIndentGuides = options2.renderIndentGuides !== RenderIndentGuides.None;
      if (shouldRenderIndentGuides !== this.shouldRenderIndentGuides) {
        this.shouldRenderIndentGuides = shouldRenderIndentGuides;
        for (const [node, templateData] of this.renderedNodes) {
          this._renderIndentGuides(node, templateData);
        }
        this.indentGuidesDisposable.dispose();
        if (shouldRenderIndentGuides) {
          const disposables = new DisposableStore();
          this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, disposables);
          this.indentGuidesDisposable = disposables;
          this._onDidChangeActiveNodes(this.activeNodes.elements);
        }
      }
    }
    if (typeof options2.hideTwistiesOfChildlessElements !== "undefined") {
      this.hideTwistiesOfChildlessElements = options2.hideTwistiesOfChildlessElements;
    }
  }
  renderTemplate(container) {
    const el = append(container, $(".monaco-tl-row"));
    const indent = append(el, $(".monaco-tl-indent"));
    const twistie = append(el, $(".monaco-tl-twistie"));
    const contents = append(el, $(".monaco-tl-contents"));
    const templateData = this.renderer.renderTemplate(contents);
    return { container, indent, twistie, indentGuidesDisposable: Disposable.None, templateData };
  }
  renderElement(node, index, templateData, height) {
    this.renderedNodes.set(node, templateData);
    this.renderedElements.set(node.element, node);
    this.renderTreeElement(node, templateData);
    this.renderer.renderElement(node, index, templateData.templateData, height);
  }
  disposeElement(node, index, templateData, height) {
    var _a2, _b2;
    templateData.indentGuidesDisposable.dispose();
    (_b2 = (_a2 = this.renderer).disposeElement) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, node, index, templateData.templateData, height);
    if (typeof height === "number") {
      this.renderedNodes.delete(node);
      this.renderedElements.delete(node.element);
    }
  }
  disposeTemplate(templateData) {
    this.renderer.disposeTemplate(templateData.templateData);
  }
  onDidChangeTwistieState(element) {
    const node = this.renderedElements.get(element);
    if (!node) {
      return;
    }
    this.onDidChangeNodeTwistieState(node);
  }
  onDidChangeNodeTwistieState(node) {
    const templateData = this.renderedNodes.get(node);
    if (!templateData) {
      return;
    }
    this._onDidChangeActiveNodes(this.activeNodes.elements);
    this.renderTreeElement(node, templateData);
  }
  renderTreeElement(node, templateData) {
    const indent = _TreeRenderer.DefaultIndent + (node.depth - 1) * this.indent;
    templateData.twistie.style.paddingLeft = `${indent}px`;
    templateData.indent.style.width = `${indent + this.indent - 16}px`;
    if (node.collapsible) {
      templateData.container.setAttribute("aria-expanded", String(!node.collapsed));
    } else {
      templateData.container.removeAttribute("aria-expanded");
    }
    templateData.twistie.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemExpanded));
    let twistieRendered = false;
    if (this.renderer.renderTwistie) {
      twistieRendered = this.renderer.renderTwistie(node.element, templateData.twistie);
    }
    if (node.collapsible && (!this.hideTwistiesOfChildlessElements || node.visibleChildrenCount > 0)) {
      if (!twistieRendered) {
        templateData.twistie.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemExpanded));
      }
      templateData.twistie.classList.add("collapsible");
      templateData.twistie.classList.toggle("collapsed", node.collapsed);
    } else {
      templateData.twistie.classList.remove("collapsible", "collapsed");
    }
    this._renderIndentGuides(node, templateData);
  }
  _renderIndentGuides(node, templateData) {
    clearNode(templateData.indent);
    templateData.indentGuidesDisposable.dispose();
    if (!this.shouldRenderIndentGuides) {
      return;
    }
    const disposableStore = new DisposableStore();
    const model = this.modelProvider();
    while (true) {
      const ref = model.getNodeLocation(node);
      const parentRef = model.getParentNodeLocation(ref);
      if (!parentRef) {
        break;
      }
      const parent = model.getNode(parentRef);
      const guide = $(".indent-guide", { style: `width: ${this.indent}px` });
      if (this.activeIndentNodes.has(parent)) {
        guide.classList.add("active");
      }
      if (templateData.indent.childElementCount === 0) {
        templateData.indent.appendChild(guide);
      } else {
        templateData.indent.insertBefore(guide, templateData.indent.firstElementChild);
      }
      this.renderedIndentGuides.add(parent, guide);
      disposableStore.add(toDisposable(() => this.renderedIndentGuides.delete(parent, guide)));
      node = parent;
    }
    templateData.indentGuidesDisposable = disposableStore;
  }
  _onDidChangeActiveNodes(nodes) {
    if (!this.shouldRenderIndentGuides) {
      return;
    }
    const set = /* @__PURE__ */ new Set();
    const model = this.modelProvider();
    nodes.forEach((node) => {
      const ref = model.getNodeLocation(node);
      try {
        const parentRef = model.getParentNodeLocation(ref);
        if (node.collapsible && node.children.length > 0 && !node.collapsed) {
          set.add(node);
        } else if (parentRef) {
          set.add(model.getNode(parentRef));
        }
      } catch (_a2) {
      }
    });
    this.activeIndentNodes.forEach((node) => {
      if (!set.has(node)) {
        this.renderedIndentGuides.forEach(node, (line) => line.classList.remove("active"));
      }
    });
    set.forEach((node) => {
      if (!this.activeIndentNodes.has(node)) {
        this.renderedIndentGuides.forEach(node, (line) => line.classList.add("active"));
      }
    });
    this.activeIndentNodes = set;
  }
  dispose() {
    this.renderedNodes.clear();
    this.renderedElements.clear();
    this.indentGuidesDisposable.dispose();
    dispose(this.disposables);
  }
};
TreeRenderer.DefaultIndent = 8;
var FindFilter = class {
  get totalCount() {
    return this._totalCount;
  }
  get matchCount() {
    return this._matchCount;
  }
  constructor(tree, keyboardNavigationLabelProvider, _filter) {
    this.tree = tree;
    this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;
    this._filter = _filter;
    this._totalCount = 0;
    this._matchCount = 0;
    this._pattern = "";
    this._lowercasePattern = "";
    this.disposables = new DisposableStore();
    tree.onWillRefilter(this.reset, this, this.disposables);
  }
  filter(element, parentVisibility) {
    let visibility = 1;
    if (this._filter) {
      const result = this._filter.filter(element, parentVisibility);
      if (typeof result === "boolean") {
        visibility = result ? 1 : 0;
      } else if (isFilterResult(result)) {
        visibility = getVisibleState(result.visibility);
      } else {
        visibility = result;
      }
      if (visibility === 0) {
        return false;
      }
    }
    this._totalCount++;
    if (!this._pattern) {
      this._matchCount++;
      return { data: FuzzyScore.Default, visibility };
    }
    const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(element);
    const labels = Array.isArray(label) ? label : [label];
    for (const l of labels) {
      const labelStr = l && l.toString();
      if (typeof labelStr === "undefined") {
        return { data: FuzzyScore.Default, visibility };
      }
      let score3;
      if (this.tree.findMatchType === TreeFindMatchType.Contiguous) {
        const index = labelStr.toLowerCase().indexOf(this._lowercasePattern);
        if (index > -1) {
          score3 = [Number.MAX_SAFE_INTEGER, 0];
          for (let i = this._lowercasePattern.length; i > 0; i--) {
            score3.push(index + i - 1);
          }
        }
      } else {
        score3 = fuzzyScore(this._pattern, this._lowercasePattern, 0, labelStr, labelStr.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });
      }
      if (score3) {
        this._matchCount++;
        return labels.length === 1 ? { data: score3, visibility } : { data: { label: labelStr, score: score3 }, visibility };
      }
    }
    if (this.tree.findMode === TreeFindMode.Filter) {
      if (typeof this.tree.options.defaultFindVisibility === "number") {
        return this.tree.options.defaultFindVisibility;
      } else if (this.tree.options.defaultFindVisibility) {
        return this.tree.options.defaultFindVisibility(element);
      } else {
        return 2;
      }
    } else {
      return { data: FuzzyScore.Default, visibility };
    }
  }
  reset() {
    this._totalCount = 0;
    this._matchCount = 0;
  }
  dispose() {
    dispose(this.disposables);
  }
};
var TreeFindMode;
(function(TreeFindMode2) {
  TreeFindMode2[TreeFindMode2["Highlight"] = 0] = "Highlight";
  TreeFindMode2[TreeFindMode2["Filter"] = 1] = "Filter";
})(TreeFindMode || (TreeFindMode = {}));
var TreeFindMatchType;
(function(TreeFindMatchType2) {
  TreeFindMatchType2[TreeFindMatchType2["Fuzzy"] = 0] = "Fuzzy";
  TreeFindMatchType2[TreeFindMatchType2["Contiguous"] = 1] = "Contiguous";
})(TreeFindMatchType || (TreeFindMatchType = {}));
var FindController = class {
  get pattern() {
    return this._pattern;
  }
  get mode() {
    return this._mode;
  }
  set mode(mode) {
    if (mode === this._mode) {
      return;
    }
    this._mode = mode;
    if (this.widget) {
      this.widget.mode = this._mode;
    }
    this.tree.refilter();
    this.render();
    this._onDidChangeMode.fire(mode);
  }
  get matchType() {
    return this._matchType;
  }
  set matchType(matchType) {
    if (matchType === this._matchType) {
      return;
    }
    this._matchType = matchType;
    if (this.widget) {
      this.widget.matchType = this._matchType;
    }
    this.tree.refilter();
    this.render();
    this._onDidChangeMatchType.fire(matchType);
  }
  constructor(tree, model, view, filter, contextViewProvider, options2 = {}) {
    var _a2, _b2;
    this.tree = tree;
    this.view = view;
    this.filter = filter;
    this.contextViewProvider = contextViewProvider;
    this.options = options2;
    this._pattern = "";
    this.width = 0;
    this._onDidChangeMode = new Emitter();
    this.onDidChangeMode = this._onDidChangeMode.event;
    this._onDidChangeMatchType = new Emitter();
    this.onDidChangeMatchType = this._onDidChangeMatchType.event;
    this._onDidChangePattern = new Emitter();
    this._onDidChangeOpenState = new Emitter();
    this.onDidChangeOpenState = this._onDidChangeOpenState.event;
    this.enabledDisposables = new DisposableStore();
    this.disposables = new DisposableStore();
    this._mode = (_a2 = tree.options.defaultFindMode) !== null && _a2 !== void 0 ? _a2 : TreeFindMode.Highlight;
    this._matchType = (_b2 = tree.options.defaultFindMatchType) !== null && _b2 !== void 0 ? _b2 : TreeFindMatchType.Fuzzy;
    model.onDidSplice(this.onDidSpliceModel, this, this.disposables);
  }
  updateOptions(optionsUpdate = {}) {
    if (optionsUpdate.defaultFindMode !== void 0) {
      this.mode = optionsUpdate.defaultFindMode;
    }
    if (optionsUpdate.defaultFindMatchType !== void 0) {
      this.matchType = optionsUpdate.defaultFindMatchType;
    }
  }
  onDidSpliceModel() {
    if (!this.widget || this.pattern.length === 0) {
      return;
    }
    this.tree.refilter();
    this.render();
  }
  render() {
    var _a2, _b2, _c, _d;
    const noMatches = this.filter.totalCount > 0 && this.filter.matchCount === 0;
    if (this.pattern && noMatches) {
      if ((_a2 = this.tree.options.showNotFoundMessage) !== null && _a2 !== void 0 ? _a2 : true) {
        (_b2 = this.widget) === null || _b2 === void 0 ? void 0 : _b2.showMessage({ type: 2, content: localize("not found", "No elements found.") });
      } else {
        (_c = this.widget) === null || _c === void 0 ? void 0 : _c.showMessage({
          type: 2
          /* MessageType.WARNING */
        });
      }
    } else {
      (_d = this.widget) === null || _d === void 0 ? void 0 : _d.clearMessage();
    }
  }
  shouldAllowFocus(node) {
    if (!this.widget || !this.pattern) {
      return true;
    }
    if (this.filter.totalCount > 0 && this.filter.matchCount <= 1) {
      return true;
    }
    return !FuzzyScore.isDefault(node.filterData);
  }
  layout(width) {
    var _a2;
    this.width = width;
    (_a2 = this.widget) === null || _a2 === void 0 ? void 0 : _a2.layout(width);
  }
  dispose() {
    this._history = void 0;
    this._onDidChangePattern.dispose();
    this.enabledDisposables.dispose();
    this.disposables.dispose();
  }
};
function stickyScrollNodeStateEquals(node1, node2) {
  return node1.position === node2.position && stickyScrollNodeEquals(node1, node2);
}
function stickyScrollNodeEquals(node1, node2) {
  return node1.node.element === node2.node.element && node1.startIndex === node2.startIndex && node1.height === node2.height && node1.endIndex === node2.endIndex;
}
var StickyScrollState = class {
  constructor(stickyNodes = []) {
    this.stickyNodes = stickyNodes;
  }
  get count() {
    return this.stickyNodes.length;
  }
  equal(state) {
    return equals(this.stickyNodes, state.stickyNodes, stickyScrollNodeStateEquals);
  }
  lastNodePartiallyVisible() {
    if (this.count === 0) {
      return false;
    }
    const lastStickyNode = this.stickyNodes[this.count - 1];
    if (this.count === 1) {
      return lastStickyNode.position !== 0;
    }
    const secondLastStickyNode = this.stickyNodes[this.count - 2];
    return secondLastStickyNode.position + secondLastStickyNode.height !== lastStickyNode.position;
  }
  animationStateChanged(previousState) {
    if (!equals(this.stickyNodes, previousState.stickyNodes, stickyScrollNodeEquals)) {
      return false;
    }
    if (this.count === 0) {
      return false;
    }
    const lastStickyNode = this.stickyNodes[this.count - 1];
    const previousLastStickyNode = previousState.stickyNodes[previousState.count - 1];
    return lastStickyNode.position !== previousLastStickyNode.position;
  }
};
var DefaultStickyScrollDelegate = class {
  constrainStickyScrollNodes(stickyNodes, stickyScrollMaxItemCount, maxWidgetHeight) {
    for (let i = 0; i < stickyNodes.length; i++) {
      const stickyNode = stickyNodes[i];
      const stickyNodeBottom = stickyNode.position + stickyNode.height;
      if (stickyNodeBottom > maxWidgetHeight || i >= stickyScrollMaxItemCount) {
        return stickyNodes.slice(0, i);
      }
    }
    return stickyNodes;
  }
};
var StickyScrollController = class extends Disposable {
  constructor(tree, model, view, renderers, treeDelegate, options2 = {}) {
    var _a2;
    super();
    this.tree = tree;
    this.model = model;
    this.view = view;
    this.treeDelegate = treeDelegate;
    this.maxWidgetViewRatio = 0.4;
    const stickyScrollOptions = this.validateStickySettings(options2);
    this.stickyScrollMaxItemCount = stickyScrollOptions.stickyScrollMaxItemCount;
    this.stickyScrollDelegate = (_a2 = options2.stickyScrollDelegate) !== null && _a2 !== void 0 ? _a2 : new DefaultStickyScrollDelegate();
    this._widget = this._register(new StickyScrollWidget(view.getScrollableElement(), view, tree, renderers, treeDelegate, options2.accessibilityProvider));
    this.onDidChangeHasFocus = this._widget.onDidChangeHasFocus;
    this.onContextMenu = this._widget.onContextMenu;
    this._register(view.onDidScroll(() => this.update()));
    this._register(view.onDidChangeContentHeight(() => this.update()));
    this._register(tree.onDidChangeCollapseState(() => this.update()));
    this.update();
  }
  getNodeAtHeight(height) {
    let index;
    if (height === 0) {
      index = this.view.firstVisibleIndex;
    } else {
      index = this.view.indexAt(height + this.view.scrollTop);
    }
    if (index < 0 || index >= this.view.length) {
      return void 0;
    }
    return this.view.element(index);
  }
  update() {
    const firstVisibleNode = this.getNodeAtHeight(0);
    if (!firstVisibleNode || this.tree.scrollTop === 0) {
      this._widget.setState(void 0);
      return;
    }
    const stickyState = this.findStickyState(firstVisibleNode);
    this._widget.setState(stickyState);
  }
  findStickyState(firstVisibleNode) {
    const stickyNodes = [];
    let firstVisibleNodeUnderWidget = firstVisibleNode;
    let stickyNodesHeight = 0;
    let nextStickyNode = this.getNextStickyNode(firstVisibleNodeUnderWidget, void 0, stickyNodesHeight);
    while (nextStickyNode) {
      stickyNodes.push(nextStickyNode);
      stickyNodesHeight += nextStickyNode.height;
      if (stickyNodes.length <= this.stickyScrollMaxItemCount) {
        firstVisibleNodeUnderWidget = this.getNextVisibleNode(nextStickyNode);
        if (!firstVisibleNodeUnderWidget) {
          break;
        }
      }
      nextStickyNode = this.getNextStickyNode(firstVisibleNodeUnderWidget, nextStickyNode.node, stickyNodesHeight);
    }
    const contrainedStickyNodes = this.constrainStickyNodes(stickyNodes);
    return contrainedStickyNodes.length ? new StickyScrollState(contrainedStickyNodes) : void 0;
  }
  getNextVisibleNode(previousStickyNode) {
    return this.getNodeAtHeight(previousStickyNode.position + previousStickyNode.height);
  }
  getNextStickyNode(firstVisibleNodeUnderWidget, previousStickyNode, stickyNodesHeight) {
    const nextStickyNode = this.getAncestorUnderPrevious(firstVisibleNodeUnderWidget, previousStickyNode);
    if (!nextStickyNode) {
      return void 0;
    }
    if (nextStickyNode === firstVisibleNodeUnderWidget) {
      if (!this.nodeIsUncollapsedParent(firstVisibleNodeUnderWidget)) {
        return void 0;
      }
      if (this.nodeTopAlignsWithStickyNodesBottom(firstVisibleNodeUnderWidget, stickyNodesHeight)) {
        return void 0;
      }
    }
    return this.createStickyScrollNode(nextStickyNode, stickyNodesHeight);
  }
  nodeTopAlignsWithStickyNodesBottom(node, stickyNodesHeight) {
    const nodeIndex = this.getNodeIndex(node);
    const elementTop = this.view.getElementTop(nodeIndex);
    const stickyPosition = stickyNodesHeight;
    return this.view.scrollTop === elementTop - stickyPosition;
  }
  createStickyScrollNode(node, currentStickyNodesHeight) {
    const height = this.treeDelegate.getHeight(node);
    const { startIndex, endIndex } = this.getNodeRange(node);
    const position = this.calculateStickyNodePosition(endIndex, currentStickyNodesHeight, height);
    return { node, position, height, startIndex, endIndex };
  }
  getAncestorUnderPrevious(node, previousAncestor = void 0) {
    let currentAncestor = node;
    let parentOfcurrentAncestor = this.getParentNode(currentAncestor);
    while (parentOfcurrentAncestor) {
      if (parentOfcurrentAncestor === previousAncestor) {
        return currentAncestor;
      }
      currentAncestor = parentOfcurrentAncestor;
      parentOfcurrentAncestor = this.getParentNode(currentAncestor);
    }
    if (previousAncestor === void 0) {
      return currentAncestor;
    }
    return void 0;
  }
  calculateStickyNodePosition(lastDescendantIndex, stickyRowPositionTop, stickyNodeHeight) {
    let lastChildRelativeTop = this.view.getRelativeTop(lastDescendantIndex);
    if (lastChildRelativeTop === null && this.view.firstVisibleIndex === lastDescendantIndex && lastDescendantIndex + 1 < this.view.length) {
      const nodeHeight = this.treeDelegate.getHeight(this.view.element(lastDescendantIndex));
      const nextNodeRelativeTop = this.view.getRelativeTop(lastDescendantIndex + 1);
      lastChildRelativeTop = nextNodeRelativeTop ? nextNodeRelativeTop - nodeHeight / this.view.renderHeight : null;
    }
    if (lastChildRelativeTop === null) {
      return stickyRowPositionTop;
    }
    const lastChildNode = this.view.element(lastDescendantIndex);
    const lastChildHeight = this.treeDelegate.getHeight(lastChildNode);
    const topOfLastChild = lastChildRelativeTop * this.view.renderHeight;
    const bottomOfLastChild = topOfLastChild + lastChildHeight;
    if (stickyRowPositionTop + stickyNodeHeight > bottomOfLastChild && stickyRowPositionTop <= bottomOfLastChild) {
      return bottomOfLastChild - stickyNodeHeight;
    }
    return stickyRowPositionTop;
  }
  constrainStickyNodes(stickyNodes) {
    if (stickyNodes.length === 0) {
      return [];
    }
    const maximumStickyWidgetHeight = this.view.renderHeight * this.maxWidgetViewRatio;
    const lastStickyNode = stickyNodes[stickyNodes.length - 1];
    if (stickyNodes.length <= this.stickyScrollMaxItemCount && lastStickyNode.position + lastStickyNode.height <= maximumStickyWidgetHeight) {
      return stickyNodes;
    }
    const constrainedStickyNodes = this.stickyScrollDelegate.constrainStickyScrollNodes(stickyNodes, this.stickyScrollMaxItemCount, maximumStickyWidgetHeight);
    if (!constrainedStickyNodes.length) {
      return [];
    }
    const lastConstrainedStickyNode = constrainedStickyNodes[constrainedStickyNodes.length - 1];
    if (constrainedStickyNodes.length > this.stickyScrollMaxItemCount || lastConstrainedStickyNode.position + lastConstrainedStickyNode.height > maximumStickyWidgetHeight) {
      throw new Error("stickyScrollDelegate violates constraints");
    }
    return constrainedStickyNodes;
  }
  getParentNode(node) {
    const nodeLocation = this.model.getNodeLocation(node);
    const parentLocation = this.model.getParentNodeLocation(nodeLocation);
    return parentLocation ? this.model.getNode(parentLocation) : void 0;
  }
  nodeIsUncollapsedParent(node) {
    const nodeLocation = this.model.getNodeLocation(node);
    return this.model.getListRenderCount(nodeLocation) > 1;
  }
  getNodeIndex(node) {
    const nodeLocation = this.model.getNodeLocation(node);
    const nodeIndex = this.model.getListIndex(nodeLocation);
    return nodeIndex;
  }
  getNodeRange(node) {
    const nodeLocation = this.model.getNodeLocation(node);
    const startIndex = this.model.getListIndex(nodeLocation);
    if (startIndex < 0) {
      throw new Error("Node not found in tree");
    }
    const renderCount = this.model.getListRenderCount(nodeLocation);
    const endIndex = startIndex + renderCount - 1;
    return { startIndex, endIndex };
  }
  nodePositionTopBelowWidget(node) {
    const ancestors = [];
    let currentAncestor = this.getParentNode(node);
    while (currentAncestor) {
      ancestors.push(currentAncestor);
      currentAncestor = this.getParentNode(currentAncestor);
    }
    let widgetHeight = 0;
    for (let i = 0; i < ancestors.length && i < this.stickyScrollMaxItemCount; i++) {
      widgetHeight += this.treeDelegate.getHeight(ancestors[i]);
    }
    return widgetHeight;
  }
  domFocus() {
    this._widget.domFocus();
  }
  // Whether sticky scroll was the last focused part in the tree or not
  focusedLast() {
    return this._widget.focusedLast();
  }
  updateOptions(optionsUpdate = {}) {
    if (!optionsUpdate.stickyScrollMaxItemCount) {
      return;
    }
    const validatedOptions = this.validateStickySettings(optionsUpdate);
    if (this.stickyScrollMaxItemCount !== validatedOptions.stickyScrollMaxItemCount) {
      this.stickyScrollMaxItemCount = validatedOptions.stickyScrollMaxItemCount;
      this.update();
    }
  }
  validateStickySettings(options2) {
    let stickyScrollMaxItemCount = 7;
    if (typeof options2.stickyScrollMaxItemCount === "number") {
      stickyScrollMaxItemCount = Math.max(options2.stickyScrollMaxItemCount, 1);
    }
    return { stickyScrollMaxItemCount };
  }
};
var StickyScrollWidget = class {
  constructor(container, view, tree, treeRenderers, treeDelegate, accessibilityProvider) {
    this.view = view;
    this.tree = tree;
    this.treeRenderers = treeRenderers;
    this.treeDelegate = treeDelegate;
    this.accessibilityProvider = accessibilityProvider;
    this._previousElements = [];
    this._previousStateDisposables = new DisposableStore();
    this._rootDomNode = $(".monaco-tree-sticky-container.empty");
    container.appendChild(this._rootDomNode);
    const shadow = $(".monaco-tree-sticky-container-shadow");
    this._rootDomNode.appendChild(shadow);
    this.stickyScrollFocus = new StickyScrollFocus(this._rootDomNode, view);
    this.onDidChangeHasFocus = this.stickyScrollFocus.onDidChangeHasFocus;
    this.onContextMenu = this.stickyScrollFocus.onContextMenu;
  }
  setState(state) {
    const wasVisible = !!this._previousState && this._previousState.count > 0;
    const isVisible = !!state && state.count > 0;
    if (!wasVisible && !isVisible || wasVisible && isVisible && this._previousState.equal(state)) {
      return;
    }
    if (wasVisible !== isVisible) {
      this.setVisible(isVisible);
    }
    if (!isVisible) {
      this._previousState = void 0;
      this._previousElements = [];
      this._previousStateDisposables.clear();
      return;
    }
    const lastStickyNode = state.stickyNodes[state.count - 1];
    if (this._previousState && state.animationStateChanged(this._previousState)) {
      this._previousElements[this._previousState.count - 1].style.top = `${lastStickyNode.position}px`;
    } else {
      this._previousStateDisposables.clear();
      const elements = Array(state.count);
      for (let stickyIndex = state.count - 1; stickyIndex >= 0; stickyIndex--) {
        const stickyNode = state.stickyNodes[stickyIndex];
        const { element, disposable } = this.createElement(stickyNode, stickyIndex, state.count);
        elements[stickyIndex] = element;
        this._rootDomNode.appendChild(element);
        this._previousStateDisposables.add(disposable);
      }
      this.stickyScrollFocus.updateElements(elements, state);
      this._previousElements = elements;
    }
    this._previousState = state;
    this._rootDomNode.style.height = `${lastStickyNode.position + lastStickyNode.height}px`;
  }
  createElement(stickyNode, stickyIndex, stickyNodesTotal) {
    const nodeIndex = stickyNode.startIndex;
    const stickyElement = document.createElement("div");
    stickyElement.style.top = `${stickyNode.position}px`;
    stickyElement.style.height = `${stickyNode.height}px`;
    stickyElement.style.lineHeight = `${stickyNode.height}px`;
    stickyElement.classList.add("monaco-tree-sticky-row");
    stickyElement.classList.add("monaco-list-row");
    stickyElement.setAttribute("data-index", `${nodeIndex}`);
    stickyElement.setAttribute("data-parity", nodeIndex % 2 === 0 ? "even" : "odd");
    stickyElement.setAttribute("id", this.view.getElementID(nodeIndex));
    this.setAccessibilityAttributes(stickyElement, stickyNode.node.element, stickyIndex, stickyNodesTotal);
    const nodeTemplateId = this.treeDelegate.getTemplateId(stickyNode.node);
    const renderer = this.treeRenderers.find((renderer2) => renderer2.templateId === nodeTemplateId);
    if (!renderer) {
      throw new Error(`No renderer found for template id ${nodeTemplateId}`);
    }
    let nodeCopy = stickyNode.node;
    if (nodeCopy === this.tree.getNode(this.tree.getNodeLocation(stickyNode.node))) {
      nodeCopy = new Proxy(stickyNode.node, {});
    }
    const templateData = renderer.renderTemplate(stickyElement);
    renderer.renderElement(nodeCopy, stickyNode.startIndex, templateData, stickyNode.height);
    const disposable = toDisposable(() => {
      renderer.disposeElement(nodeCopy, stickyNode.startIndex, templateData, stickyNode.height);
      renderer.disposeTemplate(templateData);
      stickyElement.remove();
    });
    return { element: stickyElement, disposable };
  }
  setAccessibilityAttributes(container, element, stickyIndex, stickyNodesTotal) {
    var _a2;
    if (!this.accessibilityProvider) {
      return;
    }
    if (this.accessibilityProvider.getSetSize) {
      container.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(element, stickyIndex, stickyNodesTotal)));
    }
    if (this.accessibilityProvider.getPosInSet) {
      container.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(element, stickyIndex)));
    }
    if (this.accessibilityProvider.getRole) {
      container.setAttribute("role", (_a2 = this.accessibilityProvider.getRole(element)) !== null && _a2 !== void 0 ? _a2 : "treeitem");
    }
    const ariaLabel = this.accessibilityProvider.getAriaLabel(element);
    if (ariaLabel) {
      container.setAttribute("aria-label", ariaLabel);
    }
    const ariaLevel = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(element);
    if (typeof ariaLevel === "number") {
      container.setAttribute("aria-level", `${ariaLevel}`);
    }
    container.setAttribute("aria-selected", String(false));
  }
  setVisible(visible) {
    this._rootDomNode.classList.toggle("empty", !visible);
    if (!visible) {
      this.stickyScrollFocus.updateElements([], void 0);
    }
  }
  domFocus() {
    this.stickyScrollFocus.domFocus();
  }
  focusedLast() {
    return this.stickyScrollFocus.focusedLast();
  }
  dispose() {
    this.stickyScrollFocus.dispose();
    this._previousStateDisposables.dispose();
    this._rootDomNode.remove();
  }
};
var StickyScrollFocus = class extends Disposable {
  get domHasFocus() {
    return this._domHasFocus;
  }
  set domHasFocus(hasFocus) {
    if (hasFocus !== this._domHasFocus) {
      this._onDidChangeHasFocus.fire(hasFocus);
      this._domHasFocus = hasFocus;
    }
  }
  constructor(container, view) {
    super();
    this.container = container;
    this.view = view;
    this.focusedIndex = -1;
    this.elements = [];
    this._onDidChangeHasFocus = new Emitter();
    this.onDidChangeHasFocus = this._onDidChangeHasFocus.event;
    this._onContextMenu = new Emitter();
    this.onContextMenu = this._onContextMenu.event;
    this._domHasFocus = false;
    this.container.addEventListener("focus", () => this.onFocus());
    this.container.addEventListener("blur", () => this.onBlur());
    this._register(this.view.onDidFocus(() => this.toggleStickyScrollFocused(false)));
    this._register(this.view.onKeyDown((e) => this.onKeyDown(e)));
    this._register(this.view.onMouseDown((e) => this.onMouseDown(e)));
    this._register(this.view.onContextMenu((e) => this.handleContextMenu(e)));
  }
  handleContextMenu(e) {
    const target = e.browserEvent.target;
    if (!isStickyScrollContainer(target) && !isStickyScrollElement(target)) {
      if (this.focusedLast()) {
        this.view.domFocus();
      }
      return;
    }
    if (!isKeyboardEvent(e.browserEvent)) {
      if (!this.state) {
        throw new Error("Context menu should not be triggered when state is undefined");
      }
      const stickyIndex = this.state.stickyNodes.findIndex((stickyNode2) => {
        var _a2;
        return stickyNode2.node.element === ((_a2 = e.element) === null || _a2 === void 0 ? void 0 : _a2.element);
      });
      if (stickyIndex === -1) {
        throw new Error("Context menu should not be triggered when element is not in sticky scroll widget");
      }
      this.container.focus();
      this.setFocus(stickyIndex);
      return;
    }
    if (!this.state || this.focusedIndex < 0) {
      throw new Error("Context menu key should not be triggered when focus is not in sticky scroll widget");
    }
    const stickyNode = this.state.stickyNodes[this.focusedIndex];
    const element = stickyNode.node.element;
    const anchor = this.elements[this.focusedIndex];
    this._onContextMenu.fire({ element, anchor, browserEvent: e.browserEvent, isStickyScroll: true });
  }
  onKeyDown(e) {
    if (this.domHasFocus && this.state) {
      if (e.key === "ArrowUp") {
        this.setFocusedElement(Math.max(0, this.focusedIndex - 1));
        e.preventDefault();
        e.stopPropagation();
      } else if (e.key === "ArrowDown" || e.key === "ArrowRight") {
        if (this.focusedIndex >= this.state.count - 1) {
          const nodeIndexToFocus = this.state.stickyNodes[this.state.count - 1].startIndex + 1;
          this.view.domFocus();
          this.view.setFocus([nodeIndexToFocus]);
          this.scrollNodeUnderWidget(nodeIndexToFocus, this.state);
        } else {
          this.setFocusedElement(this.focusedIndex + 1);
        }
        e.preventDefault();
        e.stopPropagation();
      }
    }
  }
  onMouseDown(e) {
    const target = e.browserEvent.target;
    if (!isStickyScrollContainer(target) && !isStickyScrollElement(target)) {
      return;
    }
    e.browserEvent.preventDefault();
    e.browserEvent.stopPropagation();
  }
  updateElements(elements, state) {
    if (state && state.count === 0) {
      throw new Error("Sticky scroll state must be undefined when there are no sticky nodes");
    }
    if (state && state.count !== elements.length) {
      throw new Error("Sticky scroll focus received illigel state");
    }
    const previousIndex = this.focusedIndex;
    this.removeFocus();
    this.elements = elements;
    this.state = state;
    if (state) {
      const newFocusedIndex = clamp(previousIndex, 0, state.count - 1);
      this.setFocus(newFocusedIndex);
    } else {
      if (this.domHasFocus) {
        this.view.domFocus();
      }
    }
    this.container.tabIndex = state ? 0 : -1;
  }
  setFocusedElement(stickyIndex) {
    const state = this.state;
    if (!state) {
      throw new Error("Cannot set focus when state is undefined");
    }
    this.setFocus(stickyIndex);
    if (stickyIndex < state.count - 1) {
      return;
    }
    if (state.lastNodePartiallyVisible()) {
      const lastStickyNode = state.stickyNodes[stickyIndex];
      this.scrollNodeUnderWidget(lastStickyNode.endIndex + 1, state);
    }
  }
  scrollNodeUnderWidget(nodeIndex, state) {
    const lastStickyNode = state.stickyNodes[state.count - 1];
    const secondLastStickyNode = state.count > 1 ? state.stickyNodes[state.count - 2] : void 0;
    const elementScrollTop = this.view.getElementTop(nodeIndex);
    const elementTargetViewTop = secondLastStickyNode ? secondLastStickyNode.position + secondLastStickyNode.height + lastStickyNode.height : lastStickyNode.height;
    this.view.scrollTop = elementScrollTop - elementTargetViewTop;
  }
  domFocus() {
    if (!this.state) {
      throw new Error("Cannot focus when state is undefined");
    }
    this.container.focus();
  }
  focusedLast() {
    if (!this.state) {
      return false;
    }
    return this.view.getHTMLElement().classList.contains("sticky-scroll-focused");
  }
  removeFocus() {
    if (this.focusedIndex === -1) {
      return;
    }
    this.toggleElementFocus(this.elements[this.focusedIndex], false);
    this.focusedIndex = -1;
  }
  setFocus(newFocusIndex) {
    if (0 > newFocusIndex) {
      throw new Error("addFocus() can not remove focus");
    }
    if (!this.state && newFocusIndex >= 0) {
      throw new Error("Cannot set focus index when state is undefined");
    }
    if (this.state && newFocusIndex >= this.state.count) {
      throw new Error("Cannot set focus index to an index that does not exist");
    }
    const oldIndex = this.focusedIndex;
    if (oldIndex >= 0) {
      this.toggleElementFocus(this.elements[oldIndex], false);
    }
    if (newFocusIndex >= 0) {
      this.toggleElementFocus(this.elements[newFocusIndex], true);
    }
    this.focusedIndex = newFocusIndex;
  }
  toggleElementFocus(element, focused) {
    element.classList.toggle("focused", focused);
  }
  toggleStickyScrollFocused(focused) {
    this.view.getHTMLElement().classList.toggle("sticky-scroll-focused", focused);
  }
  onFocus() {
    if (!this.state || this.elements.length === 0) {
      throw new Error("Cannot focus when state is undefined or elements are empty");
    }
    this.domHasFocus = true;
    this.toggleStickyScrollFocused(true);
    if (this.focusedIndex === -1) {
      this.setFocus(0);
    }
  }
  onBlur() {
    this.domHasFocus = false;
  }
  dispose() {
    this.toggleStickyScrollFocused(false);
    this._onDidChangeHasFocus.fire(false);
    super.dispose();
  }
};
function asTreeMouseEvent(event) {
  let target = TreeMouseEventTarget.Unknown;
  if (hasParentWithClass(event.browserEvent.target, "monaco-tl-twistie", "monaco-tl-row")) {
    target = TreeMouseEventTarget.Twistie;
  } else if (hasParentWithClass(event.browserEvent.target, "monaco-tl-contents", "monaco-tl-row")) {
    target = TreeMouseEventTarget.Element;
  } else if (hasParentWithClass(event.browserEvent.target, "monaco-tree-type-filter", "monaco-list")) {
    target = TreeMouseEventTarget.Filter;
  }
  return {
    browserEvent: event.browserEvent,
    element: event.element ? event.element.element : null,
    target
  };
}
function dfs(node, fn) {
  fn(node);
  node.children.forEach((child) => dfs(child, fn));
}
var Trait2 = class {
  get nodeSet() {
    if (!this._nodeSet) {
      this._nodeSet = this.createNodeSet();
    }
    return this._nodeSet;
  }
  constructor(getFirstViewElementWithTrait, identityProvider) {
    this.getFirstViewElementWithTrait = getFirstViewElementWithTrait;
    this.identityProvider = identityProvider;
    this.nodes = [];
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
  }
  set(nodes, browserEvent) {
    if (!(browserEvent === null || browserEvent === void 0 ? void 0 : browserEvent.__forceEvent) && equals(this.nodes, nodes)) {
      return;
    }
    this._set(nodes, false, browserEvent);
  }
  _set(nodes, silent, browserEvent) {
    this.nodes = [...nodes];
    this.elements = void 0;
    this._nodeSet = void 0;
    if (!silent) {
      const that = this;
      this._onDidChange.fire({ get elements() {
        return that.get();
      }, browserEvent });
    }
  }
  get() {
    if (!this.elements) {
      this.elements = this.nodes.map((node) => node.element);
    }
    return [...this.elements];
  }
  getNodes() {
    return this.nodes;
  }
  has(node) {
    return this.nodeSet.has(node);
  }
  onDidModelSplice({ insertedNodes, deletedNodes }) {
    if (!this.identityProvider) {
      const set = this.createNodeSet();
      const visit = (node) => set.delete(node);
      deletedNodes.forEach((node) => dfs(node, visit));
      this.set([...set.values()]);
      return;
    }
    const deletedNodesIdSet = /* @__PURE__ */ new Set();
    const deletedNodesVisitor = (node) => deletedNodesIdSet.add(this.identityProvider.getId(node.element).toString());
    deletedNodes.forEach((node) => dfs(node, deletedNodesVisitor));
    const insertedNodesMap = /* @__PURE__ */ new Map();
    const insertedNodesVisitor = (node) => insertedNodesMap.set(this.identityProvider.getId(node.element).toString(), node);
    insertedNodes.forEach((node) => dfs(node, insertedNodesVisitor));
    const nodes = [];
    for (const node of this.nodes) {
      const id = this.identityProvider.getId(node.element).toString();
      const wasDeleted = deletedNodesIdSet.has(id);
      if (!wasDeleted) {
        nodes.push(node);
      } else {
        const insertedNode = insertedNodesMap.get(id);
        if (insertedNode && insertedNode.visible) {
          nodes.push(insertedNode);
        }
      }
    }
    if (this.nodes.length > 0 && nodes.length === 0) {
      const node = this.getFirstViewElementWithTrait();
      if (node) {
        nodes.push(node);
      }
    }
    this._set(nodes, true);
  }
  createNodeSet() {
    const set = /* @__PURE__ */ new Set();
    for (const node of this.nodes) {
      set.add(node);
    }
    return set;
  }
};
var TreeNodeListMouseController = class extends MouseController {
  constructor(list, tree, stickyScrollProvider) {
    super(list);
    this.tree = tree;
    this.stickyScrollProvider = stickyScrollProvider;
  }
  onViewPointer(e) {
    if (isButton(e.browserEvent.target) || isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {
      return;
    }
    if (e.browserEvent.isHandledByList) {
      return;
    }
    const node = e.element;
    if (!node) {
      return super.onViewPointer(e);
    }
    if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e)) {
      return super.onViewPointer(e);
    }
    const target = e.browserEvent.target;
    const onTwistie = target.classList.contains("monaco-tl-twistie") || target.classList.contains("monaco-icon-label") && target.classList.contains("folder-icon") && e.browserEvent.offsetX < 16;
    const isStickyElement = isStickyScrollElement(e.browserEvent.target);
    let expandOnlyOnTwistieClick = false;
    if (isStickyElement) {
      expandOnlyOnTwistieClick = true;
    } else if (typeof this.tree.expandOnlyOnTwistieClick === "function") {
      expandOnlyOnTwistieClick = this.tree.expandOnlyOnTwistieClick(node.element);
    } else {
      expandOnlyOnTwistieClick = !!this.tree.expandOnlyOnTwistieClick;
    }
    if (!isStickyElement) {
      if (expandOnlyOnTwistieClick && !onTwistie && e.browserEvent.detail !== 2) {
        return super.onViewPointer(e);
      }
      if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2) {
        return super.onViewPointer(e);
      }
    } else {
      this.handleStickyScrollMouseEvent(e, node);
    }
    if (node.collapsible && (!isStickyElement || onTwistie)) {
      const location = this.tree.getNodeLocation(node);
      const recursive = e.browserEvent.altKey;
      this.tree.setFocus([location]);
      this.tree.toggleCollapsed(location, recursive);
      if (expandOnlyOnTwistieClick && onTwistie) {
        e.browserEvent.isHandledByList = true;
        return;
      }
    }
    if (!isStickyElement) {
      super.onViewPointer(e);
    }
  }
  handleStickyScrollMouseEvent(e, node) {
    if (isMonacoCustomToggle(e.browserEvent.target) || isActionItem(e.browserEvent.target)) {
      return;
    }
    const stickyScrollController = this.stickyScrollProvider();
    if (!stickyScrollController) {
      throw new Error("Sticky scroll controller not found");
    }
    const nodeIndex = this.list.indexOf(node);
    const elementScrollTop = this.list.getElementTop(nodeIndex);
    const elementTargetViewTop = stickyScrollController.nodePositionTopBelowWidget(node);
    this.tree.scrollTop = elementScrollTop - elementTargetViewTop;
    this.list.domFocus();
    this.list.setFocus([nodeIndex]);
    this.list.setSelection([nodeIndex]);
  }
  onDoubleClick(e) {
    const onTwistie = e.browserEvent.target.classList.contains("monaco-tl-twistie");
    if (onTwistie || !this.tree.expandOnDoubleClick) {
      return;
    }
    if (e.browserEvent.isHandledByList) {
      return;
    }
    super.onDoubleClick(e);
  }
  // to make sure dom focus is not stolen (for example with context menu)
  onMouseDown(e) {
    const target = e.browserEvent.target;
    if (!isStickyScrollContainer(target) && !isStickyScrollElement(target)) {
      super.onMouseDown(e);
      return;
    }
  }
  onContextMenu(e) {
    const target = e.browserEvent.target;
    if (!isStickyScrollContainer(target) && !isStickyScrollElement(target)) {
      super.onContextMenu(e);
      return;
    }
  }
};
var TreeNodeList = class extends List {
  constructor(user, container, virtualDelegate, renderers, focusTrait, selectionTrait, anchorTrait, options2) {
    super(user, container, virtualDelegate, renderers, options2);
    this.focusTrait = focusTrait;
    this.selectionTrait = selectionTrait;
    this.anchorTrait = anchorTrait;
  }
  createMouseController(options2) {
    return new TreeNodeListMouseController(this, options2.tree, options2.stickyScrollProvider);
  }
  splice(start, deleteCount, elements = []) {
    super.splice(start, deleteCount, elements);
    if (elements.length === 0) {
      return;
    }
    const additionalFocus = [];
    const additionalSelection = [];
    let anchor;
    elements.forEach((node, index) => {
      if (this.focusTrait.has(node)) {
        additionalFocus.push(start + index);
      }
      if (this.selectionTrait.has(node)) {
        additionalSelection.push(start + index);
      }
      if (this.anchorTrait.has(node)) {
        anchor = start + index;
      }
    });
    if (additionalFocus.length > 0) {
      super.setFocus(distinct([...super.getFocus(), ...additionalFocus]));
    }
    if (additionalSelection.length > 0) {
      super.setSelection(distinct([...super.getSelection(), ...additionalSelection]));
    }
    if (typeof anchor === "number") {
      super.setAnchor(anchor);
    }
  }
  setFocus(indexes, browserEvent, fromAPI = false) {
    super.setFocus(indexes, browserEvent);
    if (!fromAPI) {
      this.focusTrait.set(indexes.map((i) => this.element(i)), browserEvent);
    }
  }
  setSelection(indexes, browserEvent, fromAPI = false) {
    super.setSelection(indexes, browserEvent);
    if (!fromAPI) {
      this.selectionTrait.set(indexes.map((i) => this.element(i)), browserEvent);
    }
  }
  setAnchor(index, fromAPI = false) {
    super.setAnchor(index);
    if (!fromAPI) {
      if (typeof index === "undefined") {
        this.anchorTrait.set([]);
      } else {
        this.anchorTrait.set([this.element(index)]);
      }
    }
  }
};
var AbstractTree = class {
  get onDidScroll() {
    return this.view.onDidScroll;
  }
  get onDidChangeFocus() {
    return this.eventBufferer.wrapEvent(this.focus.onDidChange);
  }
  get onDidChangeSelection() {
    return this.eventBufferer.wrapEvent(this.selection.onDidChange);
  }
  get onMouseDblClick() {
    return Event.filter(Event.map(this.view.onMouseDblClick, asTreeMouseEvent), (e) => e.target !== TreeMouseEventTarget.Filter);
  }
  get onPointer() {
    return Event.map(this.view.onPointer, asTreeMouseEvent);
  }
  get onDidFocus() {
    return this.view.onDidFocus;
  }
  get onDidChangeModel() {
    return Event.signal(this.model.onDidSplice);
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get findMode() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.findController) === null || _a2 === void 0 ? void 0 : _a2.mode) !== null && _b2 !== void 0 ? _b2 : TreeFindMode.Highlight;
  }
  set findMode(findMode) {
    if (this.findController) {
      this.findController.mode = findMode;
    }
  }
  get findMatchType() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.findController) === null || _a2 === void 0 ? void 0 : _a2.matchType) !== null && _b2 !== void 0 ? _b2 : TreeFindMatchType.Fuzzy;
  }
  set findMatchType(findFuzzy) {
    if (this.findController) {
      this.findController.matchType = findFuzzy;
    }
  }
  get expandOnDoubleClick() {
    return typeof this._options.expandOnDoubleClick === "undefined" ? true : this._options.expandOnDoubleClick;
  }
  get expandOnlyOnTwistieClick() {
    return typeof this._options.expandOnlyOnTwistieClick === "undefined" ? true : this._options.expandOnlyOnTwistieClick;
  }
  get onDidDispose() {
    return this.view.onDidDispose;
  }
  constructor(_user, container, delegate, renderers, _options = {}) {
    var _a2;
    this._user = _user;
    this._options = _options;
    this.eventBufferer = new EventBufferer();
    this.onDidChangeFindOpenState = Event.None;
    this.onDidChangeStickyScrollFocused = Event.None;
    this.disposables = new DisposableStore();
    this._onWillRefilter = new Emitter();
    this.onWillRefilter = this._onWillRefilter.event;
    this._onDidUpdateOptions = new Emitter();
    this.treeDelegate = new ComposedTreeDelegate(delegate);
    const onDidChangeCollapseStateRelay = new Relay();
    const onDidChangeActiveNodes = new Relay();
    const activeNodes = this.disposables.add(new EventCollection(onDidChangeActiveNodes.event));
    const renderedIndentGuides = new SetMap();
    this.renderers = renderers.map((r) => new TreeRenderer(r, () => this.model, onDidChangeCollapseStateRelay.event, activeNodes, renderedIndentGuides, _options));
    for (const r of this.renderers) {
      this.disposables.add(r);
    }
    let filter;
    if (_options.keyboardNavigationLabelProvider) {
      filter = new FindFilter(this, _options.keyboardNavigationLabelProvider, _options.filter);
      _options = { ..._options, filter };
      this.disposables.add(filter);
    }
    this.focus = new Trait2(() => this.view.getFocusedElements()[0], _options.identityProvider);
    this.selection = new Trait2(() => this.view.getSelectedElements()[0], _options.identityProvider);
    this.anchor = new Trait2(() => this.view.getAnchorElement(), _options.identityProvider);
    this.view = new TreeNodeList(_user, container, this.treeDelegate, this.renderers, this.focus, this.selection, this.anchor, { ...asListOptions(() => this.model, _options), tree: this, stickyScrollProvider: () => this.stickyScrollController });
    this.model = this.createModel(_user, this.view, _options);
    onDidChangeCollapseStateRelay.input = this.model.onDidChangeCollapseState;
    const onDidModelSplice = Event.forEach(this.model.onDidSplice, (e) => {
      this.eventBufferer.bufferEvents(() => {
        this.focus.onDidModelSplice(e);
        this.selection.onDidModelSplice(e);
      });
    }, this.disposables);
    onDidModelSplice(() => null, null, this.disposables);
    const activeNodesEmitter = this.disposables.add(new Emitter());
    const activeNodesDebounce = this.disposables.add(new Delayer(0));
    this.disposables.add(Event.any(onDidModelSplice, this.focus.onDidChange, this.selection.onDidChange)(() => {
      activeNodesDebounce.trigger(() => {
        const set = /* @__PURE__ */ new Set();
        for (const node of this.focus.getNodes()) {
          set.add(node);
        }
        for (const node of this.selection.getNodes()) {
          set.add(node);
        }
        activeNodesEmitter.fire([...set.values()]);
      });
    }));
    onDidChangeActiveNodes.input = activeNodesEmitter.event;
    if (_options.keyboardSupport !== false) {
      const onKeyDown = Event.chain(this.view.onKeyDown, ($10) => $10.filter((e) => !isInputElement(e.target)).map((e) => new StandardKeyboardEvent(e)));
      Event.chain(onKeyDown, ($10) => $10.filter(
        (e) => e.keyCode === 15
        /* KeyCode.LeftArrow */
      ))(this.onLeftArrow, this, this.disposables);
      Event.chain(onKeyDown, ($10) => $10.filter(
        (e) => e.keyCode === 17
        /* KeyCode.RightArrow */
      ))(this.onRightArrow, this, this.disposables);
      Event.chain(onKeyDown, ($10) => $10.filter(
        (e) => e.keyCode === 10
        /* KeyCode.Space */
      ))(this.onSpace, this, this.disposables);
    }
    if (((_a2 = _options.findWidgetEnabled) !== null && _a2 !== void 0 ? _a2 : true) && _options.keyboardNavigationLabelProvider && _options.contextViewProvider) {
      const opts = this.options.findWidgetStyles ? { styles: this.options.findWidgetStyles } : void 0;
      this.findController = new FindController(this, this.model, this.view, filter, _options.contextViewProvider, opts);
      this.focusNavigationFilter = (node) => this.findController.shouldAllowFocus(node);
      this.onDidChangeFindOpenState = this.findController.onDidChangeOpenState;
      this.disposables.add(this.findController);
      this.onDidChangeFindMode = this.findController.onDidChangeMode;
      this.onDidChangeFindMatchType = this.findController.onDidChangeMatchType;
    } else {
      this.onDidChangeFindMode = Event.None;
      this.onDidChangeFindMatchType = Event.None;
    }
    if (_options.enableStickyScroll) {
      this.stickyScrollController = new StickyScrollController(this, this.model, this.view, this.renderers, this.treeDelegate, _options);
      this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus;
    }
    this.styleElement = createStyleSheet(this.view.getHTMLElement());
    this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === RenderIndentGuides.Always);
  }
  updateOptions(optionsUpdate = {}) {
    var _a2;
    this._options = { ...this._options, ...optionsUpdate };
    for (const renderer of this.renderers) {
      renderer.updateOptions(optionsUpdate);
    }
    this.view.updateOptions(this._options);
    (_a2 = this.findController) === null || _a2 === void 0 ? void 0 : _a2.updateOptions(optionsUpdate);
    this.updateStickyScroll(optionsUpdate);
    this._onDidUpdateOptions.fire(this._options);
    this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === RenderIndentGuides.Always);
  }
  get options() {
    return this._options;
  }
  updateStickyScroll(optionsUpdate) {
    var _a2;
    if (!this.stickyScrollController && this._options.enableStickyScroll) {
      this.stickyScrollController = new StickyScrollController(this, this.model, this.view, this.renderers, this.treeDelegate, this._options);
      this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus;
    } else if (this.stickyScrollController && !this._options.enableStickyScroll) {
      this.onDidChangeStickyScrollFocused = Event.None;
      this.stickyScrollController.dispose();
      this.stickyScrollController = void 0;
    }
    (_a2 = this.stickyScrollController) === null || _a2 === void 0 ? void 0 : _a2.updateOptions(optionsUpdate);
  }
  // Widget
  getHTMLElement() {
    return this.view.getHTMLElement();
  }
  get scrollTop() {
    return this.view.scrollTop;
  }
  set scrollTop(scrollTop) {
    this.view.scrollTop = scrollTop;
  }
  get scrollHeight() {
    return this.view.scrollHeight;
  }
  get renderHeight() {
    return this.view.renderHeight;
  }
  domFocus() {
    var _a2;
    if ((_a2 = this.stickyScrollController) === null || _a2 === void 0 ? void 0 : _a2.focusedLast()) {
      this.stickyScrollController.domFocus();
    } else {
      this.view.domFocus();
    }
  }
  layout(height, width) {
    var _a2;
    this.view.layout(height, width);
    if (isNumber(width)) {
      (_a2 = this.findController) === null || _a2 === void 0 ? void 0 : _a2.layout(width);
    }
  }
  style(styles) {
    var _a2;
    const suffix = `.${this.view.domId}`;
    const content = [];
    if (styles.treeIndentGuidesStroke) {
      content.push(`.monaco-list${suffix}:hover .monaco-tl-indent > .indent-guide, .monaco-list${suffix}.always .monaco-tl-indent > .indent-guide  { border-color: ${styles.treeInactiveIndentGuidesStroke}; }`);
      content.push(`.monaco-list${suffix} .monaco-tl-indent > .indent-guide.active { border-color: ${styles.treeIndentGuidesStroke}; }`);
    }
    if (styles.listBackground) {
      content.push(`.monaco-list${suffix} .monaco-scrollable-element .monaco-tree-sticky-container { background-color: ${styles.listBackground}; }`);
      content.push(`.monaco-list${suffix} .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-row { background-color: ${styles.listBackground}; }`);
    }
    if (styles.listFocusForeground) {
      content.push(`.monaco-list${suffix}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { color: ${styles.listFocusForeground}; }`);
      content.push(`.monaco-list${suffix}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { color: inherit; }`);
    }
    const focusAndSelectionOutline = asCssValueWithDefault(styles.listFocusAndSelectionOutline, asCssValueWithDefault(styles.listSelectionOutline, (_a2 = styles.listFocusOutline) !== null && _a2 !== void 0 ? _a2 : ""));
    if (focusAndSelectionOutline) {
      content.push(`.monaco-list${suffix}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused.selected { outline: 1px solid ${focusAndSelectionOutline}; outline-offset: -1px;}`);
      content.push(`.monaco-list${suffix}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused.selected { outline: inherit;}`);
    }
    if (styles.listFocusOutline) {
      content.push(`.monaco-list${suffix}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }`);
      content.push(`.monaco-list${suffix}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { outline: inherit; }`);
      content.push(`.monaco-workbench.context-menu-visible .monaco-list${suffix}.last-focused.sticky-scroll-focused .monaco-list-rows .monaco-list-row.focused { outline: inherit; }`);
      content.push(`.monaco-workbench.context-menu-visible .monaco-list${suffix}.last-focused:not(.sticky-scroll-focused) .monaco-tree-sticky-container .monaco-list-rows .monaco-list-row.focused { outline: inherit; }`);
    }
    this.styleElement.textContent = content.join("\n");
    this.view.style(styles);
  }
  // Tree navigation
  getParentElement(location) {
    const parentRef = this.model.getParentNodeLocation(location);
    const parentNode = this.model.getNode(parentRef);
    return parentNode.element;
  }
  getFirstElementChild(location) {
    return this.model.getFirstElementChild(location);
  }
  // Tree
  getNode(location) {
    return this.model.getNode(location);
  }
  getNodeLocation(node) {
    return this.model.getNodeLocation(node);
  }
  collapse(location, recursive = false) {
    return this.model.setCollapsed(location, true, recursive);
  }
  expand(location, recursive = false) {
    return this.model.setCollapsed(location, false, recursive);
  }
  toggleCollapsed(location, recursive = false) {
    return this.model.setCollapsed(location, void 0, recursive);
  }
  isCollapsible(location) {
    return this.model.isCollapsible(location);
  }
  setCollapsible(location, collapsible) {
    return this.model.setCollapsible(location, collapsible);
  }
  isCollapsed(location) {
    return this.model.isCollapsed(location);
  }
  refilter() {
    this._onWillRefilter.fire(void 0);
    this.model.refilter();
  }
  setSelection(elements, browserEvent) {
    this.eventBufferer.bufferEvents(() => {
      const nodes = elements.map((e) => this.model.getNode(e));
      this.selection.set(nodes, browserEvent);
      const indexes = elements.map((e) => this.model.getListIndex(e)).filter((i) => i > -1);
      this.view.setSelection(indexes, browserEvent, true);
    });
  }
  getSelection() {
    return this.selection.get();
  }
  setFocus(elements, browserEvent) {
    this.eventBufferer.bufferEvents(() => {
      const nodes = elements.map((e) => this.model.getNode(e));
      this.focus.set(nodes, browserEvent);
      const indexes = elements.map((e) => this.model.getListIndex(e)).filter((i) => i > -1);
      this.view.setFocus(indexes, browserEvent, true);
    });
  }
  getFocus() {
    return this.focus.get();
  }
  reveal(location, relativeTop) {
    this.model.expandTo(location);
    const index = this.model.getListIndex(location);
    if (index === -1) {
      return;
    }
    if (!this.stickyScrollController) {
      this.view.reveal(index, relativeTop);
    } else {
      const paddingTop = this.stickyScrollController.nodePositionTopBelowWidget(this.getNode(location));
      this.view.reveal(index, relativeTop, paddingTop);
    }
  }
  // List
  onLeftArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    const nodes = this.view.getFocusedElements();
    if (nodes.length === 0) {
      return;
    }
    const node = nodes[0];
    const location = this.model.getNodeLocation(node);
    const didChange = this.model.setCollapsed(location, true);
    if (!didChange) {
      const parentLocation = this.model.getParentNodeLocation(location);
      if (!parentLocation) {
        return;
      }
      const parentListIndex = this.model.getListIndex(parentLocation);
      this.view.reveal(parentListIndex);
      this.view.setFocus([parentListIndex]);
    }
  }
  onRightArrow(e) {
    e.preventDefault();
    e.stopPropagation();
    const nodes = this.view.getFocusedElements();
    if (nodes.length === 0) {
      return;
    }
    const node = nodes[0];
    const location = this.model.getNodeLocation(node);
    const didChange = this.model.setCollapsed(location, false);
    if (!didChange) {
      if (!node.children.some((child) => child.visible)) {
        return;
      }
      const [focusedIndex] = this.view.getFocus();
      const firstChildIndex = focusedIndex + 1;
      this.view.reveal(firstChildIndex);
      this.view.setFocus([firstChildIndex]);
    }
  }
  onSpace(e) {
    e.preventDefault();
    e.stopPropagation();
    const nodes = this.view.getFocusedElements();
    if (nodes.length === 0) {
      return;
    }
    const node = nodes[0];
    const location = this.model.getNodeLocation(node);
    const recursive = e.browserEvent.altKey;
    this.model.setCollapsed(location, void 0, recursive);
  }
  dispose() {
    var _a2;
    dispose(this.disposables);
    (_a2 = this.stickyScrollController) === null || _a2 === void 0 ? void 0 : _a2.dispose();
    this.view.dispose();
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/objectTreeModel.js
init_iterator();
var ObjectTreeModel = class {
  constructor(user, list, options2 = {}) {
    this.user = user;
    this.rootRef = null;
    this.nodes = /* @__PURE__ */ new Map();
    this.nodesByIdentity = /* @__PURE__ */ new Map();
    this.model = new IndexTreeModel(user, list, null, options2);
    this.onDidSplice = this.model.onDidSplice;
    this.onDidChangeCollapseState = this.model.onDidChangeCollapseState;
    this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount;
    if (options2.sorter) {
      this.sorter = {
        compare(a, b) {
          return options2.sorter.compare(a.element, b.element);
        }
      };
    }
    this.identityProvider = options2.identityProvider;
  }
  setChildren(element, children = Iterable.empty(), options2 = {}) {
    const location = this.getElementLocation(element);
    this._setChildren(location, this.preserveCollapseState(children), options2);
  }
  _setChildren(location, children = Iterable.empty(), options2) {
    const insertedElements = /* @__PURE__ */ new Set();
    const insertedElementIds = /* @__PURE__ */ new Set();
    const onDidCreateNode = (node) => {
      var _a2;
      if (node.element === null) {
        return;
      }
      const tnode = node;
      insertedElements.add(tnode.element);
      this.nodes.set(tnode.element, tnode);
      if (this.identityProvider) {
        const id = this.identityProvider.getId(tnode.element).toString();
        insertedElementIds.add(id);
        this.nodesByIdentity.set(id, tnode);
      }
      (_a2 = options2.onDidCreateNode) === null || _a2 === void 0 ? void 0 : _a2.call(options2, tnode);
    };
    const onDidDeleteNode = (node) => {
      var _a2;
      if (node.element === null) {
        return;
      }
      const tnode = node;
      if (!insertedElements.has(tnode.element)) {
        this.nodes.delete(tnode.element);
      }
      if (this.identityProvider) {
        const id = this.identityProvider.getId(tnode.element).toString();
        if (!insertedElementIds.has(id)) {
          this.nodesByIdentity.delete(id);
        }
      }
      (_a2 = options2.onDidDeleteNode) === null || _a2 === void 0 ? void 0 : _a2.call(options2, tnode);
    };
    this.model.splice([...location, 0], Number.MAX_VALUE, children, { ...options2, onDidCreateNode, onDidDeleteNode });
  }
  preserveCollapseState(elements = Iterable.empty()) {
    if (this.sorter) {
      elements = [...elements].sort(this.sorter.compare.bind(this.sorter));
    }
    return Iterable.map(elements, (treeElement) => {
      let node = this.nodes.get(treeElement.element);
      if (!node && this.identityProvider) {
        const id = this.identityProvider.getId(treeElement.element).toString();
        node = this.nodesByIdentity.get(id);
      }
      if (!node) {
        let collapsed2;
        if (typeof treeElement.collapsed === "undefined") {
          collapsed2 = void 0;
        } else if (treeElement.collapsed === ObjectTreeElementCollapseState.Collapsed || treeElement.collapsed === ObjectTreeElementCollapseState.PreserveOrCollapsed) {
          collapsed2 = true;
        } else if (treeElement.collapsed === ObjectTreeElementCollapseState.Expanded || treeElement.collapsed === ObjectTreeElementCollapseState.PreserveOrExpanded) {
          collapsed2 = false;
        } else {
          collapsed2 = Boolean(treeElement.collapsed);
        }
        return {
          ...treeElement,
          children: this.preserveCollapseState(treeElement.children),
          collapsed: collapsed2
        };
      }
      const collapsible = typeof treeElement.collapsible === "boolean" ? treeElement.collapsible : node.collapsible;
      let collapsed;
      if (typeof treeElement.collapsed === "undefined" || treeElement.collapsed === ObjectTreeElementCollapseState.PreserveOrCollapsed || treeElement.collapsed === ObjectTreeElementCollapseState.PreserveOrExpanded) {
        collapsed = node.collapsed;
      } else if (treeElement.collapsed === ObjectTreeElementCollapseState.Collapsed) {
        collapsed = true;
      } else if (treeElement.collapsed === ObjectTreeElementCollapseState.Expanded) {
        collapsed = false;
      } else {
        collapsed = Boolean(treeElement.collapsed);
      }
      return {
        ...treeElement,
        collapsible,
        collapsed,
        children: this.preserveCollapseState(treeElement.children)
      };
    });
  }
  rerender(element) {
    const location = this.getElementLocation(element);
    this.model.rerender(location);
  }
  getFirstElementChild(ref = null) {
    const location = this.getElementLocation(ref);
    return this.model.getFirstElementChild(location);
  }
  has(element) {
    return this.nodes.has(element);
  }
  getListIndex(element) {
    const location = this.getElementLocation(element);
    return this.model.getListIndex(location);
  }
  getListRenderCount(element) {
    const location = this.getElementLocation(element);
    return this.model.getListRenderCount(location);
  }
  isCollapsible(element) {
    const location = this.getElementLocation(element);
    return this.model.isCollapsible(location);
  }
  setCollapsible(element, collapsible) {
    const location = this.getElementLocation(element);
    return this.model.setCollapsible(location, collapsible);
  }
  isCollapsed(element) {
    const location = this.getElementLocation(element);
    return this.model.isCollapsed(location);
  }
  setCollapsed(element, collapsed, recursive) {
    const location = this.getElementLocation(element);
    return this.model.setCollapsed(location, collapsed, recursive);
  }
  expandTo(element) {
    const location = this.getElementLocation(element);
    this.model.expandTo(location);
  }
  refilter() {
    this.model.refilter();
  }
  getNode(element = null) {
    if (element === null) {
      return this.model.getNode(this.model.rootRef);
    }
    const node = this.nodes.get(element);
    if (!node) {
      throw new TreeError(this.user, `Tree element not found: ${element}`);
    }
    return node;
  }
  getNodeLocation(node) {
    return node.element;
  }
  getParentNodeLocation(element) {
    if (element === null) {
      throw new TreeError(this.user, `Invalid getParentNodeLocation call`);
    }
    const node = this.nodes.get(element);
    if (!node) {
      throw new TreeError(this.user, `Tree element not found: ${element}`);
    }
    const location = this.model.getNodeLocation(node);
    const parentLocation = this.model.getParentNodeLocation(location);
    const parent = this.model.getNode(parentLocation);
    return parent.element;
  }
  getElementLocation(element) {
    if (element === null) {
      return [];
    }
    const node = this.nodes.get(element);
    if (!node) {
      throw new TreeError(this.user, `Tree element not found: ${element}`);
    }
    return this.model.getNodeLocation(node);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/compressedObjectTreeModel.js
init_arrays();
init_event();
init_iterator();
function noCompress(element) {
  const elements = [element.element];
  const incompressible = element.incompressible || false;
  return {
    element: { elements, incompressible },
    children: Iterable.map(Iterable.from(element.children), noCompress),
    collapsible: element.collapsible,
    collapsed: element.collapsed
  };
}
function compress(element) {
  const elements = [element.element];
  const incompressible = element.incompressible || false;
  let childrenIterator;
  let children;
  while (true) {
    [children, childrenIterator] = Iterable.consume(Iterable.from(element.children), 2);
    if (children.length !== 1) {
      break;
    }
    if (children[0].incompressible) {
      break;
    }
    element = children[0];
    elements.push(element.element);
  }
  return {
    element: { elements, incompressible },
    children: Iterable.map(Iterable.concat(children, childrenIterator), compress),
    collapsible: element.collapsible,
    collapsed: element.collapsed
  };
}
function _decompress(element, index = 0) {
  let children;
  if (index < element.element.elements.length - 1) {
    children = [_decompress(element, index + 1)];
  } else {
    children = Iterable.map(Iterable.from(element.children), (el) => _decompress(el, 0));
  }
  if (index === 0 && element.element.incompressible) {
    return {
      element: element.element.elements[index],
      children,
      incompressible: true,
      collapsible: element.collapsible,
      collapsed: element.collapsed
    };
  }
  return {
    element: element.element.elements[index],
    children,
    collapsible: element.collapsible,
    collapsed: element.collapsed
  };
}
function decompress(element) {
  return _decompress(element, 0);
}
function splice2(treeElement, element, children) {
  if (treeElement.element === element) {
    return { ...treeElement, children };
  }
  return { ...treeElement, children: Iterable.map(Iterable.from(treeElement.children), (e) => splice2(e, element, children)) };
}
var wrapIdentityProvider = (base) => ({
  getId(node) {
    return node.elements.map((e) => base.getId(e).toString()).join("\0");
  }
});
var CompressedObjectTreeModel = class {
  get onDidSplice() {
    return this.model.onDidSplice;
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get onDidChangeRenderNodeCount() {
    return this.model.onDidChangeRenderNodeCount;
  }
  constructor(user, list, options2 = {}) {
    this.user = user;
    this.rootRef = null;
    this.nodes = /* @__PURE__ */ new Map();
    this.model = new ObjectTreeModel(user, list, options2);
    this.enabled = typeof options2.compressionEnabled === "undefined" ? true : options2.compressionEnabled;
    this.identityProvider = options2.identityProvider;
  }
  setChildren(element, children = Iterable.empty(), options2) {
    const diffIdentityProvider = options2.diffIdentityProvider && wrapIdentityProvider(options2.diffIdentityProvider);
    if (element === null) {
      const compressedChildren = Iterable.map(children, this.enabled ? compress : noCompress);
      this._setChildren(null, compressedChildren, { diffIdentityProvider, diffDepth: Infinity });
      return;
    }
    const compressedNode = this.nodes.get(element);
    if (!compressedNode) {
      throw new TreeError(this.user, "Unknown compressed tree node");
    }
    const node = this.model.getNode(compressedNode);
    const compressedParentNode = this.model.getParentNodeLocation(compressedNode);
    const parent = this.model.getNode(compressedParentNode);
    const decompressedElement = decompress(node);
    const splicedElement = splice2(decompressedElement, element, children);
    const recompressedElement = (this.enabled ? compress : noCompress)(splicedElement);
    const elementComparator = options2.diffIdentityProvider ? (a, b) => options2.diffIdentityProvider.getId(a) === options2.diffIdentityProvider.getId(b) : void 0;
    if (equals(recompressedElement.element.elements, node.element.elements, elementComparator)) {
      this._setChildren(compressedNode, recompressedElement.children || Iterable.empty(), { diffIdentityProvider, diffDepth: 1 });
      return;
    }
    const parentChildren = parent.children.map((child) => child === node ? recompressedElement : child);
    this._setChildren(parent.element, parentChildren, {
      diffIdentityProvider,
      diffDepth: node.depth - parent.depth
    });
  }
  isCompressionEnabled() {
    return this.enabled;
  }
  setCompressionEnabled(enabled) {
    if (enabled === this.enabled) {
      return;
    }
    this.enabled = enabled;
    const root = this.model.getNode();
    const rootChildren = root.children;
    const decompressedRootChildren = Iterable.map(rootChildren, decompress);
    const recompressedRootChildren = Iterable.map(decompressedRootChildren, enabled ? compress : noCompress);
    this._setChildren(null, recompressedRootChildren, {
      diffIdentityProvider: this.identityProvider,
      diffDepth: Infinity
    });
  }
  _setChildren(node, children, options2) {
    const insertedElements = /* @__PURE__ */ new Set();
    const onDidCreateNode = (node2) => {
      for (const element of node2.element.elements) {
        insertedElements.add(element);
        this.nodes.set(element, node2.element);
      }
    };
    const onDidDeleteNode = (node2) => {
      for (const element of node2.element.elements) {
        if (!insertedElements.has(element)) {
          this.nodes.delete(element);
        }
      }
    };
    this.model.setChildren(node, children, { ...options2, onDidCreateNode, onDidDeleteNode });
  }
  has(element) {
    return this.nodes.has(element);
  }
  getListIndex(location) {
    const node = this.getCompressedNode(location);
    return this.model.getListIndex(node);
  }
  getListRenderCount(location) {
    const node = this.getCompressedNode(location);
    return this.model.getListRenderCount(node);
  }
  getNode(location) {
    if (typeof location === "undefined") {
      return this.model.getNode();
    }
    const node = this.getCompressedNode(location);
    return this.model.getNode(node);
  }
  // TODO: review this
  getNodeLocation(node) {
    const compressedNode = this.model.getNodeLocation(node);
    if (compressedNode === null) {
      return null;
    }
    return compressedNode.elements[compressedNode.elements.length - 1];
  }
  // TODO: review this
  getParentNodeLocation(location) {
    const compressedNode = this.getCompressedNode(location);
    const parentNode = this.model.getParentNodeLocation(compressedNode);
    if (parentNode === null) {
      return null;
    }
    return parentNode.elements[parentNode.elements.length - 1];
  }
  getFirstElementChild(location) {
    const compressedNode = this.getCompressedNode(location);
    return this.model.getFirstElementChild(compressedNode);
  }
  isCollapsible(location) {
    const compressedNode = this.getCompressedNode(location);
    return this.model.isCollapsible(compressedNode);
  }
  setCollapsible(location, collapsible) {
    const compressedNode = this.getCompressedNode(location);
    return this.model.setCollapsible(compressedNode, collapsible);
  }
  isCollapsed(location) {
    const compressedNode = this.getCompressedNode(location);
    return this.model.isCollapsed(compressedNode);
  }
  setCollapsed(location, collapsed, recursive) {
    const compressedNode = this.getCompressedNode(location);
    return this.model.setCollapsed(compressedNode, collapsed, recursive);
  }
  expandTo(location) {
    const compressedNode = this.getCompressedNode(location);
    this.model.expandTo(compressedNode);
  }
  rerender(location) {
    const compressedNode = this.getCompressedNode(location);
    this.model.rerender(compressedNode);
  }
  refilter() {
    this.model.refilter();
  }
  getCompressedNode(element) {
    if (element === null) {
      return null;
    }
    const node = this.nodes.get(element);
    if (!node) {
      throw new TreeError(this.user, `Tree element not found: ${element}`);
    }
    return node;
  }
};
var DefaultElementMapper = (elements) => elements[elements.length - 1];
var CompressedTreeNodeWrapper = class _CompressedTreeNodeWrapper {
  get element() {
    return this.node.element === null ? null : this.unwrapper(this.node.element);
  }
  get children() {
    return this.node.children.map((node) => new _CompressedTreeNodeWrapper(this.unwrapper, node));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
  constructor(unwrapper, node) {
    this.unwrapper = unwrapper;
    this.node = node;
  }
};
function mapList(nodeMapper, list) {
  return {
    splice(start, deleteCount, toInsert) {
      list.splice(start, deleteCount, toInsert.map((node) => nodeMapper.map(node)));
    },
    updateElementHeight(index, height) {
      list.updateElementHeight(index, height);
    }
  };
}
function mapOptions(compressedNodeUnwrapper, options2) {
  return {
    ...options2,
    identityProvider: options2.identityProvider && {
      getId(node) {
        return options2.identityProvider.getId(compressedNodeUnwrapper(node));
      }
    },
    sorter: options2.sorter && {
      compare(node, otherNode) {
        return options2.sorter.compare(node.elements[0], otherNode.elements[0]);
      }
    },
    filter: options2.filter && {
      filter(node, parentVisibility) {
        return options2.filter.filter(compressedNodeUnwrapper(node), parentVisibility);
      }
    }
  };
}
var CompressibleObjectTreeModel = class {
  get onDidSplice() {
    return Event.map(this.model.onDidSplice, ({ insertedNodes, deletedNodes }) => ({
      insertedNodes: insertedNodes.map((node) => this.nodeMapper.map(node)),
      deletedNodes: deletedNodes.map((node) => this.nodeMapper.map(node))
    }));
  }
  get onDidChangeCollapseState() {
    return Event.map(this.model.onDidChangeCollapseState, ({ node, deep }) => ({
      node: this.nodeMapper.map(node),
      deep
    }));
  }
  get onDidChangeRenderNodeCount() {
    return Event.map(this.model.onDidChangeRenderNodeCount, (node) => this.nodeMapper.map(node));
  }
  constructor(user, list, options2 = {}) {
    this.rootRef = null;
    this.elementMapper = options2.elementMapper || DefaultElementMapper;
    const compressedNodeUnwrapper = (node) => this.elementMapper(node.elements);
    this.nodeMapper = new WeakMapper((node) => new CompressedTreeNodeWrapper(compressedNodeUnwrapper, node));
    this.model = new CompressedObjectTreeModel(user, mapList(this.nodeMapper, list), mapOptions(compressedNodeUnwrapper, options2));
  }
  setChildren(element, children = Iterable.empty(), options2 = {}) {
    this.model.setChildren(element, children, options2);
  }
  isCompressionEnabled() {
    return this.model.isCompressionEnabled();
  }
  setCompressionEnabled(enabled) {
    this.model.setCompressionEnabled(enabled);
  }
  has(location) {
    return this.model.has(location);
  }
  getListIndex(location) {
    return this.model.getListIndex(location);
  }
  getListRenderCount(location) {
    return this.model.getListRenderCount(location);
  }
  getNode(location) {
    return this.nodeMapper.map(this.model.getNode(location));
  }
  getNodeLocation(node) {
    return node.element;
  }
  getParentNodeLocation(location) {
    return this.model.getParentNodeLocation(location);
  }
  getFirstElementChild(location) {
    const result = this.model.getFirstElementChild(location);
    if (result === null || typeof result === "undefined") {
      return result;
    }
    return this.elementMapper(result.elements);
  }
  isCollapsible(location) {
    return this.model.isCollapsible(location);
  }
  setCollapsible(location, collapsed) {
    return this.model.setCollapsible(location, collapsed);
  }
  isCollapsed(location) {
    return this.model.isCollapsed(location);
  }
  setCollapsed(location, collapsed, recursive) {
    return this.model.setCollapsed(location, collapsed, recursive);
  }
  expandTo(location) {
    return this.model.expandTo(location);
  }
  rerender(location) {
    return this.model.rerender(location);
  }
  refilter() {
    return this.model.refilter();
  }
  getCompressedTreeNode(location = null) {
    return this.model.getNode(location);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/objectTree.js
init_iterator();
var __decorate25 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ObjectTree = class extends AbstractTree {
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  constructor(user, container, delegate, renderers, options2 = {}) {
    super(user, container, delegate, renderers, options2);
    this.user = user;
  }
  setChildren(element, children = Iterable.empty(), options2) {
    this.model.setChildren(element, children, options2);
  }
  rerender(element) {
    if (element === void 0) {
      this.view.rerender();
      return;
    }
    this.model.rerender(element);
  }
  hasElement(element) {
    return this.model.has(element);
  }
  createModel(user, view, options2) {
    return new ObjectTreeModel(user, view, options2);
  }
};
var CompressibleRenderer = class {
  get compressedTreeNodeProvider() {
    return this._compressedTreeNodeProvider();
  }
  constructor(_compressedTreeNodeProvider, stickyScrollDelegate, renderer) {
    this._compressedTreeNodeProvider = _compressedTreeNodeProvider;
    this.stickyScrollDelegate = stickyScrollDelegate;
    this.renderer = renderer;
    this.templateId = renderer.templateId;
    if (renderer.onDidChangeTwistieState) {
      this.onDidChangeTwistieState = renderer.onDidChangeTwistieState;
    }
  }
  renderTemplate(container) {
    const data = this.renderer.renderTemplate(container);
    return { compressedTreeNode: void 0, data };
  }
  renderElement(node, index, templateData, height) {
    let compressedTreeNode = this.stickyScrollDelegate.getCompressedNode(node);
    if (!compressedTreeNode) {
      compressedTreeNode = this.compressedTreeNodeProvider.getCompressedTreeNode(node.element);
    }
    if (compressedTreeNode.element.elements.length === 1) {
      templateData.compressedTreeNode = void 0;
      this.renderer.renderElement(node, index, templateData.data, height);
    } else {
      templateData.compressedTreeNode = compressedTreeNode;
      this.renderer.renderCompressedElements(compressedTreeNode, index, templateData.data, height);
    }
  }
  disposeElement(node, index, templateData, height) {
    var _a2, _b2, _c, _d;
    if (templateData.compressedTreeNode) {
      (_b2 = (_a2 = this.renderer).disposeCompressedElements) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, templateData.compressedTreeNode, index, templateData.data, height);
    } else {
      (_d = (_c = this.renderer).disposeElement) === null || _d === void 0 ? void 0 : _d.call(_c, node, index, templateData.data, height);
    }
  }
  disposeTemplate(templateData) {
    this.renderer.disposeTemplate(templateData.data);
  }
  renderTwistie(element, twistieElement) {
    if (this.renderer.renderTwistie) {
      return this.renderer.renderTwistie(element, twistieElement);
    }
    return false;
  }
};
__decorate25([
  memoize
], CompressibleRenderer.prototype, "compressedTreeNodeProvider", null);
var CompressibleStickyScrollDelegate = class {
  constructor(modelProvider) {
    this.modelProvider = modelProvider;
    this.compressedStickyNodes = /* @__PURE__ */ new Map();
  }
  getCompressedNode(node) {
    return this.compressedStickyNodes.get(node);
  }
  constrainStickyScrollNodes(stickyNodes, stickyScrollMaxItemCount, maxWidgetHeight) {
    this.compressedStickyNodes.clear();
    if (stickyNodes.length === 0) {
      return [];
    }
    for (let i = 0; i < stickyNodes.length; i++) {
      const stickyNode = stickyNodes[i];
      const stickyNodeBottom = stickyNode.position + stickyNode.height;
      const followingReachesMaxHeight = i + 1 < stickyNodes.length && stickyNodeBottom + stickyNodes[i + 1].height > maxWidgetHeight;
      if (followingReachesMaxHeight || i >= stickyScrollMaxItemCount - 1 && stickyScrollMaxItemCount < stickyNodes.length) {
        const uncompressedStickyNodes = stickyNodes.slice(0, i);
        const overflowingStickyNodes = stickyNodes.slice(i);
        const compressedStickyNode = this.compressStickyNodes(overflowingStickyNodes);
        return [...uncompressedStickyNodes, compressedStickyNode];
      }
    }
    return stickyNodes;
  }
  compressStickyNodes(stickyNodes) {
    if (stickyNodes.length === 0) {
      throw new Error("Can't compress empty sticky nodes");
    }
    if (!this.modelProvider().isCompressionEnabled()) {
      return stickyNodes[0];
    }
    const elements = [];
    for (const stickyNode of stickyNodes) {
      const compressedNode2 = this.modelProvider().getCompressedTreeNode(stickyNode.node.element);
      if (compressedNode2.element) {
        if (compressedNode2.element.incompressible) {
          break;
        }
        elements.push(...compressedNode2.element.elements);
      }
    }
    if (elements.length < 2) {
      return stickyNodes[0];
    }
    const lastStickyNode = stickyNodes[stickyNodes.length - 1];
    const compressedElement = { elements, incompressible: false };
    const compressedNode = { ...lastStickyNode.node, children: [], element: compressedElement };
    const stickyTreeNode = new Proxy(stickyNodes[0].node, {});
    const compressedStickyNode = {
      node: stickyTreeNode,
      startIndex: stickyNodes[0].startIndex,
      endIndex: lastStickyNode.endIndex,
      position: stickyNodes[0].position,
      height: stickyNodes[0].height
    };
    this.compressedStickyNodes.set(stickyTreeNode, compressedNode);
    return compressedStickyNode;
  }
};
function asObjectTreeOptions(compressedTreeNodeProvider, options2) {
  return options2 && {
    ...options2,
    keyboardNavigationLabelProvider: options2.keyboardNavigationLabelProvider && {
      getKeyboardNavigationLabel(e) {
        let compressedTreeNode;
        try {
          compressedTreeNode = compressedTreeNodeProvider().getCompressedTreeNode(e);
        } catch (_a2) {
          return options2.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e);
        }
        if (compressedTreeNode.element.elements.length === 1) {
          return options2.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e);
        } else {
          return options2.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(compressedTreeNode.element.elements);
        }
      }
    }
  };
}
var CompressibleObjectTree = class extends ObjectTree {
  constructor(user, container, delegate, renderers, options2 = {}) {
    const compressedTreeNodeProvider = () => this;
    const stickyScrollDelegate = new CompressibleStickyScrollDelegate(() => this.model);
    const compressibleRenderers = renderers.map((r) => new CompressibleRenderer(compressedTreeNodeProvider, stickyScrollDelegate, r));
    super(user, container, delegate, compressibleRenderers, { ...asObjectTreeOptions(compressedTreeNodeProvider, options2), stickyScrollDelegate });
  }
  setChildren(element, children = Iterable.empty(), options2) {
    this.model.setChildren(element, children, options2);
  }
  createModel(user, view, options2) {
    return new CompressibleObjectTreeModel(user, view, options2);
  }
  updateOptions(optionsUpdate = {}) {
    super.updateOptions(optionsUpdate);
    if (typeof optionsUpdate.compressionEnabled !== "undefined") {
      this.model.setCompressionEnabled(optionsUpdate.compressionEnabled);
    }
  }
  getCompressedTreeNode(element = null) {
    return this.model.getCompressedTreeNode(element);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/asyncDataTree.js
init_async();
init_codicons();
init_themables();
init_errors();
init_event();
init_iterator();
init_lifecycle();
init_types();
function createAsyncDataTreeNode(props) {
  return {
    ...props,
    children: [],
    refreshPromise: void 0,
    stale: true,
    slow: false,
    forceExpanded: false
  };
}
function isAncestor2(ancestor, descendant) {
  if (!descendant.parent) {
    return false;
  } else if (descendant.parent === ancestor) {
    return true;
  } else {
    return isAncestor2(ancestor, descendant.parent);
  }
}
function intersects(node, other) {
  return node === other || isAncestor2(node, other) || isAncestor2(other, node);
}
var AsyncDataTreeNodeWrapper = class _AsyncDataTreeNodeWrapper {
  get element() {
    return this.node.element.element;
  }
  get children() {
    return this.node.children.map((node) => new _AsyncDataTreeNodeWrapper(node));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
  constructor(node) {
    this.node = node;
  }
};
var AsyncDataTreeRenderer = class {
  constructor(renderer, nodeMapper, onDidChangeTwistieState) {
    this.renderer = renderer;
    this.nodeMapper = nodeMapper;
    this.onDidChangeTwistieState = onDidChangeTwistieState;
    this.renderedNodes = /* @__PURE__ */ new Map();
    this.templateId = renderer.templateId;
  }
  renderTemplate(container) {
    const templateData = this.renderer.renderTemplate(container);
    return { templateData };
  }
  renderElement(node, index, templateData, height) {
    this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);
  }
  renderTwistie(element, twistieElement) {
    if (element.slow) {
      twistieElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));
      return true;
    } else {
      twistieElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));
      return false;
    }
  }
  disposeElement(node, index, templateData, height) {
    var _a2, _b2;
    (_b2 = (_a2 = this.renderer).disposeElement) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, this.nodeMapper.map(node), index, templateData.templateData, height);
  }
  disposeTemplate(templateData) {
    this.renderer.disposeTemplate(templateData.templateData);
  }
  dispose() {
    this.renderedNodes.clear();
  }
};
function asTreeEvent(e) {
  return {
    browserEvent: e.browserEvent,
    elements: e.elements.map((e2) => e2.element)
  };
}
function asTreeMouseEvent2(e) {
  return {
    browserEvent: e.browserEvent,
    element: e.element && e.element.element,
    target: e.target
  };
}
var AsyncDataTreeElementsDragAndDropData = class extends ElementsDragAndDropData {
  constructor(data) {
    super(data.elements.map((node) => node.element));
    this.data = data;
  }
};
function asAsyncDataTreeDragAndDropData(data) {
  if (data instanceof ElementsDragAndDropData) {
    return new AsyncDataTreeElementsDragAndDropData(data);
  }
  return data;
}
var AsyncDataTreeNodeListDragAndDrop = class {
  constructor(dnd) {
    this.dnd = dnd;
  }
  getDragURI(node) {
    return this.dnd.getDragURI(node.element);
  }
  getDragLabel(nodes, originalEvent) {
    if (this.dnd.getDragLabel) {
      return this.dnd.getDragLabel(nodes.map((node) => node.element), originalEvent);
    }
    return void 0;
  }
  onDragStart(data, originalEvent) {
    var _a2, _b2;
    (_b2 = (_a2 = this.dnd).onDragStart) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, asAsyncDataTreeDragAndDropData(data), originalEvent);
  }
  onDragOver(data, targetNode, targetIndex, targetSector, originalEvent, raw = true) {
    return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, targetSector, originalEvent);
  }
  drop(data, targetNode, targetIndex, targetSector, originalEvent) {
    this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, targetSector, originalEvent);
  }
  onDragEnd(originalEvent) {
    var _a2, _b2;
    (_b2 = (_a2 = this.dnd).onDragEnd) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, originalEvent);
  }
  dispose() {
    this.dnd.dispose();
  }
};
function asObjectTreeOptions2(options2) {
  return options2 && {
    ...options2,
    collapseByDefault: true,
    identityProvider: options2.identityProvider && {
      getId(el) {
        return options2.identityProvider.getId(el.element);
      }
    },
    dnd: options2.dnd && new AsyncDataTreeNodeListDragAndDrop(options2.dnd),
    multipleSelectionController: options2.multipleSelectionController && {
      isSelectionSingleChangeEvent(e) {
        return options2.multipleSelectionController.isSelectionSingleChangeEvent({ ...e, element: e.element });
      },
      isSelectionRangeChangeEvent(e) {
        return options2.multipleSelectionController.isSelectionRangeChangeEvent({ ...e, element: e.element });
      }
    },
    accessibilityProvider: options2.accessibilityProvider && {
      ...options2.accessibilityProvider,
      getPosInSet: void 0,
      getSetSize: void 0,
      getRole: options2.accessibilityProvider.getRole ? (el) => {
        return options2.accessibilityProvider.getRole(el.element);
      } : () => "treeitem",
      isChecked: options2.accessibilityProvider.isChecked ? (e) => {
        var _a2;
        return !!((_a2 = options2.accessibilityProvider) === null || _a2 === void 0 ? void 0 : _a2.isChecked(e.element));
      } : void 0,
      getAriaLabel(e) {
        return options2.accessibilityProvider.getAriaLabel(e.element);
      },
      getWidgetAriaLabel() {
        return options2.accessibilityProvider.getWidgetAriaLabel();
      },
      getWidgetRole: options2.accessibilityProvider.getWidgetRole ? () => options2.accessibilityProvider.getWidgetRole() : () => "tree",
      getAriaLevel: options2.accessibilityProvider.getAriaLevel && ((node) => {
        return options2.accessibilityProvider.getAriaLevel(node.element);
      }),
      getActiveDescendantId: options2.accessibilityProvider.getActiveDescendantId && ((node) => {
        return options2.accessibilityProvider.getActiveDescendantId(node.element);
      })
    },
    filter: options2.filter && {
      filter(e, parentVisibility) {
        return options2.filter.filter(e.element, parentVisibility);
      }
    },
    keyboardNavigationLabelProvider: options2.keyboardNavigationLabelProvider && {
      ...options2.keyboardNavigationLabelProvider,
      getKeyboardNavigationLabel(e) {
        return options2.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);
      }
    },
    sorter: void 0,
    expandOnlyOnTwistieClick: typeof options2.expandOnlyOnTwistieClick === "undefined" ? void 0 : typeof options2.expandOnlyOnTwistieClick !== "function" ? options2.expandOnlyOnTwistieClick : (e) => options2.expandOnlyOnTwistieClick(e.element),
    defaultFindVisibility: (e) => {
      if (e.hasChildren && e.stale) {
        return 1;
      } else if (typeof options2.defaultFindVisibility === "number") {
        return options2.defaultFindVisibility;
      } else if (typeof options2.defaultFindVisibility === "undefined") {
        return 2;
      } else {
        return options2.defaultFindVisibility(e.element);
      }
    }
  };
}
function dfs2(node, fn) {
  fn(node);
  node.children.forEach((child) => dfs2(child, fn));
}
var AsyncDataTree = class {
  get onDidScroll() {
    return this.tree.onDidScroll;
  }
  get onDidChangeFocus() {
    return Event.map(this.tree.onDidChangeFocus, asTreeEvent);
  }
  get onDidChangeSelection() {
    return Event.map(this.tree.onDidChangeSelection, asTreeEvent);
  }
  get onMouseDblClick() {
    return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent2);
  }
  get onPointer() {
    return Event.map(this.tree.onPointer, asTreeMouseEvent2);
  }
  get onDidFocus() {
    return this.tree.onDidFocus;
  }
  /**
   * To be used internally only!
   * @deprecated
   */
  get onDidChangeModel() {
    return this.tree.onDidChangeModel;
  }
  get onDidChangeCollapseState() {
    return this.tree.onDidChangeCollapseState;
  }
  get onDidChangeFindOpenState() {
    return this.tree.onDidChangeFindOpenState;
  }
  get onDidChangeStickyScrollFocused() {
    return this.tree.onDidChangeStickyScrollFocused;
  }
  get onDidDispose() {
    return this.tree.onDidDispose;
  }
  constructor(user, container, delegate, renderers, dataSource, options2 = {}) {
    this.user = user;
    this.dataSource = dataSource;
    this.nodes = /* @__PURE__ */ new Map();
    this.subTreeRefreshPromises = /* @__PURE__ */ new Map();
    this.refreshPromises = /* @__PURE__ */ new Map();
    this._onDidRender = new Emitter();
    this._onDidChangeNodeSlowState = new Emitter();
    this.nodeMapper = new WeakMapper((node) => new AsyncDataTreeNodeWrapper(node));
    this.disposables = new DisposableStore();
    this.identityProvider = options2.identityProvider;
    this.autoExpandSingleChildren = typeof options2.autoExpandSingleChildren === "undefined" ? false : options2.autoExpandSingleChildren;
    this.sorter = options2.sorter;
    this.getDefaultCollapseState = (e) => options2.collapseByDefault ? options2.collapseByDefault(e) ? ObjectTreeElementCollapseState.PreserveOrCollapsed : ObjectTreeElementCollapseState.PreserveOrExpanded : void 0;
    this.tree = this.createTree(user, container, delegate, renderers, options2);
    this.onDidChangeFindMode = this.tree.onDidChangeFindMode;
    this.onDidChangeFindMatchType = this.tree.onDidChangeFindMatchType;
    this.root = createAsyncDataTreeNode({
      element: void 0,
      parent: null,
      hasChildren: true,
      defaultCollapseState: void 0
    });
    if (this.identityProvider) {
      this.root = {
        ...this.root,
        id: null
      };
    }
    this.nodes.set(null, this.root);
    this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);
  }
  createTree(user, container, delegate, renderers, options2) {
    const objectTreeDelegate = new ComposedTreeDelegate(delegate);
    const objectTreeRenderers = renderers.map((r) => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));
    const objectTreeOptions = asObjectTreeOptions2(options2) || {};
    return new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);
  }
  updateOptions(options2 = {}) {
    this.tree.updateOptions(options2);
  }
  // Widget
  getHTMLElement() {
    return this.tree.getHTMLElement();
  }
  get scrollTop() {
    return this.tree.scrollTop;
  }
  set scrollTop(scrollTop) {
    this.tree.scrollTop = scrollTop;
  }
  get scrollHeight() {
    return this.tree.scrollHeight;
  }
  get renderHeight() {
    return this.tree.renderHeight;
  }
  domFocus() {
    this.tree.domFocus();
  }
  layout(height, width) {
    this.tree.layout(height, width);
  }
  style(styles) {
    this.tree.style(styles);
  }
  // Model
  getInput() {
    return this.root.element;
  }
  async setInput(input, viewState) {
    this.refreshPromises.forEach((promise) => promise.cancel());
    this.refreshPromises.clear();
    this.root.element = input;
    const viewStateContext = viewState && { viewState, focus: [], selection: [] };
    await this._updateChildren(input, true, false, viewStateContext);
    if (viewStateContext) {
      this.tree.setFocus(viewStateContext.focus);
      this.tree.setSelection(viewStateContext.selection);
    }
    if (viewState && typeof viewState.scrollTop === "number") {
      this.scrollTop = viewState.scrollTop;
    }
  }
  async _updateChildren(element = this.root.element, recursive = true, rerender = false, viewStateContext, options2) {
    if (typeof this.root.element === "undefined") {
      throw new TreeError(this.user, "Tree input not set");
    }
    if (this.root.refreshPromise) {
      await this.root.refreshPromise;
      await Event.toPromise(this._onDidRender.event);
    }
    const node = this.getDataNode(element);
    await this.refreshAndRenderNode(node, recursive, viewStateContext, options2);
    if (rerender) {
      try {
        this.tree.rerender(node);
      } catch (_a2) {
      }
    }
  }
  // View
  rerender(element) {
    if (element === void 0 || element === this.root.element) {
      this.tree.rerender();
      return;
    }
    const node = this.getDataNode(element);
    this.tree.rerender(node);
  }
  // Tree
  getNode(element = this.root.element) {
    const dataNode = this.getDataNode(element);
    const node = this.tree.getNode(dataNode === this.root ? null : dataNode);
    return this.nodeMapper.map(node);
  }
  collapse(element, recursive = false) {
    const node = this.getDataNode(element);
    return this.tree.collapse(node === this.root ? null : node, recursive);
  }
  async expand(element, recursive = false) {
    if (typeof this.root.element === "undefined") {
      throw new TreeError(this.user, "Tree input not set");
    }
    if (this.root.refreshPromise) {
      await this.root.refreshPromise;
      await Event.toPromise(this._onDidRender.event);
    }
    const node = this.getDataNode(element);
    if (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {
      return false;
    }
    if (node.refreshPromise) {
      await this.root.refreshPromise;
      await Event.toPromise(this._onDidRender.event);
    }
    if (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {
      return false;
    }
    const result = this.tree.expand(node === this.root ? null : node, recursive);
    if (node.refreshPromise) {
      await this.root.refreshPromise;
      await Event.toPromise(this._onDidRender.event);
    }
    return result;
  }
  setSelection(elements, browserEvent) {
    const nodes = elements.map((e) => this.getDataNode(e));
    this.tree.setSelection(nodes, browserEvent);
  }
  getSelection() {
    const nodes = this.tree.getSelection();
    return nodes.map((n) => n.element);
  }
  setFocus(elements, browserEvent) {
    const nodes = elements.map((e) => this.getDataNode(e));
    this.tree.setFocus(nodes, browserEvent);
  }
  getFocus() {
    const nodes = this.tree.getFocus();
    return nodes.map((n) => n.element);
  }
  reveal(element, relativeTop) {
    this.tree.reveal(this.getDataNode(element), relativeTop);
  }
  // Tree navigation
  getParentElement(element) {
    const node = this.tree.getParentElement(this.getDataNode(element));
    return node && node.element;
  }
  getFirstElementChild(element = this.root.element) {
    const dataNode = this.getDataNode(element);
    const node = this.tree.getFirstElementChild(dataNode === this.root ? null : dataNode);
    return node && node.element;
  }
  // Implementation
  getDataNode(element) {
    const node = this.nodes.get(element === this.root.element ? null : element);
    if (!node) {
      throw new TreeError(this.user, `Data tree node not found: ${element}`);
    }
    return node;
  }
  async refreshAndRenderNode(node, recursive, viewStateContext, options2) {
    await this.refreshNode(node, recursive, viewStateContext);
    if (this.disposables.isDisposed) {
      return;
    }
    this.render(node, viewStateContext, options2);
  }
  async refreshNode(node, recursive, viewStateContext) {
    let result;
    this.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {
      if (!result && intersects(refreshNode, node)) {
        result = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));
      }
    });
    if (result) {
      return result;
    }
    if (node !== this.root) {
      const treeNode = this.tree.getNode(node);
      if (treeNode.collapsed) {
        node.hasChildren = !!this.dataSource.hasChildren(node.element);
        node.stale = true;
        this.setChildren(node, [], recursive, viewStateContext);
        return;
      }
    }
    return this.doRefreshSubTree(node, recursive, viewStateContext);
  }
  async doRefreshSubTree(node, recursive, viewStateContext) {
    let done;
    node.refreshPromise = new Promise((c) => done = c);
    this.subTreeRefreshPromises.set(node, node.refreshPromise);
    node.refreshPromise.finally(() => {
      node.refreshPromise = void 0;
      this.subTreeRefreshPromises.delete(node);
    });
    try {
      const childrenToRefresh = await this.doRefreshNode(node, recursive, viewStateContext);
      node.stale = false;
      await Promises.settled(childrenToRefresh.map((child) => this.doRefreshSubTree(child, recursive, viewStateContext)));
    } finally {
      done();
    }
  }
  async doRefreshNode(node, recursive, viewStateContext) {
    node.hasChildren = !!this.dataSource.hasChildren(node.element);
    let childrenPromise;
    if (!node.hasChildren) {
      childrenPromise = Promise.resolve(Iterable.empty());
    } else {
      const children = this.doGetChildren(node);
      if (isIterable(children)) {
        childrenPromise = Promise.resolve(children);
      } else {
        const slowTimeout = timeout(800);
        slowTimeout.then(() => {
          node.slow = true;
          this._onDidChangeNodeSlowState.fire(node);
        }, (_) => null);
        childrenPromise = children.finally(() => slowTimeout.cancel());
      }
    }
    try {
      const children = await childrenPromise;
      return this.setChildren(node, children, recursive, viewStateContext);
    } catch (err) {
      if (node !== this.root && this.tree.hasElement(node)) {
        this.tree.collapse(node);
      }
      if (isCancellationError(err)) {
        return [];
      }
      throw err;
    } finally {
      if (node.slow) {
        node.slow = false;
        this._onDidChangeNodeSlowState.fire(node);
      }
    }
  }
  doGetChildren(node) {
    let result = this.refreshPromises.get(node);
    if (result) {
      return result;
    }
    const children = this.dataSource.getChildren(node.element);
    if (isIterable(children)) {
      return this.processChildren(children);
    } else {
      result = createCancelablePromise(async () => this.processChildren(await children));
      this.refreshPromises.set(node, result);
      return result.finally(() => {
        this.refreshPromises.delete(node);
      });
    }
  }
  _onDidChangeCollapseState({ node, deep }) {
    if (node.element === null) {
      return;
    }
    if (!node.collapsed && node.element.stale) {
      if (deep) {
        this.collapse(node.element.element);
      } else {
        this.refreshAndRenderNode(node.element, false).catch(onUnexpectedError);
      }
    }
  }
  setChildren(node, childrenElementsIterable, recursive, viewStateContext) {
    const childrenElements = [...childrenElementsIterable];
    if (node.children.length === 0 && childrenElements.length === 0) {
      return [];
    }
    const nodesToForget = /* @__PURE__ */ new Map();
    const childrenTreeNodesById = /* @__PURE__ */ new Map();
    for (const child of node.children) {
      nodesToForget.set(child.element, child);
      if (this.identityProvider) {
        childrenTreeNodesById.set(child.id, { node: child, collapsed: this.tree.hasElement(child) && this.tree.isCollapsed(child) });
      }
    }
    const childrenToRefresh = [];
    const children = childrenElements.map((element) => {
      const hasChildren = !!this.dataSource.hasChildren(element);
      if (!this.identityProvider) {
        const asyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, hasChildren, defaultCollapseState: this.getDefaultCollapseState(element) });
        if (hasChildren && asyncDataTreeNode.defaultCollapseState === ObjectTreeElementCollapseState.PreserveOrExpanded) {
          childrenToRefresh.push(asyncDataTreeNode);
        }
        return asyncDataTreeNode;
      }
      const id = this.identityProvider.getId(element).toString();
      const result = childrenTreeNodesById.get(id);
      if (result) {
        const asyncDataTreeNode = result.node;
        nodesToForget.delete(asyncDataTreeNode.element);
        this.nodes.delete(asyncDataTreeNode.element);
        this.nodes.set(element, asyncDataTreeNode);
        asyncDataTreeNode.element = element;
        asyncDataTreeNode.hasChildren = hasChildren;
        if (recursive) {
          if (result.collapsed) {
            asyncDataTreeNode.children.forEach((node2) => dfs2(node2, (node3) => this.nodes.delete(node3.element)));
            asyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);
            asyncDataTreeNode.stale = true;
          } else {
            childrenToRefresh.push(asyncDataTreeNode);
          }
        } else if (hasChildren && !result.collapsed) {
          childrenToRefresh.push(asyncDataTreeNode);
        }
        return asyncDataTreeNode;
      }
      const childAsyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, id, hasChildren, defaultCollapseState: this.getDefaultCollapseState(element) });
      if (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {
        viewStateContext.focus.push(childAsyncDataTreeNode);
      }
      if (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {
        viewStateContext.selection.push(childAsyncDataTreeNode);
      }
      if (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {
        childrenToRefresh.push(childAsyncDataTreeNode);
      } else if (hasChildren && childAsyncDataTreeNode.defaultCollapseState === ObjectTreeElementCollapseState.PreserveOrExpanded) {
        childrenToRefresh.push(childAsyncDataTreeNode);
      }
      return childAsyncDataTreeNode;
    });
    for (const node2 of nodesToForget.values()) {
      dfs2(node2, (node3) => this.nodes.delete(node3.element));
    }
    for (const child of children) {
      this.nodes.set(child.element, child);
    }
    node.children.splice(0, node.children.length, ...children);
    if (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {
      children[0].forceExpanded = true;
      childrenToRefresh.push(children[0]);
    }
    return childrenToRefresh;
  }
  render(node, viewStateContext, options2) {
    const children = node.children.map((node2) => this.asTreeElement(node2, viewStateContext));
    const objectTreeOptions = options2 && {
      ...options2,
      diffIdentityProvider: options2.diffIdentityProvider && {
        getId(node2) {
          return options2.diffIdentityProvider.getId(node2.element);
        }
      }
    };
    this.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);
    if (node !== this.root) {
      this.tree.setCollapsible(node, node.hasChildren);
    }
    this._onDidRender.fire();
  }
  asTreeElement(node, viewStateContext) {
    if (node.stale) {
      return {
        element: node,
        collapsible: node.hasChildren,
        collapsed: true
      };
    }
    let collapsed;
    if (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {
      collapsed = false;
    } else if (node.forceExpanded) {
      collapsed = false;
      node.forceExpanded = false;
    } else {
      collapsed = node.defaultCollapseState;
    }
    return {
      element: node,
      children: node.hasChildren ? Iterable.map(node.children, (child) => this.asTreeElement(child, viewStateContext)) : [],
      collapsible: node.hasChildren,
      collapsed
    };
  }
  processChildren(children) {
    if (this.sorter) {
      children = [...children].sort(this.sorter.compare.bind(this.sorter));
    }
    return children;
  }
  dispose() {
    this.disposables.dispose();
    this.tree.dispose();
  }
};
var CompressibleAsyncDataTreeNodeWrapper = class _CompressibleAsyncDataTreeNodeWrapper {
  get element() {
    return {
      elements: this.node.element.elements.map((e) => e.element),
      incompressible: this.node.element.incompressible
    };
  }
  get children() {
    return this.node.children.map((node) => new _CompressibleAsyncDataTreeNodeWrapper(node));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
  constructor(node) {
    this.node = node;
  }
};
var CompressibleAsyncDataTreeRenderer = class {
  constructor(renderer, nodeMapper, compressibleNodeMapperProvider, onDidChangeTwistieState) {
    this.renderer = renderer;
    this.nodeMapper = nodeMapper;
    this.compressibleNodeMapperProvider = compressibleNodeMapperProvider;
    this.onDidChangeTwistieState = onDidChangeTwistieState;
    this.renderedNodes = /* @__PURE__ */ new Map();
    this.disposables = [];
    this.templateId = renderer.templateId;
  }
  renderTemplate(container) {
    const templateData = this.renderer.renderTemplate(container);
    return { templateData };
  }
  renderElement(node, index, templateData, height) {
    this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);
  }
  renderCompressedElements(node, index, templateData, height) {
    this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);
  }
  renderTwistie(element, twistieElement) {
    if (element.slow) {
      twistieElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));
      return true;
    } else {
      twistieElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));
      return false;
    }
  }
  disposeElement(node, index, templateData, height) {
    var _a2, _b2;
    (_b2 = (_a2 = this.renderer).disposeElement) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, this.nodeMapper.map(node), index, templateData.templateData, height);
  }
  disposeCompressedElements(node, index, templateData, height) {
    var _a2, _b2;
    (_b2 = (_a2 = this.renderer).disposeCompressedElements) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);
  }
  disposeTemplate(templateData) {
    this.renderer.disposeTemplate(templateData.templateData);
  }
  dispose() {
    this.renderedNodes.clear();
    this.disposables = dispose(this.disposables);
  }
};
function asCompressibleObjectTreeOptions(options2) {
  const objectTreeOptions = options2 && asObjectTreeOptions2(options2);
  return objectTreeOptions && {
    ...objectTreeOptions,
    keyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && {
      ...objectTreeOptions.keyboardNavigationLabelProvider,
      getCompressedNodeKeyboardNavigationLabel(els) {
        return options2.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(els.map((e) => e.element));
      }
    }
  };
}
var CompressibleAsyncDataTree = class extends AsyncDataTree {
  constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options2 = {}) {
    super(user, container, virtualDelegate, renderers, dataSource, options2);
    this.compressionDelegate = compressionDelegate;
    this.compressibleNodeMapper = new WeakMapper((node) => new CompressibleAsyncDataTreeNodeWrapper(node));
    this.filter = options2.filter;
  }
  createTree(user, container, delegate, renderers, options2) {
    const objectTreeDelegate = new ComposedTreeDelegate(delegate);
    const objectTreeRenderers = renderers.map((r) => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));
    const objectTreeOptions = asCompressibleObjectTreeOptions(options2) || {};
    return new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);
  }
  asTreeElement(node, viewStateContext) {
    return {
      incompressible: this.compressionDelegate.isIncompressible(node.element),
      ...super.asTreeElement(node, viewStateContext)
    };
  }
  updateOptions(options2 = {}) {
    this.tree.updateOptions(options2);
  }
  render(node, viewStateContext, options2) {
    if (!this.identityProvider) {
      return super.render(node, viewStateContext);
    }
    const getId = (element) => this.identityProvider.getId(element).toString();
    const getUncompressedIds = (nodes) => {
      const result = /* @__PURE__ */ new Set();
      for (const node2 of nodes) {
        const compressedNode = this.tree.getCompressedTreeNode(node2 === this.root ? null : node2);
        if (!compressedNode.element) {
          continue;
        }
        for (const node3 of compressedNode.element.elements) {
          result.add(getId(node3.element));
        }
      }
      return result;
    };
    const oldSelection = getUncompressedIds(this.tree.getSelection());
    const oldFocus = getUncompressedIds(this.tree.getFocus());
    super.render(node, viewStateContext, options2);
    const selection = this.getSelection();
    let didChangeSelection = false;
    const focus = this.getFocus();
    let didChangeFocus = false;
    const visit = (node2) => {
      const compressedNode = node2.element;
      if (compressedNode) {
        for (let i = 0; i < compressedNode.elements.length; i++) {
          const id = getId(compressedNode.elements[i].element);
          const element = compressedNode.elements[compressedNode.elements.length - 1].element;
          if (oldSelection.has(id) && selection.indexOf(element) === -1) {
            selection.push(element);
            didChangeSelection = true;
          }
          if (oldFocus.has(id) && focus.indexOf(element) === -1) {
            focus.push(element);
            didChangeFocus = true;
          }
        }
      }
      node2.children.forEach(visit);
    };
    visit(this.tree.getCompressedTreeNode(node === this.root ? null : node));
    if (didChangeSelection) {
      this.setSelection(selection);
    }
    if (didChangeFocus) {
      this.setFocus(focus);
    }
  }
  // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work
  // and we have to filter everything beforehand
  // Related to #85193 and #85835
  processChildren(children) {
    if (this.filter) {
      children = Iterable.filter(children, (e) => {
        const result = this.filter.filter(
          e,
          1
          /* TreeVisibility.Visible */
        );
        const visibility = getVisibility(result);
        if (visibility === 2) {
          throw new Error("Recursive tree visibility not supported in async data compressed trees");
        }
        return visibility === 1;
      });
    }
    return super.processChildren(children);
  }
};
function getVisibility(filterResult) {
  if (typeof filterResult === "boolean") {
    return filterResult ? 1 : 0;
  } else if (isFilterResult(filterResult)) {
    return getVisibleState(filterResult.visibility);
  } else {
    return getVisibleState(filterResult);
  }
}

// node_modules/monaco-editor/esm/vs/base/browser/ui/tree/dataTree.js
var DataTree = class extends AbstractTree {
  constructor(user, container, delegate, renderers, dataSource, options2 = {}) {
    super(user, container, delegate, renderers, options2);
    this.user = user;
    this.dataSource = dataSource;
    this.identityProvider = options2.identityProvider;
  }
  createModel(user, view, options2) {
    return new ObjectTreeModel(user, view, options2);
  }
};

// node_modules/monaco-editor/esm/vs/platform/list/browser/listService.js
init_event();
init_lifecycle();
init_nls();
init_configuration();
init_configurationRegistry();
init_contextkey();

// node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkeys.js
init_platform();
init_nls();
init_contextkey();
var IsMacContext = new RawContextKey("isMac", isMacintosh, localize("isMac", "Whether the operating system is macOS"));
var IsLinuxContext = new RawContextKey("isLinux", isLinux, localize("isLinux", "Whether the operating system is Linux"));
var IsWindowsContext = new RawContextKey("isWindows", isWindows, localize("isWindows", "Whether the operating system is Windows"));
var IsWebContext = new RawContextKey("isWeb", isWeb, localize("isWeb", "Whether the platform is a web browser"));
var IsMacNativeContext = new RawContextKey("isMacNative", isMacintosh && !isWeb, localize("isMacNative", "Whether the operating system is macOS on a non-browser platform"));
var IsIOSContext = new RawContextKey("isIOS", isIOS, localize("isIOS", "Whether the operating system is iOS"));
var IsMobileContext = new RawContextKey("isMobile", isMobile, localize("isMobile", "Whether the platform is a mobile web browser"));
var IsDevelopmentContext = new RawContextKey("isDevelopment", false, true);
var ProductQualityContext = new RawContextKey("productQualityType", "", localize("productQualityType", "Quality type of VS Code"));
var InputFocusedContextKey = "inputFocus";
var InputFocusedContext = new RawContextKey(InputFocusedContextKey, false, localize("inputFocus", "Whether keyboard focus is inside an input box"));

// node_modules/monaco-editor/esm/vs/platform/list/browser/listService.js
init_instantiation();
init_platform2();
var __decorate26 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param21 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var IListService = createDecorator("listService");
var ListService = class {
  get lastFocusedList() {
    return this._lastFocusedWidget;
  }
  constructor() {
    this.disposables = new DisposableStore();
    this.lists = [];
    this._lastFocusedWidget = void 0;
    this._hasCreatedStyleController = false;
  }
  setLastFocusedList(widget) {
    var _a2, _b2;
    if (widget === this._lastFocusedWidget) {
      return;
    }
    (_a2 = this._lastFocusedWidget) === null || _a2 === void 0 ? void 0 : _a2.getHTMLElement().classList.remove("last-focused");
    this._lastFocusedWidget = widget;
    (_b2 = this._lastFocusedWidget) === null || _b2 === void 0 ? void 0 : _b2.getHTMLElement().classList.add("last-focused");
  }
  register(widget, extraContextKeys) {
    if (!this._hasCreatedStyleController) {
      this._hasCreatedStyleController = true;
      const styleController = new DefaultStyleController(createStyleSheet(), "");
      styleController.style(defaultListStyles);
    }
    if (this.lists.some((l) => l.widget === widget)) {
      throw new Error("Cannot register the same widget multiple times");
    }
    const registeredList = { widget, extraContextKeys };
    this.lists.push(registeredList);
    if (isActiveElement(widget.getHTMLElement())) {
      this.setLastFocusedList(widget);
    }
    return combinedDisposable(widget.onDidFocus(() => this.setLastFocusedList(widget)), toDisposable(() => this.lists.splice(this.lists.indexOf(registeredList), 1)), widget.onDidDispose(() => {
      this.lists = this.lists.filter((l) => l !== registeredList);
      if (this._lastFocusedWidget === widget) {
        this.setLastFocusedList(void 0);
      }
    }));
  }
  dispose() {
    this.disposables.dispose();
  }
};
var RawWorkbenchListScrollAtBoundaryContextKey = new RawContextKey("listScrollAtBoundary", "none");
var WorkbenchListScrollAtTopContextKey = ContextKeyExpr.or(RawWorkbenchListScrollAtBoundaryContextKey.isEqualTo("top"), RawWorkbenchListScrollAtBoundaryContextKey.isEqualTo("both"));
var WorkbenchListScrollAtBottomContextKey = ContextKeyExpr.or(RawWorkbenchListScrollAtBoundaryContextKey.isEqualTo("bottom"), RawWorkbenchListScrollAtBoundaryContextKey.isEqualTo("both"));
var RawWorkbenchListFocusContextKey = new RawContextKey("listFocus", true);
var WorkbenchTreeStickyScrollFocused = new RawContextKey("treestickyScrollFocused", false);
var WorkbenchListSupportsMultiSelectContextKey = new RawContextKey("listSupportsMultiselect", true);
var WorkbenchListFocusContextKey = ContextKeyExpr.and(RawWorkbenchListFocusContextKey, ContextKeyExpr.not(InputFocusedContextKey), WorkbenchTreeStickyScrollFocused.negate());
var WorkbenchListHasSelectionOrFocus = new RawContextKey("listHasSelectionOrFocus", false);
var WorkbenchListDoubleSelection = new RawContextKey("listDoubleSelection", false);
var WorkbenchListMultiSelection = new RawContextKey("listMultiSelection", false);
var WorkbenchListSelectionNavigation = new RawContextKey("listSelectionNavigation", false);
var WorkbenchListSupportsFind = new RawContextKey("listSupportsFind", true);
var WorkbenchTreeElementCanCollapse = new RawContextKey("treeElementCanCollapse", false);
var WorkbenchTreeElementHasParent = new RawContextKey("treeElementHasParent", false);
var WorkbenchTreeElementCanExpand = new RawContextKey("treeElementCanExpand", false);
var WorkbenchTreeElementHasChild = new RawContextKey("treeElementHasChild", false);
var WorkbenchTreeFindOpen = new RawContextKey("treeFindOpen", false);
var WorkbenchListTypeNavigationModeKey = "listTypeNavigationMode";
var WorkbenchListAutomaticKeyboardNavigationLegacyKey = "listAutomaticKeyboardNavigation";
function createScopedContextKeyService(contextKeyService, widget) {
  const result = contextKeyService.createScoped(widget.getHTMLElement());
  RawWorkbenchListFocusContextKey.bindTo(result);
  return result;
}
function createScrollObserver(contextKeyService, widget) {
  const listScrollAt = RawWorkbenchListScrollAtBoundaryContextKey.bindTo(contextKeyService);
  const update = () => {
    const atTop = widget.scrollTop === 0;
    const atBottom = widget.scrollHeight - widget.renderHeight - widget.scrollTop < 1;
    if (atTop && atBottom) {
      listScrollAt.set("both");
    } else if (atTop) {
      listScrollAt.set("top");
    } else if (atBottom) {
      listScrollAt.set("bottom");
    } else {
      listScrollAt.set("none");
    }
  };
  update();
  return widget.onDidScroll(update);
}
var multiSelectModifierSettingKey = "workbench.list.multiSelectModifier";
var openModeSettingKey = "workbench.list.openMode";
var horizontalScrollingKey = "workbench.list.horizontalScrolling";
var defaultFindModeSettingKey = "workbench.list.defaultFindMode";
var typeNavigationModeSettingKey = "workbench.list.typeNavigationMode";
var keyboardNavigationSettingKey = "workbench.list.keyboardNavigation";
var scrollByPageKey = "workbench.list.scrollByPage";
var defaultFindMatchTypeSettingKey = "workbench.list.defaultFindMatchType";
var treeIndentKey = "workbench.tree.indent";
var treeRenderIndentGuidesKey = "workbench.tree.renderIndentGuides";
var listSmoothScrolling = "workbench.list.smoothScrolling";
var mouseWheelScrollSensitivityKey = "workbench.list.mouseWheelScrollSensitivity";
var fastScrollSensitivityKey = "workbench.list.fastScrollSensitivity";
var treeExpandMode = "workbench.tree.expandMode";
var treeStickyScroll = "workbench.tree.enableStickyScroll";
var treeStickyScrollMaxElements = "workbench.tree.stickyScrollMaxItemCount";
function useAltAsMultipleSelectionModifier(configurationService) {
  return configurationService.getValue(multiSelectModifierSettingKey) === "alt";
}
var MultipleSelectionController = class extends Disposable {
  constructor(configurationService) {
    super();
    this.configurationService = configurationService;
    this.useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
        this.useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(this.configurationService);
      }
    }));
  }
  isSelectionSingleChangeEvent(event) {
    if (this.useAltAsMultipleSelectionModifier) {
      return event.browserEvent.altKey;
    }
    return isSelectionSingleChangeEvent(event);
  }
  isSelectionRangeChangeEvent(event) {
    return isSelectionRangeChangeEvent(event);
  }
};
function toWorkbenchListOptions(accessor, options2) {
  var _a2;
  const configurationService = accessor.get(IConfigurationService);
  const keybindingService = accessor.get(IKeybindingService);
  const disposables = new DisposableStore();
  const result = {
    ...options2,
    keyboardNavigationDelegate: { mightProducePrintableCharacter(e) {
      return keybindingService.mightProducePrintableCharacter(e);
    } },
    smoothScrolling: Boolean(configurationService.getValue(listSmoothScrolling)),
    mouseWheelScrollSensitivity: configurationService.getValue(mouseWheelScrollSensitivityKey),
    fastScrollSensitivity: configurationService.getValue(fastScrollSensitivityKey),
    multipleSelectionController: (_a2 = options2.multipleSelectionController) !== null && _a2 !== void 0 ? _a2 : disposables.add(new MultipleSelectionController(configurationService)),
    keyboardNavigationEventFilter: createKeyboardNavigationEventFilter(keybindingService),
    scrollByPage: Boolean(configurationService.getValue(scrollByPageKey))
  };
  return [result, disposables];
}
var WorkbenchList = class WorkbenchList2 extends List {
  constructor(user, container, delegate, renderers, options2, contextKeyService, listService, configurationService, instantiationService) {
    const horizontalScrolling = typeof options2.horizontalScrolling !== "undefined" ? options2.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));
    const [workbenchListOptions, workbenchListOptionsDisposable] = instantiationService.invokeFunction(toWorkbenchListOptions, options2);
    super(user, container, delegate, renderers, {
      keyboardSupport: false,
      ...workbenchListOptions,
      horizontalScrolling
    });
    this.disposables.add(workbenchListOptionsDisposable);
    this.contextKeyService = createScopedContextKeyService(contextKeyService, this);
    this.disposables.add(createScrollObserver(this.contextKeyService, this));
    this.listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);
    this.listSupportsMultiSelect.set(options2.multipleSelectionSupport !== false);
    const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);
    listSelectionNavigation.set(Boolean(options2.selectionNavigation));
    this.listHasSelectionOrFocus = WorkbenchListHasSelectionOrFocus.bindTo(this.contextKeyService);
    this.listDoubleSelection = WorkbenchListDoubleSelection.bindTo(this.contextKeyService);
    this.listMultiSelection = WorkbenchListMultiSelection.bindTo(this.contextKeyService);
    this.horizontalScrolling = options2.horizontalScrolling;
    this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
    this.disposables.add(this.contextKeyService);
    this.disposables.add(listService.register(this));
    this.updateStyles(options2.overrideStyles);
    this.disposables.add(this.onDidChangeSelection(() => {
      const selection = this.getSelection();
      const focus = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);
        this.listMultiSelection.set(selection.length > 1);
        this.listDoubleSelection.set(selection.length === 2);
      });
    }));
    this.disposables.add(this.onDidChangeFocus(() => {
      const selection = this.getSelection();
      const focus = this.getFocus();
      this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);
    }));
    this.disposables.add(configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
      }
      let options3 = {};
      if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === void 0) {
        const horizontalScrolling2 = Boolean(configurationService.getValue(horizontalScrollingKey));
        options3 = { ...options3, horizontalScrolling: horizontalScrolling2 };
      }
      if (e.affectsConfiguration(scrollByPageKey)) {
        const scrollByPage = Boolean(configurationService.getValue(scrollByPageKey));
        options3 = { ...options3, scrollByPage };
      }
      if (e.affectsConfiguration(listSmoothScrolling)) {
        const smoothScrolling = Boolean(configurationService.getValue(listSmoothScrolling));
        options3 = { ...options3, smoothScrolling };
      }
      if (e.affectsConfiguration(mouseWheelScrollSensitivityKey)) {
        const mouseWheelScrollSensitivity = configurationService.getValue(mouseWheelScrollSensitivityKey);
        options3 = { ...options3, mouseWheelScrollSensitivity };
      }
      if (e.affectsConfiguration(fastScrollSensitivityKey)) {
        const fastScrollSensitivity = configurationService.getValue(fastScrollSensitivityKey);
        options3 = { ...options3, fastScrollSensitivity };
      }
      if (Object.keys(options3).length > 0) {
        this.updateOptions(options3);
      }
    }));
    this.navigator = new ListResourceNavigator(this, { configurationService, ...options2 });
    this.disposables.add(this.navigator);
  }
  updateOptions(options2) {
    super.updateOptions(options2);
    if (options2.overrideStyles !== void 0) {
      this.updateStyles(options2.overrideStyles);
    }
    if (options2.multipleSelectionSupport !== void 0) {
      this.listSupportsMultiSelect.set(!!options2.multipleSelectionSupport);
    }
  }
  updateStyles(styles) {
    this.style(styles ? getListStyles(styles) : defaultListStyles);
  }
};
WorkbenchList = __decorate26([
  __param21(5, IContextKeyService),
  __param21(6, IListService),
  __param21(7, IConfigurationService),
  __param21(8, IInstantiationService)
], WorkbenchList);
var WorkbenchPagedList = class WorkbenchPagedList2 extends PagedList {
  constructor(user, container, delegate, renderers, options2, contextKeyService, listService, configurationService, instantiationService) {
    const horizontalScrolling = typeof options2.horizontalScrolling !== "undefined" ? options2.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));
    const [workbenchListOptions, workbenchListOptionsDisposable] = instantiationService.invokeFunction(toWorkbenchListOptions, options2);
    super(user, container, delegate, renderers, {
      keyboardSupport: false,
      ...workbenchListOptions,
      horizontalScrolling
    });
    this.disposables = new DisposableStore();
    this.disposables.add(workbenchListOptionsDisposable);
    this.contextKeyService = createScopedContextKeyService(contextKeyService, this);
    this.disposables.add(createScrollObserver(this.contextKeyService, this.widget));
    this.horizontalScrolling = options2.horizontalScrolling;
    this.listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);
    this.listSupportsMultiSelect.set(options2.multipleSelectionSupport !== false);
    const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);
    listSelectionNavigation.set(Boolean(options2.selectionNavigation));
    this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
    this.disposables.add(this.contextKeyService);
    this.disposables.add(listService.register(this));
    this.updateStyles(options2.overrideStyles);
    this.disposables.add(configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
      }
      let options3 = {};
      if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === void 0) {
        const horizontalScrolling2 = Boolean(configurationService.getValue(horizontalScrollingKey));
        options3 = { ...options3, horizontalScrolling: horizontalScrolling2 };
      }
      if (e.affectsConfiguration(scrollByPageKey)) {
        const scrollByPage = Boolean(configurationService.getValue(scrollByPageKey));
        options3 = { ...options3, scrollByPage };
      }
      if (e.affectsConfiguration(listSmoothScrolling)) {
        const smoothScrolling = Boolean(configurationService.getValue(listSmoothScrolling));
        options3 = { ...options3, smoothScrolling };
      }
      if (e.affectsConfiguration(mouseWheelScrollSensitivityKey)) {
        const mouseWheelScrollSensitivity = configurationService.getValue(mouseWheelScrollSensitivityKey);
        options3 = { ...options3, mouseWheelScrollSensitivity };
      }
      if (e.affectsConfiguration(fastScrollSensitivityKey)) {
        const fastScrollSensitivity = configurationService.getValue(fastScrollSensitivityKey);
        options3 = { ...options3, fastScrollSensitivity };
      }
      if (Object.keys(options3).length > 0) {
        this.updateOptions(options3);
      }
    }));
    this.navigator = new ListResourceNavigator(this, { configurationService, ...options2 });
    this.disposables.add(this.navigator);
  }
  updateOptions(options2) {
    super.updateOptions(options2);
    if (options2.overrideStyles !== void 0) {
      this.updateStyles(options2.overrideStyles);
    }
    if (options2.multipleSelectionSupport !== void 0) {
      this.listSupportsMultiSelect.set(!!options2.multipleSelectionSupport);
    }
  }
  updateStyles(styles) {
    this.style(styles ? getListStyles(styles) : defaultListStyles);
  }
  dispose() {
    this.disposables.dispose();
    super.dispose();
  }
};
WorkbenchPagedList = __decorate26([
  __param21(5, IContextKeyService),
  __param21(6, IListService),
  __param21(7, IConfigurationService),
  __param21(8, IInstantiationService)
], WorkbenchPagedList);
var WorkbenchTable = class WorkbenchTable2 extends Table {
  constructor(user, container, delegate, columns, renderers, options2, contextKeyService, listService, configurationService, instantiationService) {
    const horizontalScrolling = typeof options2.horizontalScrolling !== "undefined" ? options2.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));
    const [workbenchListOptions, workbenchListOptionsDisposable] = instantiationService.invokeFunction(toWorkbenchListOptions, options2);
    super(user, container, delegate, columns, renderers, {
      keyboardSupport: false,
      ...workbenchListOptions,
      horizontalScrolling
    });
    this.disposables.add(workbenchListOptionsDisposable);
    this.contextKeyService = createScopedContextKeyService(contextKeyService, this);
    this.disposables.add(createScrollObserver(this.contextKeyService, this));
    this.listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);
    this.listSupportsMultiSelect.set(options2.multipleSelectionSupport !== false);
    const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);
    listSelectionNavigation.set(Boolean(options2.selectionNavigation));
    this.listHasSelectionOrFocus = WorkbenchListHasSelectionOrFocus.bindTo(this.contextKeyService);
    this.listDoubleSelection = WorkbenchListDoubleSelection.bindTo(this.contextKeyService);
    this.listMultiSelection = WorkbenchListMultiSelection.bindTo(this.contextKeyService);
    this.horizontalScrolling = options2.horizontalScrolling;
    this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
    this.disposables.add(this.contextKeyService);
    this.disposables.add(listService.register(this));
    this.updateStyles(options2.overrideStyles);
    this.disposables.add(this.onDidChangeSelection(() => {
      const selection = this.getSelection();
      const focus = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);
        this.listMultiSelection.set(selection.length > 1);
        this.listDoubleSelection.set(selection.length === 2);
      });
    }));
    this.disposables.add(this.onDidChangeFocus(() => {
      const selection = this.getSelection();
      const focus = this.getFocus();
      this.listHasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);
    }));
    this.disposables.add(configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
      }
      let options3 = {};
      if (e.affectsConfiguration(horizontalScrollingKey) && this.horizontalScrolling === void 0) {
        const horizontalScrolling2 = Boolean(configurationService.getValue(horizontalScrollingKey));
        options3 = { ...options3, horizontalScrolling: horizontalScrolling2 };
      }
      if (e.affectsConfiguration(scrollByPageKey)) {
        const scrollByPage = Boolean(configurationService.getValue(scrollByPageKey));
        options3 = { ...options3, scrollByPage };
      }
      if (e.affectsConfiguration(listSmoothScrolling)) {
        const smoothScrolling = Boolean(configurationService.getValue(listSmoothScrolling));
        options3 = { ...options3, smoothScrolling };
      }
      if (e.affectsConfiguration(mouseWheelScrollSensitivityKey)) {
        const mouseWheelScrollSensitivity = configurationService.getValue(mouseWheelScrollSensitivityKey);
        options3 = { ...options3, mouseWheelScrollSensitivity };
      }
      if (e.affectsConfiguration(fastScrollSensitivityKey)) {
        const fastScrollSensitivity = configurationService.getValue(fastScrollSensitivityKey);
        options3 = { ...options3, fastScrollSensitivity };
      }
      if (Object.keys(options3).length > 0) {
        this.updateOptions(options3);
      }
    }));
    this.navigator = new TableResourceNavigator(this, { configurationService, ...options2 });
    this.disposables.add(this.navigator);
  }
  updateOptions(options2) {
    super.updateOptions(options2);
    if (options2.overrideStyles !== void 0) {
      this.updateStyles(options2.overrideStyles);
    }
    if (options2.multipleSelectionSupport !== void 0) {
      this.listSupportsMultiSelect.set(!!options2.multipleSelectionSupport);
    }
  }
  updateStyles(styles) {
    this.style(styles ? getListStyles(styles) : defaultListStyles);
  }
  dispose() {
    this.disposables.dispose();
    super.dispose();
  }
};
WorkbenchTable = __decorate26([
  __param21(6, IContextKeyService),
  __param21(7, IListService),
  __param21(8, IConfigurationService),
  __param21(9, IInstantiationService)
], WorkbenchTable);
var ResourceNavigator = class extends Disposable {
  constructor(widget, options2) {
    var _a2;
    super();
    this.widget = widget;
    this._onDidOpen = this._register(new Emitter());
    this.onDidOpen = this._onDidOpen.event;
    this._register(Event.filter(this.widget.onDidChangeSelection, (e) => isKeyboardEvent(e.browserEvent))((e) => this.onSelectionFromKeyboard(e)));
    this._register(this.widget.onPointer((e) => this.onPointer(e.element, e.browserEvent)));
    this._register(this.widget.onMouseDblClick((e) => this.onMouseDblClick(e.element, e.browserEvent)));
    if (typeof (options2 === null || options2 === void 0 ? void 0 : options2.openOnSingleClick) !== "boolean" && (options2 === null || options2 === void 0 ? void 0 : options2.configurationService)) {
      this.openOnSingleClick = (options2 === null || options2 === void 0 ? void 0 : options2.configurationService.getValue(openModeSettingKey)) !== "doubleClick";
      this._register(options2 === null || options2 === void 0 ? void 0 : options2.configurationService.onDidChangeConfiguration((e) => {
        if (e.affectsConfiguration(openModeSettingKey)) {
          this.openOnSingleClick = (options2 === null || options2 === void 0 ? void 0 : options2.configurationService.getValue(openModeSettingKey)) !== "doubleClick";
        }
      }));
    } else {
      this.openOnSingleClick = (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.openOnSingleClick) !== null && _a2 !== void 0 ? _a2 : true;
    }
  }
  onSelectionFromKeyboard(event) {
    if (event.elements.length !== 1) {
      return;
    }
    const selectionKeyboardEvent = event.browserEvent;
    const preserveFocus = typeof selectionKeyboardEvent.preserveFocus === "boolean" ? selectionKeyboardEvent.preserveFocus : true;
    const pinned = typeof selectionKeyboardEvent.pinned === "boolean" ? selectionKeyboardEvent.pinned : !preserveFocus;
    const sideBySide = false;
    this._open(this.getSelectedElement(), preserveFocus, pinned, sideBySide, event.browserEvent);
  }
  onPointer(element, browserEvent) {
    if (!this.openOnSingleClick) {
      return;
    }
    const isDoubleClick = browserEvent.detail === 2;
    if (isDoubleClick) {
      return;
    }
    const isMiddleClick = browserEvent.button === 1;
    const preserveFocus = true;
    const pinned = isMiddleClick;
    const sideBySide = browserEvent.ctrlKey || browserEvent.metaKey || browserEvent.altKey;
    this._open(element, preserveFocus, pinned, sideBySide, browserEvent);
  }
  onMouseDblClick(element, browserEvent) {
    if (!browserEvent) {
      return;
    }
    const target = browserEvent.target;
    const onTwistie = target.classList.contains("monaco-tl-twistie") || target.classList.contains("monaco-icon-label") && target.classList.contains("folder-icon") && browserEvent.offsetX < 16;
    if (onTwistie) {
      return;
    }
    const preserveFocus = false;
    const pinned = true;
    const sideBySide = browserEvent.ctrlKey || browserEvent.metaKey || browserEvent.altKey;
    this._open(element, preserveFocus, pinned, sideBySide, browserEvent);
  }
  _open(element, preserveFocus, pinned, sideBySide, browserEvent) {
    if (!element) {
      return;
    }
    this._onDidOpen.fire({
      editorOptions: {
        preserveFocus,
        pinned,
        revealIfVisible: true
      },
      sideBySide,
      element,
      browserEvent
    });
  }
};
var ListResourceNavigator = class extends ResourceNavigator {
  constructor(widget, options2) {
    super(widget, options2);
    this.widget = widget;
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
};
var TableResourceNavigator = class extends ResourceNavigator {
  constructor(widget, options2) {
    super(widget, options2);
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
};
var TreeResourceNavigator = class extends ResourceNavigator {
  constructor(widget, options2) {
    super(widget, options2);
  }
  getSelectedElement() {
    var _a2;
    return (_a2 = this.widget.getSelection()[0]) !== null && _a2 !== void 0 ? _a2 : void 0;
  }
};
function createKeyboardNavigationEventFilter(keybindingService) {
  let inMultiChord = false;
  return (event) => {
    if (event.toKeyCodeChord().isModifierKey()) {
      return false;
    }
    if (inMultiChord) {
      inMultiChord = false;
      return false;
    }
    const result = keybindingService.softDispatch(event, event.target);
    if (result.kind === 1) {
      inMultiChord = true;
      return false;
    }
    inMultiChord = false;
    return result.kind === 0;
  };
}
var WorkbenchObjectTree = class WorkbenchObjectTree2 extends ObjectTree {
  constructor(user, container, delegate, renderers, options2, instantiationService, contextKeyService, listService, configurationService) {
    const { options: treeOptions, getTypeNavigationMode, disposable } = instantiationService.invokeFunction(workbenchTreeDataPreamble, options2);
    super(user, container, delegate, renderers, treeOptions);
    this.disposables.add(disposable);
    this.internals = new WorkbenchTreeInternals(this, options2, getTypeNavigationMode, options2.overrideStyles, contextKeyService, listService, configurationService);
    this.disposables.add(this.internals);
  }
  updateOptions(options2) {
    super.updateOptions(options2);
    this.internals.updateOptions(options2);
  }
};
WorkbenchObjectTree = __decorate26([
  __param21(5, IInstantiationService),
  __param21(6, IContextKeyService),
  __param21(7, IListService),
  __param21(8, IConfigurationService)
], WorkbenchObjectTree);
var WorkbenchCompressibleObjectTree = class WorkbenchCompressibleObjectTree2 extends CompressibleObjectTree {
  constructor(user, container, delegate, renderers, options2, instantiationService, contextKeyService, listService, configurationService) {
    const { options: treeOptions, getTypeNavigationMode, disposable } = instantiationService.invokeFunction(workbenchTreeDataPreamble, options2);
    super(user, container, delegate, renderers, treeOptions);
    this.disposables.add(disposable);
    this.internals = new WorkbenchTreeInternals(this, options2, getTypeNavigationMode, options2.overrideStyles, contextKeyService, listService, configurationService);
    this.disposables.add(this.internals);
  }
  updateOptions(options2 = {}) {
    super.updateOptions(options2);
    if (options2.overrideStyles) {
      this.internals.updateStyleOverrides(options2.overrideStyles);
    }
    this.internals.updateOptions(options2);
  }
};
WorkbenchCompressibleObjectTree = __decorate26([
  __param21(5, IInstantiationService),
  __param21(6, IContextKeyService),
  __param21(7, IListService),
  __param21(8, IConfigurationService)
], WorkbenchCompressibleObjectTree);
var WorkbenchDataTree = class WorkbenchDataTree2 extends DataTree {
  constructor(user, container, delegate, renderers, dataSource, options2, instantiationService, contextKeyService, listService, configurationService) {
    const { options: treeOptions, getTypeNavigationMode, disposable } = instantiationService.invokeFunction(workbenchTreeDataPreamble, options2);
    super(user, container, delegate, renderers, dataSource, treeOptions);
    this.disposables.add(disposable);
    this.internals = new WorkbenchTreeInternals(this, options2, getTypeNavigationMode, options2.overrideStyles, contextKeyService, listService, configurationService);
    this.disposables.add(this.internals);
  }
  updateOptions(options2 = {}) {
    super.updateOptions(options2);
    if (options2.overrideStyles !== void 0) {
      this.internals.updateStyleOverrides(options2.overrideStyles);
    }
    this.internals.updateOptions(options2);
  }
};
WorkbenchDataTree = __decorate26([
  __param21(6, IInstantiationService),
  __param21(7, IContextKeyService),
  __param21(8, IListService),
  __param21(9, IConfigurationService)
], WorkbenchDataTree);
var WorkbenchAsyncDataTree = class WorkbenchAsyncDataTree2 extends AsyncDataTree {
  get onDidOpen() {
    return this.internals.onDidOpen;
  }
  constructor(user, container, delegate, renderers, dataSource, options2, instantiationService, contextKeyService, listService, configurationService) {
    const { options: treeOptions, getTypeNavigationMode, disposable } = instantiationService.invokeFunction(workbenchTreeDataPreamble, options2);
    super(user, container, delegate, renderers, dataSource, treeOptions);
    this.disposables.add(disposable);
    this.internals = new WorkbenchTreeInternals(this, options2, getTypeNavigationMode, options2.overrideStyles, contextKeyService, listService, configurationService);
    this.disposables.add(this.internals);
  }
  updateOptions(options2 = {}) {
    super.updateOptions(options2);
    if (options2.overrideStyles) {
      this.internals.updateStyleOverrides(options2.overrideStyles);
    }
    this.internals.updateOptions(options2);
  }
};
WorkbenchAsyncDataTree = __decorate26([
  __param21(6, IInstantiationService),
  __param21(7, IContextKeyService),
  __param21(8, IListService),
  __param21(9, IConfigurationService)
], WorkbenchAsyncDataTree);
var WorkbenchCompressibleAsyncDataTree = class WorkbenchCompressibleAsyncDataTree2 extends CompressibleAsyncDataTree {
  constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options2, instantiationService, contextKeyService, listService, configurationService) {
    const { options: treeOptions, getTypeNavigationMode, disposable } = instantiationService.invokeFunction(workbenchTreeDataPreamble, options2);
    super(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, treeOptions);
    this.disposables.add(disposable);
    this.internals = new WorkbenchTreeInternals(this, options2, getTypeNavigationMode, options2.overrideStyles, contextKeyService, listService, configurationService);
    this.disposables.add(this.internals);
  }
  updateOptions(options2) {
    super.updateOptions(options2);
    this.internals.updateOptions(options2);
  }
};
WorkbenchCompressibleAsyncDataTree = __decorate26([
  __param21(7, IInstantiationService),
  __param21(8, IContextKeyService),
  __param21(9, IListService),
  __param21(10, IConfigurationService)
], WorkbenchCompressibleAsyncDataTree);
function getDefaultTreeFindMode(configurationService) {
  const value = configurationService.getValue(defaultFindModeSettingKey);
  if (value === "highlight") {
    return TreeFindMode.Highlight;
  } else if (value === "filter") {
    return TreeFindMode.Filter;
  }
  const deprecatedValue = configurationService.getValue(keyboardNavigationSettingKey);
  if (deprecatedValue === "simple" || deprecatedValue === "highlight") {
    return TreeFindMode.Highlight;
  } else if (deprecatedValue === "filter") {
    return TreeFindMode.Filter;
  }
  return void 0;
}
function getDefaultTreeFindMatchType(configurationService) {
  const value = configurationService.getValue(defaultFindMatchTypeSettingKey);
  if (value === "fuzzy") {
    return TreeFindMatchType.Fuzzy;
  } else if (value === "contiguous") {
    return TreeFindMatchType.Contiguous;
  }
  return void 0;
}
function workbenchTreeDataPreamble(accessor, options2) {
  var _a2;
  const configurationService = accessor.get(IConfigurationService);
  const contextViewService = accessor.get(IContextViewService);
  const contextKeyService = accessor.get(IContextKeyService);
  const instantiationService = accessor.get(IInstantiationService);
  const getTypeNavigationMode = () => {
    const modeString = contextKeyService.getContextKeyValue(WorkbenchListTypeNavigationModeKey);
    if (modeString === "automatic") {
      return TypeNavigationMode.Automatic;
    } else if (modeString === "trigger") {
      return TypeNavigationMode.Trigger;
    }
    const modeBoolean = contextKeyService.getContextKeyValue(WorkbenchListAutomaticKeyboardNavigationLegacyKey);
    if (modeBoolean === false) {
      return TypeNavigationMode.Trigger;
    }
    const configString = configurationService.getValue(typeNavigationModeSettingKey);
    if (configString === "automatic") {
      return TypeNavigationMode.Automatic;
    } else if (configString === "trigger") {
      return TypeNavigationMode.Trigger;
    }
    return void 0;
  };
  const horizontalScrolling = options2.horizontalScrolling !== void 0 ? options2.horizontalScrolling : Boolean(configurationService.getValue(horizontalScrollingKey));
  const [workbenchListOptions, disposable] = instantiationService.invokeFunction(toWorkbenchListOptions, options2);
  const paddingBottom = options2.paddingBottom;
  const renderIndentGuides = options2.renderIndentGuides !== void 0 ? options2.renderIndentGuides : configurationService.getValue(treeRenderIndentGuidesKey);
  return {
    getTypeNavigationMode,
    disposable,
    options: {
      // ...options, // TODO@Joao why is this not splatted here?
      keyboardSupport: false,
      ...workbenchListOptions,
      indent: typeof configurationService.getValue(treeIndentKey) === "number" ? configurationService.getValue(treeIndentKey) : void 0,
      renderIndentGuides,
      smoothScrolling: Boolean(configurationService.getValue(listSmoothScrolling)),
      defaultFindMode: getDefaultTreeFindMode(configurationService),
      defaultFindMatchType: getDefaultTreeFindMatchType(configurationService),
      horizontalScrolling,
      scrollByPage: Boolean(configurationService.getValue(scrollByPageKey)),
      paddingBottom,
      hideTwistiesOfChildlessElements: options2.hideTwistiesOfChildlessElements,
      expandOnlyOnTwistieClick: (_a2 = options2.expandOnlyOnTwistieClick) !== null && _a2 !== void 0 ? _a2 : configurationService.getValue(treeExpandMode) === "doubleClick",
      contextViewProvider: contextViewService,
      findWidgetStyles: defaultFindWidgetStyles,
      enableStickyScroll: Boolean(configurationService.getValue(treeStickyScroll)),
      stickyScrollMaxItemCount: Number(configurationService.getValue(treeStickyScrollMaxElements))
    }
  };
}
var WorkbenchTreeInternals = class WorkbenchTreeInternals2 {
  get onDidOpen() {
    return this.navigator.onDidOpen;
  }
  constructor(tree, options2, getTypeNavigationMode, overrideStyles2, contextKeyService, listService, configurationService) {
    var _a2;
    this.tree = tree;
    this.disposables = [];
    this.contextKeyService = createScopedContextKeyService(contextKeyService, tree);
    this.disposables.push(createScrollObserver(this.contextKeyService, tree));
    this.listSupportsMultiSelect = WorkbenchListSupportsMultiSelectContextKey.bindTo(this.contextKeyService);
    this.listSupportsMultiSelect.set(options2.multipleSelectionSupport !== false);
    const listSelectionNavigation = WorkbenchListSelectionNavigation.bindTo(this.contextKeyService);
    listSelectionNavigation.set(Boolean(options2.selectionNavigation));
    this.listSupportFindWidget = WorkbenchListSupportsFind.bindTo(this.contextKeyService);
    this.listSupportFindWidget.set((_a2 = options2.findWidgetEnabled) !== null && _a2 !== void 0 ? _a2 : true);
    this.hasSelectionOrFocus = WorkbenchListHasSelectionOrFocus.bindTo(this.contextKeyService);
    this.hasDoubleSelection = WorkbenchListDoubleSelection.bindTo(this.contextKeyService);
    this.hasMultiSelection = WorkbenchListMultiSelection.bindTo(this.contextKeyService);
    this.treeElementCanCollapse = WorkbenchTreeElementCanCollapse.bindTo(this.contextKeyService);
    this.treeElementHasParent = WorkbenchTreeElementHasParent.bindTo(this.contextKeyService);
    this.treeElementCanExpand = WorkbenchTreeElementCanExpand.bindTo(this.contextKeyService);
    this.treeElementHasChild = WorkbenchTreeElementHasChild.bindTo(this.contextKeyService);
    this.treeFindOpen = WorkbenchTreeFindOpen.bindTo(this.contextKeyService);
    this.treeStickyScrollFocused = WorkbenchTreeStickyScrollFocused.bindTo(this.contextKeyService);
    this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
    this.updateStyleOverrides(overrideStyles2);
    const updateCollapseContextKeys = () => {
      const focus = tree.getFocus()[0];
      if (!focus) {
        return;
      }
      const node = tree.getNode(focus);
      this.treeElementCanCollapse.set(node.collapsible && !node.collapsed);
      this.treeElementHasParent.set(!!tree.getParentElement(focus));
      this.treeElementCanExpand.set(node.collapsible && node.collapsed);
      this.treeElementHasChild.set(!!tree.getFirstElementChild(focus));
    };
    const interestingContextKeys = /* @__PURE__ */ new Set();
    interestingContextKeys.add(WorkbenchListTypeNavigationModeKey);
    interestingContextKeys.add(WorkbenchListAutomaticKeyboardNavigationLegacyKey);
    this.disposables.push(this.contextKeyService, listService.register(tree), tree.onDidChangeSelection(() => {
      const selection = tree.getSelection();
      const focus = tree.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.hasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);
        this.hasMultiSelection.set(selection.length > 1);
        this.hasDoubleSelection.set(selection.length === 2);
      });
    }), tree.onDidChangeFocus(() => {
      const selection = tree.getSelection();
      const focus = tree.getFocus();
      this.hasSelectionOrFocus.set(selection.length > 0 || focus.length > 0);
      updateCollapseContextKeys();
    }), tree.onDidChangeCollapseState(updateCollapseContextKeys), tree.onDidChangeModel(updateCollapseContextKeys), tree.onDidChangeFindOpenState((enabled) => this.treeFindOpen.set(enabled)), tree.onDidChangeStickyScrollFocused((focused) => this.treeStickyScrollFocused.set(focused)), configurationService.onDidChangeConfiguration((e) => {
      let newOptions = {};
      if (e.affectsConfiguration(multiSelectModifierSettingKey)) {
        this._useAltAsMultipleSelectionModifier = useAltAsMultipleSelectionModifier(configurationService);
      }
      if (e.affectsConfiguration(treeIndentKey)) {
        const indent = configurationService.getValue(treeIndentKey);
        newOptions = { ...newOptions, indent };
      }
      if (e.affectsConfiguration(treeRenderIndentGuidesKey) && options2.renderIndentGuides === void 0) {
        const renderIndentGuides = configurationService.getValue(treeRenderIndentGuidesKey);
        newOptions = { ...newOptions, renderIndentGuides };
      }
      if (e.affectsConfiguration(listSmoothScrolling)) {
        const smoothScrolling = Boolean(configurationService.getValue(listSmoothScrolling));
        newOptions = { ...newOptions, smoothScrolling };
      }
      if (e.affectsConfiguration(defaultFindModeSettingKey) || e.affectsConfiguration(keyboardNavigationSettingKey)) {
        const defaultFindMode = getDefaultTreeFindMode(configurationService);
        newOptions = { ...newOptions, defaultFindMode };
      }
      if (e.affectsConfiguration(typeNavigationModeSettingKey) || e.affectsConfiguration(keyboardNavigationSettingKey)) {
        const typeNavigationMode = getTypeNavigationMode();
        newOptions = { ...newOptions, typeNavigationMode };
      }
      if (e.affectsConfiguration(defaultFindMatchTypeSettingKey)) {
        const defaultFindMatchType = getDefaultTreeFindMatchType(configurationService);
        newOptions = { ...newOptions, defaultFindMatchType };
      }
      if (e.affectsConfiguration(horizontalScrollingKey) && options2.horizontalScrolling === void 0) {
        const horizontalScrolling = Boolean(configurationService.getValue(horizontalScrollingKey));
        newOptions = { ...newOptions, horizontalScrolling };
      }
      if (e.affectsConfiguration(scrollByPageKey)) {
        const scrollByPage = Boolean(configurationService.getValue(scrollByPageKey));
        newOptions = { ...newOptions, scrollByPage };
      }
      if (e.affectsConfiguration(treeExpandMode) && options2.expandOnlyOnTwistieClick === void 0) {
        newOptions = { ...newOptions, expandOnlyOnTwistieClick: configurationService.getValue(treeExpandMode) === "doubleClick" };
      }
      if (e.affectsConfiguration(treeStickyScroll)) {
        const enableStickyScroll = configurationService.getValue(treeStickyScroll);
        newOptions = { ...newOptions, enableStickyScroll };
      }
      if (e.affectsConfiguration(treeStickyScrollMaxElements)) {
        const stickyScrollMaxItemCount = Math.max(1, configurationService.getValue(treeStickyScrollMaxElements));
        newOptions = { ...newOptions, stickyScrollMaxItemCount };
      }
      if (e.affectsConfiguration(mouseWheelScrollSensitivityKey)) {
        const mouseWheelScrollSensitivity = configurationService.getValue(mouseWheelScrollSensitivityKey);
        newOptions = { ...newOptions, mouseWheelScrollSensitivity };
      }
      if (e.affectsConfiguration(fastScrollSensitivityKey)) {
        const fastScrollSensitivity = configurationService.getValue(fastScrollSensitivityKey);
        newOptions = { ...newOptions, fastScrollSensitivity };
      }
      if (Object.keys(newOptions).length > 0) {
        tree.updateOptions(newOptions);
      }
    }), this.contextKeyService.onDidChangeContext((e) => {
      if (e.affectsSome(interestingContextKeys)) {
        tree.updateOptions({ typeNavigationMode: getTypeNavigationMode() });
      }
    }));
    this.navigator = new TreeResourceNavigator(tree, { configurationService, ...options2 });
    this.disposables.push(this.navigator);
  }
  updateOptions(options2) {
    if (options2.multipleSelectionSupport !== void 0) {
      this.listSupportsMultiSelect.set(!!options2.multipleSelectionSupport);
    }
  }
  updateStyleOverrides(overrideStyles2) {
    this.tree.style(overrideStyles2 ? getListStyles(overrideStyles2) : defaultListStyles);
  }
  dispose() {
    this.disposables = dispose(this.disposables);
  }
};
WorkbenchTreeInternals = __decorate26([
  __param21(4, IContextKeyService),
  __param21(5, IListService),
  __param21(6, IConfigurationService)
], WorkbenchTreeInternals);
var configurationRegistry3 = Registry.as(Extensions2.Configuration);
configurationRegistry3.registerConfiguration({
  id: "workbench",
  order: 7,
  title: localize("workbenchConfigurationTitle", "Workbench"),
  type: "object",
  properties: {
    [multiSelectModifierSettingKey]: {
      type: "string",
      enum: ["ctrlCmd", "alt"],
      markdownEnumDescriptions: [
        localize("multiSelectModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
        localize("multiSelectModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
      ],
      default: "ctrlCmd",
      description: localize({
        key: "multiSelectModifier",
        comment: [
          "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
          "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
        ]
      }, "The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier.")
    },
    [openModeSettingKey]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: localize({
        key: "openModeModifier",
        comment: ["`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized."]
      }, "Controls how to open items in trees and lists using the mouse (if supported). Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    },
    [horizontalScrollingKey]: {
      type: "boolean",
      default: false,
      description: localize("horizontalScrolling setting", "Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication.")
    },
    [scrollByPageKey]: {
      type: "boolean",
      default: false,
      description: localize("list.scrollByPage", "Controls whether clicks in the scrollbar scroll page by page.")
    },
    [treeIndentKey]: {
      type: "number",
      default: 8,
      minimum: 4,
      maximum: 40,
      description: localize("tree indent setting", "Controls tree indentation in pixels.")
    },
    [treeRenderIndentGuidesKey]: {
      type: "string",
      enum: ["none", "onHover", "always"],
      default: "onHover",
      description: localize("render tree indent guides", "Controls whether the tree should render indent guides.")
    },
    [listSmoothScrolling]: {
      type: "boolean",
      default: false,
      description: localize("list smoothScrolling setting", "Controls whether lists and trees have smooth scrolling.")
    },
    [mouseWheelScrollSensitivityKey]: {
      type: "number",
      default: 1,
      markdownDescription: localize("Mouse Wheel Scroll Sensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.")
    },
    [fastScrollSensitivityKey]: {
      type: "number",
      default: 5,
      markdownDescription: localize("Fast Scroll Sensitivity", "Scrolling speed multiplier when pressing `Alt`.")
    },
    [defaultFindModeSettingKey]: {
      type: "string",
      enum: ["highlight", "filter"],
      enumDescriptions: [
        localize("defaultFindModeSettingKey.highlight", "Highlight elements when searching. Further up and down navigation will traverse only the highlighted elements."),
        localize("defaultFindModeSettingKey.filter", "Filter elements when searching.")
      ],
      default: "highlight",
      description: localize("defaultFindModeSettingKey", "Controls the default find mode for lists and trees in the workbench.")
    },
    [keyboardNavigationSettingKey]: {
      type: "string",
      enum: ["simple", "highlight", "filter"],
      enumDescriptions: [
        localize("keyboardNavigationSettingKey.simple", "Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes."),
        localize("keyboardNavigationSettingKey.highlight", "Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements."),
        localize("keyboardNavigationSettingKey.filter", "Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input.")
      ],
      default: "highlight",
      description: localize("keyboardNavigationSettingKey", "Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter."),
      deprecated: true,
      deprecationMessage: localize("keyboardNavigationSettingKeyDeprecated", "Please use 'workbench.list.defaultFindMode' and	'workbench.list.typeNavigationMode' instead.")
    },
    [defaultFindMatchTypeSettingKey]: {
      type: "string",
      enum: ["fuzzy", "contiguous"],
      enumDescriptions: [
        localize("defaultFindMatchTypeSettingKey.fuzzy", "Use fuzzy matching when searching."),
        localize("defaultFindMatchTypeSettingKey.contiguous", "Use contiguous matching when searching.")
      ],
      default: "fuzzy",
      description: localize("defaultFindMatchTypeSettingKey", "Controls the type of matching used when searching lists and trees in the workbench.")
    },
    [treeExpandMode]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: localize("expand mode", "Controls how tree folders are expanded when clicking the folder names. Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    },
    [treeStickyScroll]: {
      type: "boolean",
      default: true,
      description: localize("sticky scroll", "Controls whether sticky scrolling is enabled in trees.")
    },
    [treeStickyScrollMaxElements]: {
      type: "number",
      minimum: 1,
      default: 7,
      markdownDescription: localize("sticky scroll maximum items", "Controls the number of sticky elements displayed in the tree when `#workbench.tree.enableStickyScroll#` is enabled.")
    },
    [typeNavigationModeSettingKey]: {
      type: "string",
      enum: ["automatic", "trigger"],
      default: "automatic",
      markdownDescription: localize("typeNavigationMode2", "Controls how type navigation works in lists and trees in the workbench. When set to `trigger`, type navigation begins once the `list.triggerTypeNavigation` command is run.")
    }
  }
});

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickAccess.js
init_async();
init_cancellation();
init_event();
init_lifecycle();
init_instantiation();

// node_modules/monaco-editor/esm/vs/platform/quickinput/common/quickAccess.js
init_arrays();
init_lifecycle();
init_platform2();
var DefaultQuickAccessFilterValue;
(function(DefaultQuickAccessFilterValue2) {
  DefaultQuickAccessFilterValue2[DefaultQuickAccessFilterValue2["PRESERVE"] = 0] = "PRESERVE";
  DefaultQuickAccessFilterValue2[DefaultQuickAccessFilterValue2["LAST"] = 1] = "LAST";
})(DefaultQuickAccessFilterValue || (DefaultQuickAccessFilterValue = {}));
var Extensions8 = {
  Quickaccess: "workbench.contributions.quickaccess"
};
var QuickAccessRegistry = class {
  constructor() {
    this.providers = [];
    this.defaultProvider = void 0;
  }
  registerQuickAccessProvider(provider) {
    if (provider.prefix.length === 0) {
      this.defaultProvider = provider;
    } else {
      this.providers.push(provider);
    }
    this.providers.sort((providerA, providerB) => providerB.prefix.length - providerA.prefix.length);
    return toDisposable(() => {
      this.providers.splice(this.providers.indexOf(provider), 1);
      if (this.defaultProvider === provider) {
        this.defaultProvider = void 0;
      }
    });
  }
  getQuickAccessProviders() {
    return coalesce([this.defaultProvider, ...this.providers]);
  }
  getQuickAccessProvider(prefix) {
    const result = prefix ? this.providers.find((provider) => prefix.startsWith(provider.prefix)) || void 0 : void 0;
    return result || this.defaultProvider;
  }
};
Registry.add(Extensions8.Quickaccess, new QuickAccessRegistry());

// node_modules/monaco-editor/esm/vs/platform/quickinput/common/quickInput.js
init_instantiation();
var NO_KEY_MODS = { ctrlCmd: false, alt: false };
var QuickInputHideReason;
(function(QuickInputHideReason2) {
  QuickInputHideReason2[QuickInputHideReason2["Blur"] = 1] = "Blur";
  QuickInputHideReason2[QuickInputHideReason2["Gesture"] = 2] = "Gesture";
  QuickInputHideReason2[QuickInputHideReason2["Other"] = 3] = "Other";
})(QuickInputHideReason || (QuickInputHideReason = {}));
var ItemActivation;
(function(ItemActivation2) {
  ItemActivation2[ItemActivation2["NONE"] = 0] = "NONE";
  ItemActivation2[ItemActivation2["FIRST"] = 1] = "FIRST";
  ItemActivation2[ItemActivation2["SECOND"] = 2] = "SECOND";
  ItemActivation2[ItemActivation2["LAST"] = 3] = "LAST";
})(ItemActivation || (ItemActivation = {}));
var QuickPickItemScorerAccessor = class {
  constructor(options2) {
    this.options = options2;
  }
};
var quickPickItemScorerAccessor = new QuickPickItemScorerAccessor();
var IQuickInputService = createDecorator("quickInputService");

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickAccess.js
init_platform2();
var __decorate27 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param22 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var QuickAccessController = class QuickAccessController2 extends Disposable {
  constructor(quickInputService, instantiationService) {
    super();
    this.quickInputService = quickInputService;
    this.instantiationService = instantiationService;
    this.registry = Registry.as(Extensions8.Quickaccess);
    this.mapProviderToDescriptor = /* @__PURE__ */ new Map();
    this.lastAcceptedPickerValues = /* @__PURE__ */ new Map();
    this.visibleQuickAccess = void 0;
  }
  show(value = "", options2) {
    this.doShowOrPick(value, false, options2);
  }
  doShowOrPick(value, pick, options2) {
    var _a2;
    const [provider, descriptor] = this.getOrInstantiateProvider(value);
    const visibleQuickAccess = this.visibleQuickAccess;
    const visibleDescriptor = visibleQuickAccess === null || visibleQuickAccess === void 0 ? void 0 : visibleQuickAccess.descriptor;
    if (visibleQuickAccess && descriptor && visibleDescriptor === descriptor) {
      if (value !== descriptor.prefix && !(options2 === null || options2 === void 0 ? void 0 : options2.preserveValue)) {
        visibleQuickAccess.picker.value = value;
      }
      this.adjustValueSelection(visibleQuickAccess.picker, descriptor, options2);
      return;
    }
    if (descriptor && !(options2 === null || options2 === void 0 ? void 0 : options2.preserveValue)) {
      let newValue = void 0;
      if (visibleQuickAccess && visibleDescriptor && visibleDescriptor !== descriptor) {
        const newValueCandidateWithoutPrefix = visibleQuickAccess.value.substr(visibleDescriptor.prefix.length);
        if (newValueCandidateWithoutPrefix) {
          newValue = `${descriptor.prefix}${newValueCandidateWithoutPrefix}`;
        }
      }
      if (!newValue) {
        const defaultFilterValue = provider === null || provider === void 0 ? void 0 : provider.defaultFilterValue;
        if (defaultFilterValue === DefaultQuickAccessFilterValue.LAST) {
          newValue = this.lastAcceptedPickerValues.get(descriptor);
        } else if (typeof defaultFilterValue === "string") {
          newValue = `${descriptor.prefix}${defaultFilterValue}`;
        }
      }
      if (typeof newValue === "string") {
        value = newValue;
      }
    }
    const disposables = new DisposableStore();
    const picker = disposables.add(this.quickInputService.createQuickPick());
    picker.value = value;
    this.adjustValueSelection(picker, descriptor, options2);
    picker.placeholder = descriptor === null || descriptor === void 0 ? void 0 : descriptor.placeholder;
    picker.quickNavigate = options2 === null || options2 === void 0 ? void 0 : options2.quickNavigateConfiguration;
    picker.hideInput = !!picker.quickNavigate && !visibleQuickAccess;
    if (typeof (options2 === null || options2 === void 0 ? void 0 : options2.itemActivation) === "number" || (options2 === null || options2 === void 0 ? void 0 : options2.quickNavigateConfiguration)) {
      picker.itemActivation = (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.itemActivation) !== null && _a2 !== void 0 ? _a2 : ItemActivation.SECOND;
    }
    picker.contextKey = descriptor === null || descriptor === void 0 ? void 0 : descriptor.contextKey;
    picker.filterValue = (value2) => value2.substring(descriptor ? descriptor.prefix.length : 0);
    let pickPromise = void 0;
    if (pick) {
      pickPromise = new DeferredPromise();
      disposables.add(Event.once(picker.onWillAccept)((e) => {
        e.veto();
        picker.hide();
      }));
    }
    disposables.add(this.registerPickerListeners(picker, provider, descriptor, value, options2 === null || options2 === void 0 ? void 0 : options2.providerOptions));
    const cts = disposables.add(new CancellationTokenSource());
    if (provider) {
      disposables.add(provider.provide(picker, cts.token, options2 === null || options2 === void 0 ? void 0 : options2.providerOptions));
    }
    Event.once(picker.onDidHide)(() => {
      if (picker.selectedItems.length === 0) {
        cts.cancel();
      }
      disposables.dispose();
      pickPromise === null || pickPromise === void 0 ? void 0 : pickPromise.complete(picker.selectedItems.slice(0));
    });
    picker.show();
    if (pick) {
      return pickPromise === null || pickPromise === void 0 ? void 0 : pickPromise.p;
    }
  }
  adjustValueSelection(picker, descriptor, options2) {
    var _a2;
    let valueSelection;
    if (options2 === null || options2 === void 0 ? void 0 : options2.preserveValue) {
      valueSelection = [picker.value.length, picker.value.length];
    } else {
      valueSelection = [(_a2 = descriptor === null || descriptor === void 0 ? void 0 : descriptor.prefix.length) !== null && _a2 !== void 0 ? _a2 : 0, picker.value.length];
    }
    picker.valueSelection = valueSelection;
  }
  registerPickerListeners(picker, provider, descriptor, value, providerOptions) {
    const disposables = new DisposableStore();
    const visibleQuickAccess = this.visibleQuickAccess = { picker, descriptor, value };
    disposables.add(toDisposable(() => {
      if (visibleQuickAccess === this.visibleQuickAccess) {
        this.visibleQuickAccess = void 0;
      }
    }));
    disposables.add(picker.onDidChangeValue((value2) => {
      const [providerForValue] = this.getOrInstantiateProvider(value2);
      if (providerForValue !== provider) {
        this.show(value2, {
          // do not rewrite value from user typing!
          preserveValue: true,
          // persist the value of the providerOptions from the original showing
          providerOptions
        });
      } else {
        visibleQuickAccess.value = value2;
      }
    }));
    if (descriptor) {
      disposables.add(picker.onDidAccept(() => {
        this.lastAcceptedPickerValues.set(descriptor, picker.value);
      }));
    }
    return disposables;
  }
  getOrInstantiateProvider(value) {
    const providerDescriptor = this.registry.getQuickAccessProvider(value);
    if (!providerDescriptor) {
      return [void 0, void 0];
    }
    let provider = this.mapProviderToDescriptor.get(providerDescriptor);
    if (!provider) {
      provider = this.instantiationService.createInstance(providerDescriptor.ctor);
      this.mapProviderToDescriptor.set(providerDescriptor, provider);
    }
    return [provider, providerDescriptor];
  }
};
QuickAccessController = __decorate27([
  __param22(0, IQuickInputService),
  __param22(1, IInstantiationService)
], QuickAccessController);

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputService.js
init_colorRegistry();
init_themeService();

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInput.js
init_dom();
init_keyboardEvent();
init_arrays();
init_async();
init_codicons();
init_event();
init_lifecycle();
init_platform();
init_themables();
init_nls();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/platform/quickinput/browser/media/quickInput.css";

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputList.js
init_dom();
init_keyboardEvent();

// node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabel.js
init_dom();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconlabel.css";

// node_modules/monaco-editor/esm/vs/base/browser/ui/highlightedlabel/highlightedLabel.js
init_dom();
init_iconLabels();
init_objects();
var HighlightedLabel = class _HighlightedLabel {
  /**
   * Create a new {@link HighlightedLabel}.
   *
   * @param container The parent container to append to.
   */
  constructor(container, options2) {
    var _a2;
    this.text = "";
    this.title = "";
    this.highlights = [];
    this.didEverRender = false;
    this.supportIcons = (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.supportIcons) !== null && _a2 !== void 0 ? _a2 : false;
    this.domNode = append(container, $("span.monaco-highlighted-label"));
  }
  /**
   * The label's DOM node.
   */
  get element() {
    return this.domNode;
  }
  /**
   * Set the label and highlights.
   *
   * @param text The label to display.
   * @param highlights The ranges to highlight.
   * @param title An optional title for the hover tooltip.
   * @param escapeNewLines Whether to escape new lines.
   * @returns
   */
  set(text, highlights = [], title = "", escapeNewLines) {
    if (!text) {
      text = "";
    }
    if (escapeNewLines) {
      text = _HighlightedLabel.escapeNewLines(text, highlights);
    }
    if (this.didEverRender && this.text === text && this.title === title && equals2(this.highlights, highlights)) {
      return;
    }
    this.text = text;
    this.title = title;
    this.highlights = highlights;
    this.render();
  }
  render() {
    const children = [];
    let pos = 0;
    for (const highlight of this.highlights) {
      if (highlight.end === highlight.start) {
        continue;
      }
      if (pos < highlight.start) {
        const substring2 = this.text.substring(pos, highlight.start);
        if (this.supportIcons) {
          children.push(...renderLabelWithIcons(substring2));
        } else {
          children.push(substring2);
        }
        pos = highlight.start;
      }
      const substring = this.text.substring(pos, highlight.end);
      const element = $("span.highlight", void 0, ...this.supportIcons ? renderLabelWithIcons(substring) : [substring]);
      if (highlight.extraClasses) {
        element.classList.add(...highlight.extraClasses);
      }
      children.push(element);
      pos = highlight.end;
    }
    if (pos < this.text.length) {
      const substring = this.text.substring(pos);
      if (this.supportIcons) {
        children.push(...renderLabelWithIcons(substring));
      } else {
        children.push(substring);
      }
    }
    reset(this.domNode, ...children);
    if (this.title) {
      this.domNode.title = this.title;
    } else {
      this.domNode.removeAttribute("title");
    }
    this.didEverRender = true;
  }
  static escapeNewLines(text, highlights) {
    let total = 0;
    let extra = 0;
    return text.replace(/\r\n|\r|\n/g, (match2, offset) => {
      extra = match2 === "\r\n" ? -1 : 0;
      offset += total;
      for (const highlight of highlights) {
        if (highlight.end <= offset) {
          continue;
        }
        if (highlight.start >= offset) {
          highlight.start += extra;
        }
        if (highlight.end >= offset) {
          highlight.end += extra;
        }
      }
      total += extra;
      return "";
    });
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabel.js
init_lifecycle();
init_objects();
var FastLabelNode = class {
  constructor(_element) {
    this._element = _element;
  }
  get element() {
    return this._element;
  }
  set textContent(content) {
    if (this.disposed || content === this._textContent) {
      return;
    }
    this._textContent = content;
    this._element.textContent = content;
  }
  set className(className) {
    if (this.disposed || className === this._className) {
      return;
    }
    this._className = className;
    this._element.className = className;
  }
  set empty(empty) {
    if (this.disposed || empty === this._empty) {
      return;
    }
    this._empty = empty;
    this._element.style.marginLeft = empty ? "0" : "";
  }
  dispose() {
    this.disposed = true;
  }
};
var IconLabel = class extends Disposable {
  constructor(container, options2) {
    var _a2;
    super();
    this.customHovers = /* @__PURE__ */ new Map();
    this.creationOptions = options2;
    this.domNode = this._register(new FastLabelNode(append(container, $(".monaco-icon-label"))));
    this.labelContainer = append(this.domNode.element, $(".monaco-icon-label-container"));
    this.nameContainer = append(this.labelContainer, $("span.monaco-icon-name-container"));
    if ((options2 === null || options2 === void 0 ? void 0 : options2.supportHighlights) || (options2 === null || options2 === void 0 ? void 0 : options2.supportIcons)) {
      this.nameNode = new LabelWithHighlights(this.nameContainer, !!options2.supportIcons);
    } else {
      this.nameNode = new Label(this.nameContainer);
    }
    this.hoverDelegate = (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.hoverDelegate) !== null && _a2 !== void 0 ? _a2 : getDefaultHoverDelegate("mouse");
  }
  get element() {
    return this.domNode.element;
  }
  setLabel(label, description, options2) {
    var _a2;
    const labelClasses = ["monaco-icon-label"];
    const containerClasses = ["monaco-icon-label-container"];
    let ariaLabel = "";
    if (options2) {
      if (options2.extraClasses) {
        labelClasses.push(...options2.extraClasses);
      }
      if (options2.italic) {
        labelClasses.push("italic");
      }
      if (options2.strikethrough) {
        labelClasses.push("strikethrough");
      }
      if (options2.disabledCommand) {
        containerClasses.push("disabled");
      }
      if (options2.title) {
        if (typeof options2.title === "string") {
          ariaLabel += options2.title;
        } else {
          ariaLabel += label;
        }
      }
    }
    this.domNode.className = labelClasses.join(" ");
    this.domNode.element.setAttribute("aria-label", ariaLabel);
    this.labelContainer.className = containerClasses.join(" ");
    this.setupHover((options2 === null || options2 === void 0 ? void 0 : options2.descriptionTitle) ? this.labelContainer : this.element, options2 === null || options2 === void 0 ? void 0 : options2.title);
    this.nameNode.setLabel(label, options2);
    if (description || this.descriptionNode) {
      const descriptionNode = this.getOrCreateDescriptionNode();
      if (descriptionNode instanceof HighlightedLabel) {
        descriptionNode.set(description || "", options2 ? options2.descriptionMatches : void 0, void 0, options2 === null || options2 === void 0 ? void 0 : options2.labelEscapeNewLines);
        this.setupHover(descriptionNode.element, options2 === null || options2 === void 0 ? void 0 : options2.descriptionTitle);
      } else {
        descriptionNode.textContent = description && (options2 === null || options2 === void 0 ? void 0 : options2.labelEscapeNewLines) ? HighlightedLabel.escapeNewLines(description, []) : description || "";
        this.setupHover(descriptionNode.element, (options2 === null || options2 === void 0 ? void 0 : options2.descriptionTitle) || "");
        descriptionNode.empty = !description;
      }
    }
    if ((options2 === null || options2 === void 0 ? void 0 : options2.suffix) || this.suffixNode) {
      const suffixNode = this.getOrCreateSuffixNode();
      suffixNode.textContent = (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.suffix) !== null && _a2 !== void 0 ? _a2 : "";
    }
  }
  setupHover(htmlElement, tooltip) {
    const previousCustomHover = this.customHovers.get(htmlElement);
    if (previousCustomHover) {
      previousCustomHover.dispose();
      this.customHovers.delete(htmlElement);
    }
    if (!tooltip) {
      htmlElement.removeAttribute("title");
      return;
    }
    if (this.hoverDelegate.showNativeHover) {
      setupNativeHover(htmlElement, tooltip);
    } else {
      const hoverDisposable = setupCustomHover(this.hoverDelegate, htmlElement, tooltip);
      if (hoverDisposable) {
        this.customHovers.set(htmlElement, hoverDisposable);
      }
    }
  }
  dispose() {
    super.dispose();
    for (const disposable of this.customHovers.values()) {
      disposable.dispose();
    }
    this.customHovers.clear();
  }
  getOrCreateSuffixNode() {
    if (!this.suffixNode) {
      const suffixContainer = this._register(new FastLabelNode(after(this.nameContainer, $("span.monaco-icon-suffix-container"))));
      this.suffixNode = this._register(new FastLabelNode(append(suffixContainer.element, $("span.label-suffix"))));
    }
    return this.suffixNode;
  }
  getOrCreateDescriptionNode() {
    var _a2;
    if (!this.descriptionNode) {
      const descriptionContainer = this._register(new FastLabelNode(append(this.labelContainer, $("span.monaco-icon-description-container"))));
      if ((_a2 = this.creationOptions) === null || _a2 === void 0 ? void 0 : _a2.supportDescriptionHighlights) {
        this.descriptionNode = new HighlightedLabel(append(descriptionContainer.element, $("span.label-description")), { supportIcons: !!this.creationOptions.supportIcons });
      } else {
        this.descriptionNode = this._register(new FastLabelNode(append(descriptionContainer.element, $("span.label-description"))));
      }
    }
    return this.descriptionNode;
  }
};
var Label = class {
  constructor(container) {
    this.container = container;
    this.label = void 0;
    this.singleLabel = void 0;
  }
  setLabel(label, options2) {
    if (this.label === label && equals2(this.options, options2)) {
      return;
    }
    this.label = label;
    this.options = options2;
    if (typeof label === "string") {
      if (!this.singleLabel) {
        this.container.innerText = "";
        this.container.classList.remove("multiple");
        this.singleLabel = append(this.container, $("a.label-name", { id: options2 === null || options2 === void 0 ? void 0 : options2.domId }));
      }
      this.singleLabel.textContent = label;
    } else {
      this.container.innerText = "";
      this.container.classList.add("multiple");
      this.singleLabel = void 0;
      for (let i = 0; i < label.length; i++) {
        const l = label[i];
        const id = (options2 === null || options2 === void 0 ? void 0 : options2.domId) && `${options2 === null || options2 === void 0 ? void 0 : options2.domId}_${i}`;
        append(this.container, $("a.label-name", { id, "data-icon-label-count": label.length, "data-icon-label-index": i, "role": "treeitem" }, l));
        if (i < label.length - 1) {
          append(this.container, $("span.label-separator", void 0, (options2 === null || options2 === void 0 ? void 0 : options2.separator) || "/"));
        }
      }
    }
  }
};
function splitMatches(labels, separator, matches) {
  if (!matches) {
    return void 0;
  }
  let labelStart = 0;
  return labels.map((label) => {
    const labelRange = { start: labelStart, end: labelStart + label.length };
    const result = matches.map((match2) => Range.intersect(labelRange, match2)).filter((range2) => !Range.isEmpty(range2)).map(({ start, end }) => ({ start: start - labelStart, end: end - labelStart }));
    labelStart = labelRange.end + separator.length;
    return result;
  });
}
var LabelWithHighlights = class {
  constructor(container, supportIcons) {
    this.container = container;
    this.supportIcons = supportIcons;
    this.label = void 0;
    this.singleLabel = void 0;
  }
  setLabel(label, options2) {
    if (this.label === label && equals2(this.options, options2)) {
      return;
    }
    this.label = label;
    this.options = options2;
    if (typeof label === "string") {
      if (!this.singleLabel) {
        this.container.innerText = "";
        this.container.classList.remove("multiple");
        this.singleLabel = new HighlightedLabel(append(this.container, $("a.label-name", { id: options2 === null || options2 === void 0 ? void 0 : options2.domId })), { supportIcons: this.supportIcons });
      }
      this.singleLabel.set(label, options2 === null || options2 === void 0 ? void 0 : options2.matches, void 0, options2 === null || options2 === void 0 ? void 0 : options2.labelEscapeNewLines);
    } else {
      this.container.innerText = "";
      this.container.classList.add("multiple");
      this.singleLabel = void 0;
      const separator = (options2 === null || options2 === void 0 ? void 0 : options2.separator) || "/";
      const matches = splitMatches(label, separator, options2 === null || options2 === void 0 ? void 0 : options2.matches);
      for (let i = 0; i < label.length; i++) {
        const l = label[i];
        const m = matches ? matches[i] : void 0;
        const id = (options2 === null || options2 === void 0 ? void 0 : options2.domId) && `${options2 === null || options2 === void 0 ? void 0 : options2.domId}_${i}`;
        const name = $("a.label-name", { id, "data-icon-label-count": label.length, "data-icon-label-index": i, "role": "treeitem" });
        const highlightedLabel = new HighlightedLabel(append(this.container, name), { supportIcons: this.supportIcons });
        highlightedLabel.set(l, m, void 0, options2 === null || options2 === void 0 ? void 0 : options2.labelEscapeNewLines);
        if (i < label.length - 1) {
          append(name, $("span.label-separator", void 0, separator));
        }
      }
    }
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/keybindingLabel/keybindingLabel.js
init_dom();
init_objects();
init_nls();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/keybindingLabel/keybindingLabel.css";
var $6 = $;
var unthemedKeybindingLabelOptions = {
  keybindingLabelBackground: void 0,
  keybindingLabelForeground: void 0,
  keybindingLabelBorder: void 0,
  keybindingLabelBottomBorder: void 0,
  keybindingLabelShadow: void 0
};
var KeybindingLabel = class _KeybindingLabel {
  constructor(container, os, options2) {
    this.os = os;
    this.keyElements = /* @__PURE__ */ new Set();
    this.options = options2 || /* @__PURE__ */ Object.create(null);
    const labelForeground = this.options.keybindingLabelForeground;
    this.domNode = append(container, $6(".monaco-keybinding"));
    if (labelForeground) {
      this.domNode.style.color = labelForeground;
    }
    this.didEverRender = false;
    container.appendChild(this.domNode);
  }
  get element() {
    return this.domNode;
  }
  set(keybinding, matches) {
    if (this.didEverRender && this.keybinding === keybinding && _KeybindingLabel.areSame(this.matches, matches)) {
      return;
    }
    this.keybinding = keybinding;
    this.matches = matches;
    this.render();
  }
  render() {
    var _a2;
    this.clear();
    if (this.keybinding) {
      const chords = this.keybinding.getChords();
      if (chords[0]) {
        this.renderChord(this.domNode, chords[0], this.matches ? this.matches.firstPart : null);
      }
      for (let i = 1; i < chords.length; i++) {
        append(this.domNode, $6("span.monaco-keybinding-key-chord-separator", void 0, " "));
        this.renderChord(this.domNode, chords[i], this.matches ? this.matches.chordPart : null);
      }
      const title = ((_a2 = this.options.disableTitle) !== null && _a2 !== void 0 ? _a2 : false) ? void 0 : this.keybinding.getAriaLabel() || void 0;
      if (title !== void 0) {
        this.domNode.title = title;
      } else {
        this.domNode.removeAttribute("title");
      }
    } else if (this.options && this.options.renderUnboundKeybindings) {
      this.renderUnbound(this.domNode);
    }
    this.didEverRender = true;
  }
  clear() {
    clearNode(this.domNode);
    this.keyElements.clear();
  }
  renderChord(parent, chord, match2) {
    const modifierLabels = UILabelProvider.modifierLabels[this.os];
    if (chord.ctrlKey) {
      this.renderKey(parent, modifierLabels.ctrlKey, Boolean(match2 === null || match2 === void 0 ? void 0 : match2.ctrlKey), modifierLabels.separator);
    }
    if (chord.shiftKey) {
      this.renderKey(parent, modifierLabels.shiftKey, Boolean(match2 === null || match2 === void 0 ? void 0 : match2.shiftKey), modifierLabels.separator);
    }
    if (chord.altKey) {
      this.renderKey(parent, modifierLabels.altKey, Boolean(match2 === null || match2 === void 0 ? void 0 : match2.altKey), modifierLabels.separator);
    }
    if (chord.metaKey) {
      this.renderKey(parent, modifierLabels.metaKey, Boolean(match2 === null || match2 === void 0 ? void 0 : match2.metaKey), modifierLabels.separator);
    }
    const keyLabel = chord.keyLabel;
    if (keyLabel) {
      this.renderKey(parent, keyLabel, Boolean(match2 === null || match2 === void 0 ? void 0 : match2.keyCode), "");
    }
  }
  renderKey(parent, label, highlight, separator) {
    append(parent, this.createKeyElement(label, highlight ? ".highlight" : ""));
    if (separator) {
      append(parent, $6("span.monaco-keybinding-key-separator", void 0, separator));
    }
  }
  renderUnbound(parent) {
    append(parent, this.createKeyElement(localize("unbound", "Unbound")));
  }
  createKeyElement(label, extraClass = "") {
    const keyElement = $6("span.monaco-keybinding-key" + extraClass, void 0, label);
    this.keyElements.add(keyElement);
    if (this.options.keybindingLabelBackground) {
      keyElement.style.backgroundColor = this.options.keybindingLabelBackground;
    }
    if (this.options.keybindingLabelBorder) {
      keyElement.style.borderColor = this.options.keybindingLabelBorder;
    }
    if (this.options.keybindingLabelBottomBorder) {
      keyElement.style.borderBottomColor = this.options.keybindingLabelBottomBorder;
    }
    if (this.options.keybindingLabelShadow) {
      keyElement.style.boxShadow = `inset 0 -1px 0 ${this.options.keybindingLabelShadow}`;
    }
    return keyElement;
  }
  static areSame(a, b) {
    if (a === b || !a && !b) {
      return true;
    }
    return !!a && !!b && equals2(a.firstPart, b.firstPart) && equals2(a.chordPart, b.chordPart);
  }
};

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputList.js
init_arrays();
init_async();

// node_modules/monaco-editor/esm/vs/base/common/comparers.js
init_lazy();
var intlFileNameCollatorBaseNumeric = new Lazy(() => {
  const collator = new Intl.Collator(void 0, { numeric: true, sensitivity: "base" });
  return {
    collator,
    collatorIsNumeric: collator.resolvedOptions().numeric
  };
});
var intlFileNameCollatorNumeric = new Lazy(() => {
  const collator = new Intl.Collator(void 0, { numeric: true });
  return {
    collator
  };
});
var intlFileNameCollatorNumericCaseInsensitive = new Lazy(() => {
  const collator = new Intl.Collator(void 0, { numeric: true, sensitivity: "accent" });
  return {
    collator
  };
});
function compareFileNames(one, other, caseSensitive = false) {
  const a = one || "";
  const b = other || "";
  const result = intlFileNameCollatorBaseNumeric.value.collator.compare(a, b);
  if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && a !== b) {
    return a < b ? -1 : 1;
  }
  return result;
}
function compareAnything(one, other, lookFor) {
  const elementAName = one.toLowerCase();
  const elementBName = other.toLowerCase();
  const prefixCompare = compareByPrefix(one, other, lookFor);
  if (prefixCompare) {
    return prefixCompare;
  }
  const elementASuffixMatch = elementAName.endsWith(lookFor);
  const elementBSuffixMatch = elementBName.endsWith(lookFor);
  if (elementASuffixMatch !== elementBSuffixMatch) {
    return elementASuffixMatch ? -1 : 1;
  }
  const r = compareFileNames(elementAName, elementBName);
  if (r !== 0) {
    return r;
  }
  return elementAName.localeCompare(elementBName);
}
function compareByPrefix(one, other, lookFor) {
  const elementAName = one.toLowerCase();
  const elementBName = other.toLowerCase();
  const elementAPrefixMatch = elementAName.startsWith(lookFor);
  const elementBPrefixMatch = elementBName.startsWith(lookFor);
  if (elementAPrefixMatch !== elementBPrefixMatch) {
    return elementAPrefixMatch ? -1 : 1;
  } else if (elementAPrefixMatch && elementBPrefixMatch) {
    if (elementAName.length < elementBName.length) {
      return -1;
    }
    if (elementAName.length > elementBName.length) {
      return 1;
    }
  }
  return 0;
}

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputList.js
init_errors();
init_event();
init_iconLabels2();
init_lifecycle();
init_platform();
init_strings();
init_nls();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/platform/quickinput/browser/media/quickInput.css";

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputUtils.js
init_dom();
init_event();
init_keyboardEvent();
init_iconLabels();

// node_modules/monaco-editor/esm/vs/base/common/linkedText.js
var __decorate28 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var LinkedText = class {
  constructor(nodes) {
    this.nodes = nodes;
  }
  toString() {
    return this.nodes.map((node) => typeof node === "string" ? node : node.label).join("");
  }
};
__decorate28([
  memoize
], LinkedText.prototype, "toString", null);
var LINK_REGEX = /\[([^\]]+)\]\(((?:https?:\/\/|command:|file:)[^\)\s]+)(?: (["'])(.+?)(\3))?\)/gi;
function parseLinkedText(text) {
  const result = [];
  let index = 0;
  let match2;
  while (match2 = LINK_REGEX.exec(text)) {
    if (match2.index - index > 0) {
      result.push(text.substring(index, match2.index));
    }
    const [, label, href, , title] = match2;
    if (title) {
      result.push({ label, href, title });
    } else {
      result.push({ label, href });
    }
    index = match2.index + match2[0].length;
  }
  if (index < text.length) {
    result.push(text.substring(index));
  }
  return new LinkedText(result);
}

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputUtils.js
init_nls();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/platform/quickinput/browser/media/quickInput.css";
var iconPathToClass = {};
var iconClassGenerator = new IdGenerator("quick-input-button-icon-");
function getIconClass(iconPath) {
  if (!iconPath) {
    return void 0;
  }
  let iconClass;
  const key = iconPath.dark.toString();
  if (iconPathToClass[key]) {
    iconClass = iconPathToClass[key];
  } else {
    iconClass = iconClassGenerator.nextId();
    createCSSRule(`.${iconClass}, .hc-light .${iconClass}`, `background-image: ${asCSSUrl(iconPath.light || iconPath.dark)}`);
    createCSSRule(`.vs-dark .${iconClass}, .hc-black .${iconClass}`, `background-image: ${asCSSUrl(iconPath.dark)}`);
    iconPathToClass[key] = iconClass;
  }
  return iconClass;
}
function quickInputButtonToAction(button, id, run) {
  let cssClasses = button.iconClass || getIconClass(button.iconPath);
  if (button.alwaysVisible) {
    cssClasses = cssClasses ? `${cssClasses} always-visible` : "always-visible";
  }
  return {
    id,
    label: "",
    tooltip: button.tooltip || "",
    class: cssClasses,
    enabled: true,
    run
  };
}
function renderQuickInputDescription(description, container, actionHandler) {
  reset(container);
  const parsed = parseLinkedText(description);
  let tabIndex = 0;
  for (const node of parsed.nodes) {
    if (typeof node === "string") {
      container.append(...renderLabelWithIcons(node));
    } else {
      let title = node.title;
      if (!title && node.href.startsWith("command:")) {
        title = localize("executeCommand", "Click to execute command '{0}'", node.href.substring("command:".length));
      } else if (!title) {
        title = node.href;
      }
      const anchor = $("a", { href: node.href, title, tabIndex: tabIndex++ }, node.label);
      anchor.style.textDecoration = "underline";
      const handleOpen = (e) => {
        if (isEventLike(e)) {
          EventHelper.stop(e, true);
        }
        actionHandler.callback(node.href);
      };
      const onClick = actionHandler.disposables.add(new DomEmitter(anchor, EventType.CLICK)).event;
      const onKeydown = actionHandler.disposables.add(new DomEmitter(anchor, EventType.KEY_DOWN)).event;
      const onSpaceOrEnter = Event.chain(onKeydown, ($10) => $10.filter((e) => {
        const event = new StandardKeyboardEvent(e);
        return event.equals(
          10
          /* KeyCode.Space */
        ) || event.equals(
          3
          /* KeyCode.Enter */
        );
      }));
      actionHandler.disposables.add(Gesture.addTarget(anchor));
      const onTap = actionHandler.disposables.add(new DomEmitter(anchor, EventType2.Tap)).event;
      Event.any(onClick, onTap, onSpaceOrEnter)(handleOpen, null, actionHandler.disposables);
      container.appendChild(anchor);
    }
  }
}

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputList.js
init_lazy();
init_uri();
init_theme();
var __decorate29 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var $7 = $;
var ListElement = class {
  constructor(mainItem, previous, index, hasCheckbox, fireButtonTriggered, fireSeparatorButtonTriggered, onCheckedEmitter) {
    var _a2, _b2, _c;
    this._checked = false;
    this._hidden = false;
    this.hasCheckbox = hasCheckbox;
    this.index = index;
    this.fireButtonTriggered = fireButtonTriggered;
    this.fireSeparatorButtonTriggered = fireSeparatorButtonTriggered;
    this._onChecked = onCheckedEmitter;
    this.onChecked = hasCheckbox ? Event.map(Event.filter(this._onChecked.event, (e) => e.listElement === this), (e) => e.checked) : Event.None;
    if (mainItem.type === "separator") {
      this._separator = mainItem;
    } else {
      this.item = mainItem;
      if (previous && previous.type === "separator" && !previous.buttons) {
        this._separator = previous;
      }
      this.saneDescription = this.item.description;
      this.saneDetail = this.item.detail;
      this._labelHighlights = (_a2 = this.item.highlights) === null || _a2 === void 0 ? void 0 : _a2.label;
      this._descriptionHighlights = (_b2 = this.item.highlights) === null || _b2 === void 0 ? void 0 : _b2.description;
      this._detailHighlights = (_c = this.item.highlights) === null || _c === void 0 ? void 0 : _c.detail;
      this.saneTooltip = this.item.tooltip;
    }
    this._init = new Lazy(() => {
      var _a3;
      const saneLabel = (_a3 = mainItem.label) !== null && _a3 !== void 0 ? _a3 : "";
      const saneSortLabel = parseLabelWithIcons(saneLabel).text.trim();
      const saneAriaLabel = mainItem.ariaLabel || [saneLabel, this.saneDescription, this.saneDetail].map((s) => getCodiconAriaLabel(s)).filter((s) => !!s).join(", ");
      return {
        saneLabel,
        saneSortLabel,
        saneAriaLabel
      };
    });
  }
  // #region Lazy Getters
  get saneLabel() {
    return this._init.value.saneLabel;
  }
  get saneSortLabel() {
    return this._init.value.saneSortLabel;
  }
  get saneAriaLabel() {
    return this._init.value.saneAriaLabel;
  }
  // #endregion
  // #region Getters and Setters
  get element() {
    return this._element;
  }
  set element(value) {
    this._element = value;
  }
  get hidden() {
    return this._hidden;
  }
  set hidden(value) {
    this._hidden = value;
  }
  get checked() {
    return this._checked;
  }
  set checked(value) {
    if (value !== this._checked) {
      this._checked = value;
      this._onChecked.fire({ listElement: this, checked: value });
    }
  }
  get separator() {
    return this._separator;
  }
  set separator(value) {
    this._separator = value;
  }
  get labelHighlights() {
    return this._labelHighlights;
  }
  set labelHighlights(value) {
    this._labelHighlights = value;
  }
  get descriptionHighlights() {
    return this._descriptionHighlights;
  }
  set descriptionHighlights(value) {
    this._descriptionHighlights = value;
  }
  get detailHighlights() {
    return this._detailHighlights;
  }
  set detailHighlights(value) {
    this._detailHighlights = value;
  }
};
var ListElementRenderer = class _ListElementRenderer {
  constructor(themeService, hoverDelegate) {
    this.themeService = themeService;
    this.hoverDelegate = hoverDelegate;
  }
  get templateId() {
    return _ListElementRenderer.ID;
  }
  renderTemplate(container) {
    const data = /* @__PURE__ */ Object.create(null);
    data.toDisposeElement = [];
    data.toDisposeTemplate = [];
    data.entry = append(container, $7(".quick-input-list-entry"));
    const label = append(data.entry, $7("label.quick-input-list-label"));
    data.toDisposeTemplate.push(addStandardDisposableListener(label, EventType.CLICK, (e) => {
      if (!data.checkbox.offsetParent) {
        e.preventDefault();
      }
    }));
    data.checkbox = append(label, $7("input.quick-input-list-checkbox"));
    data.checkbox.type = "checkbox";
    data.toDisposeTemplate.push(addStandardDisposableListener(data.checkbox, EventType.CHANGE, (e) => {
      data.element.checked = data.checkbox.checked;
    }));
    const rows = append(label, $7(".quick-input-list-rows"));
    const row1 = append(rows, $7(".quick-input-list-row"));
    const row2 = append(rows, $7(".quick-input-list-row"));
    data.label = new IconLabel(row1, { supportHighlights: true, supportDescriptionHighlights: true, supportIcons: true, hoverDelegate: this.hoverDelegate });
    data.toDisposeTemplate.push(data.label);
    data.icon = prepend(data.label.element, $7(".quick-input-list-icon"));
    const keybindingContainer = append(row1, $7(".quick-input-list-entry-keybinding"));
    data.keybinding = new KeybindingLabel(keybindingContainer, OS);
    const detailContainer = append(row2, $7(".quick-input-list-label-meta"));
    data.detail = new IconLabel(detailContainer, { supportHighlights: true, supportIcons: true, hoverDelegate: this.hoverDelegate });
    data.toDisposeTemplate.push(data.detail);
    data.separator = append(data.entry, $7(".quick-input-list-separator"));
    data.actionBar = new ActionBar(data.entry, this.hoverDelegate ? { hoverDelegate: this.hoverDelegate } : void 0);
    data.actionBar.domNode.classList.add("quick-input-list-entry-action-bar");
    data.toDisposeTemplate.push(data.actionBar);
    return data;
  }
  renderElement(element, index, data) {
    var _a2, _b2, _c, _d;
    data.element = element;
    element.element = (_a2 = data.entry) !== null && _a2 !== void 0 ? _a2 : void 0;
    const mainItem = element.item ? element.item : element.separator;
    data.checkbox.checked = element.checked;
    data.toDisposeElement.push(element.onChecked((checked) => data.checkbox.checked = checked));
    const { labelHighlights, descriptionHighlights, detailHighlights } = element;
    if ((_b2 = element.item) === null || _b2 === void 0 ? void 0 : _b2.iconPath) {
      const icon = isDark(this.themeService.getColorTheme().type) ? element.item.iconPath.dark : (_c = element.item.iconPath.light) !== null && _c !== void 0 ? _c : element.item.iconPath.dark;
      const iconUrl = URI.revive(icon);
      data.icon.className = "quick-input-list-icon";
      data.icon.style.backgroundImage = asCSSUrl(iconUrl);
    } else {
      data.icon.style.backgroundImage = "";
      data.icon.className = ((_d = element.item) === null || _d === void 0 ? void 0 : _d.iconClass) ? `quick-input-list-icon ${element.item.iconClass}` : "";
    }
    let descriptionTitle;
    if (!element.saneTooltip && element.saneDescription) {
      descriptionTitle = {
        markdown: {
          value: element.saneDescription,
          supportThemeIcons: true
        },
        markdownNotSupportedFallback: element.saneDescription
      };
    }
    const options2 = {
      matches: labelHighlights || [],
      // If we have a tooltip, we want that to be shown and not any other hover
      descriptionTitle,
      descriptionMatches: descriptionHighlights || [],
      labelEscapeNewLines: true
    };
    if (mainItem.type !== "separator") {
      options2.extraClasses = mainItem.iconClasses;
      options2.italic = mainItem.italic;
      options2.strikethrough = mainItem.strikethrough;
      data.entry.classList.remove("quick-input-list-separator-as-item");
    } else {
      data.entry.classList.add("quick-input-list-separator-as-item");
    }
    data.label.setLabel(element.saneLabel, element.saneDescription, options2);
    data.keybinding.set(mainItem.type === "separator" ? void 0 : mainItem.keybinding);
    if (element.saneDetail) {
      let title;
      if (!element.saneTooltip) {
        title = {
          markdown: {
            value: element.saneDetail,
            supportThemeIcons: true
          },
          markdownNotSupportedFallback: element.saneDetail
        };
      }
      data.detail.element.style.display = "";
      data.detail.setLabel(element.saneDetail, void 0, {
        matches: detailHighlights,
        title,
        labelEscapeNewLines: true
      });
    } else {
      data.detail.element.style.display = "none";
    }
    if (element.item && element.separator && element.separator.label) {
      data.separator.textContent = element.separator.label;
      data.separator.style.display = "";
    } else {
      data.separator.style.display = "none";
    }
    data.entry.classList.toggle("quick-input-list-separator-border", !!element.separator);
    const buttons = mainItem.buttons;
    if (buttons && buttons.length) {
      data.actionBar.push(buttons.map((button, index2) => quickInputButtonToAction(button, `id-${index2}`, () => mainItem.type !== "separator" ? element.fireButtonTriggered({ button, item: mainItem }) : element.fireSeparatorButtonTriggered({ button, separator: mainItem }))), { icon: true, label: false });
      data.entry.classList.add("has-actions");
    } else {
      data.entry.classList.remove("has-actions");
    }
  }
  disposeElement(element, index, data) {
    data.toDisposeElement = dispose(data.toDisposeElement);
    data.actionBar.clear();
  }
  disposeTemplate(data) {
    data.toDisposeElement = dispose(data.toDisposeElement);
    data.toDisposeTemplate = dispose(data.toDisposeTemplate);
  }
};
ListElementRenderer.ID = "listelement";
var ListElementDelegate = class {
  getHeight(element) {
    if (!element.item) {
      return 24;
    }
    return element.saneDetail ? 44 : 22;
  }
  getTemplateId(element) {
    return ListElementRenderer.ID;
  }
};
var QuickInputListFocus;
(function(QuickInputListFocus2) {
  QuickInputListFocus2[QuickInputListFocus2["First"] = 1] = "First";
  QuickInputListFocus2[QuickInputListFocus2["Second"] = 2] = "Second";
  QuickInputListFocus2[QuickInputListFocus2["Last"] = 3] = "Last";
  QuickInputListFocus2[QuickInputListFocus2["Next"] = 4] = "Next";
  QuickInputListFocus2[QuickInputListFocus2["Previous"] = 5] = "Previous";
  QuickInputListFocus2[QuickInputListFocus2["NextPage"] = 6] = "NextPage";
  QuickInputListFocus2[QuickInputListFocus2["PreviousPage"] = 7] = "PreviousPage";
})(QuickInputListFocus || (QuickInputListFocus = {}));
var QuickInputList = class {
  constructor(parent, id, options2, themeService) {
    this.parent = parent;
    this.options = options2;
    this.inputElements = [];
    this.elements = [];
    this.elementsToIndexes = /* @__PURE__ */ new Map();
    this.matchOnDescription = false;
    this.matchOnDetail = false;
    this.matchOnLabel = true;
    this.matchOnLabelMode = "fuzzy";
    this.sortByLabel = true;
    this._onChangedAllVisibleChecked = new Emitter();
    this.onChangedAllVisibleChecked = this._onChangedAllVisibleChecked.event;
    this._onChangedCheckedCount = new Emitter();
    this.onChangedCheckedCount = this._onChangedCheckedCount.event;
    this._onChangedVisibleCount = new Emitter();
    this.onChangedVisibleCount = this._onChangedVisibleCount.event;
    this._onChangedCheckedElements = new Emitter();
    this.onChangedCheckedElements = this._onChangedCheckedElements.event;
    this._onButtonTriggered = new Emitter();
    this.onButtonTriggered = this._onButtonTriggered.event;
    this._onSeparatorButtonTriggered = new Emitter();
    this.onSeparatorButtonTriggered = this._onSeparatorButtonTriggered.event;
    this._onKeyDown = new Emitter();
    this.onKeyDown = this._onKeyDown.event;
    this._onLeave = new Emitter();
    this.onLeave = this._onLeave.event;
    this._listElementChecked = new Emitter();
    this._fireCheckedEvents = true;
    this.elementDisposables = [];
    this.disposables = [];
    this.id = id;
    this.container = append(this.parent, $7(".quick-input-list"));
    const delegate = new ListElementDelegate();
    const accessibilityProvider = new QuickInputAccessibilityProvider();
    this.list = options2.createList("QuickInput", this.container, delegate, [new ListElementRenderer(themeService, options2.hoverDelegate)], {
      identityProvider: {
        getId: (element) => {
          var _a2, _b2, _c, _d, _e, _f, _g, _h;
          return (_h = (_f = (_d = (_b2 = (_a2 = element.item) === null || _a2 === void 0 ? void 0 : _a2.id) !== null && _b2 !== void 0 ? _b2 : (_c = element.item) === null || _c === void 0 ? void 0 : _c.label) !== null && _d !== void 0 ? _d : (_e = element.separator) === null || _e === void 0 ? void 0 : _e.id) !== null && _f !== void 0 ? _f : (_g = element.separator) === null || _g === void 0 ? void 0 : _g.label) !== null && _h !== void 0 ? _h : "";
        }
      },
      setRowLineHeight: false,
      multipleSelectionSupport: false,
      horizontalScrolling: false,
      accessibilityProvider
    });
    this.list.getHTMLElement().id = id;
    this.disposables.push(this.list);
    this.disposables.push(this.list.onKeyDown((e) => {
      const event = new StandardKeyboardEvent(e);
      switch (event.keyCode) {
        case 10:
          this.toggleCheckbox();
          break;
        case 31:
          if (isMacintosh ? e.metaKey : e.ctrlKey) {
            this.list.setFocus(range(this.list.length));
          }
          break;
        case 16: {
          const focus1 = this.list.getFocus();
          if (focus1.length === 1 && focus1[0] === 0) {
            this._onLeave.fire();
          }
          break;
        }
        case 18: {
          const focus2 = this.list.getFocus();
          if (focus2.length === 1 && focus2[0] === this.list.length - 1) {
            this._onLeave.fire();
          }
          break;
        }
      }
      this._onKeyDown.fire(event);
    }));
    this.disposables.push(this.list.onMouseDown((e) => {
      if (e.browserEvent.button !== 2) {
        e.browserEvent.preventDefault();
      }
    }));
    this.disposables.push(addDisposableListener(this.container, EventType.CLICK, (e) => {
      if (e.x || e.y) {
        this._onLeave.fire();
      }
    }));
    this.disposables.push(this.list.onMouseMiddleClick((e) => {
      this._onLeave.fire();
    }));
    this.disposables.push(this.list.onContextMenu((e) => {
      if (typeof e.index === "number") {
        e.browserEvent.preventDefault();
        this.list.setSelection([e.index]);
      }
    }));
    const delayer3 = new ThrottledDelayer(options2.hoverDelegate.delay);
    this.disposables.push(this.list.onMouseOver(async (e) => {
      var _a2;
      if (e.browserEvent.target instanceof HTMLAnchorElement) {
        delayer3.cancel();
        return;
      }
      if (
        // anchors are an exception as called out above so we skip them here
        !(e.browserEvent.relatedTarget instanceof HTMLAnchorElement) && // check if the mouse is still over the same element
        isAncestor(e.browserEvent.relatedTarget, (_a2 = e.element) === null || _a2 === void 0 ? void 0 : _a2.element)
      ) {
        return;
      }
      try {
        await delayer3.trigger(async () => {
          if (e.element) {
            this.showHover(e.element);
          }
        });
      } catch (e2) {
        if (!isCancellationError(e2)) {
          throw e2;
        }
      }
    }));
    this.disposables.push(this.list.onMouseOut((e) => {
      var _a2;
      if (isAncestor(e.browserEvent.relatedTarget, (_a2 = e.element) === null || _a2 === void 0 ? void 0 : _a2.element)) {
        return;
      }
      delayer3.cancel();
    }));
    this.disposables.push(delayer3);
    this.disposables.push(this._listElementChecked.event((_) => this.fireCheckedEvents()));
    this.disposables.push(this._onChangedAllVisibleChecked, this._onChangedCheckedCount, this._onChangedVisibleCount, this._onChangedCheckedElements, this._onButtonTriggered, this._onSeparatorButtonTriggered, this._onLeave, this._onKeyDown);
  }
  get onDidChangeFocus() {
    return Event.map(this.list.onDidChangeFocus, (e) => e.elements.map((e2) => e2.item));
  }
  get onDidChangeSelection() {
    return Event.map(this.list.onDidChangeSelection, (e) => ({ items: e.elements.map((e2) => e2.item), event: e.browserEvent }));
  }
  get scrollTop() {
    return this.list.scrollTop;
  }
  set scrollTop(scrollTop) {
    this.list.scrollTop = scrollTop;
  }
  get ariaLabel() {
    return this.list.getHTMLElement().ariaLabel;
  }
  set ariaLabel(label) {
    this.list.getHTMLElement().ariaLabel = label;
  }
  getAllVisibleChecked() {
    return this.allVisibleChecked(this.elements, false);
  }
  allVisibleChecked(elements, whenNoneVisible = true) {
    for (let i = 0, n = elements.length; i < n; i++) {
      const element = elements[i];
      if (!element.hidden) {
        if (!element.checked) {
          return false;
        } else {
          whenNoneVisible = true;
        }
      }
    }
    return whenNoneVisible;
  }
  getCheckedCount() {
    let count = 0;
    const elements = this.elements;
    for (let i = 0, n = elements.length; i < n; i++) {
      if (elements[i].checked) {
        count++;
      }
    }
    return count;
  }
  getVisibleCount() {
    let count = 0;
    const elements = this.elements;
    for (let i = 0, n = elements.length; i < n; i++) {
      if (!elements[i].hidden) {
        count++;
      }
    }
    return count;
  }
  setAllVisibleChecked(checked) {
    try {
      this._fireCheckedEvents = false;
      this.elements.forEach((element) => {
        if (!element.hidden) {
          element.checked = checked;
        }
      });
    } finally {
      this._fireCheckedEvents = true;
      this.fireCheckedEvents();
    }
  }
  setElements(inputElements) {
    this.elementDisposables = dispose(this.elementDisposables);
    const fireButtonTriggered = (event) => this.fireButtonTriggered(event);
    const fireSeparatorButtonTriggered = (event) => this.fireSeparatorButtonTriggered(event);
    this.inputElements = inputElements;
    const elementsToIndexes = /* @__PURE__ */ new Map();
    const hasCheckbox = this.parent.classList.contains("show-checkboxes");
    this.elements = inputElements.reduce((result, item, index) => {
      var _a2;
      const previous = index > 0 ? inputElements[index - 1] : void 0;
      if (item.type === "separator") {
        if (!item.buttons) {
          return result;
        }
      }
      const element = new ListElement(item, previous, index, hasCheckbox, fireButtonTriggered, fireSeparatorButtonTriggered, this._listElementChecked);
      const resultIndex = result.length;
      result.push(element);
      elementsToIndexes.set((_a2 = element.item) !== null && _a2 !== void 0 ? _a2 : element.separator, resultIndex);
      return result;
    }, []);
    this.elementsToIndexes = elementsToIndexes;
    this.list.splice(0, this.list.length);
    this.list.splice(0, this.list.length, this.elements);
    this._onChangedVisibleCount.fire(this.elements.length);
  }
  getFocusedElements() {
    return this.list.getFocusedElements().map((e) => e.item);
  }
  setFocusedElements(items) {
    this.list.setFocus(items.filter((item) => this.elementsToIndexes.has(item)).map((item) => this.elementsToIndexes.get(item)));
    if (items.length > 0) {
      const focused = this.list.getFocus()[0];
      if (typeof focused === "number") {
        this.list.reveal(focused);
      }
    }
  }
  getActiveDescendant() {
    return this.list.getHTMLElement().getAttribute("aria-activedescendant");
  }
  setSelectedElements(items) {
    this.list.setSelection(items.filter((item) => this.elementsToIndexes.has(item)).map((item) => this.elementsToIndexes.get(item)));
  }
  getCheckedElements() {
    return this.elements.filter((e) => e.checked).map((e) => e.item).filter((e) => !!e);
  }
  setCheckedElements(items) {
    try {
      this._fireCheckedEvents = false;
      const checked = /* @__PURE__ */ new Set();
      for (const item of items) {
        checked.add(item);
      }
      for (const element of this.elements) {
        element.checked = checked.has(element.item);
      }
    } finally {
      this._fireCheckedEvents = true;
      this.fireCheckedEvents();
    }
  }
  set enabled(value) {
    this.list.getHTMLElement().style.pointerEvents = value ? "" : "none";
  }
  focus(what) {
    if (!this.list.length) {
      return;
    }
    if (what === QuickInputListFocus.Second && this.list.length < 2) {
      what = QuickInputListFocus.First;
    }
    switch (what) {
      case QuickInputListFocus.First:
        this.list.scrollTop = 0;
        this.list.focusFirst(void 0, (e) => !!e.item);
        break;
      case QuickInputListFocus.Second:
        this.list.scrollTop = 0;
        this.list.focusNth(1, void 0, (e) => !!e.item);
        break;
      case QuickInputListFocus.Last:
        this.list.scrollTop = this.list.scrollHeight;
        this.list.focusLast(void 0, (e) => !!e.item);
        break;
      case QuickInputListFocus.Next: {
        this.list.focusNext(void 0, true, void 0, (e) => !!e.item);
        const index = this.list.getFocus()[0];
        if (index !== 0 && !this.elements[index - 1].item && this.list.firstVisibleIndex > index - 1) {
          this.list.reveal(index - 1);
        }
        break;
      }
      case QuickInputListFocus.Previous: {
        this.list.focusPrevious(void 0, true, void 0, (e) => !!e.item);
        const index = this.list.getFocus()[0];
        if (index !== 0 && !this.elements[index - 1].item && this.list.firstVisibleIndex > index - 1) {
          this.list.reveal(index - 1);
        }
        break;
      }
      case QuickInputListFocus.NextPage:
        this.list.focusNextPage(void 0, (e) => !!e.item);
        break;
      case QuickInputListFocus.PreviousPage:
        this.list.focusPreviousPage(void 0, (e) => !!e.item);
        break;
    }
    const focused = this.list.getFocus()[0];
    if (typeof focused === "number") {
      this.list.reveal(focused);
    }
  }
  clearFocus() {
    this.list.setFocus([]);
  }
  domFocus() {
    this.list.domFocus();
  }
  /**
   * Disposes of the hover and shows a new one for the given index if it has a tooltip.
   * @param element The element to show the hover for
   */
  showHover(element) {
    var _a2, _b2, _c;
    if (this._lastHover && !this._lastHover.isDisposed) {
      (_b2 = (_a2 = this.options.hoverDelegate).onDidHideHover) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      (_c = this._lastHover) === null || _c === void 0 ? void 0 : _c.dispose();
    }
    if (!element.element || !element.saneTooltip) {
      return;
    }
    this._lastHover = this.options.hoverDelegate.showHover({
      content: element.saneTooltip,
      target: element.element,
      linkHandler: (url) => {
        this.options.linkOpenerDelegate(url);
      },
      appearance: {
        showPointer: true
      },
      container: this.container,
      position: {
        hoverPosition: 1
        /* HoverPosition.RIGHT */
      }
    }, false);
  }
  layout(maxHeight) {
    this.list.getHTMLElement().style.maxHeight = maxHeight ? `${// Make sure height aligns with list item heights
    Math.floor(maxHeight / 44) * 44 + 6}px` : "";
    this.list.layout();
  }
  filter(query) {
    if (!(this.sortByLabel || this.matchOnLabel || this.matchOnDescription || this.matchOnDetail)) {
      this.list.layout();
      return false;
    }
    const queryWithWhitespace = query;
    query = query.trim();
    if (!query || !(this.matchOnLabel || this.matchOnDescription || this.matchOnDetail)) {
      this.elements.forEach((element) => {
        element.labelHighlights = void 0;
        element.descriptionHighlights = void 0;
        element.detailHighlights = void 0;
        element.hidden = false;
        const previous = element.index && this.inputElements[element.index - 1];
        if (element.item) {
          element.separator = previous && previous.type === "separator" && !previous.buttons ? previous : void 0;
        }
      });
    } else {
      let currentSeparator;
      this.elements.forEach((element) => {
        var _a2, _b2, _c, _d;
        let labelHighlights;
        if (this.matchOnLabelMode === "fuzzy") {
          labelHighlights = this.matchOnLabel ? (_a2 = matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneLabel))) !== null && _a2 !== void 0 ? _a2 : void 0 : void 0;
        } else {
          labelHighlights = this.matchOnLabel ? (_b2 = matchesContiguousIconAware(queryWithWhitespace, parseLabelWithIcons(element.saneLabel))) !== null && _b2 !== void 0 ? _b2 : void 0 : void 0;
        }
        const descriptionHighlights = this.matchOnDescription ? (_c = matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneDescription || ""))) !== null && _c !== void 0 ? _c : void 0 : void 0;
        const detailHighlights = this.matchOnDetail ? (_d = matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneDetail || ""))) !== null && _d !== void 0 ? _d : void 0 : void 0;
        if (labelHighlights || descriptionHighlights || detailHighlights) {
          element.labelHighlights = labelHighlights;
          element.descriptionHighlights = descriptionHighlights;
          element.detailHighlights = detailHighlights;
          element.hidden = false;
        } else {
          element.labelHighlights = void 0;
          element.descriptionHighlights = void 0;
          element.detailHighlights = void 0;
          element.hidden = element.item ? !element.item.alwaysShow : true;
        }
        if (element.item) {
          element.separator = void 0;
        } else if (element.separator) {
          element.hidden = true;
        }
        if (!this.sortByLabel) {
          const previous = element.index && this.inputElements[element.index - 1];
          currentSeparator = previous && previous.type === "separator" ? previous : currentSeparator;
          if (currentSeparator && !element.hidden) {
            element.separator = currentSeparator;
            currentSeparator = void 0;
          }
        }
      });
    }
    const shownElements = this.elements.filter((element) => !element.hidden);
    if (this.sortByLabel && query) {
      const normalizedSearchValue = query.toLowerCase();
      shownElements.sort((a, b) => {
        return compareEntries(a, b, normalizedSearchValue);
      });
    }
    this.elementsToIndexes = shownElements.reduce((map, element, index) => {
      var _a2;
      map.set((_a2 = element.item) !== null && _a2 !== void 0 ? _a2 : element.separator, index);
      return map;
    }, /* @__PURE__ */ new Map());
    this.list.splice(0, this.list.length, shownElements);
    this.list.setFocus([]);
    this.list.layout();
    this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked());
    this._onChangedVisibleCount.fire(shownElements.length);
    return true;
  }
  toggleCheckbox() {
    try {
      this._fireCheckedEvents = false;
      const elements = this.list.getFocusedElements();
      const allChecked = this.allVisibleChecked(elements);
      for (const element of elements) {
        element.checked = !allChecked;
      }
    } finally {
      this._fireCheckedEvents = true;
      this.fireCheckedEvents();
    }
  }
  display(display) {
    this.container.style.display = display ? "" : "none";
  }
  isDisplayed() {
    return this.container.style.display !== "none";
  }
  dispose() {
    this.elementDisposables = dispose(this.elementDisposables);
    this.disposables = dispose(this.disposables);
  }
  fireCheckedEvents() {
    if (this._fireCheckedEvents) {
      this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked());
      this._onChangedCheckedCount.fire(this.getCheckedCount());
      this._onChangedCheckedElements.fire(this.getCheckedElements());
    }
  }
  fireButtonTriggered(event) {
    this._onButtonTriggered.fire(event);
  }
  fireSeparatorButtonTriggered(event) {
    this._onSeparatorButtonTriggered.fire(event);
  }
  style(styles) {
    this.list.style(styles);
  }
  toggleHover() {
    const element = this.list.getFocusedElements()[0];
    if (!(element === null || element === void 0 ? void 0 : element.saneTooltip)) {
      return;
    }
    if (this._lastHover && !this._lastHover.isDisposed) {
      this._lastHover.dispose();
      return;
    }
    const focused = this.list.getFocusedElements()[0];
    if (!focused) {
      return;
    }
    this.showHover(focused);
    const store = new DisposableStore();
    store.add(this.list.onDidChangeFocus((e) => {
      if (e.indexes.length) {
        this.showHover(e.elements[0]);
      }
    }));
    if (this._lastHover) {
      store.add(this._lastHover);
    }
    this._toggleHover = store;
    this.elementDisposables.push(this._toggleHover);
  }
};
__decorate29([
  memoize
], QuickInputList.prototype, "onDidChangeFocus", null);
__decorate29([
  memoize
], QuickInputList.prototype, "onDidChangeSelection", null);
function matchesContiguousIconAware(query, target) {
  const { text, iconOffsets } = target;
  if (!iconOffsets || iconOffsets.length === 0) {
    return matchesContiguous(query, text);
  }
  const wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, " ");
  const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;
  const matches = matchesContiguous(query, wordToMatchAgainstWithoutIconsTrimmed);
  if (matches) {
    for (const match2 of matches) {
      const iconOffset = iconOffsets[match2.start + leadingWhitespaceOffset] + leadingWhitespaceOffset;
      match2.start += iconOffset;
      match2.end += iconOffset;
    }
  }
  return matches;
}
function matchesContiguous(word, wordToMatchAgainst) {
  const matchIndex = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());
  if (matchIndex !== -1) {
    return [{ start: matchIndex, end: matchIndex + word.length }];
  }
  return null;
}
function compareEntries(elementA, elementB, lookFor) {
  const labelHighlightsA = elementA.labelHighlights || [];
  const labelHighlightsB = elementB.labelHighlights || [];
  if (labelHighlightsA.length && !labelHighlightsB.length) {
    return -1;
  }
  if (!labelHighlightsA.length && labelHighlightsB.length) {
    return 1;
  }
  if (labelHighlightsA.length === 0 && labelHighlightsB.length === 0) {
    return 0;
  }
  return compareAnything(elementA.saneSortLabel, elementB.saneSortLabel, lookFor);
}
var QuickInputAccessibilityProvider = class {
  getWidgetAriaLabel() {
    return localize("quickInput", "Quick Input");
  }
  getAriaLabel(element) {
    var _a2;
    return ((_a2 = element.separator) === null || _a2 === void 0 ? void 0 : _a2.label) ? `${element.saneAriaLabel}, ${element.separator.label}` : element.saneAriaLabel;
  }
  getWidgetRole() {
    return "listbox";
  }
  getRole(element) {
    return element.hasCheckbox ? "checkbox" : "option";
  }
  isChecked(element) {
    if (!element.hasCheckbox) {
      return void 0;
    }
    return {
      value: element.checked,
      onDidChange: element.onChecked
    };
  }
};

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInput.js
init_configuration();
var __decorate30 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param23 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var backButton = {
  iconClass: ThemeIcon.asClassName(Codicon.quickInputBack),
  tooltip: localize("quickInput.back", "Back"),
  handle: -1
  // TODO
};
var QuickInput = class _QuickInput extends Disposable {
  constructor(ui) {
    super();
    this.ui = ui;
    this._widgetUpdated = false;
    this.visible = false;
    this._enabled = true;
    this._busy = false;
    this._ignoreFocusOut = false;
    this._buttons = [];
    this.buttonsUpdated = false;
    this._toggles = [];
    this.togglesUpdated = false;
    this.noValidationMessage = _QuickInput.noPromptMessage;
    this._severity = severity_default.Ignore;
    this.onDidTriggerButtonEmitter = this._register(new Emitter());
    this.onDidHideEmitter = this._register(new Emitter());
    this.onDisposeEmitter = this._register(new Emitter());
    this.visibleDisposables = this._register(new DisposableStore());
    this.onDidHide = this.onDidHideEmitter.event;
  }
  get title() {
    return this._title;
  }
  set title(title) {
    this._title = title;
    this.update();
  }
  get description() {
    return this._description;
  }
  set description(description) {
    this._description = description;
    this.update();
  }
  get step() {
    return this._steps;
  }
  set step(step) {
    this._steps = step;
    this.update();
  }
  get totalSteps() {
    return this._totalSteps;
  }
  set totalSteps(totalSteps) {
    this._totalSteps = totalSteps;
    this.update();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    this._enabled = enabled;
    this.update();
  }
  get contextKey() {
    return this._contextKey;
  }
  set contextKey(contextKey) {
    this._contextKey = contextKey;
    this.update();
  }
  get busy() {
    return this._busy;
  }
  set busy(busy) {
    this._busy = busy;
    this.update();
  }
  get ignoreFocusOut() {
    return this._ignoreFocusOut;
  }
  set ignoreFocusOut(ignoreFocusOut) {
    const shouldUpdate = this._ignoreFocusOut !== ignoreFocusOut && !isIOS;
    this._ignoreFocusOut = ignoreFocusOut && !isIOS;
    if (shouldUpdate) {
      this.update();
    }
  }
  get buttons() {
    return this._buttons;
  }
  set buttons(buttons) {
    this._buttons = buttons;
    this.buttonsUpdated = true;
    this.update();
  }
  get toggles() {
    return this._toggles;
  }
  set toggles(toggles) {
    this._toggles = toggles !== null && toggles !== void 0 ? toggles : [];
    this.togglesUpdated = true;
    this.update();
  }
  get validationMessage() {
    return this._validationMessage;
  }
  set validationMessage(validationMessage) {
    this._validationMessage = validationMessage;
    this.update();
  }
  get severity() {
    return this._severity;
  }
  set severity(severity) {
    this._severity = severity;
    this.update();
  }
  show() {
    if (this.visible) {
      return;
    }
    this.visibleDisposables.add(this.ui.onDidTriggerButton((button) => {
      if (this.buttons.indexOf(button) !== -1) {
        this.onDidTriggerButtonEmitter.fire(button);
      }
    }));
    this.ui.show(this);
    this.visible = true;
    this._lastValidationMessage = void 0;
    this._lastSeverity = void 0;
    if (this.buttons.length) {
      this.buttonsUpdated = true;
    }
    if (this.toggles.length) {
      this.togglesUpdated = true;
    }
    this.update();
  }
  hide() {
    if (!this.visible) {
      return;
    }
    this.ui.hide();
  }
  didHide(reason = QuickInputHideReason.Other) {
    this.visible = false;
    this.visibleDisposables.clear();
    this.onDidHideEmitter.fire({ reason });
  }
  update() {
    var _a2, _b2;
    if (!this.visible) {
      return;
    }
    const title = this.getTitle();
    if (title && this.ui.title.textContent !== title) {
      this.ui.title.textContent = title;
    } else if (!title && this.ui.title.innerHTML !== "&nbsp;") {
      this.ui.title.innerText = "";
    }
    const description = this.getDescription();
    if (this.ui.description1.textContent !== description) {
      this.ui.description1.textContent = description;
    }
    if (this.ui.description2.textContent !== description) {
      this.ui.description2.textContent = description;
    }
    if (this._widgetUpdated) {
      this._widgetUpdated = false;
      if (this._widget) {
        reset(this.ui.widget, this._widget);
      } else {
        reset(this.ui.widget);
      }
    }
    if (this.busy && !this.busyDelay) {
      this.busyDelay = new TimeoutTimer();
      this.busyDelay.setIfNotSet(() => {
        if (this.visible) {
          this.ui.progressBar.infinite();
        }
      }, 800);
    }
    if (!this.busy && this.busyDelay) {
      this.ui.progressBar.stop();
      this.busyDelay.cancel();
      this.busyDelay = void 0;
    }
    if (this.buttonsUpdated) {
      this.buttonsUpdated = false;
      this.ui.leftActionBar.clear();
      const leftButtons = this.buttons.filter((button) => button === backButton).map((button, index) => quickInputButtonToAction(button, `id-${index}`, async () => this.onDidTriggerButtonEmitter.fire(button)));
      this.ui.leftActionBar.push(leftButtons, { icon: true, label: false });
      this.ui.rightActionBar.clear();
      const rightButtons = this.buttons.filter((button) => button !== backButton).map((button, index) => quickInputButtonToAction(button, `id-${index}`, async () => this.onDidTriggerButtonEmitter.fire(button)));
      this.ui.rightActionBar.push(rightButtons, { icon: true, label: false });
    }
    if (this.togglesUpdated) {
      this.togglesUpdated = false;
      const concreteToggles = (_b2 = (_a2 = this.toggles) === null || _a2 === void 0 ? void 0 : _a2.filter((opts) => opts instanceof Toggle)) !== null && _b2 !== void 0 ? _b2 : [];
      this.ui.inputBox.toggles = concreteToggles;
    }
    this.ui.ignoreFocusOut = this.ignoreFocusOut;
    this.ui.setEnabled(this.enabled);
    this.ui.setContextKey(this.contextKey);
    const validationMessage = this.validationMessage || this.noValidationMessage;
    if (this._lastValidationMessage !== validationMessage) {
      this._lastValidationMessage = validationMessage;
      reset(this.ui.message);
      renderQuickInputDescription(validationMessage, this.ui.message, {
        callback: (content) => {
          this.ui.linkOpenerDelegate(content);
        },
        disposables: this.visibleDisposables
      });
    }
    if (this._lastSeverity !== this.severity) {
      this._lastSeverity = this.severity;
      this.showMessageDecoration(this.severity);
    }
  }
  getTitle() {
    if (this.title && this.step) {
      return `${this.title} (${this.getSteps()})`;
    }
    if (this.title) {
      return this.title;
    }
    if (this.step) {
      return this.getSteps();
    }
    return "";
  }
  getDescription() {
    return this.description || "";
  }
  getSteps() {
    if (this.step && this.totalSteps) {
      return localize("quickInput.steps", "{0}/{1}", this.step, this.totalSteps);
    }
    if (this.step) {
      return String(this.step);
    }
    return "";
  }
  showMessageDecoration(severity) {
    this.ui.inputBox.showDecoration(severity);
    if (severity !== severity_default.Ignore) {
      const styles = this.ui.inputBox.stylesForType(severity);
      this.ui.message.style.color = styles.foreground ? `${styles.foreground}` : "";
      this.ui.message.style.backgroundColor = styles.background ? `${styles.background}` : "";
      this.ui.message.style.border = styles.border ? `1px solid ${styles.border}` : "";
      this.ui.message.style.marginBottom = "-2px";
    } else {
      this.ui.message.style.color = "";
      this.ui.message.style.backgroundColor = "";
      this.ui.message.style.border = "";
      this.ui.message.style.marginBottom = "";
    }
  }
  dispose() {
    this.hide();
    this.onDisposeEmitter.fire();
    super.dispose();
  }
};
QuickInput.noPromptMessage = localize("inputModeEntry", "Press 'Enter' to confirm your input or 'Escape' to cancel");
var QuickPick = class _QuickPick extends QuickInput {
  constructor() {
    super(...arguments);
    this._value = "";
    this.onDidChangeValueEmitter = this._register(new Emitter());
    this.onWillAcceptEmitter = this._register(new Emitter());
    this.onDidAcceptEmitter = this._register(new Emitter());
    this.onDidCustomEmitter = this._register(new Emitter());
    this._items = [];
    this.itemsUpdated = false;
    this._canSelectMany = false;
    this._canAcceptInBackground = false;
    this._matchOnDescription = false;
    this._matchOnDetail = false;
    this._matchOnLabel = true;
    this._matchOnLabelMode = "fuzzy";
    this._sortByLabel = true;
    this._keepScrollPosition = false;
    this._itemActivation = ItemActivation.FIRST;
    this._activeItems = [];
    this.activeItemsUpdated = false;
    this.activeItemsToConfirm = [];
    this.onDidChangeActiveEmitter = this._register(new Emitter());
    this._selectedItems = [];
    this.selectedItemsUpdated = false;
    this.selectedItemsToConfirm = [];
    this.onDidChangeSelectionEmitter = this._register(new Emitter());
    this.onDidTriggerItemButtonEmitter = this._register(new Emitter());
    this.onDidTriggerSeparatorButtonEmitter = this._register(new Emitter());
    this.valueSelectionUpdated = true;
    this._ok = "default";
    this._customButton = false;
    this.filterValue = (value) => value;
    this.onDidChangeValue = this.onDidChangeValueEmitter.event;
    this.onWillAccept = this.onWillAcceptEmitter.event;
    this.onDidAccept = this.onDidAcceptEmitter.event;
    this.onDidChangeActive = this.onDidChangeActiveEmitter.event;
    this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event;
    this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event;
    this.onDidTriggerSeparatorButton = this.onDidTriggerSeparatorButtonEmitter.event;
  }
  get quickNavigate() {
    return this._quickNavigate;
  }
  set quickNavigate(quickNavigate) {
    this._quickNavigate = quickNavigate;
    this.update();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this.doSetValue(value);
  }
  doSetValue(value, skipUpdate) {
    if (this._value !== value) {
      this._value = value;
      if (!skipUpdate) {
        this.update();
      }
      if (this.visible) {
        const didFilter = this.ui.list.filter(this.filterValue(this._value));
        if (didFilter) {
          this.trySelectFirst();
        }
      }
      this.onDidChangeValueEmitter.fire(this._value);
    }
  }
  set ariaLabel(ariaLabel) {
    this._ariaLabel = ariaLabel;
    this.update();
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(placeholder) {
    this._placeholder = placeholder;
    this.update();
  }
  get items() {
    return this._items;
  }
  get scrollTop() {
    return this.ui.list.scrollTop;
  }
  set scrollTop(scrollTop) {
    this.ui.list.scrollTop = scrollTop;
  }
  set items(items) {
    this._items = items;
    this.itemsUpdated = true;
    this.update();
  }
  get canSelectMany() {
    return this._canSelectMany;
  }
  set canSelectMany(canSelectMany) {
    this._canSelectMany = canSelectMany;
    this.update();
  }
  get canAcceptInBackground() {
    return this._canAcceptInBackground;
  }
  set canAcceptInBackground(canAcceptInBackground) {
    this._canAcceptInBackground = canAcceptInBackground;
  }
  get matchOnDescription() {
    return this._matchOnDescription;
  }
  set matchOnDescription(matchOnDescription) {
    this._matchOnDescription = matchOnDescription;
    this.update();
  }
  get matchOnDetail() {
    return this._matchOnDetail;
  }
  set matchOnDetail(matchOnDetail) {
    this._matchOnDetail = matchOnDetail;
    this.update();
  }
  get matchOnLabel() {
    return this._matchOnLabel;
  }
  set matchOnLabel(matchOnLabel) {
    this._matchOnLabel = matchOnLabel;
    this.update();
  }
  get matchOnLabelMode() {
    return this._matchOnLabelMode;
  }
  set matchOnLabelMode(matchOnLabelMode) {
    this._matchOnLabelMode = matchOnLabelMode;
    this.update();
  }
  get sortByLabel() {
    return this._sortByLabel;
  }
  set sortByLabel(sortByLabel) {
    this._sortByLabel = sortByLabel;
    this.update();
  }
  get keepScrollPosition() {
    return this._keepScrollPosition;
  }
  set keepScrollPosition(keepScrollPosition) {
    this._keepScrollPosition = keepScrollPosition;
  }
  get itemActivation() {
    return this._itemActivation;
  }
  set itemActivation(itemActivation) {
    this._itemActivation = itemActivation;
  }
  get activeItems() {
    return this._activeItems;
  }
  set activeItems(activeItems) {
    this._activeItems = activeItems;
    this.activeItemsUpdated = true;
    this.update();
  }
  get selectedItems() {
    return this._selectedItems;
  }
  set selectedItems(selectedItems) {
    this._selectedItems = selectedItems;
    this.selectedItemsUpdated = true;
    this.update();
  }
  get keyMods() {
    if (this._quickNavigate) {
      return NO_KEY_MODS;
    }
    return this.ui.keyMods;
  }
  set valueSelection(valueSelection) {
    this._valueSelection = valueSelection;
    this.valueSelectionUpdated = true;
    this.update();
  }
  get customButton() {
    return this._customButton;
  }
  set customButton(showCustomButton) {
    this._customButton = showCustomButton;
    this.update();
  }
  get customLabel() {
    return this._customButtonLabel;
  }
  set customLabel(label) {
    this._customButtonLabel = label;
    this.update();
  }
  get customHover() {
    return this._customButtonHover;
  }
  set customHover(hover) {
    this._customButtonHover = hover;
    this.update();
  }
  get ok() {
    return this._ok;
  }
  set ok(showOkButton) {
    this._ok = showOkButton;
    this.update();
  }
  get hideInput() {
    return !!this._hideInput;
  }
  set hideInput(hideInput) {
    this._hideInput = hideInput;
    this.update();
  }
  trySelectFirst() {
    if (!this.canSelectMany) {
      this.ui.list.focus(QuickInputListFocus.First);
    }
  }
  show() {
    if (!this.visible) {
      this.visibleDisposables.add(this.ui.inputBox.onDidChange((value) => {
        this.doSetValue(
          value,
          true
          /* skip update since this originates from the UI */
        );
      }));
      this.visibleDisposables.add((this._hideInput ? this.ui.list : this.ui.inputBox).onKeyDown((event) => {
        switch (event.keyCode) {
          case 18:
            this.ui.list.focus(QuickInputListFocus.Next);
            if (this.canSelectMany) {
              this.ui.list.domFocus();
            }
            EventHelper.stop(event, true);
            break;
          case 16:
            if (this.ui.list.getFocusedElements().length) {
              this.ui.list.focus(QuickInputListFocus.Previous);
            } else {
              this.ui.list.focus(QuickInputListFocus.Last);
            }
            if (this.canSelectMany) {
              this.ui.list.domFocus();
            }
            EventHelper.stop(event, true);
            break;
          case 12:
            this.ui.list.focus(QuickInputListFocus.NextPage);
            if (this.canSelectMany) {
              this.ui.list.domFocus();
            }
            EventHelper.stop(event, true);
            break;
          case 11:
            this.ui.list.focus(QuickInputListFocus.PreviousPage);
            if (this.canSelectMany) {
              this.ui.list.domFocus();
            }
            EventHelper.stop(event, true);
            break;
          case 17:
            if (!this._canAcceptInBackground) {
              return;
            }
            if (!this.ui.inputBox.isSelectionAtEnd()) {
              return;
            }
            if (this.activeItems[0]) {
              this._selectedItems = [this.activeItems[0]];
              this.onDidChangeSelectionEmitter.fire(this.selectedItems);
              this.handleAccept(true);
            }
            break;
          case 14:
            if ((event.ctrlKey || event.metaKey) && !event.shiftKey && !event.altKey) {
              this.ui.list.focus(QuickInputListFocus.First);
              EventHelper.stop(event, true);
            }
            break;
          case 13:
            if ((event.ctrlKey || event.metaKey) && !event.shiftKey && !event.altKey) {
              this.ui.list.focus(QuickInputListFocus.Last);
              EventHelper.stop(event, true);
            }
            break;
        }
      }));
      this.visibleDisposables.add(this.ui.onDidAccept(() => {
        if (this.canSelectMany) {
          if (!this.ui.list.getCheckedElements().length) {
            this._selectedItems = [];
            this.onDidChangeSelectionEmitter.fire(this.selectedItems);
          }
        } else if (this.activeItems[0]) {
          this._selectedItems = [this.activeItems[0]];
          this.onDidChangeSelectionEmitter.fire(this.selectedItems);
        }
        this.handleAccept(false);
      }));
      this.visibleDisposables.add(this.ui.onDidCustom(() => {
        this.onDidCustomEmitter.fire();
      }));
      this.visibleDisposables.add(this.ui.list.onDidChangeFocus((focusedItems) => {
        if (this.activeItemsUpdated) {
          return;
        }
        if (this.activeItemsToConfirm !== this._activeItems && equals(focusedItems, this._activeItems, (a, b) => a === b)) {
          return;
        }
        this._activeItems = focusedItems;
        this.onDidChangeActiveEmitter.fire(focusedItems);
      }));
      this.visibleDisposables.add(this.ui.list.onDidChangeSelection(({ items: selectedItems, event }) => {
        if (this.canSelectMany) {
          if (selectedItems.length) {
            this.ui.list.setSelectedElements([]);
          }
          return;
        }
        if (this.selectedItemsToConfirm !== this._selectedItems && equals(selectedItems, this._selectedItems, (a, b) => a === b)) {
          return;
        }
        this._selectedItems = selectedItems;
        this.onDidChangeSelectionEmitter.fire(selectedItems);
        if (selectedItems.length) {
          this.handleAccept(
            isMouseEvent(event) && event.button === 1
            /* mouse middle click */
          );
        }
      }));
      this.visibleDisposables.add(this.ui.list.onChangedCheckedElements((checkedItems) => {
        if (!this.canSelectMany) {
          return;
        }
        if (this.selectedItemsToConfirm !== this._selectedItems && equals(checkedItems, this._selectedItems, (a, b) => a === b)) {
          return;
        }
        this._selectedItems = checkedItems;
        this.onDidChangeSelectionEmitter.fire(checkedItems);
      }));
      this.visibleDisposables.add(this.ui.list.onButtonTriggered((event) => this.onDidTriggerItemButtonEmitter.fire(event)));
      this.visibleDisposables.add(this.ui.list.onSeparatorButtonTriggered((event) => this.onDidTriggerSeparatorButtonEmitter.fire(event)));
      this.visibleDisposables.add(this.registerQuickNavigation());
      this.valueSelectionUpdated = true;
    }
    super.show();
  }
  handleAccept(inBackground) {
    let veto = false;
    this.onWillAcceptEmitter.fire({ veto: () => veto = true });
    if (!veto) {
      this.onDidAcceptEmitter.fire({ inBackground });
    }
  }
  registerQuickNavigation() {
    return addDisposableListener(this.ui.container, EventType.KEY_UP, (e) => {
      if (this.canSelectMany || !this._quickNavigate) {
        return;
      }
      const keyboardEvent = new StandardKeyboardEvent(e);
      const keyCode = keyboardEvent.keyCode;
      const quickNavKeys = this._quickNavigate.keybindings;
      const wasTriggerKeyPressed = quickNavKeys.some((k) => {
        const chords = k.getChords();
        if (chords.length > 1) {
          return false;
        }
        if (chords[0].shiftKey && keyCode === 4) {
          if (keyboardEvent.ctrlKey || keyboardEvent.altKey || keyboardEvent.metaKey) {
            return false;
          }
          return true;
        }
        if (chords[0].altKey && keyCode === 6) {
          return true;
        }
        if (chords[0].ctrlKey && keyCode === 5) {
          return true;
        }
        if (chords[0].metaKey && keyCode === 57) {
          return true;
        }
        return false;
      });
      if (wasTriggerKeyPressed) {
        if (this.activeItems[0]) {
          this._selectedItems = [this.activeItems[0]];
          this.onDidChangeSelectionEmitter.fire(this.selectedItems);
          this.handleAccept(false);
        }
        this._quickNavigate = void 0;
      }
    });
  }
  update() {
    if (!this.visible) {
      return;
    }
    const scrollTopBefore = this.keepScrollPosition ? this.scrollTop : 0;
    const hasDescription = !!this.description;
    const visibilities = {
      title: !!this.title || !!this.step || !!this.buttons.length,
      description: hasDescription,
      checkAll: this.canSelectMany && !this._hideCheckAll,
      checkBox: this.canSelectMany,
      inputBox: !this._hideInput,
      progressBar: !this._hideInput || hasDescription,
      visibleCount: true,
      count: this.canSelectMany && !this._hideCountBadge,
      ok: this.ok === "default" ? this.canSelectMany : this.ok,
      list: true,
      message: !!this.validationMessage,
      customButton: this.customButton
    };
    this.ui.setVisibilities(visibilities);
    super.update();
    if (this.ui.inputBox.value !== this.value) {
      this.ui.inputBox.value = this.value;
    }
    if (this.valueSelectionUpdated) {
      this.valueSelectionUpdated = false;
      this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] });
    }
    if (this.ui.inputBox.placeholder !== (this.placeholder || "")) {
      this.ui.inputBox.placeholder = this.placeholder || "";
    }
    let ariaLabel = this.ariaLabel;
    if (!ariaLabel && visibilities.inputBox) {
      ariaLabel = this.placeholder || _QuickPick.DEFAULT_ARIA_LABEL;
      if (this.title) {
        ariaLabel += ` - ${this.title}`;
      }
    }
    if (this.ui.list.ariaLabel !== ariaLabel) {
      this.ui.list.ariaLabel = ariaLabel !== null && ariaLabel !== void 0 ? ariaLabel : null;
    }
    this.ui.list.matchOnDescription = this.matchOnDescription;
    this.ui.list.matchOnDetail = this.matchOnDetail;
    this.ui.list.matchOnLabel = this.matchOnLabel;
    this.ui.list.matchOnLabelMode = this.matchOnLabelMode;
    this.ui.list.sortByLabel = this.sortByLabel;
    if (this.itemsUpdated) {
      this.itemsUpdated = false;
      this.ui.list.setElements(this.items);
      this.ui.list.filter(this.filterValue(this.ui.inputBox.value));
      this.ui.checkAll.checked = this.ui.list.getAllVisibleChecked();
      this.ui.visibleCount.setCount(this.ui.list.getVisibleCount());
      this.ui.count.setCount(this.ui.list.getCheckedCount());
      switch (this._itemActivation) {
        case ItemActivation.NONE:
          this._itemActivation = ItemActivation.FIRST;
          break;
        case ItemActivation.SECOND:
          this.ui.list.focus(QuickInputListFocus.Second);
          this._itemActivation = ItemActivation.FIRST;
          break;
        case ItemActivation.LAST:
          this.ui.list.focus(QuickInputListFocus.Last);
          this._itemActivation = ItemActivation.FIRST;
          break;
        default:
          this.trySelectFirst();
          break;
      }
    }
    if (this.ui.container.classList.contains("show-checkboxes") !== !!this.canSelectMany) {
      if (this.canSelectMany) {
        this.ui.list.clearFocus();
      } else {
        this.trySelectFirst();
      }
    }
    if (this.activeItemsUpdated) {
      this.activeItemsUpdated = false;
      this.activeItemsToConfirm = this._activeItems;
      this.ui.list.setFocusedElements(this.activeItems);
      if (this.activeItemsToConfirm === this._activeItems) {
        this.activeItemsToConfirm = null;
      }
    }
    if (this.selectedItemsUpdated) {
      this.selectedItemsUpdated = false;
      this.selectedItemsToConfirm = this._selectedItems;
      if (this.canSelectMany) {
        this.ui.list.setCheckedElements(this.selectedItems);
      } else {
        this.ui.list.setSelectedElements(this.selectedItems);
      }
      if (this.selectedItemsToConfirm === this._selectedItems) {
        this.selectedItemsToConfirm = null;
      }
    }
    this.ui.customButton.label = this.customLabel || "";
    this.ui.customButton.element.title = this.customHover || "";
    if (!visibilities.inputBox) {
      this.ui.list.domFocus();
      if (this.canSelectMany) {
        this.ui.list.focus(QuickInputListFocus.First);
      }
    }
    if (this.keepScrollPosition) {
      this.scrollTop = scrollTopBefore;
    }
  }
};
QuickPick.DEFAULT_ARIA_LABEL = localize("quickInputBox.ariaLabel", "Type to narrow down results.");
var InputBox2 = class extends QuickInput {
  constructor() {
    super(...arguments);
    this._value = "";
    this.valueSelectionUpdated = true;
    this._password = false;
    this.onDidValueChangeEmitter = this._register(new Emitter());
    this.onDidAcceptEmitter = this._register(new Emitter());
    this.onDidChangeValue = this.onDidValueChangeEmitter.event;
    this.onDidAccept = this.onDidAcceptEmitter.event;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value || "";
    this.update();
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(placeholder) {
    this._placeholder = placeholder;
    this.update();
  }
  get password() {
    return this._password;
  }
  set password(password) {
    this._password = password;
    this.update();
  }
  show() {
    if (!this.visible) {
      this.visibleDisposables.add(this.ui.inputBox.onDidChange((value) => {
        if (value === this.value) {
          return;
        }
        this._value = value;
        this.onDidValueChangeEmitter.fire(value);
      }));
      this.visibleDisposables.add(this.ui.onDidAccept(() => this.onDidAcceptEmitter.fire()));
      this.valueSelectionUpdated = true;
    }
    super.show();
  }
  update() {
    if (!this.visible) {
      return;
    }
    this.ui.container.classList.remove("hidden-input");
    const visibilities = {
      title: !!this.title || !!this.step || !!this.buttons.length,
      description: !!this.description || !!this.step,
      inputBox: true,
      message: true,
      progressBar: true
    };
    this.ui.setVisibilities(visibilities);
    super.update();
    if (this.ui.inputBox.value !== this.value) {
      this.ui.inputBox.value = this.value;
    }
    if (this.valueSelectionUpdated) {
      this.valueSelectionUpdated = false;
      this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] });
    }
    if (this.ui.inputBox.placeholder !== (this.placeholder || "")) {
      this.ui.inputBox.placeholder = this.placeholder || "";
    }
    if (this.ui.inputBox.password !== this.password) {
      this.ui.inputBox.password = this.password;
    }
  }
};
var QuickInputHoverDelegate = class QuickInputHoverDelegate2 extends WorkbenchHoverDelegate {
  constructor(configurationService, hoverService) {
    super("element", false, (options2) => this.getOverrideOptions(options2), configurationService, hoverService);
  }
  getOverrideOptions(options2) {
    var _a2;
    const showHoverHint = (options2.content instanceof HTMLElement ? (_a2 = options2.content.textContent) !== null && _a2 !== void 0 ? _a2 : "" : typeof options2.content === "string" ? options2.content : options2.content.value).includes("\n");
    return {
      persistence: {
        hideOnKeyDown: false
      },
      appearance: {
        showHoverHint,
        skipFadeInAnimation: true
      }
    };
  }
};
QuickInputHoverDelegate = __decorate30([
  __param23(0, IConfigurationService),
  __param23(1, IHoverService)
], QuickInputHoverDelegate);

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputController.js
init_dom();

// node_modules/monaco-editor/esm/vs/base/browser/ui/button/button.js
init_dom();
init_dompurify();
init_keyboardEvent();
init_iconLabels();
init_color();
init_event();
init_htmlContent();
init_lifecycle();
init_themables();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/button/button.css";
var unthemedButtonStyles = {
  buttonBackground: "#0E639C",
  buttonHoverBackground: "#006BB3",
  buttonSeparator: Color.white.toString(),
  buttonForeground: Color.white.toString(),
  buttonBorder: void 0,
  buttonSecondaryBackground: void 0,
  buttonSecondaryForeground: void 0,
  buttonSecondaryHoverBackground: void 0
};
var Button = class extends Disposable {
  get onDidClick() {
    return this._onDidClick.event;
  }
  constructor(container, options2) {
    super();
    this._label = "";
    this._onDidClick = this._register(new Emitter());
    this._onDidEscape = this._register(new Emitter());
    this.options = options2;
    this._element = document.createElement("a");
    this._element.classList.add("monaco-button");
    this._element.tabIndex = 0;
    this._element.setAttribute("role", "button");
    this._element.classList.toggle("secondary", !!options2.secondary);
    const background = options2.secondary ? options2.buttonSecondaryBackground : options2.buttonBackground;
    const foreground2 = options2.secondary ? options2.buttonSecondaryForeground : options2.buttonForeground;
    this._element.style.color = foreground2 || "";
    this._element.style.backgroundColor = background || "";
    if (options2.supportShortLabel) {
      this._labelShortElement = document.createElement("div");
      this._labelShortElement.classList.add("monaco-button-label-short");
      this._element.appendChild(this._labelShortElement);
      this._labelElement = document.createElement("div");
      this._labelElement.classList.add("monaco-button-label");
      this._element.appendChild(this._labelElement);
      this._element.classList.add("monaco-text-button-with-short-label");
    }
    if (typeof options2.ariaLabel === "string") {
      this._element.setAttribute("aria-label", options2.ariaLabel);
    }
    container.appendChild(this._element);
    this._register(Gesture.addTarget(this._element));
    [EventType.CLICK, EventType2.Tap].forEach((eventType) => {
      this._register(addDisposableListener(this._element, eventType, (e) => {
        if (!this.enabled) {
          EventHelper.stop(e);
          return;
        }
        this._onDidClick.fire(e);
      }));
    });
    this._register(addDisposableListener(this._element, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      let eventHandled = false;
      if (this.enabled && (event.equals(
        3
        /* KeyCode.Enter */
      ) || event.equals(
        10
        /* KeyCode.Space */
      ))) {
        this._onDidClick.fire(e);
        eventHandled = true;
      } else if (event.equals(
        9
        /* KeyCode.Escape */
      )) {
        this._onDidEscape.fire(e);
        this._element.blur();
        eventHandled = true;
      }
      if (eventHandled) {
        EventHelper.stop(event, true);
      }
    }));
    this._register(addDisposableListener(this._element, EventType.MOUSE_OVER, (e) => {
      if (!this._element.classList.contains("disabled")) {
        this.updateBackground(true);
      }
    }));
    this._register(addDisposableListener(this._element, EventType.MOUSE_OUT, (e) => {
      this.updateBackground(false);
    }));
    this.focusTracker = this._register(trackFocus(this._element));
    this._register(this.focusTracker.onDidFocus(() => {
      if (this.enabled) {
        this.updateBackground(true);
      }
    }));
    this._register(this.focusTracker.onDidBlur(() => {
      if (this.enabled) {
        this.updateBackground(false);
      }
    }));
  }
  dispose() {
    super.dispose();
    this._element.remove();
  }
  getContentElements(content) {
    const elements = [];
    for (let segment of renderLabelWithIcons(content)) {
      if (typeof segment === "string") {
        segment = segment.trim();
        if (segment === "") {
          continue;
        }
        const node = document.createElement("span");
        node.textContent = segment;
        elements.push(node);
      } else {
        elements.push(segment);
      }
    }
    return elements;
  }
  updateBackground(hover) {
    let background;
    if (this.options.secondary) {
      background = hover ? this.options.buttonSecondaryHoverBackground : this.options.buttonSecondaryBackground;
    } else {
      background = hover ? this.options.buttonHoverBackground : this.options.buttonBackground;
    }
    if (background) {
      this._element.style.backgroundColor = background;
    }
  }
  get element() {
    return this._element;
  }
  set label(value) {
    var _a2;
    if (this._label === value) {
      return;
    }
    if (isMarkdownString(this._label) && isMarkdownString(value) && markdownStringEqual(this._label, value)) {
      return;
    }
    this._element.classList.add("monaco-text-button");
    const labelElement = this.options.supportShortLabel ? this._labelElement : this._element;
    if (isMarkdownString(value)) {
      const rendered = renderMarkdown(value, { inline: true });
      rendered.dispose();
      const root = (_a2 = rendered.element.querySelector("p")) === null || _a2 === void 0 ? void 0 : _a2.innerHTML;
      if (root) {
        const sanitized = sanitize(root, { ADD_TAGS: ["b", "i", "u", "code", "span"], ALLOWED_ATTR: ["class"], RETURN_TRUSTED_TYPE: true });
        labelElement.innerHTML = sanitized;
      } else {
        reset(labelElement);
      }
    } else {
      if (this.options.supportIcons) {
        reset(labelElement, ...this.getContentElements(value));
      } else {
        labelElement.textContent = value;
      }
    }
    let title = "";
    if (typeof this.options.title === "string") {
      title = this.options.title;
    } else if (this.options.title) {
      title = renderStringAsPlaintext(value);
    }
    if (!this._hover) {
      this._hover = this._register(setupCustomHover(getDefaultHoverDelegate("mouse"), this._element, title));
    } else {
      this._hover.update(title);
    }
    if (typeof this.options.ariaLabel === "string") {
      this._element.setAttribute("aria-label", this.options.ariaLabel);
    } else if (this.options.ariaLabel) {
      this._element.setAttribute("aria-label", this._element.title);
    }
    this._label = value;
  }
  get label() {
    return this._label;
  }
  set icon(icon) {
    this._element.classList.add(...ThemeIcon.asClassNameArray(icon));
  }
  set enabled(value) {
    if (value) {
      this._element.classList.remove("disabled");
      this._element.setAttribute("aria-disabled", String(false));
      this._element.tabIndex = 0;
    } else {
      this._element.classList.add("disabled");
      this._element.setAttribute("aria-disabled", String(true));
    }
  }
  get enabled() {
    return !this._element.classList.contains("disabled");
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/countBadge/countBadge.js
init_dom();
init_strings();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/countBadge/countBadge.css";
var CountBadge = class {
  constructor(container, options2, styles) {
    this.options = options2;
    this.styles = styles;
    this.count = 0;
    this.element = append(container, $(".monaco-count-badge"));
    this.countFormat = this.options.countFormat || "{0}";
    this.titleFormat = this.options.titleFormat || "";
    this.setCount(this.options.count || 0);
  }
  setCount(count) {
    this.count = count;
    this.render();
  }
  setTitleFormat(titleFormat) {
    this.titleFormat = titleFormat;
    this.render();
  }
  render() {
    var _a2, _b2;
    this.element.textContent = format(this.countFormat, this.count);
    this.element.title = format(this.titleFormat, this.count);
    this.element.style.backgroundColor = (_a2 = this.styles.badgeBackground) !== null && _a2 !== void 0 ? _a2 : "";
    this.element.style.color = (_b2 = this.styles.badgeForeground) !== null && _b2 !== void 0 ? _b2 : "";
    if (this.styles.badgeBorder) {
      this.element.style.border = `1px solid ${this.styles.badgeBorder}`;
    }
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/progressbar/progressbar.js
init_dom();
init_async();
init_lifecycle();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/base/browser/ui/progressbar/progressbar.css";
var CSS_DONE = "done";
var CSS_ACTIVE = "active";
var CSS_INFINITE = "infinite";
var CSS_INFINITE_LONG_RUNNING = "infinite-long-running";
var CSS_DISCRETE = "discrete";
var ProgressBar = class _ProgressBar extends Disposable {
  constructor(container, options2) {
    super();
    this.workedVal = 0;
    this.showDelayedScheduler = this._register(new RunOnceScheduler(() => show(this.element), 0));
    this.longRunningScheduler = this._register(new RunOnceScheduler(() => this.infiniteLongRunning(), _ProgressBar.LONG_RUNNING_INFINITE_THRESHOLD));
    this.create(container, options2);
  }
  create(container, options2) {
    this.element = document.createElement("div");
    this.element.classList.add("monaco-progress-container");
    this.element.setAttribute("role", "progressbar");
    this.element.setAttribute("aria-valuemin", "0");
    container.appendChild(this.element);
    this.bit = document.createElement("div");
    this.bit.classList.add("progress-bit");
    this.bit.style.backgroundColor = (options2 === null || options2 === void 0 ? void 0 : options2.progressBarBackground) || "#0E70C0";
    this.element.appendChild(this.bit);
  }
  off() {
    this.bit.style.width = "inherit";
    this.bit.style.opacity = "1";
    this.element.classList.remove(CSS_ACTIVE, CSS_INFINITE, CSS_INFINITE_LONG_RUNNING, CSS_DISCRETE);
    this.workedVal = 0;
    this.totalWork = void 0;
    this.longRunningScheduler.cancel();
  }
  /**
   * Stops the progressbar from showing any progress instantly without fading out.
   */
  stop() {
    return this.doDone(false);
  }
  doDone(delayed) {
    this.element.classList.add(CSS_DONE);
    if (!this.element.classList.contains(CSS_INFINITE)) {
      this.bit.style.width = "inherit";
      if (delayed) {
        setTimeout(() => this.off(), 200);
      } else {
        this.off();
      }
    } else {
      this.bit.style.opacity = "0";
      if (delayed) {
        setTimeout(() => this.off(), 200);
      } else {
        this.off();
      }
    }
    return this;
  }
  /**
   * Use this mode to indicate progress that has no total number of work units.
   */
  infinite() {
    this.bit.style.width = "2%";
    this.bit.style.opacity = "1";
    this.element.classList.remove(CSS_DISCRETE, CSS_DONE, CSS_INFINITE_LONG_RUNNING);
    this.element.classList.add(CSS_ACTIVE, CSS_INFINITE);
    this.longRunningScheduler.schedule();
    return this;
  }
  infiniteLongRunning() {
    this.element.classList.add(CSS_INFINITE_LONG_RUNNING);
  }
  getContainer() {
    return this.element;
  }
};
ProgressBar.LONG_RUNNING_INFINITE_THRESHOLD = 1e4;

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputController.js
init_cancellation();
init_event();
init_lifecycle();
init_nls();

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputBox.js
init_dom();
init_lifecycle();
import "/Users/chenzihua/Documents/Slidev/slidev/node_modules/monaco-editor/esm/vs/platform/quickinput/browser/media/quickInput.css";
var $8 = $;
var QuickInputBox = class extends Disposable {
  constructor(parent, inputBoxStyles, toggleStyles) {
    super();
    this.parent = parent;
    this.onKeyDown = (handler) => {
      return addStandardDisposableListener(this.findInput.inputBox.inputElement, EventType.KEY_DOWN, handler);
    };
    this.onDidChange = (handler) => {
      return this.findInput.onDidChange(handler);
    };
    this.container = append(this.parent, $8(".quick-input-box"));
    this.findInput = this._register(new FindInput(this.container, void 0, { label: "", inputBoxStyles, toggleStyles }));
    const input = this.findInput.inputBox.inputElement;
    input.role = "combobox";
    input.ariaHasPopup = "menu";
    input.ariaAutoComplete = "list";
    input.ariaExpanded = "true";
  }
  get value() {
    return this.findInput.getValue();
  }
  set value(value) {
    this.findInput.setValue(value);
  }
  select(range2 = null) {
    this.findInput.inputBox.select(range2);
  }
  isSelectionAtEnd() {
    return this.findInput.inputBox.isSelectionAtEnd();
  }
  get placeholder() {
    return this.findInput.inputBox.inputElement.getAttribute("placeholder") || "";
  }
  set placeholder(placeholder) {
    this.findInput.inputBox.setPlaceHolder(placeholder);
  }
  get password() {
    return this.findInput.inputBox.inputElement.type === "password";
  }
  set password(password) {
    this.findInput.inputBox.inputElement.type = password ? "password" : "text";
  }
  set enabled(enabled) {
    this.findInput.inputBox.inputElement.toggleAttribute("readonly", !enabled);
  }
  set toggles(toggles) {
    this.findInput.setAdditionalToggles(toggles);
  }
  setAttribute(name, value) {
    this.findInput.inputBox.inputElement.setAttribute(name, value);
  }
  showDecoration(decoration) {
    if (decoration === severity_default.Ignore) {
      this.findInput.clearMessage();
    } else {
      this.findInput.showMessage({ type: decoration === severity_default.Info ? 1 : decoration === severity_default.Warning ? 2 : 3, content: "" });
    }
  }
  stylesForType(decoration) {
    return this.findInput.inputBox.stylesForType(
      decoration === severity_default.Info ? 1 : decoration === severity_default.Warning ? 2 : 3
      /* MessageType.ERROR */
    );
  }
  setFocus() {
    this.findInput.focus();
  }
  layout() {
    this.findInput.inputBox.layout();
  }
};

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputController.js
init_window();
var $9 = $;
var QuickInputController = class _QuickInputController extends Disposable {
  get container() {
    return this._container;
  }
  constructor(options2, themeService, layoutService) {
    super();
    this.options = options2;
    this.themeService = themeService;
    this.layoutService = layoutService;
    this.enabled = true;
    this.onDidAcceptEmitter = this._register(new Emitter());
    this.onDidCustomEmitter = this._register(new Emitter());
    this.onDidTriggerButtonEmitter = this._register(new Emitter());
    this.keyMods = { ctrlCmd: false, alt: false };
    this.controller = null;
    this.onShowEmitter = this._register(new Emitter());
    this.onShow = this.onShowEmitter.event;
    this.onHideEmitter = this._register(new Emitter());
    this.onHide = this.onHideEmitter.event;
    this.idPrefix = options2.idPrefix;
    this._container = options2.container;
    this.styles = options2.styles;
    this._register(Event.runAndSubscribe(onDidRegisterWindow, ({ window, disposables }) => this.registerKeyModsListeners(window, disposables), { window: mainWindow, disposables: this._store }));
    this._register(onWillUnregisterWindow((window) => {
      if (this.ui && getWindow(this.ui.container) === window) {
        this.reparentUI(this.layoutService.mainContainer);
        this.layout(this.layoutService.mainContainerDimension, this.layoutService.mainContainerOffset.quickPickTop);
      }
    }));
  }
  registerKeyModsListeners(window, disposables) {
    const listener = (e) => {
      this.keyMods.ctrlCmd = e.ctrlKey || e.metaKey;
      this.keyMods.alt = e.altKey;
    };
    for (const event of [EventType.KEY_DOWN, EventType.KEY_UP, EventType.MOUSE_DOWN]) {
      disposables.add(addDisposableListener(window, event, listener, true));
    }
  }
  getUI(showInActiveContainer) {
    if (this.ui) {
      if (showInActiveContainer) {
        if (getWindow(this._container) !== getWindow(this.layoutService.activeContainer)) {
          this.reparentUI(this.layoutService.activeContainer);
          this.layout(this.layoutService.activeContainerDimension, this.layoutService.activeContainerOffset.quickPickTop);
        }
      }
      return this.ui;
    }
    const container = append(this._container, $9(".quick-input-widget.show-file-icons"));
    container.tabIndex = -1;
    container.style.display = "none";
    const styleSheet = createStyleSheet(container);
    const titleBar = append(container, $9(".quick-input-titlebar"));
    const leftActionBar = this._register(new ActionBar(titleBar, { hoverDelegate: this.options.hoverDelegate }));
    leftActionBar.domNode.classList.add("quick-input-left-action-bar");
    const title = append(titleBar, $9(".quick-input-title"));
    const rightActionBar = this._register(new ActionBar(titleBar, { hoverDelegate: this.options.hoverDelegate }));
    rightActionBar.domNode.classList.add("quick-input-right-action-bar");
    const headerContainer = append(container, $9(".quick-input-header"));
    const checkAll = append(headerContainer, $9("input.quick-input-check-all"));
    checkAll.type = "checkbox";
    checkAll.setAttribute("aria-label", localize("quickInput.checkAll", "Toggle all checkboxes"));
    this._register(addStandardDisposableListener(checkAll, EventType.CHANGE, (e) => {
      const checked = checkAll.checked;
      list.setAllVisibleChecked(checked);
    }));
    this._register(addDisposableListener(checkAll, EventType.CLICK, (e) => {
      if (e.x || e.y) {
        inputBox.setFocus();
      }
    }));
    const description2 = append(headerContainer, $9(".quick-input-description"));
    const inputContainer = append(headerContainer, $9(".quick-input-and-message"));
    const filterContainer = append(inputContainer, $9(".quick-input-filter"));
    const inputBox = this._register(new QuickInputBox(filterContainer, this.styles.inputBox, this.styles.toggle));
    inputBox.setAttribute("aria-describedby", `${this.idPrefix}message`);
    const visibleCountContainer = append(filterContainer, $9(".quick-input-visible-count"));
    visibleCountContainer.setAttribute("aria-live", "polite");
    visibleCountContainer.setAttribute("aria-atomic", "true");
    const visibleCount = new CountBadge(visibleCountContainer, { countFormat: localize({ key: "quickInput.visibleCount", comment: ["This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers."] }, "{0} Results") }, this.styles.countBadge);
    const countContainer = append(filterContainer, $9(".quick-input-count"));
    countContainer.setAttribute("aria-live", "polite");
    const count = new CountBadge(countContainer, { countFormat: localize({ key: "quickInput.countSelected", comment: ["This tells the user how many items are selected in a list of items to select from. The items can be anything."] }, "{0} Selected") }, this.styles.countBadge);
    const okContainer = append(headerContainer, $9(".quick-input-action"));
    const ok2 = this._register(new Button(okContainer, this.styles.button));
    ok2.label = localize("ok", "OK");
    this._register(ok2.onDidClick((e) => {
      this.onDidAcceptEmitter.fire();
    }));
    const customButtonContainer = append(headerContainer, $9(".quick-input-action"));
    const customButton = this._register(new Button(customButtonContainer, { ...this.styles.button, supportIcons: true }));
    customButton.label = localize("custom", "Custom");
    this._register(customButton.onDidClick((e) => {
      this.onDidCustomEmitter.fire();
    }));
    const message = append(inputContainer, $9(`#${this.idPrefix}message.quick-input-message`));
    const progressBar = this._register(new ProgressBar(container, this.styles.progressBar));
    progressBar.getContainer().classList.add("quick-input-progress");
    const widget = append(container, $9(".quick-input-html-widget"));
    widget.tabIndex = -1;
    const description1 = append(container, $9(".quick-input-description"));
    const listId = this.idPrefix + "list";
    const list = this._register(new QuickInputList(container, listId, this.options, this.themeService));
    inputBox.setAttribute("aria-controls", listId);
    this._register(list.onDidChangeFocus(() => {
      var _a2;
      inputBox.setAttribute("aria-activedescendant", (_a2 = list.getActiveDescendant()) !== null && _a2 !== void 0 ? _a2 : "");
    }));
    this._register(list.onChangedAllVisibleChecked((checked) => {
      checkAll.checked = checked;
    }));
    this._register(list.onChangedVisibleCount((c) => {
      visibleCount.setCount(c);
    }));
    this._register(list.onChangedCheckedCount((c) => {
      count.setCount(c);
    }));
    this._register(list.onLeave(() => {
      setTimeout(() => {
        if (!this.controller) {
          return;
        }
        inputBox.setFocus();
        if (this.controller instanceof QuickPick && this.controller.canSelectMany) {
          list.clearFocus();
        }
      }, 0);
    }));
    const focusTracker = trackFocus(container);
    this._register(focusTracker);
    this._register(addDisposableListener(container, EventType.FOCUS, (e) => {
      if (isAncestor(e.relatedTarget, container)) {
        return;
      }
      this.previousFocusElement = e.relatedTarget instanceof HTMLElement ? e.relatedTarget : void 0;
    }, true));
    this._register(focusTracker.onDidBlur(() => {
      if (!this.getUI().ignoreFocusOut && !this.options.ignoreFocusOut()) {
        this.hide(QuickInputHideReason.Blur);
      }
      this.previousFocusElement = void 0;
    }));
    this._register(addDisposableListener(container, EventType.FOCUS, (e) => {
      inputBox.setFocus();
    }));
    this._register(addStandardDisposableListener(container, EventType.KEY_DOWN, (event) => {
      if (isAncestor(event.target, widget)) {
        return;
      }
      switch (event.keyCode) {
        case 3:
          EventHelper.stop(event, true);
          if (this.enabled) {
            this.onDidAcceptEmitter.fire();
          }
          break;
        case 9:
          EventHelper.stop(event, true);
          this.hide(QuickInputHideReason.Gesture);
          break;
        case 2:
          if (!event.altKey && !event.ctrlKey && !event.metaKey) {
            const selectors = [
              ".quick-input-list .monaco-action-bar .always-visible",
              ".quick-input-list-entry:hover .monaco-action-bar",
              ".monaco-list-row.focused .monaco-action-bar"
            ];
            if (container.classList.contains("show-checkboxes")) {
              selectors.push("input");
            } else {
              selectors.push("input[type=text]");
            }
            if (this.getUI().list.isDisplayed()) {
              selectors.push(".monaco-list");
            }
            if (this.getUI().message) {
              selectors.push(".quick-input-message a");
            }
            if (this.getUI().widget) {
              if (isAncestor(event.target, this.getUI().widget)) {
                break;
              }
              selectors.push(".quick-input-html-widget");
            }
            const stops = container.querySelectorAll(selectors.join(", "));
            if (event.shiftKey && event.target === stops[0]) {
              EventHelper.stop(event, true);
              list.clearFocus();
            } else if (!event.shiftKey && isAncestor(event.target, stops[stops.length - 1])) {
              EventHelper.stop(event, true);
              stops[0].focus();
            }
          }
          break;
        case 10:
          if (event.ctrlKey) {
            EventHelper.stop(event, true);
            this.getUI().list.toggleHover();
          }
          break;
      }
    }));
    this.ui = {
      container,
      styleSheet,
      leftActionBar,
      titleBar,
      title,
      description1,
      description2,
      widget,
      rightActionBar,
      checkAll,
      inputContainer,
      filterContainer,
      inputBox,
      visibleCountContainer,
      visibleCount,
      countContainer,
      count,
      okContainer,
      ok: ok2,
      message,
      customButtonContainer,
      customButton,
      list,
      progressBar,
      onDidAccept: this.onDidAcceptEmitter.event,
      onDidCustom: this.onDidCustomEmitter.event,
      onDidTriggerButton: this.onDidTriggerButtonEmitter.event,
      ignoreFocusOut: false,
      keyMods: this.keyMods,
      show: (controller) => this.show(controller),
      hide: () => this.hide(),
      setVisibilities: (visibilities) => this.setVisibilities(visibilities),
      setEnabled: (enabled) => this.setEnabled(enabled),
      setContextKey: (contextKey) => this.options.setContextKey(contextKey),
      linkOpenerDelegate: (content) => this.options.linkOpenerDelegate(content)
    };
    this.updateStyles();
    return this.ui;
  }
  reparentUI(container) {
    if (this.ui) {
      this._container = container;
      append(this._container, this.ui.container);
    }
  }
  pick(picks, options2 = {}, token = CancellationToken.None) {
    return new Promise((doResolve, reject) => {
      let resolve2 = (result) => {
        var _a2;
        resolve2 = doResolve;
        (_a2 = options2.onKeyMods) === null || _a2 === void 0 ? void 0 : _a2.call(options2, input.keyMods);
        doResolve(result);
      };
      if (token.isCancellationRequested) {
        resolve2(void 0);
        return;
      }
      const input = this.createQuickPick();
      let activeItem;
      const disposables = [
        input,
        input.onDidAccept(() => {
          if (input.canSelectMany) {
            resolve2(input.selectedItems.slice());
            input.hide();
          } else {
            const result = input.activeItems[0];
            if (result) {
              resolve2(result);
              input.hide();
            }
          }
        }),
        input.onDidChangeActive((items) => {
          const focused = items[0];
          if (focused && options2.onDidFocus) {
            options2.onDidFocus(focused);
          }
        }),
        input.onDidChangeSelection((items) => {
          if (!input.canSelectMany) {
            const result = items[0];
            if (result) {
              resolve2(result);
              input.hide();
            }
          }
        }),
        input.onDidTriggerItemButton((event) => options2.onDidTriggerItemButton && options2.onDidTriggerItemButton({
          ...event,
          removeItem: () => {
            const index = input.items.indexOf(event.item);
            if (index !== -1) {
              const items = input.items.slice();
              const removed = items.splice(index, 1);
              const activeItems = input.activeItems.filter((activeItem2) => activeItem2 !== removed[0]);
              const keepScrollPositionBefore = input.keepScrollPosition;
              input.keepScrollPosition = true;
              input.items = items;
              if (activeItems) {
                input.activeItems = activeItems;
              }
              input.keepScrollPosition = keepScrollPositionBefore;
            }
          }
        })),
        input.onDidTriggerSeparatorButton((event) => {
          var _a2;
          return (_a2 = options2.onDidTriggerSeparatorButton) === null || _a2 === void 0 ? void 0 : _a2.call(options2, event);
        }),
        input.onDidChangeValue((value) => {
          if (activeItem && !value && (input.activeItems.length !== 1 || input.activeItems[0] !== activeItem)) {
            input.activeItems = [activeItem];
          }
        }),
        token.onCancellationRequested(() => {
          input.hide();
        }),
        input.onDidHide(() => {
          dispose(disposables);
          resolve2(void 0);
        })
      ];
      input.title = options2.title;
      input.canSelectMany = !!options2.canPickMany;
      input.placeholder = options2.placeHolder;
      input.ignoreFocusOut = !!options2.ignoreFocusLost;
      input.matchOnDescription = !!options2.matchOnDescription;
      input.matchOnDetail = !!options2.matchOnDetail;
      input.matchOnLabel = options2.matchOnLabel === void 0 || options2.matchOnLabel;
      input.quickNavigate = options2.quickNavigate;
      input.hideInput = !!options2.hideInput;
      input.contextKey = options2.contextKey;
      input.busy = true;
      Promise.all([picks, options2.activeItem]).then(([items, _activeItem]) => {
        activeItem = _activeItem;
        input.busy = false;
        input.items = items;
        if (input.canSelectMany) {
          input.selectedItems = items.filter((item) => item.type !== "separator" && item.picked);
        }
        if (activeItem) {
          input.activeItems = [activeItem];
        }
      });
      input.show();
      Promise.resolve(picks).then(void 0, (err) => {
        reject(err);
        input.hide();
      });
    });
  }
  createQuickPick() {
    const ui = this.getUI(true);
    return new QuickPick(ui);
  }
  createInputBox() {
    const ui = this.getUI(true);
    return new InputBox2(ui);
  }
  show(controller) {
    const ui = this.getUI(true);
    this.onShowEmitter.fire();
    const oldController = this.controller;
    this.controller = controller;
    oldController === null || oldController === void 0 ? void 0 : oldController.didHide();
    this.setEnabled(true);
    ui.leftActionBar.clear();
    ui.title.textContent = "";
    ui.description1.textContent = "";
    ui.description2.textContent = "";
    reset(ui.widget);
    ui.rightActionBar.clear();
    ui.checkAll.checked = false;
    ui.inputBox.placeholder = "";
    ui.inputBox.password = false;
    ui.inputBox.showDecoration(severity_default.Ignore);
    ui.visibleCount.setCount(0);
    ui.count.setCount(0);
    reset(ui.message);
    ui.progressBar.stop();
    ui.list.setElements([]);
    ui.list.matchOnDescription = false;
    ui.list.matchOnDetail = false;
    ui.list.matchOnLabel = true;
    ui.list.sortByLabel = true;
    ui.ignoreFocusOut = false;
    ui.inputBox.toggles = void 0;
    const backKeybindingLabel = this.options.backKeybindingLabel();
    backButton.tooltip = backKeybindingLabel ? localize("quickInput.backWithKeybinding", "Back ({0})", backKeybindingLabel) : localize("quickInput.back", "Back");
    ui.container.style.display = "";
    this.updateLayout();
    ui.inputBox.setFocus();
  }
  isVisible() {
    return !!this.ui && this.ui.container.style.display !== "none";
  }
  setVisibilities(visibilities) {
    const ui = this.getUI();
    ui.title.style.display = visibilities.title ? "" : "none";
    ui.description1.style.display = visibilities.description && (visibilities.inputBox || visibilities.checkAll) ? "" : "none";
    ui.description2.style.display = visibilities.description && !(visibilities.inputBox || visibilities.checkAll) ? "" : "none";
    ui.checkAll.style.display = visibilities.checkAll ? "" : "none";
    ui.inputContainer.style.display = visibilities.inputBox ? "" : "none";
    ui.filterContainer.style.display = visibilities.inputBox ? "" : "none";
    ui.visibleCountContainer.style.display = visibilities.visibleCount ? "" : "none";
    ui.countContainer.style.display = visibilities.count ? "" : "none";
    ui.okContainer.style.display = visibilities.ok ? "" : "none";
    ui.customButtonContainer.style.display = visibilities.customButton ? "" : "none";
    ui.message.style.display = visibilities.message ? "" : "none";
    ui.progressBar.getContainer().style.display = visibilities.progressBar ? "" : "none";
    ui.list.display(!!visibilities.list);
    ui.container.classList.toggle("show-checkboxes", !!visibilities.checkBox);
    ui.container.classList.toggle("hidden-input", !visibilities.inputBox && !visibilities.description);
    this.updateLayout();
  }
  setEnabled(enabled) {
    if (enabled !== this.enabled) {
      this.enabled = enabled;
      for (const item of this.getUI().leftActionBar.viewItems) {
        item.action.enabled = enabled;
      }
      for (const item of this.getUI().rightActionBar.viewItems) {
        item.action.enabled = enabled;
      }
      this.getUI().checkAll.disabled = !enabled;
      this.getUI().inputBox.enabled = enabled;
      this.getUI().ok.enabled = enabled;
      this.getUI().list.enabled = enabled;
    }
  }
  hide(reason) {
    var _a2, _b2;
    const controller = this.controller;
    if (!controller) {
      return;
    }
    const container = (_a2 = this.ui) === null || _a2 === void 0 ? void 0 : _a2.container;
    const focusChanged = container && !isAncestorOfActiveElement(container);
    this.controller = null;
    this.onHideEmitter.fire();
    if (container) {
      container.style.display = "none";
    }
    if (!focusChanged) {
      let currentElement = this.previousFocusElement;
      while (currentElement && !currentElement.offsetParent) {
        currentElement = (_b2 = currentElement.parentElement) !== null && _b2 !== void 0 ? _b2 : void 0;
      }
      if (currentElement === null || currentElement === void 0 ? void 0 : currentElement.offsetParent) {
        currentElement.focus();
        this.previousFocusElement = void 0;
      } else {
        this.options.returnFocus();
      }
    }
    controller.didHide(reason);
  }
  layout(dimension, titleBarOffset) {
    this.dimension = dimension;
    this.titleBarOffset = titleBarOffset;
    this.updateLayout();
  }
  updateLayout() {
    if (this.ui && this.isVisible()) {
      this.ui.container.style.top = `${this.titleBarOffset}px`;
      const style = this.ui.container.style;
      const width = Math.min(this.dimension.width * 0.62, _QuickInputController.MAX_WIDTH);
      style.width = width + "px";
      style.marginLeft = "-" + width / 2 + "px";
      this.ui.inputBox.layout();
      this.ui.list.layout(this.dimension && this.dimension.height * 0.4);
    }
  }
  applyStyles(styles) {
    this.styles = styles;
    this.updateStyles();
  }
  updateStyles() {
    if (this.ui) {
      const { quickInputTitleBackground: quickInputTitleBackground2, quickInputBackground: quickInputBackground2, quickInputForeground: quickInputForeground2, widgetBorder: widgetBorder2, widgetShadow: widgetShadow2 } = this.styles.widget;
      this.ui.titleBar.style.backgroundColor = quickInputTitleBackground2 !== null && quickInputTitleBackground2 !== void 0 ? quickInputTitleBackground2 : "";
      this.ui.container.style.backgroundColor = quickInputBackground2 !== null && quickInputBackground2 !== void 0 ? quickInputBackground2 : "";
      this.ui.container.style.color = quickInputForeground2 !== null && quickInputForeground2 !== void 0 ? quickInputForeground2 : "";
      this.ui.container.style.border = widgetBorder2 ? `1px solid ${widgetBorder2}` : "";
      this.ui.container.style.boxShadow = widgetShadow2 ? `0 0 8px 2px ${widgetShadow2}` : "";
      this.ui.list.style(this.styles.list);
      const content = [];
      if (this.styles.pickerGroup.pickerGroupBorder) {
        content.push(`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.styles.pickerGroup.pickerGroupBorder}; }`);
      }
      if (this.styles.pickerGroup.pickerGroupForeground) {
        content.push(`.quick-input-list .quick-input-list-separator { color:  ${this.styles.pickerGroup.pickerGroupForeground}; }`);
      }
      if (this.styles.pickerGroup.pickerGroupForeground) {
        content.push(`.quick-input-list .quick-input-list-separator-as-item { color: var(--vscode-descriptionForeground); }`);
      }
      if (this.styles.keybindingLabel.keybindingLabelBackground || this.styles.keybindingLabel.keybindingLabelBorder || this.styles.keybindingLabel.keybindingLabelBottomBorder || this.styles.keybindingLabel.keybindingLabelShadow || this.styles.keybindingLabel.keybindingLabelForeground) {
        content.push(".quick-input-list .monaco-keybinding > .monaco-keybinding-key {");
        if (this.styles.keybindingLabel.keybindingLabelBackground) {
          content.push(`background-color: ${this.styles.keybindingLabel.keybindingLabelBackground};`);
        }
        if (this.styles.keybindingLabel.keybindingLabelBorder) {
          content.push(`border-color: ${this.styles.keybindingLabel.keybindingLabelBorder};`);
        }
        if (this.styles.keybindingLabel.keybindingLabelBottomBorder) {
          content.push(`border-bottom-color: ${this.styles.keybindingLabel.keybindingLabelBottomBorder};`);
        }
        if (this.styles.keybindingLabel.keybindingLabelShadow) {
          content.push(`box-shadow: inset 0 -1px 0 ${this.styles.keybindingLabel.keybindingLabelShadow};`);
        }
        if (this.styles.keybindingLabel.keybindingLabelForeground) {
          content.push(`color: ${this.styles.keybindingLabel.keybindingLabelForeground};`);
        }
        content.push("}");
      }
      const newStyles = content.join("\n");
      if (newStyles !== this.ui.styleSheet.textContent) {
        this.ui.styleSheet.textContent = newStyles;
      }
    }
  }
};
QuickInputController.MAX_WIDTH = 600;

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputService.js
init_configuration();
init_dom();
var __decorate31 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param24 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var QuickInputService = class QuickInputService2 extends Themable {
  get controller() {
    if (!this._controller) {
      this._controller = this._register(this.createController());
    }
    return this._controller;
  }
  get hasController() {
    return !!this._controller;
  }
  get quickAccess() {
    if (!this._quickAccess) {
      this._quickAccess = this._register(this.instantiationService.createInstance(QuickAccessController));
    }
    return this._quickAccess;
  }
  constructor(instantiationService, contextKeyService, themeService, layoutService, configurationService) {
    super(themeService);
    this.instantiationService = instantiationService;
    this.contextKeyService = contextKeyService;
    this.layoutService = layoutService;
    this.configurationService = configurationService;
    this._onShow = this._register(new Emitter());
    this._onHide = this._register(new Emitter());
    this.contexts = /* @__PURE__ */ new Map();
  }
  createController(host = this.layoutService, options2) {
    const defaultOptions = {
      idPrefix: "quickInput_",
      container: host.activeContainer,
      ignoreFocusOut: () => false,
      backKeybindingLabel: () => void 0,
      setContextKey: (id) => this.setContextKey(id),
      linkOpenerDelegate: (content) => {
        this.instantiationService.invokeFunction((accessor) => {
          const openerService = accessor.get(IOpenerService);
          openerService.open(content, { allowCommands: true, fromUserGesture: true });
        });
      },
      returnFocus: () => host.focus(),
      createList: (user, container, delegate, renderers, options3) => this.instantiationService.createInstance(WorkbenchList, user, container, delegate, renderers, options3),
      styles: this.computeStyles(),
      hoverDelegate: this._register(this.instantiationService.createInstance(QuickInputHoverDelegate))
    };
    const controller = this._register(new QuickInputController({
      ...defaultOptions,
      ...options2
    }, this.themeService, this.layoutService));
    controller.layout(host.activeContainerDimension, host.activeContainerOffset.quickPickTop);
    this._register(host.onDidLayoutActiveContainer((dimension) => {
      if (getWindow(host.activeContainer) === getWindow(controller.container)) {
        controller.layout(dimension, host.activeContainerOffset.quickPickTop);
      }
    }));
    this._register(host.onDidChangeActiveContainer(() => {
      if (controller.isVisible()) {
        return;
      }
      controller.layout(host.activeContainerDimension, host.activeContainerOffset.quickPickTop);
    }));
    this._register(controller.onShow(() => {
      this.resetContextKeys();
      this._onShow.fire();
    }));
    this._register(controller.onHide(() => {
      this.resetContextKeys();
      this._onHide.fire();
    }));
    return controller;
  }
  setContextKey(id) {
    let key;
    if (id) {
      key = this.contexts.get(id);
      if (!key) {
        key = new RawContextKey(id, false).bindTo(this.contextKeyService);
        this.contexts.set(id, key);
      }
    }
    if (key && key.get()) {
      return;
    }
    this.resetContextKeys();
    key === null || key === void 0 ? void 0 : key.set(true);
  }
  resetContextKeys() {
    this.contexts.forEach((context) => {
      if (context.get()) {
        context.reset();
      }
    });
  }
  pick(picks, options2 = {}, token = CancellationToken.None) {
    return this.controller.pick(picks, options2, token);
  }
  createQuickPick() {
    return this.controller.createQuickPick();
  }
  createInputBox() {
    return this.controller.createInputBox();
  }
  updateStyles() {
    if (this.hasController) {
      this.controller.applyStyles(this.computeStyles());
    }
  }
  computeStyles() {
    return {
      widget: {
        quickInputBackground: asCssVariable(quickInputBackground),
        quickInputForeground: asCssVariable(quickInputForeground),
        quickInputTitleBackground: asCssVariable(quickInputTitleBackground),
        widgetBorder: asCssVariable(widgetBorder),
        widgetShadow: asCssVariable(widgetShadow)
      },
      inputBox: defaultInputBoxStyles,
      toggle: defaultToggleStyles,
      countBadge: defaultCountBadgeStyles,
      button: defaultButtonStyles,
      progressBar: defaultProgressBarStyles,
      keybindingLabel: defaultKeybindingLabelStyles,
      list: getListStyles({
        listBackground: quickInputBackground,
        listFocusBackground: quickInputListFocusBackground,
        listFocusForeground: quickInputListFocusForeground,
        // Look like focused when inactive.
        listInactiveFocusForeground: quickInputListFocusForeground,
        listInactiveSelectionIconForeground: quickInputListFocusIconForeground,
        listInactiveFocusBackground: quickInputListFocusBackground,
        listFocusOutline: activeContrastBorder,
        listInactiveFocusOutline: activeContrastBorder
      }),
      pickerGroup: {
        pickerGroupBorder: asCssVariable(pickerGroupBorder),
        pickerGroupForeground: asCssVariable(pickerGroupForeground)
      }
    };
  }
};
QuickInputService = __decorate31([
  __param24(0, IInstantiationService),
  __param24(1, IContextKeyService),
  __param24(2, IThemeService),
  __param24(3, ILayoutService),
  __param24(4, IConfigurationService)
], QuickInputService);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickInput/standaloneQuickInputService.js
init_functional();
init_configuration();
var __decorate32 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param25 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var EditorScopedQuickInputService = class EditorScopedQuickInputService2 extends QuickInputService {
  constructor(editor, instantiationService, contextKeyService, themeService, codeEditorService, configurationService) {
    super(instantiationService, contextKeyService, themeService, new EditorScopedLayoutService(editor.getContainerDomNode(), codeEditorService), configurationService);
    this.host = void 0;
    const contribution = QuickInputEditorContribution.get(editor);
    if (contribution) {
      const widget = contribution.widget;
      this.host = {
        _serviceBrand: void 0,
        get mainContainer() {
          return widget.getDomNode();
        },
        getContainer() {
          return widget.getDomNode();
        },
        get containers() {
          return [widget.getDomNode()];
        },
        get activeContainer() {
          return widget.getDomNode();
        },
        get mainContainerDimension() {
          return editor.getLayoutInfo();
        },
        get activeContainerDimension() {
          return editor.getLayoutInfo();
        },
        get onDidLayoutMainContainer() {
          return editor.onDidLayoutChange;
        },
        get onDidLayoutActiveContainer() {
          return editor.onDidLayoutChange;
        },
        get onDidLayoutContainer() {
          return Event.map(editor.onDidLayoutChange, (dimension) => ({ container: widget.getDomNode(), dimension }));
        },
        get onDidChangeActiveContainer() {
          return Event.None;
        },
        get onDidAddContainer() {
          return Event.None;
        },
        get whenActiveContainerStylesLoaded() {
          return Promise.resolve();
        },
        get mainContainerOffset() {
          return { top: 0, quickPickTop: 0 };
        },
        get activeContainerOffset() {
          return { top: 0, quickPickTop: 0 };
        },
        focus: () => editor.focus()
      };
    } else {
      this.host = void 0;
    }
  }
  createController() {
    return super.createController(this.host);
  }
};
EditorScopedQuickInputService = __decorate32([
  __param25(1, IInstantiationService),
  __param25(2, IContextKeyService),
  __param25(3, IThemeService),
  __param25(4, ICodeEditorService),
  __param25(5, IConfigurationService)
], EditorScopedQuickInputService);
var StandaloneQuickInputService = class StandaloneQuickInputService2 {
  get activeService() {
    const editor = this.codeEditorService.getFocusedCodeEditor();
    if (!editor) {
      throw new Error("Quick input service needs a focused editor to work.");
    }
    let quickInputService = this.mapEditorToService.get(editor);
    if (!quickInputService) {
      const newQuickInputService = quickInputService = this.instantiationService.createInstance(EditorScopedQuickInputService, editor);
      this.mapEditorToService.set(editor, quickInputService);
      createSingleCallFunction(editor.onDidDispose)(() => {
        newQuickInputService.dispose();
        this.mapEditorToService.delete(editor);
      });
    }
    return quickInputService;
  }
  get quickAccess() {
    return this.activeService.quickAccess;
  }
  constructor(instantiationService, codeEditorService) {
    this.instantiationService = instantiationService;
    this.codeEditorService = codeEditorService;
    this.mapEditorToService = /* @__PURE__ */ new Map();
  }
  pick(picks, options2 = {}, token = CancellationToken.None) {
    return this.activeService.pick(picks, options2, token);
  }
  createQuickPick() {
    return this.activeService.createQuickPick();
  }
  createInputBox() {
    return this.activeService.createInputBox();
  }
};
StandaloneQuickInputService = __decorate32([
  __param25(0, IInstantiationService),
  __param25(1, ICodeEditorService)
], StandaloneQuickInputService);
var QuickInputEditorContribution = class _QuickInputEditorContribution {
  static get(editor) {
    return editor.getContribution(_QuickInputEditorContribution.ID);
  }
  constructor(editor) {
    this.editor = editor;
    this.widget = new QuickInputEditorWidget(this.editor);
  }
  dispose() {
    this.widget.dispose();
  }
};
QuickInputEditorContribution.ID = "editor.controller.quickInput";
var QuickInputEditorWidget = class _QuickInputEditorWidget {
  constructor(codeEditor) {
    this.codeEditor = codeEditor;
    this.domNode = document.createElement("div");
    this.codeEditor.addOverlayWidget(this);
  }
  getId() {
    return _QuickInputEditorWidget.ID;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      preference: 2
      /* OverlayWidgetPositionPreference.TOP_CENTER */
    };
  }
  dispose() {
    this.codeEditor.removeOverlayWidget(this);
  }
};
QuickInputEditorWidget.ID = "editor.contrib.quickInputWidget";
registerEditorContribution(
  QuickInputEditorContribution.ID,
  QuickInputEditorContribution,
  4
  /* EditorContributionInstantiation.Lazy */
);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneThemeService.js
init_dom();
init_browser();
init_color();
init_event();
init_languages();
init_encodedTokenAttributes();

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports/tokenization.js
init_color();
var ParsedTokenThemeRule = class {
  constructor(token, index, fontStyle, foreground2, background) {
    this._parsedThemeRuleBrand = void 0;
    this.token = token;
    this.index = index;
    this.fontStyle = fontStyle;
    this.foreground = foreground2;
    this.background = background;
  }
};
function parseTokenTheme(source) {
  if (!source || !Array.isArray(source)) {
    return [];
  }
  const result = [];
  let resultLen = 0;
  for (let i = 0, len = source.length; i < len; i++) {
    const entry = source[i];
    let fontStyle = -1;
    if (typeof entry.fontStyle === "string") {
      fontStyle = 0;
      const segments = entry.fontStyle.split(" ");
      for (let j = 0, lenJ = segments.length; j < lenJ; j++) {
        const segment = segments[j];
        switch (segment) {
          case "italic":
            fontStyle = fontStyle | 1;
            break;
          case "bold":
            fontStyle = fontStyle | 2;
            break;
          case "underline":
            fontStyle = fontStyle | 4;
            break;
          case "strikethrough":
            fontStyle = fontStyle | 8;
            break;
        }
      }
    }
    let foreground2 = null;
    if (typeof entry.foreground === "string") {
      foreground2 = entry.foreground;
    }
    let background = null;
    if (typeof entry.background === "string") {
      background = entry.background;
    }
    result[resultLen++] = new ParsedTokenThemeRule(entry.token || "", i, fontStyle, foreground2, background);
  }
  return result;
}
function resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {
  parsedThemeRules.sort((a, b) => {
    const r = strcmp(a.token, b.token);
    if (r !== 0) {
      return r;
    }
    return a.index - b.index;
  });
  let defaultFontStyle = 0;
  let defaultForeground = "000000";
  let defaultBackground = "ffffff";
  while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === "") {
    const incomingDefaults = parsedThemeRules.shift();
    if (incomingDefaults.fontStyle !== -1) {
      defaultFontStyle = incomingDefaults.fontStyle;
    }
    if (incomingDefaults.foreground !== null) {
      defaultForeground = incomingDefaults.foreground;
    }
    if (incomingDefaults.background !== null) {
      defaultBackground = incomingDefaults.background;
    }
  }
  const colorMap = new ColorMap();
  for (const color of customTokenColors) {
    colorMap.getId(color);
  }
  const foregroundColorId = colorMap.getId(defaultForeground);
  const backgroundColorId = colorMap.getId(defaultBackground);
  const defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);
  const root = new ThemeTrieElement(defaults);
  for (let i = 0, len = parsedThemeRules.length; i < len; i++) {
    const rule = parsedThemeRules[i];
    root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));
  }
  return new TokenTheme(colorMap, root);
}
var colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
var ColorMap = class {
  constructor() {
    this._lastColorId = 0;
    this._id2color = [];
    this._color2id = /* @__PURE__ */ new Map();
  }
  getId(color) {
    if (color === null) {
      return 0;
    }
    const match2 = color.match(colorRegExp);
    if (!match2) {
      throw new Error("Illegal value for token color: " + color);
    }
    color = match2[1].toUpperCase();
    let value = this._color2id.get(color);
    if (value) {
      return value;
    }
    value = ++this._lastColorId;
    this._color2id.set(color, value);
    this._id2color[value] = Color.fromHex("#" + color);
    return value;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
};
var TokenTheme = class {
  static createFromRawTokenTheme(source, customTokenColors) {
    return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);
  }
  static createFromParsedTokenTheme(source, customTokenColors) {
    return resolveParsedTokenThemeRules(source, customTokenColors);
  }
  constructor(colorMap, root) {
    this._colorMap = colorMap;
    this._root = root;
    this._cache = /* @__PURE__ */ new Map();
  }
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  _match(token) {
    return this._root.match(token);
  }
  match(languageId, token) {
    let result = this._cache.get(token);
    if (typeof result === "undefined") {
      const rule = this._match(token);
      const standardToken = toStandardTokenType(token);
      result = (rule.metadata | standardToken << 8) >>> 0;
      this._cache.set(token, result);
    }
    return (result | languageId << 0) >>> 0;
  }
};
var STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|regexp)\b/;
function toStandardTokenType(tokenType) {
  const m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);
  if (!m) {
    return 0;
  }
  switch (m[1]) {
    case "comment":
      return 1;
    case "string":
      return 2;
    case "regex":
      return 3;
    case "regexp":
      return 3;
  }
  throw new Error("Unexpected match for standard token type!");
}
function strcmp(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
var ThemeTrieElementRule = class _ThemeTrieElementRule {
  constructor(fontStyle, foreground2, background) {
    this._themeTrieElementRuleBrand = void 0;
    this._fontStyle = fontStyle;
    this._foreground = foreground2;
    this._background = background;
    this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
  }
  clone() {
    return new _ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);
  }
  acceptOverwrite(fontStyle, foreground2, background) {
    if (fontStyle !== -1) {
      this._fontStyle = fontStyle;
    }
    if (foreground2 !== 0) {
      this._foreground = foreground2;
    }
    if (background !== 0) {
      this._background = background;
    }
    this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
  }
};
var ThemeTrieElement = class _ThemeTrieElement {
  constructor(mainRule) {
    this._themeTrieElementBrand = void 0;
    this._mainRule = mainRule;
    this._children = /* @__PURE__ */ new Map();
  }
  match(token) {
    if (token === "") {
      return this._mainRule;
    }
    const dotIndex = token.indexOf(".");
    let head;
    let tail3;
    if (dotIndex === -1) {
      head = token;
      tail3 = "";
    } else {
      head = token.substring(0, dotIndex);
      tail3 = token.substring(dotIndex + 1);
    }
    const child = this._children.get(head);
    if (typeof child !== "undefined") {
      return child.match(tail3);
    }
    return this._mainRule;
  }
  insert(token, fontStyle, foreground2, background) {
    if (token === "") {
      this._mainRule.acceptOverwrite(fontStyle, foreground2, background);
      return;
    }
    const dotIndex = token.indexOf(".");
    let head;
    let tail3;
    if (dotIndex === -1) {
      head = token;
      tail3 = "";
    } else {
      head = token.substring(0, dotIndex);
      tail3 = token.substring(dotIndex + 1);
    }
    let child = this._children.get(head);
    if (typeof child === "undefined") {
      child = new _ThemeTrieElement(this._mainRule.clone());
      this._children.set(head, child);
    }
    child.insert(tail3, fontStyle, foreground2, background);
  }
};
function generateTokensCSSForColorMap(colorMap) {
  const rules = [];
  for (let i = 1, len = colorMap.length; i < len; i++) {
    const color = colorMap[i];
    rules[i] = `.mtk${i} { color: ${color}; }`;
  }
  rules.push(".mtki { font-style: italic; }");
  rules.push(".mtkb { font-weight: bold; }");
  rules.push(".mtku { text-decoration: underline; text-underline-position: under; }");
  rules.push(".mtks { text-decoration: line-through; }");
  rules.push(".mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }");
  return rules.join("\n");
}

// node_modules/monaco-editor/esm/vs/editor/standalone/common/themes.js
init_editorColorRegistry();
init_colorRegistry();
var vs = {
  base: "vs",
  inherit: false,
  rules: [
    { token: "", foreground: "000000", background: "fffffe" },
    { token: "invalid", foreground: "cd3131" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "001188" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "delimiter.xml", foreground: "0000FF" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "FF0000" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "FF0000" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "attribute.value.number", foreground: "098658" },
    { token: "attribute.value.unit", foreground: "098658" },
    { token: "attribute.value.html", foreground: "0000FF" },
    { token: "attribute.value.xml", foreground: "0000FF" },
    { token: "string", foreground: "A31515" },
    { token: "string.html", foreground: "0000FF" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "string.yaml", foreground: "0451A5" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.json", foreground: "0451A5" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "keyword.flow.scss", foreground: "0000FF" },
    { token: "operator.scss", foreground: "666666" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [editorBackground]: "#FFFFFE",
    [editorForeground]: "#000000",
    [editorInactiveSelection]: "#E5EBF1",
    [editorIndentGuide1]: "#D3D3D3",
    [editorActiveIndentGuide1]: "#939393",
    [editorSelectionHighlight]: "#ADD6FF4D"
  }
};
var vs_dark = {
  base: "vs-dark",
  inherit: false,
  rules: [
    { token: "", foreground: "D4D4D4", background: "1E1E1E" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "74B0DF" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "B5CEA8" },
    { token: "number.hex", foreground: "5BB498" },
    { token: "regexp", foreground: "B46695" },
    { token: "annotation", foreground: "cc6666" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "DCDCDC" },
    { token: "delimiter.html", foreground: "808080" },
    { token: "delimiter.xml", foreground: "808080" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "A79873" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "DD6A6F" },
    { token: "metatag.content.html", foreground: "9CDCFE" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key.json", foreground: "9CDCFE" },
    { token: "string.value.json", foreground: "CE9178" },
    { token: "attribute.name", foreground: "9CDCFE" },
    { token: "attribute.value", foreground: "CE9178" },
    { token: "attribute.value.number.css", foreground: "B5CEA8" },
    { token: "attribute.value.unit.css", foreground: "B5CEA8" },
    { token: "attribute.value.hex.css", foreground: "D4D4D4" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "keyword.json", foreground: "CE9178" },
    { token: "keyword.flow.scss", foreground: "569CD6" },
    { token: "operator.scss", foreground: "909090" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [editorBackground]: "#1E1E1E",
    [editorForeground]: "#D4D4D4",
    [editorInactiveSelection]: "#3A3D41",
    [editorIndentGuide1]: "#404040",
    [editorActiveIndentGuide1]: "#707070",
    [editorSelectionHighlight]: "#ADD6FF26"
  }
};
var hc_black = {
  base: "hc-black",
  inherit: false,
  rules: [
    { token: "", foreground: "FFFFFF", background: "000000" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "1AEBFF" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "FFFFFF" },
    { token: "regexp", foreground: "C0C0C0" },
    { token: "annotation", foreground: "569CD6" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "FFFF00" },
    { token: "delimiter.html", foreground: "FFFF00" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta", foreground: "D4D4D4" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "569CD6" },
    { token: "metatag.content.html", foreground: "1AEBFF" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key", foreground: "9CDCFE" },
    { token: "string.value", foreground: "CE9178" },
    { token: "attribute.name", foreground: "569CD6" },
    { token: "attribute.value", foreground: "3FF23F" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [editorBackground]: "#000000",
    [editorForeground]: "#FFFFFF",
    [editorIndentGuide1]: "#FFFFFF",
    [editorActiveIndentGuide1]: "#FFFFFF"
  }
};
var hc_light = {
  base: "hc-light",
  inherit: false,
  rules: [
    { token: "", foreground: "292929", background: "FFFFFF" },
    { token: "invalid", foreground: "B5200D" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "264F70" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "B5200D" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "264F78" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "string", foreground: "A31515" },
    { token: "string.sql", foreground: "B5200D" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [editorBackground]: "#FFFFFF",
    [editorForeground]: "#292929",
    [editorIndentGuide1]: "#292929",
    [editorActiveIndentGuide1]: "#292929"
  }
};

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneThemeService.js
init_platform2();
init_colorRegistry();
init_themeService();
init_lifecycle();
init_theme();

// node_modules/monaco-editor/esm/vs/platform/theme/browser/iconsStyleSheet.js
init_dom();
init_event();
init_lifecycle();
init_themables();

// node_modules/monaco-editor/esm/vs/platform/theme/common/iconRegistry.js
init_async();
init_codicons();
init_themables();
init_event();
init_types();
init_uri();
init_nls();
init_jsonContributionRegistry();
init_platform2();
var Extensions9 = {
  IconContribution: "base.contributions.icons"
};
var IconContribution;
(function(IconContribution2) {
  function getDefinition(contribution, registry) {
    let definition = contribution.defaults;
    while (ThemeIcon.isThemeIcon(definition)) {
      const c = iconRegistry.getIcon(definition.id);
      if (!c) {
        return void 0;
      }
      definition = c.defaults;
    }
    return definition;
  }
  IconContribution2.getDefinition = getDefinition;
})(IconContribution || (IconContribution = {}));
var IconFontDefinition;
(function(IconFontDefinition2) {
  function toJSONObject(iconFont) {
    return {
      weight: iconFont.weight,
      style: iconFont.style,
      src: iconFont.src.map((s) => ({ format: s.format, location: s.location.toString() }))
    };
  }
  IconFontDefinition2.toJSONObject = toJSONObject;
  function fromJSONObject(json) {
    const stringOrUndef = (s) => isString(s) ? s : void 0;
    if (json && Array.isArray(json.src) && json.src.every((s) => isString(s.format) && isString(s.location))) {
      return {
        weight: stringOrUndef(json.weight),
        style: stringOrUndef(json.style),
        src: json.src.map((s) => ({ format: s.format, location: URI.parse(s.location) }))
      };
    }
    return void 0;
  }
  IconFontDefinition2.fromJSONObject = fromJSONObject;
})(IconFontDefinition || (IconFontDefinition = {}));
var IconRegistry = class {
  constructor() {
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this.iconSchema = {
      definitions: {
        icons: {
          type: "object",
          properties: {
            fontId: { type: "string", description: localize("iconDefinition.fontId", "The id of the font to use. If not set, the font that is defined first is used.") },
            fontCharacter: { type: "string", description: localize("iconDefinition.fontCharacter", "The font character associated with the icon definition.") }
          },
          additionalProperties: false,
          defaultSnippets: [{ body: { fontCharacter: "\\\\e030" } }]
        }
      },
      type: "object",
      properties: {}
    };
    this.iconReferenceSchema = { type: "string", pattern: `^${ThemeIcon.iconNameExpression}$`, enum: [], enumDescriptions: [] };
    this.iconsById = {};
    this.iconFontsById = {};
  }
  registerIcon(id, defaults, description, deprecationMessage) {
    const existing = this.iconsById[id];
    if (existing) {
      if (description && !existing.description) {
        existing.description = description;
        this.iconSchema.properties[id].markdownDescription = `${description} $(${id})`;
        const enumIndex = this.iconReferenceSchema.enum.indexOf(id);
        if (enumIndex !== -1) {
          this.iconReferenceSchema.enumDescriptions[enumIndex] = description;
        }
        this._onDidChange.fire();
      }
      return existing;
    }
    const iconContribution = { id, description, defaults, deprecationMessage };
    this.iconsById[id] = iconContribution;
    const propertySchema = { $ref: "#/definitions/icons" };
    if (deprecationMessage) {
      propertySchema.deprecationMessage = deprecationMessage;
    }
    if (description) {
      propertySchema.markdownDescription = `${description}: $(${id})`;
    }
    this.iconSchema.properties[id] = propertySchema;
    this.iconReferenceSchema.enum.push(id);
    this.iconReferenceSchema.enumDescriptions.push(description || "");
    this._onDidChange.fire();
    return { id };
  }
  getIcons() {
    return Object.keys(this.iconsById).map((id) => this.iconsById[id]);
  }
  getIcon(id) {
    return this.iconsById[id];
  }
  getIconSchema() {
    return this.iconSchema;
  }
  toString() {
    const sorter2 = (i1, i2) => {
      return i1.id.localeCompare(i2.id);
    };
    const classNames = (i) => {
      while (ThemeIcon.isThemeIcon(i.defaults)) {
        i = this.iconsById[i.defaults.id];
      }
      return `codicon codicon-${i ? i.id : ""}`;
    };
    const reference = [];
    reference.push(`| preview     | identifier                        | default codicon ID                | description`);
    reference.push(`| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |`);
    const contributions = Object.keys(this.iconsById).map((key) => this.iconsById[key]);
    for (const i of contributions.filter((i2) => !!i2.description).sort(sorter2)) {
      reference.push(`|<i class="${classNames(i)}"></i>|${i.id}|${ThemeIcon.isThemeIcon(i.defaults) ? i.defaults.id : i.id}|${i.description || ""}|`);
    }
    reference.push(`| preview     | identifier                        `);
    reference.push(`| ----------- | --------------------------------- |`);
    for (const i of contributions.filter((i2) => !ThemeIcon.isThemeIcon(i2.defaults)).sort(sorter2)) {
      reference.push(`|<i class="${classNames(i)}"></i>|${i.id}|`);
    }
    return reference.join("\n");
  }
};
var iconRegistry = new IconRegistry();
Registry.add(Extensions9.IconContribution, iconRegistry);
function registerIcon(id, defaults, description, deprecationMessage) {
  return iconRegistry.registerIcon(id, defaults, description, deprecationMessage);
}
function getIconRegistry() {
  return iconRegistry;
}
function initialize() {
  const codiconFontCharacters = getCodiconFontCharacters();
  for (const icon in codiconFontCharacters) {
    const fontCharacter = "\\" + codiconFontCharacters[icon].toString(16);
    iconRegistry.registerIcon(icon, { fontCharacter });
  }
}
initialize();
var iconsSchemaId = "vscode://schemas/icons";
var schemaRegistry2 = Registry.as(Extensions.JSONContribution);
schemaRegistry2.registerSchema(iconsSchemaId, iconRegistry.getIconSchema());
var delayer2 = new RunOnceScheduler(() => schemaRegistry2.notifySchemaChanged(iconsSchemaId), 200);
iconRegistry.onDidChange(() => {
  if (!delayer2.isScheduled()) {
    delayer2.schedule();
  }
});
var widgetClose = registerIcon("widget-close", Codicon.close, localize("widgetClose", "Icon for the close action in widgets."));
var gotoPreviousLocation = registerIcon("goto-previous-location", Codicon.arrowUp, localize("previousChangeIcon", "Icon for goto previous editor location."));
var gotoNextLocation = registerIcon("goto-next-location", Codicon.arrowDown, localize("nextChangeIcon", "Icon for goto next editor location."));
var syncing = ThemeIcon.modify(Codicon.sync, "spin");
var spinningLoading = ThemeIcon.modify(Codicon.loading, "spin");

// node_modules/monaco-editor/esm/vs/platform/theme/browser/iconsStyleSheet.js
function getIconsStyleSheet(themeService) {
  const disposable = new DisposableStore();
  const onDidChangeEmmiter = disposable.add(new Emitter());
  const iconRegistry2 = getIconRegistry();
  disposable.add(iconRegistry2.onDidChange(() => onDidChangeEmmiter.fire()));
  if (themeService) {
    disposable.add(themeService.onDidProductIconThemeChange(() => onDidChangeEmmiter.fire()));
  }
  return {
    dispose: () => disposable.dispose(),
    onDidChange: onDidChangeEmmiter.event,
    getCSS() {
      const productIconTheme = themeService ? themeService.getProductIconTheme() : new UnthemedProductIconTheme();
      const usedFontIds = {};
      const formatIconRule = (contribution) => {
        const definition = productIconTheme.getIcon(contribution);
        if (!definition) {
          return void 0;
        }
        const fontContribution = definition.font;
        if (fontContribution) {
          usedFontIds[fontContribution.id] = fontContribution.definition;
          return `.codicon-${contribution.id}:before { content: '${definition.fontCharacter}'; font-family: ${asCSSPropertyValue(fontContribution.id)}; }`;
        }
        return `.codicon-${contribution.id}:before { content: '${definition.fontCharacter}'; }`;
      };
      const rules = [];
      for (const contribution of iconRegistry2.getIcons()) {
        const rule = formatIconRule(contribution);
        if (rule) {
          rules.push(rule);
        }
      }
      for (const id in usedFontIds) {
        const definition = usedFontIds[id];
        const fontWeight = definition.weight ? `font-weight: ${definition.weight};` : "";
        const fontStyle = definition.style ? `font-style: ${definition.style};` : "";
        const src = definition.src.map((l) => `${asCSSUrl(l.location)} format('${l.format}')`).join(", ");
        rules.push(`@font-face { src: ${src}; font-family: ${asCSSPropertyValue(id)};${fontWeight}${fontStyle} font-display: block; }`);
      }
      return rules.join("\n");
    }
  };
}
var UnthemedProductIconTheme = class {
  getIcon(contribution) {
    const iconRegistry2 = getIconRegistry();
    let definition = contribution.defaults;
    while (ThemeIcon.isThemeIcon(definition)) {
      const c = iconRegistry2.getIcon(definition.id);
      if (!c) {
        return void 0;
      }
      definition = c.defaults;
    }
    return definition;
  }
};

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneThemeService.js
init_window();
var VS_LIGHT_THEME_NAME = "vs";
var VS_DARK_THEME_NAME = "vs-dark";
var HC_BLACK_THEME_NAME = "hc-black";
var HC_LIGHT_THEME_NAME = "hc-light";
var colorRegistry2 = Registry.as(Extensions5.ColorContribution);
var themingRegistry2 = Registry.as(Extensions4.ThemingContribution);
var StandaloneTheme = class {
  constructor(name, standaloneThemeData) {
    this.semanticHighlighting = false;
    this.themeData = standaloneThemeData;
    const base = standaloneThemeData.base;
    if (name.length > 0) {
      if (isBuiltinTheme(name)) {
        this.id = name;
      } else {
        this.id = base + " " + name;
      }
      this.themeName = name;
    } else {
      this.id = base;
      this.themeName = base;
    }
    this.colors = null;
    this.defaultColors = /* @__PURE__ */ Object.create(null);
    this._tokenTheme = null;
  }
  get base() {
    return this.themeData.base;
  }
  notifyBaseUpdated() {
    if (this.themeData.inherit) {
      this.colors = null;
      this._tokenTheme = null;
    }
  }
  getColors() {
    if (!this.colors) {
      const colors = /* @__PURE__ */ new Map();
      for (const id in this.themeData.colors) {
        colors.set(id, Color.fromHex(this.themeData.colors[id]));
      }
      if (this.themeData.inherit) {
        const baseData = getBuiltinRules(this.themeData.base);
        for (const id in baseData.colors) {
          if (!colors.has(id)) {
            colors.set(id, Color.fromHex(baseData.colors[id]));
          }
        }
      }
      this.colors = colors;
    }
    return this.colors;
  }
  getColor(colorId, useDefault) {
    const color = this.getColors().get(colorId);
    if (color) {
      return color;
    }
    if (useDefault !== false) {
      return this.getDefault(colorId);
    }
    return void 0;
  }
  getDefault(colorId) {
    let color = this.defaultColors[colorId];
    if (color) {
      return color;
    }
    color = colorRegistry2.resolveDefaultColor(colorId, this);
    this.defaultColors[colorId] = color;
    return color;
  }
  defines(colorId) {
    return this.getColors().has(colorId);
  }
  get type() {
    switch (this.base) {
      case VS_LIGHT_THEME_NAME:
        return ColorScheme.LIGHT;
      case HC_BLACK_THEME_NAME:
        return ColorScheme.HIGH_CONTRAST_DARK;
      case HC_LIGHT_THEME_NAME:
        return ColorScheme.HIGH_CONTRAST_LIGHT;
      default:
        return ColorScheme.DARK;
    }
  }
  get tokenTheme() {
    if (!this._tokenTheme) {
      let rules = [];
      let encodedTokensColors = [];
      if (this.themeData.inherit) {
        const baseData = getBuiltinRules(this.themeData.base);
        rules = baseData.rules;
        if (baseData.encodedTokensColors) {
          encodedTokensColors = baseData.encodedTokensColors;
        }
      }
      const editorForeground2 = this.themeData.colors["editor.foreground"];
      const editorBackground2 = this.themeData.colors["editor.background"];
      if (editorForeground2 || editorBackground2) {
        const rule = { token: "" };
        if (editorForeground2) {
          rule.foreground = editorForeground2;
        }
        if (editorBackground2) {
          rule.background = editorBackground2;
        }
        rules.push(rule);
      }
      rules = rules.concat(this.themeData.rules);
      if (this.themeData.encodedTokensColors) {
        encodedTokensColors = this.themeData.encodedTokensColors;
      }
      this._tokenTheme = TokenTheme.createFromRawTokenTheme(rules, encodedTokensColors);
    }
    return this._tokenTheme;
  }
  getTokenStyleMetadata(type, modifiers, modelLanguage) {
    const style = this.tokenTheme._match([type].concat(modifiers).join("."));
    const metadata = style.metadata;
    const foreground2 = TokenMetadata.getForeground(metadata);
    const fontStyle = TokenMetadata.getFontStyle(metadata);
    return {
      foreground: foreground2,
      italic: Boolean(
        fontStyle & 1
        /* FontStyle.Italic */
      ),
      bold: Boolean(
        fontStyle & 2
        /* FontStyle.Bold */
      ),
      underline: Boolean(
        fontStyle & 4
        /* FontStyle.Underline */
      ),
      strikethrough: Boolean(
        fontStyle & 8
        /* FontStyle.Strikethrough */
      )
    };
  }
};
function isBuiltinTheme(themeName) {
  return themeName === VS_LIGHT_THEME_NAME || themeName === VS_DARK_THEME_NAME || themeName === HC_BLACK_THEME_NAME || themeName === HC_LIGHT_THEME_NAME;
}
function getBuiltinRules(builtinTheme) {
  switch (builtinTheme) {
    case VS_LIGHT_THEME_NAME:
      return vs;
    case VS_DARK_THEME_NAME:
      return vs_dark;
    case HC_BLACK_THEME_NAME:
      return hc_black;
    case HC_LIGHT_THEME_NAME:
      return hc_light;
  }
}
function newBuiltInTheme(builtinTheme) {
  const themeData = getBuiltinRules(builtinTheme);
  return new StandaloneTheme(builtinTheme, themeData);
}
var StandaloneThemeService = class extends Disposable {
  constructor() {
    super();
    this._onColorThemeChange = this._register(new Emitter());
    this.onDidColorThemeChange = this._onColorThemeChange.event;
    this._onProductIconThemeChange = this._register(new Emitter());
    this.onDidProductIconThemeChange = this._onProductIconThemeChange.event;
    this._environment = /* @__PURE__ */ Object.create(null);
    this._builtInProductIconTheme = new UnthemedProductIconTheme();
    this._autoDetectHighContrast = true;
    this._knownThemes = /* @__PURE__ */ new Map();
    this._knownThemes.set(VS_LIGHT_THEME_NAME, newBuiltInTheme(VS_LIGHT_THEME_NAME));
    this._knownThemes.set(VS_DARK_THEME_NAME, newBuiltInTheme(VS_DARK_THEME_NAME));
    this._knownThemes.set(HC_BLACK_THEME_NAME, newBuiltInTheme(HC_BLACK_THEME_NAME));
    this._knownThemes.set(HC_LIGHT_THEME_NAME, newBuiltInTheme(HC_LIGHT_THEME_NAME));
    const iconsStyleSheet = this._register(getIconsStyleSheet(this));
    this._codiconCSS = iconsStyleSheet.getCSS();
    this._themeCSS = "";
    this._allCSS = `${this._codiconCSS}
${this._themeCSS}`;
    this._globalStyleElement = null;
    this._styleElements = [];
    this._colorMapOverride = null;
    this.setTheme(VS_LIGHT_THEME_NAME);
    this._onOSSchemeChanged();
    this._register(iconsStyleSheet.onDidChange(() => {
      this._codiconCSS = iconsStyleSheet.getCSS();
      this._updateCSS();
    }));
    addMatchMediaChangeListener(mainWindow, "(forced-colors: active)", () => {
      this._onOSSchemeChanged();
    });
  }
  registerEditorContainer(domNode) {
    if (isInShadowDOM(domNode)) {
      return this._registerShadowDomContainer(domNode);
    }
    return this._registerRegularEditorContainer();
  }
  _registerRegularEditorContainer() {
    if (!this._globalStyleElement) {
      this._globalStyleElement = createStyleSheet(void 0, (style) => {
        style.className = "monaco-colors";
        style.textContent = this._allCSS;
      });
      this._styleElements.push(this._globalStyleElement);
    }
    return Disposable.None;
  }
  _registerShadowDomContainer(domNode) {
    const styleElement = createStyleSheet(domNode, (style) => {
      style.className = "monaco-colors";
      style.textContent = this._allCSS;
    });
    this._styleElements.push(styleElement);
    return {
      dispose: () => {
        for (let i = 0; i < this._styleElements.length; i++) {
          if (this._styleElements[i] === styleElement) {
            this._styleElements.splice(i, 1);
            return;
          }
        }
      }
    };
  }
  defineTheme(themeName, themeData) {
    if (!/^[a-z0-9\-]+$/i.test(themeName)) {
      throw new Error("Illegal theme name!");
    }
    if (!isBuiltinTheme(themeData.base) && !isBuiltinTheme(themeName)) {
      throw new Error("Illegal theme base!");
    }
    this._knownThemes.set(themeName, new StandaloneTheme(themeName, themeData));
    if (isBuiltinTheme(themeName)) {
      this._knownThemes.forEach((theme) => {
        if (theme.base === themeName) {
          theme.notifyBaseUpdated();
        }
      });
    }
    if (this._theme.themeName === themeName) {
      this.setTheme(themeName);
    }
  }
  getColorTheme() {
    return this._theme;
  }
  setColorMapOverride(colorMapOverride) {
    this._colorMapOverride = colorMapOverride;
    this._updateThemeOrColorMap();
  }
  setTheme(themeName) {
    let theme;
    if (this._knownThemes.has(themeName)) {
      theme = this._knownThemes.get(themeName);
    } else {
      theme = this._knownThemes.get(VS_LIGHT_THEME_NAME);
    }
    this._updateActualTheme(theme);
  }
  _updateActualTheme(desiredTheme) {
    if (!desiredTheme || this._theme === desiredTheme) {
      return;
    }
    this._theme = desiredTheme;
    this._updateThemeOrColorMap();
  }
  _onOSSchemeChanged() {
    if (this._autoDetectHighContrast) {
      const wantsHighContrast = mainWindow.matchMedia(`(forced-colors: active)`).matches;
      if (wantsHighContrast !== isHighContrast(this._theme.type)) {
        let newThemeName;
        if (isDark(this._theme.type)) {
          newThemeName = wantsHighContrast ? HC_BLACK_THEME_NAME : VS_DARK_THEME_NAME;
        } else {
          newThemeName = wantsHighContrast ? HC_LIGHT_THEME_NAME : VS_LIGHT_THEME_NAME;
        }
        this._updateActualTheme(this._knownThemes.get(newThemeName));
      }
    }
  }
  setAutoDetectHighContrast(autoDetectHighContrast) {
    this._autoDetectHighContrast = autoDetectHighContrast;
    this._onOSSchemeChanged();
  }
  _updateThemeOrColorMap() {
    const cssRules = [];
    const hasRule = {};
    const ruleCollector = {
      addRule: (rule) => {
        if (!hasRule[rule]) {
          cssRules.push(rule);
          hasRule[rule] = true;
        }
      }
    };
    themingRegistry2.getThemingParticipants().forEach((p) => p(this._theme, ruleCollector, this._environment));
    const colorVariables = [];
    for (const item of colorRegistry2.getColors()) {
      const color = this._theme.getColor(item.id, true);
      if (color) {
        colorVariables.push(`${asCssVariableName(item.id)}: ${color.toString()};`);
      }
    }
    ruleCollector.addRule(`.monaco-editor, .monaco-diff-editor, .monaco-component { ${colorVariables.join("\n")} }`);
    const colorMap = this._colorMapOverride || this._theme.tokenTheme.getColorMap();
    ruleCollector.addRule(generateTokensCSSForColorMap(colorMap));
    this._themeCSS = cssRules.join("\n");
    this._updateCSS();
    TokenizationRegistry2.setColorMap(colorMap);
    this._onColorThemeChange.fire(this._theme);
  }
  _updateCSS() {
    this._allCSS = `${this._codiconCSS}
${this._themeCSS}`;
    this._styleElements.forEach((styleElement) => styleElement.textContent = this._allCSS);
  }
  getFileIconTheme() {
    return {
      hasFileIcons: false,
      hasFolderIcons: false,
      hidesExplorerArrows: false
    };
  }
  getProductIconTheme() {
    return this._builtInProductIconTheme;
  }
};

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
init_standaloneTheme();

// node_modules/monaco-editor/esm/vs/platform/accessibility/browser/accessibilityService.js
init_dom();
init_window();
init_event();
init_lifecycle();
init_configuration();
init_contextkey();
var __decorate33 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param26 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var AccessibilityService = class AccessibilityService2 extends Disposable {
  constructor(_contextKeyService, _layoutService, _configurationService) {
    super();
    this._contextKeyService = _contextKeyService;
    this._layoutService = _layoutService;
    this._configurationService = _configurationService;
    this._accessibilitySupport = 0;
    this._onDidChangeScreenReaderOptimized = new Emitter();
    this._onDidChangeReducedMotion = new Emitter();
    this._accessibilityModeEnabledContext = CONTEXT_ACCESSIBILITY_MODE_ENABLED.bindTo(this._contextKeyService);
    const updateContextKey = () => this._accessibilityModeEnabledContext.set(this.isScreenReaderOptimized());
    this._register(this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("editor.accessibilitySupport")) {
        updateContextKey();
        this._onDidChangeScreenReaderOptimized.fire();
      }
      if (e.affectsConfiguration("workbench.reduceMotion")) {
        this._configMotionReduced = this._configurationService.getValue("workbench.reduceMotion");
        this._onDidChangeReducedMotion.fire();
      }
    }));
    updateContextKey();
    this._register(this.onDidChangeScreenReaderOptimized(() => updateContextKey()));
    const reduceMotionMatcher = mainWindow.matchMedia(`(prefers-reduced-motion: reduce)`);
    this._systemMotionReduced = reduceMotionMatcher.matches;
    this._configMotionReduced = this._configurationService.getValue("workbench.reduceMotion");
    this.initReducedMotionListeners(reduceMotionMatcher);
  }
  initReducedMotionListeners(reduceMotionMatcher) {
    this._register(addDisposableListener(reduceMotionMatcher, "change", () => {
      this._systemMotionReduced = reduceMotionMatcher.matches;
      if (this._configMotionReduced === "auto") {
        this._onDidChangeReducedMotion.fire();
      }
    }));
    const updateRootClasses = () => {
      const reduce = this.isMotionReduced();
      this._layoutService.mainContainer.classList.toggle("reduce-motion", reduce);
      this._layoutService.mainContainer.classList.toggle("enable-motion", !reduce);
    };
    updateRootClasses();
    this._register(this.onDidChangeReducedMotion(() => updateRootClasses()));
  }
  get onDidChangeScreenReaderOptimized() {
    return this._onDidChangeScreenReaderOptimized.event;
  }
  isScreenReaderOptimized() {
    const config = this._configurationService.getValue("editor.accessibilitySupport");
    return config === "on" || config === "auto" && this._accessibilitySupport === 2;
  }
  get onDidChangeReducedMotion() {
    return this._onDidChangeReducedMotion.event;
  }
  isMotionReduced() {
    const config = this._configMotionReduced;
    return config === "on" || config === "auto" && this._systemMotionReduced;
  }
  getAccessibilitySupport() {
    return this._accessibilitySupport;
  }
};
AccessibilityService = __decorate33([
  __param26(0, IContextKeyService),
  __param26(1, ILayoutService),
  __param26(2, IConfigurationService)
], AccessibilityService);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
init_actions2();

// node_modules/monaco-editor/esm/vs/platform/actions/common/menuService.js
init_async();
init_event();
init_lifecycle();
init_actions2();
init_commands();
init_contextkey();
init_actions();
init_arrays();
init_nls();
var __decorate34 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param27 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var PersistedMenuHideState_1;
var MenuInfo_1;
var MenuService = class MenuService2 {
  constructor(_commandService, storageService) {
    this._commandService = _commandService;
    this._hiddenStates = new PersistedMenuHideState(storageService);
  }
  createMenu(id, contextKeyService, options2) {
    return new MenuImpl(id, this._hiddenStates, { emitEventsForSubmenuChanges: false, eventDebounceDelay: 50, ...options2 }, this._commandService, contextKeyService);
  }
  resetHiddenStates(ids) {
    this._hiddenStates.reset(ids);
  }
};
MenuService = __decorate34([
  __param27(0, ICommandService),
  __param27(1, IStorageService)
], MenuService);
var PersistedMenuHideState = PersistedMenuHideState_1 = class PersistedMenuHideState2 {
  constructor(_storageService) {
    this._storageService = _storageService;
    this._disposables = new DisposableStore();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._ignoreChangeEvent = false;
    this._hiddenByDefaultCache = /* @__PURE__ */ new Map();
    try {
      const raw = _storageService.get(PersistedMenuHideState_1._key, 0, "{}");
      this._data = JSON.parse(raw);
    } catch (err) {
      this._data = /* @__PURE__ */ Object.create(null);
    }
    this._disposables.add(_storageService.onDidChangeValue(0, PersistedMenuHideState_1._key, this._disposables)(() => {
      if (!this._ignoreChangeEvent) {
        try {
          const raw = _storageService.get(PersistedMenuHideState_1._key, 0, "{}");
          this._data = JSON.parse(raw);
        } catch (err) {
          console.log("FAILED to read storage after UPDATE", err);
        }
      }
      this._onDidChange.fire();
    }));
  }
  dispose() {
    this._onDidChange.dispose();
    this._disposables.dispose();
  }
  _isHiddenByDefault(menu, commandId) {
    var _a2;
    return (_a2 = this._hiddenByDefaultCache.get(`${menu.id}/${commandId}`)) !== null && _a2 !== void 0 ? _a2 : false;
  }
  setDefaultState(menu, commandId, hidden) {
    this._hiddenByDefaultCache.set(`${menu.id}/${commandId}`, hidden);
  }
  isHidden(menu, commandId) {
    var _a2, _b2;
    const hiddenByDefault = this._isHiddenByDefault(menu, commandId);
    const state = (_b2 = (_a2 = this._data[menu.id]) === null || _a2 === void 0 ? void 0 : _a2.includes(commandId)) !== null && _b2 !== void 0 ? _b2 : false;
    return hiddenByDefault ? !state : state;
  }
  updateHidden(menu, commandId, hidden) {
    const hiddenByDefault = this._isHiddenByDefault(menu, commandId);
    if (hiddenByDefault) {
      hidden = !hidden;
    }
    const entries = this._data[menu.id];
    if (!hidden) {
      if (entries) {
        const idx = entries.indexOf(commandId);
        if (idx >= 0) {
          removeFastWithoutKeepingOrder(entries, idx);
        }
        if (entries.length === 0) {
          delete this._data[menu.id];
        }
      }
    } else {
      if (!entries) {
        this._data[menu.id] = [commandId];
      } else {
        const idx = entries.indexOf(commandId);
        if (idx < 0) {
          entries.push(commandId);
        }
      }
    }
    this._persist();
  }
  reset(menus) {
    if (menus === void 0) {
      this._data = /* @__PURE__ */ Object.create(null);
      this._persist();
    } else {
      for (const { id } of menus) {
        if (this._data[id]) {
          delete this._data[id];
        }
      }
      this._persist();
    }
  }
  _persist() {
    try {
      this._ignoreChangeEvent = true;
      const raw = JSON.stringify(this._data);
      this._storageService.store(
        PersistedMenuHideState_1._key,
        raw,
        0,
        0
        /* StorageTarget.USER */
      );
    } finally {
      this._ignoreChangeEvent = false;
    }
  }
};
PersistedMenuHideState._key = "menu.hiddenCommands";
PersistedMenuHideState = PersistedMenuHideState_1 = __decorate34([
  __param27(0, IStorageService)
], PersistedMenuHideState);
var MenuInfo = MenuInfo_1 = class MenuInfo2 {
  constructor(_id, _hiddenStates, _collectContextKeysForSubmenus, _commandService, _contextKeyService) {
    this._id = _id;
    this._hiddenStates = _hiddenStates;
    this._collectContextKeysForSubmenus = _collectContextKeysForSubmenus;
    this._commandService = _commandService;
    this._contextKeyService = _contextKeyService;
    this._menuGroups = [];
    this._structureContextKeys = /* @__PURE__ */ new Set();
    this._preconditionContextKeys = /* @__PURE__ */ new Set();
    this._toggledContextKeys = /* @__PURE__ */ new Set();
    this.refresh();
  }
  get structureContextKeys() {
    return this._structureContextKeys;
  }
  get preconditionContextKeys() {
    return this._preconditionContextKeys;
  }
  get toggledContextKeys() {
    return this._toggledContextKeys;
  }
  refresh() {
    this._menuGroups.length = 0;
    this._structureContextKeys.clear();
    this._preconditionContextKeys.clear();
    this._toggledContextKeys.clear();
    const menuItems = MenuRegistry.getMenuItems(this._id);
    let group;
    menuItems.sort(MenuInfo_1._compareMenuItems);
    for (const item of menuItems) {
      const groupName = item.group || "";
      if (!group || group[0] !== groupName) {
        group = [groupName, []];
        this._menuGroups.push(group);
      }
      group[1].push(item);
      this._collectContextKeys(item);
    }
  }
  _collectContextKeys(item) {
    MenuInfo_1._fillInKbExprKeys(item.when, this._structureContextKeys);
    if (isIMenuItem(item)) {
      if (item.command.precondition) {
        MenuInfo_1._fillInKbExprKeys(item.command.precondition, this._preconditionContextKeys);
      }
      if (item.command.toggled) {
        const toggledExpression = item.command.toggled.condition || item.command.toggled;
        MenuInfo_1._fillInKbExprKeys(toggledExpression, this._toggledContextKeys);
      }
    } else if (this._collectContextKeysForSubmenus) {
      MenuRegistry.getMenuItems(item.submenu).forEach(this._collectContextKeys, this);
    }
  }
  createActionGroups(options2) {
    const result = [];
    for (const group of this._menuGroups) {
      const [id, items] = group;
      const activeActions = [];
      for (const item of items) {
        if (this._contextKeyService.contextMatchesRules(item.when)) {
          const isMenuItem = isIMenuItem(item);
          if (isMenuItem) {
            this._hiddenStates.setDefaultState(this._id, item.command.id, !!item.isHiddenByDefault);
          }
          const menuHide = createMenuHide(this._id, isMenuItem ? item.command : item, this._hiddenStates);
          if (isMenuItem) {
            activeActions.push(new MenuItemAction(item.command, item.alt, options2, menuHide, this._contextKeyService, this._commandService));
          } else {
            const groups = new MenuInfo_1(item.submenu, this._hiddenStates, this._collectContextKeysForSubmenus, this._commandService, this._contextKeyService).createActionGroups(options2);
            const submenuActions = Separator.join(...groups.map((g) => g[1]));
            if (submenuActions.length > 0) {
              activeActions.push(new SubmenuItemAction(item, menuHide, submenuActions));
            }
          }
        }
      }
      if (activeActions.length > 0) {
        result.push([id, activeActions]);
      }
    }
    return result;
  }
  static _fillInKbExprKeys(exp, set) {
    if (exp) {
      for (const key of exp.keys()) {
        set.add(key);
      }
    }
  }
  static _compareMenuItems(a, b) {
    const aGroup = a.group;
    const bGroup = b.group;
    if (aGroup !== bGroup) {
      if (!aGroup) {
        return 1;
      } else if (!bGroup) {
        return -1;
      }
      if (aGroup === "navigation") {
        return -1;
      } else if (bGroup === "navigation") {
        return 1;
      }
      const value = aGroup.localeCompare(bGroup);
      if (value !== 0) {
        return value;
      }
    }
    const aPrio = a.order || 0;
    const bPrio = b.order || 0;
    if (aPrio < bPrio) {
      return -1;
    } else if (aPrio > bPrio) {
      return 1;
    }
    return MenuInfo_1._compareTitles(isIMenuItem(a) ? a.command.title : a.title, isIMenuItem(b) ? b.command.title : b.title);
  }
  static _compareTitles(a, b) {
    const aStr = typeof a === "string" ? a : a.original;
    const bStr = typeof b === "string" ? b : b.original;
    return aStr.localeCompare(bStr);
  }
};
MenuInfo = MenuInfo_1 = __decorate34([
  __param27(3, ICommandService),
  __param27(4, IContextKeyService)
], MenuInfo);
var MenuImpl = class MenuImpl2 {
  constructor(id, hiddenStates, options2, commandService, contextKeyService) {
    this._disposables = new DisposableStore();
    this._menuInfo = new MenuInfo(id, hiddenStates, options2.emitEventsForSubmenuChanges, commandService, contextKeyService);
    const rebuildMenuSoon = new RunOnceScheduler(() => {
      this._menuInfo.refresh();
      this._onDidChange.fire({ menu: this, isStructuralChange: true, isEnablementChange: true, isToggleChange: true });
    }, options2.eventDebounceDelay);
    this._disposables.add(rebuildMenuSoon);
    this._disposables.add(MenuRegistry.onDidChangeMenu((e) => {
      if (e.has(id)) {
        rebuildMenuSoon.schedule();
      }
    }));
    const lazyListener = this._disposables.add(new DisposableStore());
    const merge = (events) => {
      let isStructuralChange = false;
      let isEnablementChange = false;
      let isToggleChange = false;
      for (const item of events) {
        isStructuralChange = isStructuralChange || item.isStructuralChange;
        isEnablementChange = isEnablementChange || item.isEnablementChange;
        isToggleChange = isToggleChange || item.isToggleChange;
        if (isStructuralChange && isEnablementChange && isToggleChange) {
          break;
        }
      }
      return { menu: this, isStructuralChange, isEnablementChange, isToggleChange };
    };
    const startLazyListener = () => {
      lazyListener.add(contextKeyService.onDidChangeContext((e) => {
        const isStructuralChange = e.affectsSome(this._menuInfo.structureContextKeys);
        const isEnablementChange = e.affectsSome(this._menuInfo.preconditionContextKeys);
        const isToggleChange = e.affectsSome(this._menuInfo.toggledContextKeys);
        if (isStructuralChange || isEnablementChange || isToggleChange) {
          this._onDidChange.fire({ menu: this, isStructuralChange, isEnablementChange, isToggleChange });
        }
      }));
      lazyListener.add(hiddenStates.onDidChange((e) => {
        this._onDidChange.fire({ menu: this, isStructuralChange: true, isEnablementChange: false, isToggleChange: false });
      }));
    };
    this._onDidChange = new DebounceEmitter({
      // start/stop context key listener
      onWillAddFirstListener: startLazyListener,
      onDidRemoveLastListener: lazyListener.clear.bind(lazyListener),
      delay: options2.eventDebounceDelay,
      merge
    });
    this.onDidChange = this._onDidChange.event;
  }
  getActions(options2) {
    return this._menuInfo.createActionGroups(options2);
  }
  dispose() {
    this._disposables.dispose();
    this._onDidChange.dispose();
  }
};
MenuImpl = __decorate34([
  __param27(3, ICommandService),
  __param27(4, IContextKeyService)
], MenuImpl);
function createMenuHide(menu, command, states) {
  const id = isISubmenuItem(command) ? command.submenu.id : command.id;
  const title = typeof command.title === "string" ? command.title : command.title.value;
  const hide = toAction({
    id: `hide/${menu.id}/${id}`,
    label: localize("hide.label", "Hide '{0}'", title),
    run() {
      states.updateHidden(menu, id, true);
    }
  });
  const toggle = toAction({
    id: `toggle/${menu.id}/${id}`,
    label: title,
    get checked() {
      return !states.isHidden(menu, id);
    },
    run() {
      states.updateHidden(menu, id, !!this.checked);
    }
  });
  return {
    hide,
    toggle,
    get isHidden() {
      return !toggle.checked;
    }
  };
}

// node_modules/monaco-editor/esm/vs/platform/clipboard/browser/clipboardService.js
init_browser();
init_dom();
init_window();
init_async();
init_event();
init_hash();
init_lifecycle();
init_log();
var __decorate35 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param28 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var BrowserClipboardService_1;
var BrowserClipboardService = BrowserClipboardService_1 = class BrowserClipboardService2 extends Disposable {
  constructor(layoutService, logService) {
    super();
    this.layoutService = layoutService;
    this.logService = logService;
    this.mapTextToType = /* @__PURE__ */ new Map();
    this.findText = "";
    this.resources = [];
    this.resourcesStateHash = void 0;
    if (isSafari2 || isWebkitWebView) {
      this.installWebKitWriteTextWorkaround();
    }
    this._register(Event.runAndSubscribe(onDidRegisterWindow, ({ window, disposables }) => {
      disposables.add(addDisposableListener(window.document, "copy", () => this.clearResources()));
    }, { window: mainWindow, disposables: this._store }));
  }
  // In Safari, it has the following note:
  //
  // "The request to write to the clipboard must be triggered during a user gesture.
  // A call to clipboard.write or clipboard.writeText outside the scope of a user
  // gesture(such as "click" or "touch" event handlers) will result in the immediate
  // rejection of the promise returned by the API call."
  // From: https://webkit.org/blog/10855/async-clipboard-api/
  //
  // Since extensions run in a web worker, and handle gestures in an asynchronous way,
  // they are not classified by Safari as "in response to a user gesture" and will reject.
  //
  // This function sets up some handlers to work around that behavior.
  installWebKitWriteTextWorkaround() {
    const handler = () => {
      const currentWritePromise = new DeferredPromise();
      if (this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled) {
        this.webKitPendingClipboardWritePromise.cancel();
      }
      this.webKitPendingClipboardWritePromise = currentWritePromise;
      navigator.clipboard.write([new ClipboardItem({
        "text/plain": currentWritePromise.p
      })]).catch(async (err) => {
        if (!(err instanceof Error) || err.name !== "NotAllowedError" || !currentWritePromise.isRejected) {
          this.logService.error(err);
        }
      });
    };
    this._register(Event.runAndSubscribe(this.layoutService.onDidAddContainer, ({ container, disposables }) => {
      disposables.add(addDisposableListener(container, "click", handler));
      disposables.add(addDisposableListener(container, "keydown", handler));
    }, { container: this.layoutService.mainContainer, disposables: this._store }));
  }
  async writeText(text, type) {
    this.writeResources([]);
    if (type) {
      this.mapTextToType.set(type, text);
      return;
    }
    if (this.webKitPendingClipboardWritePromise) {
      return this.webKitPendingClipboardWritePromise.complete(text);
    }
    try {
      return await navigator.clipboard.writeText(text);
    } catch (error) {
      console.error(error);
    }
    this.fallbackWriteText(text);
  }
  fallbackWriteText(text) {
    const activeDocument = getActiveDocument();
    const activeElement = activeDocument.activeElement;
    const textArea = activeDocument.body.appendChild($("textarea", { "aria-hidden": true }));
    textArea.style.height = "1px";
    textArea.style.width = "1px";
    textArea.style.position = "absolute";
    textArea.value = text;
    textArea.focus();
    textArea.select();
    activeDocument.execCommand("copy");
    if (activeElement instanceof HTMLElement) {
      activeElement.focus();
    }
    activeDocument.body.removeChild(textArea);
  }
  async readText(type) {
    if (type) {
      return this.mapTextToType.get(type) || "";
    }
    try {
      return await navigator.clipboard.readText();
    } catch (error) {
      console.error(error);
    }
    return "";
  }
  async readFindText() {
    return this.findText;
  }
  async writeFindText(text) {
    this.findText = text;
  }
  async writeResources(resources) {
    if (resources.length === 0) {
      this.clearResources();
    } else {
      this.resources = resources;
      this.resourcesStateHash = await this.computeResourcesStateHash();
    }
  }
  async readResources() {
    const resourcesStateHash = await this.computeResourcesStateHash();
    if (this.resourcesStateHash !== resourcesStateHash) {
      this.clearResources();
    }
    return this.resources;
  }
  async computeResourcesStateHash() {
    if (this.resources.length === 0) {
      return void 0;
    }
    const clipboardText = await this.readText();
    return hash(clipboardText.substring(0, BrowserClipboardService_1.MAX_RESOURCE_STATE_SOURCE_LENGTH));
  }
  clearResources() {
    this.resources = [];
    this.resourcesStateHash = void 0;
  }
};
BrowserClipboardService.MAX_RESOURCE_STATE_SOURCE_LENGTH = 1e3;
BrowserClipboardService = BrowserClipboardService_1 = __decorate35([
  __param28(0, ILayoutService),
  __param28(1, ILogService)
], BrowserClipboardService);

// node_modules/monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js
init_instantiation();
var IClipboardService = createDecorator("clipboardService");

// node_modules/monaco-editor/esm/vs/platform/contextkey/browser/contextKeyService.js
init_event();
init_iterator();
init_lifecycle();
init_objects();
init_uri();
init_nls();
init_commands();
init_configuration();
init_contextkey();
var __decorate36 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param29 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var KEYBINDING_CONTEXT_ATTR = "data-keybinding-context";
var Context = class {
  constructor(id, parent) {
    this._id = id;
    this._parent = parent;
    this._value = /* @__PURE__ */ Object.create(null);
    this._value["_contextId"] = id;
  }
  get value() {
    return { ...this._value };
  }
  setValue(key, value) {
    if (this._value[key] !== value) {
      this._value[key] = value;
      return true;
    }
    return false;
  }
  removeValue(key) {
    if (key in this._value) {
      delete this._value[key];
      return true;
    }
    return false;
  }
  getValue(key) {
    const ret = this._value[key];
    if (typeof ret === "undefined" && this._parent) {
      return this._parent.getValue(key);
    }
    return ret;
  }
};
var NullContext = class extends Context {
  constructor() {
    super(-1, null);
  }
  setValue(key, value) {
    return false;
  }
  removeValue(key) {
    return false;
  }
  getValue(key) {
    return void 0;
  }
};
NullContext.INSTANCE = new NullContext();
var ConfigAwareContextValuesContainer = class _ConfigAwareContextValuesContainer extends Context {
  constructor(id, _configurationService, emitter) {
    super(id, null);
    this._configurationService = _configurationService;
    this._values = TernarySearchTree.forConfigKeys();
    this._listener = this._configurationService.onDidChangeConfiguration((event) => {
      if (event.source === 7) {
        const allKeys = Array.from(this._values, ([k]) => k);
        this._values.clear();
        emitter.fire(new ArrayContextKeyChangeEvent(allKeys));
      } else {
        const changedKeys = [];
        for (const configKey of event.affectedKeys) {
          const contextKey = `config.${configKey}`;
          const cachedItems = this._values.findSuperstr(contextKey);
          if (cachedItems !== void 0) {
            changedKeys.push(...Iterable.map(cachedItems, ([key]) => key));
            this._values.deleteSuperstr(contextKey);
          }
          if (this._values.has(contextKey)) {
            changedKeys.push(contextKey);
            this._values.delete(contextKey);
          }
        }
        emitter.fire(new ArrayContextKeyChangeEvent(changedKeys));
      }
    });
  }
  dispose() {
    this._listener.dispose();
  }
  getValue(key) {
    if (key.indexOf(_ConfigAwareContextValuesContainer._keyPrefix) !== 0) {
      return super.getValue(key);
    }
    if (this._values.has(key)) {
      return this._values.get(key);
    }
    const configKey = key.substr(_ConfigAwareContextValuesContainer._keyPrefix.length);
    const configValue = this._configurationService.getValue(configKey);
    let value = void 0;
    switch (typeof configValue) {
      case "number":
      case "boolean":
      case "string":
        value = configValue;
        break;
      default:
        if (Array.isArray(configValue)) {
          value = JSON.stringify(configValue);
        } else {
          value = configValue;
        }
    }
    this._values.set(key, value);
    return value;
  }
  setValue(key, value) {
    return super.setValue(key, value);
  }
  removeValue(key) {
    return super.removeValue(key);
  }
};
ConfigAwareContextValuesContainer._keyPrefix = "config.";
var ContextKey = class {
  constructor(service, key, defaultValue) {
    this._service = service;
    this._key = key;
    this._defaultValue = defaultValue;
    this.reset();
  }
  set(value) {
    this._service.setContext(this._key, value);
  }
  reset() {
    if (typeof this._defaultValue === "undefined") {
      this._service.removeContext(this._key);
    } else {
      this._service.setContext(this._key, this._defaultValue);
    }
  }
  get() {
    return this._service.getContextKeyValue(this._key);
  }
};
var SimpleContextKeyChangeEvent = class {
  constructor(key) {
    this.key = key;
  }
  affectsSome(keys) {
    return keys.has(this.key);
  }
  allKeysContainedIn(keys) {
    return this.affectsSome(keys);
  }
};
var ArrayContextKeyChangeEvent = class {
  constructor(keys) {
    this.keys = keys;
  }
  affectsSome(keys) {
    for (const key of this.keys) {
      if (keys.has(key)) {
        return true;
      }
    }
    return false;
  }
  allKeysContainedIn(keys) {
    return this.keys.every((key) => keys.has(key));
  }
};
var CompositeContextKeyChangeEvent = class {
  constructor(events) {
    this.events = events;
  }
  affectsSome(keys) {
    for (const e of this.events) {
      if (e.affectsSome(keys)) {
        return true;
      }
    }
    return false;
  }
  allKeysContainedIn(keys) {
    return this.events.every((evt) => evt.allKeysContainedIn(keys));
  }
};
function allEventKeysInContext(event, context) {
  return event.allKeysContainedIn(new Set(Object.keys(context)));
}
var AbstractContextKeyService = class extends Disposable {
  constructor(myContextId) {
    super();
    this._onDidChangeContext = this._register(new PauseableEmitter({ merge: (input) => new CompositeContextKeyChangeEvent(input) }));
    this.onDidChangeContext = this._onDidChangeContext.event;
    this._isDisposed = false;
    this._myContextId = myContextId;
  }
  createKey(key, defaultValue) {
    if (this._isDisposed) {
      throw new Error(`AbstractContextKeyService has been disposed`);
    }
    return new ContextKey(this, key, defaultValue);
  }
  bufferChangeEvents(callback) {
    this._onDidChangeContext.pause();
    try {
      callback();
    } finally {
      this._onDidChangeContext.resume();
    }
  }
  createScoped(domNode) {
    if (this._isDisposed) {
      throw new Error(`AbstractContextKeyService has been disposed`);
    }
    return new ScopedContextKeyService(this, domNode);
  }
  contextMatchesRules(rules) {
    if (this._isDisposed) {
      throw new Error(`AbstractContextKeyService has been disposed`);
    }
    const context = this.getContextValuesContainer(this._myContextId);
    const result = rules ? rules.evaluate(context) : true;
    return result;
  }
  getContextKeyValue(key) {
    if (this._isDisposed) {
      return void 0;
    }
    return this.getContextValuesContainer(this._myContextId).getValue(key);
  }
  setContext(key, value) {
    if (this._isDisposed) {
      return;
    }
    const myContext = this.getContextValuesContainer(this._myContextId);
    if (!myContext) {
      return;
    }
    if (myContext.setValue(key, value)) {
      this._onDidChangeContext.fire(new SimpleContextKeyChangeEvent(key));
    }
  }
  removeContext(key) {
    if (this._isDisposed) {
      return;
    }
    if (this.getContextValuesContainer(this._myContextId).removeValue(key)) {
      this._onDidChangeContext.fire(new SimpleContextKeyChangeEvent(key));
    }
  }
  getContext(target) {
    if (this._isDisposed) {
      return NullContext.INSTANCE;
    }
    return this.getContextValuesContainer(findContextAttr(target));
  }
  dispose() {
    super.dispose();
    this._isDisposed = true;
  }
};
var ContextKeyService = class ContextKeyService2 extends AbstractContextKeyService {
  constructor(configurationService) {
    super(0);
    this._contexts = /* @__PURE__ */ new Map();
    this._lastContextId = 0;
    const myContext = this._register(new ConfigAwareContextValuesContainer(this._myContextId, configurationService, this._onDidChangeContext));
    this._contexts.set(this._myContextId, myContext);
  }
  getContextValuesContainer(contextId) {
    if (this._isDisposed) {
      return NullContext.INSTANCE;
    }
    return this._contexts.get(contextId) || NullContext.INSTANCE;
  }
  createChildContext(parentContextId = this._myContextId) {
    if (this._isDisposed) {
      throw new Error(`ContextKeyService has been disposed`);
    }
    const id = ++this._lastContextId;
    this._contexts.set(id, new Context(id, this.getContextValuesContainer(parentContextId)));
    return id;
  }
  disposeContext(contextId) {
    if (!this._isDisposed) {
      this._contexts.delete(contextId);
    }
  }
};
ContextKeyService = __decorate36([
  __param29(0, IConfigurationService)
], ContextKeyService);
var ScopedContextKeyService = class extends AbstractContextKeyService {
  constructor(parent, domNode) {
    super(parent.createChildContext());
    this._parentChangeListener = this._register(new MutableDisposable());
    this._parent = parent;
    this._updateParentChangeListener();
    this._domNode = domNode;
    if (this._domNode.hasAttribute(KEYBINDING_CONTEXT_ATTR)) {
      let extraInfo = "";
      if (this._domNode.classList) {
        extraInfo = Array.from(this._domNode.classList.values()).join(", ");
      }
      console.error(`Element already has context attribute${extraInfo ? ": " + extraInfo : ""}`);
    }
    this._domNode.setAttribute(KEYBINDING_CONTEXT_ATTR, String(this._myContextId));
  }
  _updateParentChangeListener() {
    this._parentChangeListener.value = this._parent.onDidChangeContext((e) => {
      const thisContainer = this._parent.getContextValuesContainer(this._myContextId);
      const thisContextValues = thisContainer.value;
      if (!allEventKeysInContext(e, thisContextValues)) {
        this._onDidChangeContext.fire(e);
      }
    });
  }
  dispose() {
    if (this._isDisposed) {
      return;
    }
    this._parent.disposeContext(this._myContextId);
    this._domNode.removeAttribute(KEYBINDING_CONTEXT_ATTR);
    super.dispose();
  }
  getContextValuesContainer(contextId) {
    if (this._isDisposed) {
      return NullContext.INSTANCE;
    }
    return this._parent.getContextValuesContainer(contextId);
  }
  createChildContext(parentContextId = this._myContextId) {
    if (this._isDisposed) {
      throw new Error(`ScopedContextKeyService has been disposed`);
    }
    return this._parent.createChildContext(parentContextId);
  }
  disposeContext(contextId) {
    if (this._isDisposed) {
      return;
    }
    this._parent.disposeContext(contextId);
  }
};
function findContextAttr(domNode) {
  while (domNode) {
    if (domNode.hasAttribute(KEYBINDING_CONTEXT_ATTR)) {
      const attr = domNode.getAttribute(KEYBINDING_CONTEXT_ATTR);
      if (attr) {
        return parseInt(attr, 10);
      }
      return NaN;
    }
    domNode = domNode.parentElement;
  }
  return 0;
}
function setContext(accessor, contextKey, contextValue) {
  const contextKeyService = accessor.get(IContextKeyService);
  contextKeyService.createKey(String(contextKey), stringifyURIs(contextValue));
}
function stringifyURIs(contextValue) {
  return cloneAndChange(contextValue, (obj) => {
    if (typeof obj === "object" && obj.$mid === 1) {
      return URI.revive(obj).toString();
    }
    if (obj instanceof URI) {
      return obj.toString();
    }
    return void 0;
  });
}
CommandsRegistry.registerCommand("_setContext", setContext);
CommandsRegistry.registerCommand({
  id: "getContextKeyInfo",
  handler() {
    return [...RawContextKey.all()].sort((a, b) => a.key.localeCompare(b.key));
  },
  metadata: {
    description: localize("getContextKeyInfo", "A command that returns information about context keys"),
    args: []
  }
});
CommandsRegistry.registerCommand("_generateContextKeyInfo", function() {
  const result = [];
  const seen = /* @__PURE__ */ new Set();
  for (const info of RawContextKey.all()) {
    if (!seen.has(info.key)) {
      seen.add(info.key);
      result.push(info);
    }
  }
  result.sort((a, b) => a.key.localeCompare(b.key));
  console.log(JSON.stringify(result, void 0, 2));
});

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
init_descriptors();

// node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiationService.js
init_async();
init_errors();
init_lifecycle();
init_descriptors();

// node_modules/monaco-editor/esm/vs/platform/instantiation/common/graph.js
var Node2 = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
    this.incoming = /* @__PURE__ */ new Map();
    this.outgoing = /* @__PURE__ */ new Map();
  }
};
var Graph = class {
  constructor(_hashFn) {
    this._hashFn = _hashFn;
    this._nodes = /* @__PURE__ */ new Map();
  }
  roots() {
    const ret = [];
    for (const node of this._nodes.values()) {
      if (node.outgoing.size === 0) {
        ret.push(node);
      }
    }
    return ret;
  }
  insertEdge(from, to) {
    const fromNode = this.lookupOrInsertNode(from);
    const toNode = this.lookupOrInsertNode(to);
    fromNode.outgoing.set(toNode.key, toNode);
    toNode.incoming.set(fromNode.key, fromNode);
  }
  removeNode(data) {
    const key = this._hashFn(data);
    this._nodes.delete(key);
    for (const node of this._nodes.values()) {
      node.outgoing.delete(key);
      node.incoming.delete(key);
    }
  }
  lookupOrInsertNode(data) {
    const key = this._hashFn(data);
    let node = this._nodes.get(key);
    if (!node) {
      node = new Node2(key, data);
      this._nodes.set(key, node);
    }
    return node;
  }
  isEmpty() {
    return this._nodes.size === 0;
  }
  toString() {
    const data = [];
    for (const [key, value] of this._nodes) {
      data.push(`${key}
	(-> incoming)[${[...value.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...value.outgoing.keys()].join(",")}]
`);
    }
    return data.join("\n");
  }
  /**
   * This is brute force and slow and **only** be used
   * to trouble shoot.
   */
  findCycleSlow() {
    for (const [id, node] of this._nodes) {
      const seen = /* @__PURE__ */ new Set([id]);
      const res = this._findCycle(node, seen);
      if (res) {
        return res;
      }
    }
    return void 0;
  }
  _findCycle(node, seen) {
    for (const [id, outgoing] of node.outgoing) {
      if (seen.has(id)) {
        return [...seen, id].join(" -> ");
      }
      seen.add(id);
      const value = this._findCycle(outgoing, seen);
      if (value) {
        return value;
      }
      seen.delete(id);
    }
    return void 0;
  }
};

// node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiationService.js
init_instantiation();

// node_modules/monaco-editor/esm/vs/platform/instantiation/common/serviceCollection.js
var ServiceCollection = class {
  constructor(...entries) {
    this._entries = /* @__PURE__ */ new Map();
    for (const [id, service] of entries) {
      this.set(id, service);
    }
  }
  set(id, instanceOrDescriptor) {
    const result = this._entries.get(id);
    this._entries.set(id, instanceOrDescriptor);
    return result;
  }
  get(id) {
    return this._entries.get(id);
  }
};

// node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiationService.js
init_linkedList();
var _enableAllTracing = false;
var CyclicDependencyError = class extends Error {
  constructor(graph) {
    var _a2;
    super("cyclic dependency between services");
    this.message = (_a2 = graph.findCycleSlow()) !== null && _a2 !== void 0 ? _a2 : `UNABLE to detect cycle, dumping graph: 
${graph.toString()}`;
  }
};
var InstantiationService = class _InstantiationService {
  constructor(_services = new ServiceCollection(), _strict = false, _parent, _enableTracing = _enableAllTracing) {
    var _a2;
    this._services = _services;
    this._strict = _strict;
    this._parent = _parent;
    this._enableTracing = _enableTracing;
    this._activeInstantiations = /* @__PURE__ */ new Set();
    this._services.set(IInstantiationService, this);
    this._globalGraph = _enableTracing ? (_a2 = _parent === null || _parent === void 0 ? void 0 : _parent._globalGraph) !== null && _a2 !== void 0 ? _a2 : new Graph((e) => e) : void 0;
  }
  createChild(services) {
    return new _InstantiationService(services, this._strict, this, this._enableTracing);
  }
  invokeFunction(fn, ...args) {
    const _trace = Trace.traceInvocation(this._enableTracing, fn);
    let _done = false;
    try {
      const accessor = {
        get: (id) => {
          if (_done) {
            throw illegalState("service accessor is only valid during the invocation of its target method");
          }
          const result = this._getOrCreateServiceInstance(id, _trace);
          if (!result) {
            throw new Error(`[invokeFunction] unknown service '${id}'`);
          }
          return result;
        }
      };
      return fn(accessor, ...args);
    } finally {
      _done = true;
      _trace.stop();
    }
  }
  createInstance(ctorOrDescriptor, ...rest) {
    let _trace;
    let result;
    if (ctorOrDescriptor instanceof SyncDescriptor) {
      _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor.ctor);
      result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);
    } else {
      _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor);
      result = this._createInstance(ctorOrDescriptor, rest, _trace);
    }
    _trace.stop();
    return result;
  }
  _createInstance(ctor, args = [], _trace) {
    const serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);
    const serviceArgs = [];
    for (const dependency of serviceDependencies) {
      const service = this._getOrCreateServiceInstance(dependency.id, _trace);
      if (!service) {
        this._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);
      }
      serviceArgs.push(service);
    }
    const firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;
    if (args.length !== firstServiceArgPos) {
      console.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);
      const delta = firstServiceArgPos - args.length;
      if (delta > 0) {
        args = args.concat(new Array(delta));
      } else {
        args = args.slice(0, firstServiceArgPos);
      }
    }
    return Reflect.construct(ctor, args.concat(serviceArgs));
  }
  _setServiceInstance(id, instance) {
    if (this._services.get(id) instanceof SyncDescriptor) {
      this._services.set(id, instance);
    } else if (this._parent) {
      this._parent._setServiceInstance(id, instance);
    } else {
      throw new Error("illegalState - setting UNKNOWN service instance");
    }
  }
  _getServiceInstanceOrDescriptor(id) {
    const instanceOrDesc = this._services.get(id);
    if (!instanceOrDesc && this._parent) {
      return this._parent._getServiceInstanceOrDescriptor(id);
    } else {
      return instanceOrDesc;
    }
  }
  _getOrCreateServiceInstance(id, _trace) {
    if (this._globalGraph && this._globalGraphImplicitDependency) {
      this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(id));
    }
    const thing = this._getServiceInstanceOrDescriptor(id);
    if (thing instanceof SyncDescriptor) {
      return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));
    } else {
      _trace.branch(id, false);
      return thing;
    }
  }
  _safeCreateAndCacheServiceInstance(id, desc, _trace) {
    if (this._activeInstantiations.has(id)) {
      throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);
    }
    this._activeInstantiations.add(id);
    try {
      return this._createAndCacheServiceInstance(id, desc, _trace);
    } finally {
      this._activeInstantiations.delete(id);
    }
  }
  _createAndCacheServiceInstance(id, desc, _trace) {
    var _a2;
    const graph = new Graph((data) => data.id.toString());
    let cycleCount = 0;
    const stack = [{ id, desc, _trace }];
    while (stack.length) {
      const item = stack.pop();
      graph.lookupOrInsertNode(item);
      if (cycleCount++ > 1e3) {
        throw new CyclicDependencyError(graph);
      }
      for (const dependency of _util.getServiceDependencies(item.desc.ctor)) {
        const instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);
        if (!instanceOrDesc) {
          this._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, true);
        }
        (_a2 = this._globalGraph) === null || _a2 === void 0 ? void 0 : _a2.insertEdge(String(item.id), String(dependency.id));
        if (instanceOrDesc instanceof SyncDescriptor) {
          const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };
          graph.insertEdge(item, d);
          stack.push(d);
        }
      }
    }
    while (true) {
      const roots = graph.roots();
      if (roots.length === 0) {
        if (!graph.isEmpty()) {
          throw new CyclicDependencyError(graph);
        }
        break;
      }
      for (const { data } of roots) {
        const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);
        if (instanceOrDesc instanceof SyncDescriptor) {
          const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);
          this._setServiceInstance(data.id, instance);
        }
        graph.removeNode(data);
      }
    }
    return this._getServiceInstanceOrDescriptor(id);
  }
  _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {
    if (this._services.get(id) instanceof SyncDescriptor) {
      return this._createServiceInstance(id, ctor, args, supportsDelayedInstantiation, _trace);
    } else if (this._parent) {
      return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);
    } else {
      throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);
    }
  }
  _createServiceInstance(id, ctor, args = [], supportsDelayedInstantiation, _trace) {
    if (!supportsDelayedInstantiation) {
      return this._createInstance(ctor, args, _trace);
    } else {
      const child = new _InstantiationService(void 0, this._strict, this, this._enableTracing);
      child._globalGraphImplicitDependency = String(id);
      const earlyListeners = /* @__PURE__ */ new Map();
      const idle = new GlobalIdleValue(() => {
        const result = child._createInstance(ctor, args, _trace);
        for (const [key, values] of earlyListeners) {
          const candidate = result[key];
          if (typeof candidate === "function") {
            for (const value of values) {
              value.disposable = candidate.apply(result, value.listener);
            }
          }
        }
        earlyListeners.clear();
        return result;
      });
      return new Proxy(/* @__PURE__ */ Object.create(null), {
        get(target, key) {
          if (!idle.isInitialized) {
            if (typeof key === "string" && (key.startsWith("onDid") || key.startsWith("onWill"))) {
              let list = earlyListeners.get(key);
              if (!list) {
                list = new LinkedList();
                earlyListeners.set(key, list);
              }
              const event = (callback, thisArg, disposables) => {
                if (idle.isInitialized) {
                  return idle.value[key](callback, thisArg, disposables);
                } else {
                  const entry = { listener: [callback, thisArg, disposables], disposable: void 0 };
                  const rm = list.push(entry);
                  const result = toDisposable(() => {
                    var _a2;
                    rm();
                    (_a2 = entry.disposable) === null || _a2 === void 0 ? void 0 : _a2.dispose();
                  });
                  return result;
                }
              };
              return event;
            }
          }
          if (key in target) {
            return target[key];
          }
          const obj = idle.value;
          let prop = obj[key];
          if (typeof prop !== "function") {
            return prop;
          }
          prop = prop.bind(obj);
          target[key] = prop;
          return prop;
        },
        set(_target, p, value) {
          idle.value[p] = value;
          return true;
        },
        getPrototypeOf(_target) {
          return ctor.prototype;
        }
      });
    }
  }
  _throwIfStrict(msg, printWarning) {
    if (printWarning) {
      console.warn(msg);
    }
    if (this._strict) {
      throw new Error(msg);
    }
  }
};
var Trace = class _Trace {
  static traceInvocation(_enableTracing, ctor) {
    return !_enableTracing ? _Trace._None : new _Trace(2, ctor.name || new Error().stack.split("\n").slice(3, 4).join("\n"));
  }
  static traceCreation(_enableTracing, ctor) {
    return !_enableTracing ? _Trace._None : new _Trace(1, ctor.name);
  }
  constructor(type, name) {
    this.type = type;
    this.name = name;
    this._start = Date.now();
    this._dep = [];
  }
  branch(id, first) {
    const child = new _Trace(3, id.toString());
    this._dep.push([id, first, child]);
    return child;
  }
  stop() {
    const dur = Date.now() - this._start;
    _Trace._totals += dur;
    let causedCreation = false;
    function printChild(n, trace) {
      const res = [];
      const prefix = new Array(n + 1).join("	");
      for (const [id, first, child] of trace._dep) {
        if (first && child) {
          causedCreation = true;
          res.push(`${prefix}CREATES -> ${id}`);
          const nested = printChild(n + 1, child);
          if (nested) {
            res.push(nested);
          }
        } else {
          res.push(`${prefix}uses -> ${id}`);
        }
      }
      return res.join("\n");
    }
    const lines = [
      `${this.type === 1 ? "CREATE" : "CALL"} ${this.name}`,
      `${printChild(1, this)}`,
      `DONE, took ${dur.toFixed(2)}ms (grand total ${_Trace._totals.toFixed(2)}ms)`
    ];
    if (dur > 2 || causedCreation) {
      _Trace.all.add(lines.join("\n"));
    }
  }
};
Trace.all = /* @__PURE__ */ new Set();
Trace._None = new class extends Trace {
  constructor() {
    super(0, null);
  }
  stop() {
  }
  branch() {
    return this;
  }
}();
Trace._totals = 0;

// node_modules/monaco-editor/esm/vs/platform/markers/common/markerService.js
init_arrays();
init_event();
init_iterator();
init_map();
init_network();
init_uri();
var unsupportedSchemas = /* @__PURE__ */ new Set([Schemas.inMemory, Schemas.vscodeSourceControl, Schemas.walkThrough, Schemas.walkThroughSnippet]);
var DoubleResourceMap = class {
  constructor() {
    this._byResource = new ResourceMap();
    this._byOwner = /* @__PURE__ */ new Map();
  }
  set(resource, owner, value) {
    let ownerMap = this._byResource.get(resource);
    if (!ownerMap) {
      ownerMap = /* @__PURE__ */ new Map();
      this._byResource.set(resource, ownerMap);
    }
    ownerMap.set(owner, value);
    let resourceMap = this._byOwner.get(owner);
    if (!resourceMap) {
      resourceMap = new ResourceMap();
      this._byOwner.set(owner, resourceMap);
    }
    resourceMap.set(resource, value);
  }
  get(resource, owner) {
    const ownerMap = this._byResource.get(resource);
    return ownerMap === null || ownerMap === void 0 ? void 0 : ownerMap.get(owner);
  }
  delete(resource, owner) {
    let removedA = false;
    let removedB = false;
    const ownerMap = this._byResource.get(resource);
    if (ownerMap) {
      removedA = ownerMap.delete(owner);
    }
    const resourceMap = this._byOwner.get(owner);
    if (resourceMap) {
      removedB = resourceMap.delete(resource);
    }
    if (removedA !== removedB) {
      throw new Error("illegal state");
    }
    return removedA && removedB;
  }
  values(key) {
    var _a2, _b2, _c, _d;
    if (typeof key === "string") {
      return (_b2 = (_a2 = this._byOwner.get(key)) === null || _a2 === void 0 ? void 0 : _a2.values()) !== null && _b2 !== void 0 ? _b2 : Iterable.empty();
    }
    if (URI.isUri(key)) {
      return (_d = (_c = this._byResource.get(key)) === null || _c === void 0 ? void 0 : _c.values()) !== null && _d !== void 0 ? _d : Iterable.empty();
    }
    return Iterable.map(Iterable.concat(...this._byOwner.values()), (map) => map[1]);
  }
};
var MarkerStats = class {
  constructor(service) {
    this.errors = 0;
    this.infos = 0;
    this.warnings = 0;
    this.unknowns = 0;
    this._data = new ResourceMap();
    this._service = service;
    this._subscription = service.onMarkerChanged(this._update, this);
  }
  dispose() {
    this._subscription.dispose();
  }
  _update(resources) {
    for (const resource of resources) {
      const oldStats = this._data.get(resource);
      if (oldStats) {
        this._substract(oldStats);
      }
      const newStats = this._resourceStats(resource);
      this._add(newStats);
      this._data.set(resource, newStats);
    }
  }
  _resourceStats(resource) {
    const result = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };
    if (unsupportedSchemas.has(resource.scheme)) {
      return result;
    }
    for (const { severity } of this._service.read({ resource })) {
      if (severity === MarkerSeverity2.Error) {
        result.errors += 1;
      } else if (severity === MarkerSeverity2.Warning) {
        result.warnings += 1;
      } else if (severity === MarkerSeverity2.Info) {
        result.infos += 1;
      } else {
        result.unknowns += 1;
      }
    }
    return result;
  }
  _substract(op) {
    this.errors -= op.errors;
    this.warnings -= op.warnings;
    this.infos -= op.infos;
    this.unknowns -= op.unknowns;
  }
  _add(op) {
    this.errors += op.errors;
    this.warnings += op.warnings;
    this.infos += op.infos;
    this.unknowns += op.unknowns;
  }
};
var MarkerService = class _MarkerService {
  constructor() {
    this._onMarkerChanged = new DebounceEmitter({
      delay: 0,
      merge: _MarkerService._merge
    });
    this.onMarkerChanged = this._onMarkerChanged.event;
    this._data = new DoubleResourceMap();
    this._stats = new MarkerStats(this);
  }
  dispose() {
    this._stats.dispose();
    this._onMarkerChanged.dispose();
  }
  remove(owner, resources) {
    for (const resource of resources || []) {
      this.changeOne(owner, resource, []);
    }
  }
  changeOne(owner, resource, markerData) {
    if (isFalsyOrEmpty(markerData)) {
      const removed = this._data.delete(resource, owner);
      if (removed) {
        this._onMarkerChanged.fire([resource]);
      }
    } else {
      const markers = [];
      for (const data of markerData) {
        const marker = _MarkerService._toMarker(owner, resource, data);
        if (marker) {
          markers.push(marker);
        }
      }
      this._data.set(resource, owner, markers);
      this._onMarkerChanged.fire([resource]);
    }
  }
  static _toMarker(owner, resource, data) {
    let { code, severity, message, source, startLineNumber, startColumn, endLineNumber, endColumn, relatedInformation, tags } = data;
    if (!message) {
      return void 0;
    }
    startLineNumber = startLineNumber > 0 ? startLineNumber : 1;
    startColumn = startColumn > 0 ? startColumn : 1;
    endLineNumber = endLineNumber >= startLineNumber ? endLineNumber : startLineNumber;
    endColumn = endColumn > 0 ? endColumn : startColumn;
    return {
      resource,
      owner,
      code,
      severity,
      message,
      source,
      startLineNumber,
      startColumn,
      endLineNumber,
      endColumn,
      relatedInformation,
      tags
    };
  }
  changeAll(owner, data) {
    const changes = [];
    const existing = this._data.values(owner);
    if (existing) {
      for (const data2 of existing) {
        const first = Iterable.first(data2);
        if (first) {
          changes.push(first.resource);
          this._data.delete(first.resource, owner);
        }
      }
    }
    if (isNonEmptyArray(data)) {
      const groups = new ResourceMap();
      for (const { resource, marker: markerData } of data) {
        const marker = _MarkerService._toMarker(owner, resource, markerData);
        if (!marker) {
          continue;
        }
        const array = groups.get(resource);
        if (!array) {
          groups.set(resource, [marker]);
          changes.push(resource);
        } else {
          array.push(marker);
        }
      }
      for (const [resource, value] of groups) {
        this._data.set(resource, owner, value);
      }
    }
    if (changes.length > 0) {
      this._onMarkerChanged.fire(changes);
    }
  }
  read(filter = /* @__PURE__ */ Object.create(null)) {
    let { owner, resource, severities, take } = filter;
    if (!take || take < 0) {
      take = -1;
    }
    if (owner && resource) {
      const data = this._data.get(resource, owner);
      if (!data) {
        return [];
      } else {
        const result = [];
        for (const marker of data) {
          if (_MarkerService._accept(marker, severities)) {
            const newLen = result.push(marker);
            if (take > 0 && newLen === take) {
              break;
            }
          }
        }
        return result;
      }
    } else if (!owner && !resource) {
      const result = [];
      for (const markers of this._data.values()) {
        for (const data of markers) {
          if (_MarkerService._accept(data, severities)) {
            const newLen = result.push(data);
            if (take > 0 && newLen === take) {
              return result;
            }
          }
        }
      }
      return result;
    } else {
      const iterable = this._data.values(resource !== null && resource !== void 0 ? resource : owner);
      const result = [];
      for (const markers of iterable) {
        for (const data of markers) {
          if (_MarkerService._accept(data, severities)) {
            const newLen = result.push(data);
            if (take > 0 && newLen === take) {
              return result;
            }
          }
        }
      }
      return result;
    }
  }
  static _accept(marker, severities) {
    return severities === void 0 || (severities & marker.severity) === marker.severity;
  }
  // --- event debounce logic
  static _merge(all) {
    const set = new ResourceMap();
    for (const array of all) {
      for (const item of array) {
        set.set(item, true);
      }
    }
    return Array.from(set.keys());
  }
};

// node_modules/monaco-editor/esm/vs/platform/configuration/common/configurations.js
init_lifecycle();
init_configurationRegistry();
init_platform2();
var DefaultConfiguration = class extends Disposable {
  constructor() {
    super(...arguments);
    this._configurationModel = new ConfigurationModel();
  }
  get configurationModel() {
    return this._configurationModel;
  }
  reload() {
    this.resetConfigurationModel();
    return this.configurationModel;
  }
  getConfigurationDefaultOverrides() {
    return {};
  }
  resetConfigurationModel() {
    this._configurationModel = new ConfigurationModel();
    const properties = Registry.as(Extensions2.Configuration).getConfigurationProperties();
    this.updateConfigurationModel(Object.keys(properties), properties);
  }
  updateConfigurationModel(properties, configurationProperties) {
    const configurationDefaultsOverrides = this.getConfigurationDefaultOverrides();
    for (const key of properties) {
      const defaultOverrideValue = configurationDefaultsOverrides[key];
      const propertySchema = configurationProperties[key];
      if (defaultOverrideValue !== void 0) {
        this._configurationModel.addValue(key, defaultOverrideValue);
      } else if (propertySchema) {
        this._configurationModel.addValue(key, propertySchema.default);
      } else {
        this._configurationModel.removeValue(key);
      }
    }
  }
};

// node_modules/monaco-editor/esm/vs/platform/accessibilitySignal/browser/accessibilitySignalService.js
init_instantiation();
init_nls();
var IAccessibilitySignalService = createDecorator("accessibilitySignalService");
var Sound = class _Sound {
  static register(options2) {
    const sound = new _Sound(options2.fileName);
    return sound;
  }
  constructor(fileName) {
    this.fileName = fileName;
  }
};
Sound.error = Sound.register({ fileName: "error.mp3" });
Sound.warning = Sound.register({ fileName: "warning.mp3" });
Sound.foldedArea = Sound.register({ fileName: "foldedAreas.mp3" });
Sound.break = Sound.register({ fileName: "break.mp3" });
Sound.quickFixes = Sound.register({ fileName: "quickFixes.mp3" });
Sound.taskCompleted = Sound.register({ fileName: "taskCompleted.mp3" });
Sound.taskFailed = Sound.register({ fileName: "taskFailed.mp3" });
Sound.terminalBell = Sound.register({ fileName: "terminalBell.mp3" });
Sound.diffLineInserted = Sound.register({ fileName: "diffLineInserted.mp3" });
Sound.diffLineDeleted = Sound.register({ fileName: "diffLineDeleted.mp3" });
Sound.diffLineModified = Sound.register({ fileName: "diffLineModified.mp3" });
Sound.chatRequestSent = Sound.register({ fileName: "chatRequestSent.mp3" });
Sound.chatResponsePending = Sound.register({ fileName: "chatResponsePending.mp3" });
Sound.chatResponseReceived1 = Sound.register({ fileName: "chatResponseReceived1.mp3" });
Sound.chatResponseReceived2 = Sound.register({ fileName: "chatResponseReceived2.mp3" });
Sound.chatResponseReceived3 = Sound.register({ fileName: "chatResponseReceived3.mp3" });
Sound.chatResponseReceived4 = Sound.register({ fileName: "chatResponseReceived4.mp3" });
Sound.clear = Sound.register({ fileName: "clear.mp3" });
Sound.save = Sound.register({ fileName: "save.mp3" });
Sound.format = Sound.register({ fileName: "format.mp3" });
var SoundSource = class {
  constructor(randomOneOf) {
    this.randomOneOf = randomOneOf;
  }
};
var AccessibilitySignal = class _AccessibilitySignal {
  static register(options2) {
    const soundSource = new SoundSource("randomOneOf" in options2.sound ? options2.sound.randomOneOf : [options2.sound]);
    const signal = new _AccessibilitySignal(soundSource, options2.name, options2.legacySoundSettingsKey, options2.settingsKey, options2.legacyAnnouncementSettingsKey, options2.announcementMessage);
    _AccessibilitySignal._signals.add(signal);
    return signal;
  }
  constructor(sound, name, legacySoundSettingsKey, settingsKey, legacyAnnouncementSettingsKey, announcementMessage) {
    this.sound = sound;
    this.name = name;
    this.legacySoundSettingsKey = legacySoundSettingsKey;
    this.settingsKey = settingsKey;
    this.legacyAnnouncementSettingsKey = legacyAnnouncementSettingsKey;
    this.announcementMessage = announcementMessage;
  }
};
AccessibilitySignal._signals = /* @__PURE__ */ new Set();
AccessibilitySignal.error = AccessibilitySignal.register({
  name: localize("accessibilitySignals.lineHasError.name", "Error on Line"),
  sound: Sound.error,
  legacySoundSettingsKey: "audioCues.lineHasError",
  legacyAnnouncementSettingsKey: "accessibility.alert.error",
  announcementMessage: localize("accessibility.signals.lineHasError", "Error"),
  settingsKey: "accessibility.signals.lineHasError"
});
AccessibilitySignal.warning = AccessibilitySignal.register({
  name: localize("accessibilitySignals.lineHasWarning.name", "Warning on Line"),
  sound: Sound.warning,
  legacySoundSettingsKey: "audioCues.lineHasWarning",
  legacyAnnouncementSettingsKey: "accessibility.alert.warning",
  announcementMessage: localize("accessibility.signals.lineHasWarning", "Warning"),
  settingsKey: "accessibility.signals.lineHasWarning"
});
AccessibilitySignal.foldedArea = AccessibilitySignal.register({
  name: localize("accessibilitySignals.lineHasFoldedArea.name", "Folded Area on Line"),
  sound: Sound.foldedArea,
  legacySoundSettingsKey: "audioCues.lineHasFoldedArea",
  legacyAnnouncementSettingsKey: "accessibility.alert.foldedArea",
  announcementMessage: localize("accessibility.signals.lineHasFoldedArea", "Folded"),
  settingsKey: "accessibility.signals.lineHasFoldedArea"
});
AccessibilitySignal.break = AccessibilitySignal.register({
  name: localize("accessibilitySignals.lineHasBreakpoint.name", "Breakpoint on Line"),
  sound: Sound.break,
  legacySoundSettingsKey: "audioCues.lineHasBreakpoint",
  legacyAnnouncementSettingsKey: "accessibility.alert.breakpoint",
  announcementMessage: localize("accessibility.signals.lineHasBreakpoint", "Breakpoint"),
  settingsKey: "accessibility.signals.lineHasBreakpoint"
});
AccessibilitySignal.inlineSuggestion = AccessibilitySignal.register({
  name: localize("accessibilitySignals.lineHasInlineSuggestion.name", "Inline Suggestion on Line"),
  sound: Sound.quickFixes,
  legacySoundSettingsKey: "audioCues.lineHasInlineSuggestion",
  settingsKey: "accessibility.signals.lineHasInlineSuggestion"
});
AccessibilitySignal.terminalQuickFix = AccessibilitySignal.register({
  name: localize("accessibilitySignals.terminalQuickFix.name", "Terminal Quick Fix"),
  sound: Sound.quickFixes,
  legacySoundSettingsKey: "audioCues.terminalQuickFix",
  legacyAnnouncementSettingsKey: "accessibility.alert.terminalQuickFix",
  announcementMessage: localize("accessibility.signals.terminalQuickFix", "Quick Fix"),
  settingsKey: "accessibility.signals.terminalQuickFix"
});
AccessibilitySignal.onDebugBreak = AccessibilitySignal.register({
  name: localize("accessibilitySignals.onDebugBreak.name", "Debugger Stopped on Breakpoint"),
  sound: Sound.break,
  legacySoundSettingsKey: "audioCues.onDebugBreak",
  legacyAnnouncementSettingsKey: "accessibility.alert.onDebugBreak",
  announcementMessage: localize("accessibility.signals.onDebugBreak", "Breakpoint"),
  settingsKey: "accessibility.signals.onDebugBreak"
});
AccessibilitySignal.noInlayHints = AccessibilitySignal.register({
  name: localize("accessibilitySignals.noInlayHints", "No Inlay Hints on Line"),
  sound: Sound.error,
  legacySoundSettingsKey: "audioCues.noInlayHints",
  legacyAnnouncementSettingsKey: "accessibility.alert.noInlayHints",
  announcementMessage: localize("accessibility.signals.noInlayHints", "No Inlay Hints"),
  settingsKey: "accessibility.signals.noInlayHints"
});
AccessibilitySignal.taskCompleted = AccessibilitySignal.register({
  name: localize("accessibilitySignals.taskCompleted", "Task Completed"),
  sound: Sound.taskCompleted,
  legacySoundSettingsKey: "audioCues.taskCompleted",
  legacyAnnouncementSettingsKey: "accessibility.alert.taskCompleted",
  announcementMessage: localize("accessibility.signals.taskCompleted", "Task Completed"),
  settingsKey: "accessibility.signals.taskCompleted"
});
AccessibilitySignal.taskFailed = AccessibilitySignal.register({
  name: localize("accessibilitySignals.taskFailed", "Task Failed"),
  sound: Sound.taskFailed,
  legacySoundSettingsKey: "audioCues.taskFailed",
  legacyAnnouncementSettingsKey: "accessibility.alert.taskFailed",
  announcementMessage: localize("accessibility.signals.taskFailed", "Task Failed"),
  settingsKey: "accessibility.signals.taskFailed"
});
AccessibilitySignal.terminalCommandFailed = AccessibilitySignal.register({
  name: localize("accessibilitySignals.terminalCommandFailed", "Terminal Command Failed"),
  sound: Sound.error,
  legacySoundSettingsKey: "audioCues.terminalCommandFailed",
  legacyAnnouncementSettingsKey: "accessibility.alert.terminalCommandFailed",
  announcementMessage: localize("accessibility.signals.terminalCommandFailed", "Command Failed"),
  settingsKey: "accessibility.signals.terminalCommandFailed"
});
AccessibilitySignal.terminalBell = AccessibilitySignal.register({
  name: localize("accessibilitySignals.terminalBell", "Terminal Bell"),
  sound: Sound.terminalBell,
  legacySoundSettingsKey: "audioCues.terminalBell",
  legacyAnnouncementSettingsKey: "accessibility.alert.terminalBell",
  announcementMessage: localize("accessibility.signals.terminalBell", "Terminal Bell"),
  settingsKey: "accessibility.signals.terminalBell"
});
AccessibilitySignal.notebookCellCompleted = AccessibilitySignal.register({
  name: localize("accessibilitySignals.notebookCellCompleted", "Notebook Cell Completed"),
  sound: Sound.taskCompleted,
  legacySoundSettingsKey: "audioCues.notebookCellCompleted",
  legacyAnnouncementSettingsKey: "accessibility.alert.notebookCellCompleted",
  announcementMessage: localize("accessibility.signals.notebookCellCompleted", "Notebook Cell Completed"),
  settingsKey: "accessibility.signals.notebookCellCompleted"
});
AccessibilitySignal.notebookCellFailed = AccessibilitySignal.register({
  name: localize("accessibilitySignals.notebookCellFailed", "Notebook Cell Failed"),
  sound: Sound.taskFailed,
  legacySoundSettingsKey: "audioCues.notebookCellFailed",
  legacyAnnouncementSettingsKey: "accessibility.alert.notebookCellFailed",
  announcementMessage: localize("accessibility.signals.notebookCellFailed", "Notebook Cell Failed"),
  settingsKey: "accessibility.signals.notebookCellFailed"
});
AccessibilitySignal.diffLineInserted = AccessibilitySignal.register({
  name: localize("accessibilitySignals.diffLineInserted", "Diff Line Inserted"),
  sound: Sound.diffLineInserted,
  legacySoundSettingsKey: "audioCues.diffLineInserted",
  settingsKey: "accessibility.signals.diffLineInserted"
});
AccessibilitySignal.diffLineDeleted = AccessibilitySignal.register({
  name: localize("accessibilitySignals.diffLineDeleted", "Diff Line Deleted"),
  sound: Sound.diffLineDeleted,
  legacySoundSettingsKey: "audioCues.diffLineDeleted",
  settingsKey: "accessibility.signals.diffLineDeleted"
});
AccessibilitySignal.diffLineModified = AccessibilitySignal.register({
  name: localize("accessibilitySignals.diffLineModified", "Diff Line Modified"),
  sound: Sound.diffLineModified,
  legacySoundSettingsKey: "audioCues.diffLineModified",
  settingsKey: "accessibility.signals.diffLineModified"
});
AccessibilitySignal.chatRequestSent = AccessibilitySignal.register({
  name: localize("accessibilitySignals.chatRequestSent", "Chat Request Sent"),
  sound: Sound.chatRequestSent,
  legacySoundSettingsKey: "audioCues.chatRequestSent",
  legacyAnnouncementSettingsKey: "accessibility.alert.chatRequestSent",
  announcementMessage: localize("accessibility.signals.chatRequestSent", "Chat Request Sent"),
  settingsKey: "accessibility.signals.chatRequestSent"
});
AccessibilitySignal.chatResponseReceived = AccessibilitySignal.register({
  name: localize("accessibilitySignals.chatResponseReceived", "Chat Response Received"),
  legacySoundSettingsKey: "audioCues.chatResponseReceived",
  sound: {
    randomOneOf: [
      Sound.chatResponseReceived1,
      Sound.chatResponseReceived2,
      Sound.chatResponseReceived3,
      Sound.chatResponseReceived4
    ]
  },
  settingsKey: "accessibility.signals.chatResponseReceived"
});
AccessibilitySignal.chatResponsePending = AccessibilitySignal.register({
  name: localize("accessibilitySignals.chatResponsePending", "Chat Response Pending"),
  sound: Sound.chatResponsePending,
  legacySoundSettingsKey: "audioCues.chatResponsePending",
  legacyAnnouncementSettingsKey: "accessibility.alert.chatResponsePending",
  announcementMessage: localize("accessibility.signals.chatResponsePending", "Chat Response Pending"),
  settingsKey: "accessibility.signals.chatResponsePending"
});
AccessibilitySignal.clear = AccessibilitySignal.register({
  name: localize("accessibilitySignals.clear", "Clear"),
  sound: Sound.clear,
  legacySoundSettingsKey: "audioCues.clear",
  legacyAnnouncementSettingsKey: "accessibility.alert.clear",
  announcementMessage: localize("accessibility.signals.clear", "Clear"),
  settingsKey: "accessibility.signals.clear"
});
AccessibilitySignal.save = AccessibilitySignal.register({
  name: localize("accessibilitySignals.save", "Save"),
  sound: Sound.save,
  legacySoundSettingsKey: "audioCues.save",
  legacyAnnouncementSettingsKey: "accessibility.alert.save",
  announcementMessage: localize("accessibility.signals.save", "Save"),
  settingsKey: "accessibility.signals.save"
});
AccessibilitySignal.format = AccessibilitySignal.register({
  name: localize("accessibilitySignals.format", "Format"),
  sound: Sound.format,
  legacySoundSettingsKey: "audioCues.format",
  legacyAnnouncementSettingsKey: "accessibility.alert.format",
  announcementMessage: localize("accessibility.signals.format", "Format"),
  settingsKey: "accessibility.signals.format"
});

// node_modules/monaco-editor/esm/vs/platform/log/common/logService.js
init_lifecycle();
init_log();
var LogService = class extends Disposable {
  constructor(primaryLogger, otherLoggers = []) {
    super();
    this.logger = new MultiplexLogger([primaryLogger, ...otherLoggers]);
    this._register(primaryLogger.onDidChangeLogLevel((level) => this.setLevel(level)));
  }
  get onDidChangeLogLevel() {
    return this.logger.onDidChangeLogLevel;
  }
  setLevel(level) {
    this.logger.setLevel(level);
  }
  getLevel() {
    return this.logger.getLevel();
  }
  trace(message, ...args) {
    this.logger.trace(message, ...args);
  }
  debug(message, ...args) {
    this.logger.debug(message, ...args);
  }
  info(message, ...args) {
    this.logger.info(message, ...args);
  }
  warn(message, ...args) {
    this.logger.warn(message, ...args);
  }
  error(message, ...args) {
    this.logger.error(message, ...args);
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/editorFeatures.js
var editorFeatures = [];
function registerEditorFeature(ctor) {
  editorFeatures.push(ctor);
}
function getEditorFeatures() {
  return editorFeatures.slice(0);
}

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
init_errors();
init_environment();
init_window();
var __decorate37 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param30 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SimpleModel = class {
  constructor(model) {
    this.disposed = false;
    this.model = model;
    this._onWillDispose = new Emitter();
  }
  get textEditorModel() {
    return this.model;
  }
  dispose() {
    this.disposed = true;
    this._onWillDispose.fire();
  }
};
var StandaloneTextModelService = class StandaloneTextModelService2 {
  constructor(modelService) {
    this.modelService = modelService;
  }
  createModelReference(resource) {
    const model = this.modelService.getModel(resource);
    if (!model) {
      return Promise.reject(new Error(`Model not found`));
    }
    return Promise.resolve(new ImmortalReference(new SimpleModel(model)));
  }
};
StandaloneTextModelService = __decorate37([
  __param30(0, IModelService)
], StandaloneTextModelService);
var StandaloneEditorProgressService = class _StandaloneEditorProgressService {
  show() {
    return _StandaloneEditorProgressService.NULL_PROGRESS_RUNNER;
  }
  async showWhile(promise, delay) {
    await promise;
  }
};
StandaloneEditorProgressService.NULL_PROGRESS_RUNNER = {
  done: () => {
  },
  total: () => {
  },
  worked: () => {
  }
};
var StandaloneProgressService = class {
  withProgress(_options, task, onDidCancel) {
    return task({
      report: () => {
      }
    });
  }
};
var StandaloneEnvironmentService = class {
  constructor() {
    this.isExtensionDevelopment = false;
    this.isBuilt = false;
  }
};
var StandaloneDialogService = class {
  async confirm(confirmation) {
    const confirmed = this.doConfirm(confirmation.message, confirmation.detail);
    return {
      confirmed,
      checkboxChecked: false
      // unsupported
    };
  }
  doConfirm(message, detail) {
    let messageText = message;
    if (detail) {
      messageText = messageText + "\n\n" + detail;
    }
    return mainWindow.confirm(messageText);
  }
  async prompt(prompt) {
    var _a2, _b2;
    let result = void 0;
    const confirmed = this.doConfirm(prompt.message, prompt.detail);
    if (confirmed) {
      const promptButtons = [...(_a2 = prompt.buttons) !== null && _a2 !== void 0 ? _a2 : []];
      if (prompt.cancelButton && typeof prompt.cancelButton !== "string" && typeof prompt.cancelButton !== "boolean") {
        promptButtons.push(prompt.cancelButton);
      }
      result = await ((_b2 = promptButtons[0]) === null || _b2 === void 0 ? void 0 : _b2.run({ checkboxChecked: false }));
    }
    return { result };
  }
  async error(message, detail) {
    await this.prompt({ type: severity_default.Error, message, detail });
  }
};
var StandaloneNotificationService = class _StandaloneNotificationService {
  info(message) {
    return this.notify({ severity: severity_default.Info, message });
  }
  warn(message) {
    return this.notify({ severity: severity_default.Warning, message });
  }
  error(error) {
    return this.notify({ severity: severity_default.Error, message: error });
  }
  notify(notification) {
    switch (notification.severity) {
      case severity_default.Error:
        console.error(notification.message);
        break;
      case severity_default.Warning:
        console.warn(notification.message);
        break;
      default:
        console.log(notification.message);
        break;
    }
    return _StandaloneNotificationService.NO_OP;
  }
  prompt(severity, message, choices, options2) {
    return _StandaloneNotificationService.NO_OP;
  }
  status(message, options2) {
    return Disposable.None;
  }
};
StandaloneNotificationService.NO_OP = new NoOpNotification();
var StandaloneCommandService = class StandaloneCommandService2 {
  constructor(instantiationService) {
    this._onWillExecuteCommand = new Emitter();
    this._onDidExecuteCommand = new Emitter();
    this.onDidExecuteCommand = this._onDidExecuteCommand.event;
    this._instantiationService = instantiationService;
  }
  executeCommand(id, ...args) {
    const command = CommandsRegistry.getCommand(id);
    if (!command) {
      return Promise.reject(new Error(`command '${id}' not found`));
    }
    try {
      this._onWillExecuteCommand.fire({ commandId: id, args });
      const result = this._instantiationService.invokeFunction.apply(this._instantiationService, [command.handler, ...args]);
      this._onDidExecuteCommand.fire({ commandId: id, args });
      return Promise.resolve(result);
    } catch (err) {
      return Promise.reject(err);
    }
  }
};
StandaloneCommandService = __decorate37([
  __param30(0, IInstantiationService)
], StandaloneCommandService);
var StandaloneKeybindingService = class StandaloneKeybindingService2 extends AbstractKeybindingService {
  constructor(contextKeyService, commandService, telemetryService, notificationService, logService, codeEditorService) {
    super(contextKeyService, commandService, telemetryService, notificationService, logService);
    this._cachedResolver = null;
    this._dynamicKeybindings = [];
    this._domNodeListeners = [];
    const addContainer = (domNode) => {
      const disposables = new DisposableStore();
      disposables.add(addDisposableListener(domNode, EventType.KEY_DOWN, (e) => {
        const keyEvent = new StandardKeyboardEvent(e);
        const shouldPreventDefault = this._dispatch(keyEvent, keyEvent.target);
        if (shouldPreventDefault) {
          keyEvent.preventDefault();
          keyEvent.stopPropagation();
        }
      }));
      disposables.add(addDisposableListener(domNode, EventType.KEY_UP, (e) => {
        const keyEvent = new StandardKeyboardEvent(e);
        const shouldPreventDefault = this._singleModifierDispatch(keyEvent, keyEvent.target);
        if (shouldPreventDefault) {
          keyEvent.preventDefault();
        }
      }));
      this._domNodeListeners.push(new DomNodeListeners(domNode, disposables));
    };
    const removeContainer = (domNode) => {
      for (let i = 0; i < this._domNodeListeners.length; i++) {
        const domNodeListeners = this._domNodeListeners[i];
        if (domNodeListeners.domNode === domNode) {
          this._domNodeListeners.splice(i, 1);
          domNodeListeners.dispose();
        }
      }
    };
    const addCodeEditor = (codeEditor) => {
      if (codeEditor.getOption(
        61
        /* EditorOption.inDiffEditor */
      )) {
        return;
      }
      addContainer(codeEditor.getContainerDomNode());
    };
    const removeCodeEditor = (codeEditor) => {
      if (codeEditor.getOption(
        61
        /* EditorOption.inDiffEditor */
      )) {
        return;
      }
      removeContainer(codeEditor.getContainerDomNode());
    };
    this._register(codeEditorService.onCodeEditorAdd(addCodeEditor));
    this._register(codeEditorService.onCodeEditorRemove(removeCodeEditor));
    codeEditorService.listCodeEditors().forEach(addCodeEditor);
    const addDiffEditor = (diffEditor) => {
      addContainer(diffEditor.getContainerDomNode());
    };
    const removeDiffEditor = (diffEditor) => {
      removeContainer(diffEditor.getContainerDomNode());
    };
    this._register(codeEditorService.onDiffEditorAdd(addDiffEditor));
    this._register(codeEditorService.onDiffEditorRemove(removeDiffEditor));
    codeEditorService.listDiffEditors().forEach(addDiffEditor);
  }
  addDynamicKeybinding(command, keybinding, handler, when) {
    return combinedDisposable(CommandsRegistry.registerCommand(command, handler), this.addDynamicKeybindings([{
      keybinding,
      command,
      when
    }]));
  }
  addDynamicKeybindings(rules) {
    const entries = rules.map((rule) => {
      var _a2;
      const keybinding = decodeKeybinding(rule.keybinding, OS);
      return {
        keybinding,
        command: (_a2 = rule.command) !== null && _a2 !== void 0 ? _a2 : null,
        commandArgs: rule.commandArgs,
        when: rule.when,
        weight1: 1e3,
        weight2: 0,
        extensionId: null,
        isBuiltinExtension: false
      };
    });
    this._dynamicKeybindings = this._dynamicKeybindings.concat(entries);
    this.updateResolver();
    return toDisposable(() => {
      for (let i = 0; i < this._dynamicKeybindings.length; i++) {
        if (this._dynamicKeybindings[i] === entries[0]) {
          this._dynamicKeybindings.splice(i, entries.length);
          this.updateResolver();
          return;
        }
      }
    });
  }
  updateResolver() {
    this._cachedResolver = null;
    this._onDidUpdateKeybindings.fire();
  }
  _getResolver() {
    if (!this._cachedResolver) {
      const defaults = this._toNormalizedKeybindingItems(KeybindingsRegistry.getDefaultKeybindings(), true);
      const overrides = this._toNormalizedKeybindingItems(this._dynamicKeybindings, false);
      this._cachedResolver = new KeybindingResolver(defaults, overrides, (str) => this._log(str));
    }
    return this._cachedResolver;
  }
  _documentHasFocus() {
    return mainWindow.document.hasFocus();
  }
  _toNormalizedKeybindingItems(items, isDefault) {
    const result = [];
    let resultLen = 0;
    for (const item of items) {
      const when = item.when || void 0;
      const keybinding = item.keybinding;
      if (!keybinding) {
        result[resultLen++] = new ResolvedKeybindingItem(void 0, item.command, item.commandArgs, when, isDefault, null, false);
      } else {
        const resolvedKeybindings = USLayoutResolvedKeybinding.resolveKeybinding(keybinding, OS);
        for (const resolvedKeybinding of resolvedKeybindings) {
          result[resultLen++] = new ResolvedKeybindingItem(resolvedKeybinding, item.command, item.commandArgs, when, isDefault, null, false);
        }
      }
    }
    return result;
  }
  resolveKeyboardEvent(keyboardEvent) {
    const chord = new KeyCodeChord(keyboardEvent.ctrlKey, keyboardEvent.shiftKey, keyboardEvent.altKey, keyboardEvent.metaKey, keyboardEvent.keyCode);
    return new USLayoutResolvedKeybinding([chord], OS);
  }
};
StandaloneKeybindingService = __decorate37([
  __param30(0, IContextKeyService),
  __param30(1, ICommandService),
  __param30(2, ITelemetryService),
  __param30(3, INotificationService),
  __param30(4, ILogService),
  __param30(5, ICodeEditorService)
], StandaloneKeybindingService);
var DomNodeListeners = class extends Disposable {
  constructor(domNode, disposables) {
    super();
    this.domNode = domNode;
    this._register(disposables);
  }
};
function isConfigurationOverrides(thing) {
  return thing && typeof thing === "object" && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === "string") && (!thing.resource || thing.resource instanceof URI);
}
var StandaloneConfigurationService = class {
  constructor() {
    this._onDidChangeConfiguration = new Emitter();
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    const defaultConfiguration = new DefaultConfiguration();
    this._configuration = new Configuration(defaultConfiguration.reload(), new ConfigurationModel(), new ConfigurationModel(), new ConfigurationModel());
    defaultConfiguration.dispose();
  }
  getValue(arg1, arg2) {
    const section = typeof arg1 === "string" ? arg1 : void 0;
    const overrides = isConfigurationOverrides(arg1) ? arg1 : isConfigurationOverrides(arg2) ? arg2 : {};
    return this._configuration.getValue(section, overrides, void 0);
  }
  updateValues(values) {
    const previous = { data: this._configuration.toData() };
    const changedKeys = [];
    for (const entry of values) {
      const [key, value] = entry;
      if (this.getValue(key) === value) {
        continue;
      }
      this._configuration.updateValue(key, value);
      changedKeys.push(key);
    }
    if (changedKeys.length > 0) {
      const configurationChangeEvent = new ConfigurationChangeEvent({ keys: changedKeys, overrides: [] }, previous, this._configuration);
      configurationChangeEvent.source = 8;
      this._onDidChangeConfiguration.fire(configurationChangeEvent);
    }
    return Promise.resolve();
  }
  updateValue(key, value, arg3, arg4) {
    return this.updateValues([[key, value]]);
  }
  inspect(key, options2 = {}) {
    return this._configuration.inspect(key, options2, void 0);
  }
};
var StandaloneResourceConfigurationService = class StandaloneResourceConfigurationService2 {
  constructor(configurationService, modelService, languageService) {
    this.configurationService = configurationService;
    this.modelService = modelService;
    this.languageService = languageService;
    this._onDidChangeConfiguration = new Emitter();
    this.configurationService.onDidChangeConfiguration((e) => {
      this._onDidChangeConfiguration.fire({ affectedKeys: e.affectedKeys, affectsConfiguration: (resource, configuration) => e.affectsConfiguration(configuration) });
    });
  }
  getValue(resource, arg2, arg3) {
    const position = Position.isIPosition(arg2) ? arg2 : null;
    const section = position ? typeof arg3 === "string" ? arg3 : void 0 : typeof arg2 === "string" ? arg2 : void 0;
    const language = resource ? this.getLanguage(resource, position) : void 0;
    if (typeof section === "undefined") {
      return this.configurationService.getValue({
        resource,
        overrideIdentifier: language
      });
    }
    return this.configurationService.getValue(section, {
      resource,
      overrideIdentifier: language
    });
  }
  getLanguage(resource, position) {
    const model = this.modelService.getModel(resource);
    if (model) {
      return position ? model.getLanguageIdAtPosition(position.lineNumber, position.column) : model.getLanguageId();
    }
    return this.languageService.guessLanguageIdByFilepathOrFirstLine(resource);
  }
};
StandaloneResourceConfigurationService = __decorate37([
  __param30(0, IConfigurationService),
  __param30(1, IModelService),
  __param30(2, ILanguageService)
], StandaloneResourceConfigurationService);
var StandaloneResourcePropertiesService = class StandaloneResourcePropertiesService2 {
  constructor(configurationService) {
    this.configurationService = configurationService;
  }
  getEOL(resource, language) {
    const eol = this.configurationService.getValue("files.eol", { overrideIdentifier: language, resource });
    if (eol && typeof eol === "string" && eol !== "auto") {
      return eol;
    }
    return isLinux || isMacintosh ? "\n" : "\r\n";
  }
};
StandaloneResourcePropertiesService = __decorate37([
  __param30(0, IConfigurationService)
], StandaloneResourcePropertiesService);
var StandaloneTelemetryService = class {
  publicLog2() {
  }
};
var StandaloneWorkspaceContextService = class _StandaloneWorkspaceContextService {
  constructor() {
    const resource = URI.from({ scheme: _StandaloneWorkspaceContextService.SCHEME, authority: "model", path: "/" });
    this.workspace = { id: STANDALONE_EDITOR_WORKSPACE_ID, folders: [new WorkspaceFolder({ uri: resource, name: "", index: 0 })] };
  }
  getWorkspace() {
    return this.workspace;
  }
  getWorkspaceFolder(resource) {
    return resource && resource.scheme === _StandaloneWorkspaceContextService.SCHEME ? this.workspace.folders[0] : null;
  }
};
StandaloneWorkspaceContextService.SCHEME = "inmemory";
function updateConfigurationService(configurationService, source, isDiffEditor) {
  if (!source) {
    return;
  }
  if (!(configurationService instanceof StandaloneConfigurationService)) {
    return;
  }
  const toUpdate = [];
  Object.keys(source).forEach((key) => {
    if (isEditorConfigurationKey(key)) {
      toUpdate.push([`editor.${key}`, source[key]]);
    }
    if (isDiffEditor && isDiffEditorConfigurationKey(key)) {
      toUpdate.push([`diffEditor.${key}`, source[key]]);
    }
  });
  if (toUpdate.length > 0) {
    configurationService.updateValues(toUpdate);
  }
}
var StandaloneBulkEditService = class StandaloneBulkEditService2 {
  constructor(_modelService) {
    this._modelService = _modelService;
  }
  hasPreviewHandler() {
    return false;
  }
  async apply(editsIn, _options) {
    const edits = Array.isArray(editsIn) ? editsIn : ResourceEdit.convert(editsIn);
    const textEdits = /* @__PURE__ */ new Map();
    for (const edit of edits) {
      if (!(edit instanceof ResourceTextEdit)) {
        throw new Error("bad edit - only text edits are supported");
      }
      const model = this._modelService.getModel(edit.resource);
      if (!model) {
        throw new Error("bad edit - model not found");
      }
      if (typeof edit.versionId === "number" && model.getVersionId() !== edit.versionId) {
        throw new Error("bad state - model changed in the meantime");
      }
      let array = textEdits.get(model);
      if (!array) {
        array = [];
        textEdits.set(model, array);
      }
      array.push(EditOperation.replaceMove(Range2.lift(edit.textEdit.range), edit.textEdit.text));
    }
    let totalEdits = 0;
    let totalFiles = 0;
    for (const [model, edits2] of textEdits) {
      model.pushStackElement();
      model.pushEditOperations([], edits2, () => []);
      model.pushStackElement();
      totalFiles += 1;
      totalEdits += edits2.length;
    }
    return {
      ariaSummary: format(StandaloneServicesNLS.bulkEditServiceSummary, totalEdits, totalFiles),
      isApplied: totalEdits > 0
    };
  }
};
StandaloneBulkEditService = __decorate37([
  __param30(0, IModelService)
], StandaloneBulkEditService);
var StandaloneUriLabelService = class {
  getUriLabel(resource, options2) {
    if (resource.scheme === "file") {
      return resource.fsPath;
    }
    return resource.path;
  }
  getUriBasenameLabel(resource) {
    return basename2(resource);
  }
};
var StandaloneContextViewService = class StandaloneContextViewService2 extends ContextViewService {
  constructor(layoutService, _codeEditorService) {
    super(layoutService);
    this._codeEditorService = _codeEditorService;
  }
  showContextView(delegate, container, shadowRoot) {
    if (!container) {
      const codeEditor = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();
      if (codeEditor) {
        container = codeEditor.getContainerDomNode();
      }
    }
    return super.showContextView(delegate, container, shadowRoot);
  }
};
StandaloneContextViewService = __decorate37([
  __param30(0, ILayoutService),
  __param30(1, ICodeEditorService)
], StandaloneContextViewService);
var StandaloneWorkspaceTrustManagementService = class {
  constructor() {
    this._neverEmitter = new Emitter();
    this.onDidChangeTrust = this._neverEmitter.event;
  }
  isWorkspaceTrusted() {
    return true;
  }
};
var StandaloneLanguageService = class extends LanguageService {
  constructor() {
    super();
  }
};
var StandaloneLogService = class extends LogService {
  constructor() {
    super(new ConsoleLogger());
  }
};
var StandaloneContextMenuService = class StandaloneContextMenuService2 extends ContextMenuService {
  constructor(telemetryService, notificationService, contextViewService, keybindingService, menuService, contextKeyService) {
    super(telemetryService, notificationService, contextViewService, keybindingService, menuService, contextKeyService);
    this.configure({ blockMouse: false });
  }
};
StandaloneContextMenuService = __decorate37([
  __param30(0, ITelemetryService),
  __param30(1, INotificationService),
  __param30(2, IContextViewService),
  __param30(3, IKeybindingService),
  __param30(4, IMenuService),
  __param30(5, IContextKeyService)
], StandaloneContextMenuService);
var StandaloneAccessbilitySignalService = class {
  async playSignal(cue, options2) {
  }
};
registerSingleton(
  IConfigurationService,
  StandaloneConfigurationService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  ITextResourceConfigurationService,
  StandaloneResourceConfigurationService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  ITextResourcePropertiesService,
  StandaloneResourcePropertiesService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IWorkspaceContextService,
  StandaloneWorkspaceContextService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  ILabelService,
  StandaloneUriLabelService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  ITelemetryService,
  StandaloneTelemetryService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IDialogService,
  StandaloneDialogService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IEnvironmentService,
  StandaloneEnvironmentService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  INotificationService,
  StandaloneNotificationService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IMarkerService,
  MarkerService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  ILanguageService,
  StandaloneLanguageService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IStandaloneThemeService,
  StandaloneThemeService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  ILogService,
  StandaloneLogService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IModelService,
  ModelService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IMarkerDecorationsService,
  MarkerDecorationsService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IContextKeyService,
  ContextKeyService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IProgressService,
  StandaloneProgressService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IEditorProgressService,
  StandaloneEditorProgressService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IStorageService,
  InMemoryStorageService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IEditorWorkerService,
  EditorWorkerService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IBulkEditService,
  StandaloneBulkEditService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IWorkspaceTrustManagementService,
  StandaloneWorkspaceTrustManagementService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  ITextModelService,
  StandaloneTextModelService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IAccessibilityService,
  AccessibilityService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IListService,
  ListService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  ICommandService,
  StandaloneCommandService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IKeybindingService,
  StandaloneKeybindingService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IQuickInputService,
  StandaloneQuickInputService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IContextViewService,
  StandaloneContextViewService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IOpenerService,
  OpenerService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IClipboardService,
  BrowserClipboardService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IContextMenuService,
  StandaloneContextMenuService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IMenuService,
  MenuService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IAccessibilitySignalService,
  StandaloneAccessbilitySignalService,
  0
  /* InstantiationType.Eager */
);
var StandaloneServices;
(function(StandaloneServices2) {
  const serviceCollection = new ServiceCollection();
  for (const [id, descriptor] of getSingletonServiceDescriptors()) {
    serviceCollection.set(id, descriptor);
  }
  const instantiationService = new InstantiationService(serviceCollection, true);
  serviceCollection.set(IInstantiationService, instantiationService);
  function get(serviceId) {
    if (!initialized) {
      initialize2({});
    }
    const r = serviceCollection.get(serviceId);
    if (!r) {
      throw new Error("Missing service " + serviceId);
    }
    if (r instanceof SyncDescriptor) {
      return instantiationService.invokeFunction((accessor) => accessor.get(serviceId));
    } else {
      return r;
    }
  }
  StandaloneServices2.get = get;
  let initialized = false;
  const onDidInitialize = new Emitter();
  function initialize2(overrides) {
    if (initialized) {
      return instantiationService;
    }
    initialized = true;
    for (const [id, descriptor] of getSingletonServiceDescriptors()) {
      if (!serviceCollection.get(id)) {
        serviceCollection.set(id, descriptor);
      }
    }
    for (const serviceId in overrides) {
      if (overrides.hasOwnProperty(serviceId)) {
        const serviceIdentifier = createDecorator(serviceId);
        const r = serviceCollection.get(serviceIdentifier);
        if (r instanceof SyncDescriptor) {
          serviceCollection.set(serviceIdentifier, overrides[serviceId]);
        }
      }
    }
    const editorFeatures2 = getEditorFeatures();
    for (const feature of editorFeatures2) {
      try {
        instantiationService.createInstance(feature);
      } catch (err) {
        onUnexpectedError(err);
      }
    }
    onDidInitialize.fire();
    return instantiationService;
  }
  StandaloneServices2.initialize = initialize2;
  function withServices(callback) {
    if (initialized) {
      return callback();
    }
    const disposable = new DisposableStore();
    const listener = disposable.add(onDidInitialize.event(() => {
      listener.dispose();
      disposable.add(callback());
    }));
    return disposable;
  }
  StandaloneServices2.withServices = withServices;
})(StandaloneServices || (StandaloneServices = {}));

export {
  equals,
  binarySearch,
  quickSelect,
  groupBy,
  groupAdjacentBy,
  forEachAdjacent,
  coalesce,
  coalesceInPlace,
  isFalsyOrEmpty,
  isNonEmptyArray,
  distinct,
  asArray,
  compareBy,
  tieBreakComparators,
  numberComparator,
  booleanComparator,
  reverseOrder,
  ArrayQueue,
  init_arrays,
  isString,
  isObject,
  isNumber,
  isBoolean,
  isUndefined,
  isDefined,
  assertType,
  assertIsDefined,
  isFunction,
  init_types,
  deepClone,
  mixin,
  getAllMethodNames,
  init_objects,
  MINIMAP_GUTTER_WIDTH,
  ConfigurationChangedEvent,
  ComputeOptionsMemory,
  ApplyUpdateResult,
  boolean,
  clampedInt,
  clampedFloat,
  stringSet,
  TextEditorCursorStyle,
  EditorFontLigatures,
  EditorFontVariations,
  EditorLayoutInfoComputer,
  ShowLightbulbIconMode,
  filterValidationDecorations,
  inUntrustedWorkspace,
  unicodeHighlightConfigKeys,
  EDITOR_FONT_DEFAULTS,
  editorOptionsRegistry,
  EditorOptions,
  Position,
  init_position,
  Range2 as Range,
  init_range,
  Selection,
  init_selection,
  Codicon,
  init_codicons,
  Token,
  TokenizationResult,
  EncodedTokenizationResult,
  CompletionItemKinds,
  InlineCompletionTriggerKind,
  SelectedSuggestionInfo,
  SignatureHelpTriggerKind,
  DocumentHighlightKind,
  isLocationLink,
  getAriaLabelForSymbol,
  SymbolKinds,
  FoldingRangeKind,
  NewSymbolNameTag,
  Command,
  InlayHintKind,
  LazyTokenizationSupport,
  TokenizationRegistry2 as TokenizationRegistry,
  InlineEditTriggerKind,
  init_languages,
  AccessibilitySupport,
  CodeActionTriggerType,
  CompletionItemInsertTextRule,
  CompletionItemKind,
  CompletionItemTag,
  CompletionTriggerKind,
  ContentWidgetPositionPreference,
  CursorChangeReason,
  DefaultEndOfLine,
  DocumentHighlightKind2,
  EditorAutoIndentStrategy,
  EditorOption,
  EndOfLinePreference,
  EndOfLineSequence,
  GlyphMarginLane2 as GlyphMarginLane,
  IndentAction2 as IndentAction,
  InjectedTextCursorStops2 as InjectedTextCursorStops,
  InlayHintKind2,
  InlineCompletionTriggerKind2,
  InlineEditTriggerKind2,
  MinimapPosition2 as MinimapPosition,
  MouseTargetType,
  NewSymbolNameTag2,
  OverlayWidgetPositionPreference,
  OverviewRulerLane2 as OverviewRulerLane,
  PositionAffinity,
  RenderLineNumbersType,
  RenderMinimap,
  ScrollType,
  ScrollbarVisibility,
  ShowLightbulbIconMode2,
  SignatureHelpTriggerKind2,
  SymbolKind,
  SymbolTag,
  TextEditorCursorBlinkingStyle,
  TextEditorCursorStyle2,
  TrackedRangeStickiness,
  WrappingIndent,
  createMonacoBaseAPI,
  createFastDomNode,
  applyFontInfo,
  ICodeEditorService,
  init_codeEditorService,
  IModelService,
  init_model2 as init_model,
  ITextModelService,
  init_resolverService,
  Action,
  ActionRunner,
  Separator,
  SubmenuAction,
  toAction,
  init_actions,
  ThemeIcon,
  init_themables,
  ICommandService,
  CommandsRegistry,
  init_commands,
  ContextKeyExpr,
  ContextKeyEqualsExpr,
  RawContextKey,
  IContextKeyService,
  init_contextkey,
  assertNever,
  softAssert,
  assertFn,
  init_assert,
  Registry,
  init_platform2 as init_platform,
  KeybindingsRegistry,
  init_keybindingsRegistry,
  isIMenuItem,
  MenuId,
  IMenuService,
  MenuRegistry,
  SubmenuItemAction,
  MenuItemAction,
  Action2,
  registerAction2,
  init_actions2,
  ITelemetryService,
  init_telemetry,
  ILogService,
  init_log,
  Command2,
  MultiCommand,
  EditorCommand,
  EditorAction,
  MultiEditorAction,
  EditorAction2,
  registerModelAndPositionCommand,
  registerEditorCommand,
  registerEditorAction,
  registerMultiEditorAction,
  registerInstantiatedEditorAction,
  registerEditorContribution,
  EditorExtensionsRegistry,
  UndoCommand,
  RedoCommand,
  SelectAllCommand,
  init_editorExtensions,
  createTrustedTypesPolicy,
  IndentAction as IndentAction2,
  init_languageConfiguration,
  createScopedLineTokens,
  init_supports,
  VSBuffer,
  init_buffer,
  StringBuilder,
  init_stringBuilder,
  IConfigurationService,
  init_configuration,
  ILanguageService,
  init_language,
  registerSingleton,
  init_extensions,
  Mimes,
  init_mime,
  Extensions2 as Extensions,
  init_configurationRegistry,
  ModesRegistry,
  PLAINTEXT_LANGUAGE_ID,
  init_modesRegistry,
  ILanguageConfigurationService,
  getIndentationAtPosition,
  getScopedLineTokens,
  init_languageConfigurationRegistry,
  LcsDiff,
  toUint8,
  init_uint,
  ConstantTimePrefixSumComputer,
  CharacterClassifier,
  CharacterSet,
  init_characterClassifier,
  getMapForWordSeparators,
  init_wordCharacterClassifier,
  OverviewRulerLane as OverviewRulerLane2,
  GlyphMarginLane as GlyphMarginLane2,
  MinimapPosition as MinimapPosition2,
  InjectedTextCursorStops as InjectedTextCursorStops2,
  TextModelResolvedOptions,
  FindMatch,
  shouldSynchronizeModel,
  init_model as init_model2,
  SearchParams,
  init_textModelSearch,
  UnicodeTextModelHighlighter,
  OffsetRange,
  OffsetRangeSet,
  init_offsetRange,
  findLast,
  findFirstIdxMonotonousOrArrLen,
  findFirstMaxBy,
  findLastMaxBy,
  findFirstMinBy,
  findMaxIdxBy,
  mapFindFirst,
  init_arraysFind,
  LineRange,
  LineRangeSet,
  init_lineRange,
  LineRangeMapping,
  DetailedLineRangeMapping,
  RangeMapping,
  ResourceMap,
  LRUCache,
  SetMap,
  init_map,
  optimizeSequenceDiffs,
  DefaultLinesDiffComputer,
  RGBA,
  HSVA,
  Color,
  init_color,
  ITextResourceConfigurationService,
  ILanguageFeaturesService,
  init_languageFeatures,
  EditorWorkerClient,
  NullState,
  nullTokenize,
  nullTokenizeEncoded,
  init_nullTokenize,
  TokenMetadata,
  init_encodedTokenAttributes,
  LineTokens,
  init_lineTokens,
  setARIAContainer,
  alert,
  status,
  IMarkerDecorationsService,
  IAccessibilityService,
  CONTEXT_ACCESSIBILITY_MODE_ENABLED,
  GlobalPointerMoveMonitor,
  asCssVariable,
  registerColor,
  foreground,
  iconForeground,
  contrastBorder,
  activeContrastBorder,
  widgetShadow,
  widgetBorder,
  inputBackground,
  inputForeground,
  inputBorder,
  inputActiveOptionBorder,
  inputActiveOptionBackground,
  inputActiveOptionForeground,
  editorErrorForeground,
  editorErrorBorder,
  editorWarningForeground,
  editorWarningBorder,
  editorInfoForeground,
  editorInfoBorder,
  editorHintForeground,
  editorBackground,
  editorForeground,
  editorWidgetBackground,
  editorWidgetBorder,
  editorSelectionBackground,
  editorSelectionForeground,
  editorSelectionHighlight,
  editorFindMatchHighlight,
  editorFindMatchHighlightBorder,
  editorFindRangeHighlightBorder,
  editorHoverBackground,
  editorHoverBorder,
  editorActiveLinkForeground,
  editorInlayHintForeground,
  editorInlayHintBackground,
  editorInlayHintTypeForeground,
  editorInlayHintTypeBackground,
  editorInlayHintParameterForeground,
  editorInlayHintParameterBackground,
  defaultInsertColor,
  defaultRemoveColor,
  diffInserted,
  diffRemoved,
  diffOverviewRulerInserted,
  diffOverviewRulerRemoved,
  listHighlightForeground,
  listFocusHighlightForeground,
  quickInputListFocusForeground,
  quickInputListFocusIconForeground,
  quickInputListFocusBackground,
  overviewRulerFindMatchForeground,
  overviewRulerSelectionHighlightForeground,
  minimapFindMatch,
  minimapSelectionOccurrenceHighlight,
  minimapSelection,
  minimapBackground,
  minimapForegroundOpacity,
  transparent,
  oneOf,
  init_colorRegistry,
  isHighContrast,
  isDark,
  init_theme,
  CursorColumns,
  init_cursorColumns,
  EventType2 as EventType,
  Gesture,
  Widget,
  ScrollbarState,
  Scrollable,
  MouseWheelClassifier,
  ScrollableElement,
  SmoothScrollableElement,
  DomScrollableElement,
  DomEmitter,
  IThemeService,
  themeColorFromId,
  getThemeTypeSelector,
  registerThemingParticipant,
  init_themeService,
  editorLineHighlight,
  editorLineHighlightBorder,
  editorCursorForeground,
  editorCursorBackground,
  editorWhitespaces,
  editorLineNumbers,
  editorIndentGuide1,
  editorIndentGuide2,
  editorIndentGuide3,
  editorIndentGuide4,
  editorIndentGuide5,
  editorIndentGuide6,
  editorActiveIndentGuide1,
  editorActiveIndentGuide2,
  editorActiveIndentGuide3,
  editorActiveIndentGuide4,
  editorActiveIndentGuide5,
  editorActiveIndentGuide6,
  editorDimmedLineNumber,
  editorOverviewRulerBorder,
  editorOverviewRulerBackground,
  editorUnnecessaryCodeOpacity,
  overviewRulerRangeHighlight,
  editorBracketHighlightingForeground1,
  editorBracketHighlightingForeground2,
  editorBracketHighlightingForeground3,
  editorBracketHighlightingForeground4,
  editorBracketHighlightingForeground5,
  editorBracketHighlightingForeground6,
  editorBracketPairGuideBackground1,
  editorBracketPairGuideBackground2,
  editorBracketPairGuideBackground3,
  editorBracketPairGuideBackground4,
  editorBracketPairGuideBackground5,
  editorBracketPairGuideBackground6,
  editorBracketPairGuideActiveBackground1,
  editorBracketPairGuideActiveBackground2,
  editorBracketPairGuideActiveBackground3,
  editorBracketPairGuideActiveBackground4,
  editorBracketPairGuideActiveBackground5,
  editorBracketPairGuideActiveBackground6,
  init_editorColorRegistry,
  IME,
  IKeybindingService,
  normalizeIndentation,
  init_indentation,
  computeIndentLevel,
  init_utils,
  HorizontalGuidesState,
  IndentGuide,
  IndentGuideHorizontalLine,
  init_textModelGuides,
  BracketPairGuidesClassNames,
  init_guidesTextModelPart,
  LineInjectedText,
  ModelInjectedTextChangedEvent,
  InternalModelContentChangeEvent,
  init_textModelEvents,
  countEOL,
  init_eolCounter,
  LengthObj,
  lengthZero,
  lengthGetColumnCountIfZeroLineCount,
  lengthAdd,
  init_length,
  TextEditInfo,
  init_beforeEditPositionMapper,
  DenseKeyProvider,
  init_smallImmutableSet,
  TextBufferTokenizer,
  init_tokenizer,
  LanguageAgnosticBracketTokens,
  init_brackets,
  parseDocument,
  init_parser,
  combineTextEditInfos,
  init_combineTextEditInfos,
  hasDriveLetter,
  init_extpath,
  originalFSPath,
  extUri,
  isEqual,
  basenameOrAuthority,
  basename2 as basename,
  extname2 as extname,
  dirname2 as dirname,
  joinPath,
  relativePath,
  DataUri,
  init_resources,
  IUndoRedoService,
  init_undoRedo,
  TextModel,
  ModelDecorationInjectedTextOptions,
  ModelDecorationOptions,
  init_textModel,
  tokenizeLineToHTML,
  ServiceCollection,
  severity_default,
  Severity2 as Severity,
  INotificationService,
  StandaloneCodeEditorService,
  IDialogService,
  clamp,
  init_numbers,
  IEnvironmentService,
  init_environment,
  ILanguageFeatureDebounceService,
  init_languageFeatureDebounce,
  toMultilineTokens2,
  ISemanticTokensStylingService,
  score,
  WorkbenchHoverDelegate,
  IContextViewService,
  IContextMenuService,
  HoverWidget,
  HoverAction,
  getHoverAccessibleViewHint,
  IOpenerService,
  renderLabelWithIcons,
  renderIcon,
  init_iconLabels,
  or,
  matchesPrefix,
  matchesContiguousSubString,
  matchesSubString,
  matchesWords,
  anyScore,
  createMatches,
  FuzzyScore,
  FuzzyScoreOptions,
  fuzzyScore,
  fuzzyScoreGracefulAggressive,
  init_filters,
  stripIcons,
  init_iconLabels2,
  MarkdownString,
  isEmptyMarkdownString,
  isMarkdownString,
  init_htmlContent,
  IdGenerator,
  defaultGenerator,
  renderMarkdown,
  MarkdownRenderer,
  openLinkFromMarkdown,
  IBulkEditService,
  ResourceTextEdit,
  diffEditorDefaultOptions,
  editorConfigurationBaseNode,
  EditOperation,
  ILabelService,
  IProgressService,
  Progress,
  IEditorProgressService,
  TernarySearchTree,
  IWorkspaceContextService,
  isSingleFolderWorkspaceIdentifier,
  isEmptyWorkspaceIdentifier,
  toWorkspaceIdentifier,
  WORKSPACE_EXTENSION,
  isStandaloneEditorWorkspace,
  InspectTokensNLS,
  GoToLineNLS,
  QuickHelpNLS,
  QuickCommandNLS,
  QuickOutlineNLS,
  StandaloneCodeEditorNLS,
  ToggleHighContrastNLS,
  init_standaloneStrings,
  IWorkspaceTrustManagementService,
  DataTransfers,
  setHoverDelegateFactory,
  getDefaultHoverDelegate,
  List,
  ActionViewItem,
  DropdownMenuActionViewItem,
  IStorageService,
  WillSaveStateReason,
  defaultToggleStyles,
  defaultInputBoxStyles,
  defaultCountBadgeStyles,
  defaultListStyles,
  getListStyles,
  createAndFillInActionBarActions,
  MenuEntryActionViewItem,
  createActionViewItem,
  ActionBar,
  IEditorWorkerService,
  init_editorWorker,
  MarkerSeverity2 as MarkerSeverity,
  IMarkerData,
  IMarkerService,
  intersection,
  OrthogonalEdge,
  Sash,
  Sizing,
  SplitView,
  Toggle,
  CaseSensitiveToggle,
  WholeWordsToggle,
  RegexToggle,
  HistoryInputBox,
  FindInput,
  IsWindowsContext,
  IsWebContext,
  InputFocusedContext,
  IListService,
  WorkbenchListFocusContextKey,
  WorkbenchTreeElementCanCollapse,
  WorkbenchTreeElementCanExpand,
  WorkbenchAsyncDataTree,
  Extensions8 as Extensions2,
  ItemActivation,
  IQuickInputService,
  HighlightedLabel,
  IconLabel,
  unthemedKeybindingLabelOptions,
  KeybindingLabel,
  Button,
  CountBadge,
  registerIcon,
  widgetClose,
  VS_LIGHT_THEME_NAME,
  VS_DARK_THEME_NAME,
  HC_BLACK_THEME_NAME,
  HC_LIGHT_THEME_NAME,
  IStandaloneThemeService,
  init_standaloneTheme,
  IClipboardService,
  IAccessibilitySignalService,
  AccessibilitySignal,
  registerEditorFeature,
  StandaloneNotificationService,
  StandaloneCommandService,
  StandaloneKeybindingService,
  StandaloneConfigurationService,
  updateConfigurationService,
  StandaloneServices
};
//# sourceMappingURL=chunk-3NU3TA42.js.map
